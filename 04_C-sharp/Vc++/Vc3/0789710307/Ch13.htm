<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 1:30 PM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 13</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 13<BR>
Creating ActiveX COM Objects and Custom Interfaces Using ATL</H1>

<UL>
	<LI><A HREF="#Heading1">Creating ActiveX COM Objects and Custom Interfaces Using
	ATL</A>
	<UL>
		<LI><A HREF="#Heading2">Reaping Benefits of the ActiveX Template Library</A>
		<UL>
			<LI><A HREF="#Heading3">Support for Multiple Server Types</A>
			<LI><A HREF="#Heading4">Threading Models Supported by ATL</A>
			<LI><A HREF="#Heading5">Tear-Off Interfaces</A>
			<LI><A HREF="#Heading6">Implementing Interface Aggregation</A>
			<LI><A HREF="#Heading7">Built-In Support for Error Handling</A>
		</UL>
		<LI><A HREF="#Heading8">Creating a COM Server Using ATL</A>
		<UL>
			<LI><A HREF="#Heading9">Using the ATL COM Wizard to Create a COM Server</A>
			<LI><A HREF="#Heading10">Examining the Results of the ATL COM Wizard</A>
			<LI><A HREF="#Heading11">Implementing the COM Server Access Functions</A>
			<LI><A HREF="#Heading12">Listing 13.1 AtlCustomBass.def--Library Definition File
			for CAtlCustomBass</A>
			<LI><A HREF="#Heading13">Listing 13.2 AtlCustomBass.cpp--ATL Implementation of DLL
			Access Functions for COM Server</A>
			<LI><A HREF="#Heading14">Using IDL to Create Object Definitions</A>
			<LI><A HREF="#Heading15">Listing 13.3 AtlCustomBass.idl--Adding Custom Interface
			Methods to the Project Interface Definition File</A>
			<LI><A HREF="#Heading16">Implementing the COM Interface</A>
			<LI><A HREF="#Heading17">Listing 13.4 AtlCustomBass.h--C++ Class Definition for the
			AtlCustomBass COM Server</A>
			<LI><A HREF="#Heading18">Listing 13.5 CAltCustomBass1.cpp--Listing of CAltCustomBass1.cpp,
			Which Implements the COM Interfaces for IFish and IBass</A>
			<LI><A HREF="#Heading19">Using Object Maps to Specify COM Objects</A>
		</UL>
		<LI><A HREF="#Heading20">When to Use the ActiveX Template Library</A>
		<LI><A HREF="#Heading21">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Creating ActiveX COM Objects and Custom Interfaces Using
ATL</H1>

<UL>
	<LI><B>Benefits of using ATL</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 ATL allows for the creation of many types of COM servers and COM models.
	<P>
	<LI><B>Easy creation of COM interfaces and classes</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The ATL project wizard produces template code for the creation of COM classes and
	interfaces.
	<P>
	<LI><B>Implementing tear-off interfaces</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 A tear-off interface is an interface that is allocated on demand rather than upon
	COM class allocation.
	<P>
	<LI><B>Using custom interfaces in ATL</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Most COM objects support more than one interface; using ATL makes support for more
	than one interface an easy task.
	<P>
	<LI><B>When to use ATL for COM server development</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 You'll find situations where using other techniques, such as the MFC framework,
	provides more benefits than using ATL.
</UL>

<P>In the past, designing COM objects was relegated to the use of large application
frameworks such as MFC or to building your own components. Using large application
frameworks eases the construction and implementation of COM objects but requires
a significant amount of overhead code for the building and distribution of the COM
servers. Conversely, building your own COM server framework results in fast, lightweight
objects but requires a significant amount of up-front programming to implement the
control.</P>
<P>To address this dilemma, Microsoft created the ActiveX Template Library (ATL),
which provides a middle ground between large application frameworks and building
your own COM objects. ATL is a set of template-based C++ classes that simplifies
the programming of COM objects. ATL provides the necessary COM foundation, allowing
the focus to be on programming the functionality of your objects. ATL is shipped
with Visual C++ 5.0 and is backward compatible with Visual C++ 4.1 and 4.2. ATL can
be downloaded separately from the Microsoft Web site at <A HREF="http://www.microsoft.com"><B>http://www.microsoft.com</B></A>.
<BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Users of Visual C++ 4.0 must upgrade to version 4.1 or higher of
	the Visual C++ compiler in order to use the ActiveX Template Library.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The goal of ATL is to allow for the easy creation of small, fast COM servers. This
goal has been achieved by the following:

<UL>
	<LI>Eliminating the need for static libraries (LIBs) or Dynamic Link Libraries (DLLs)
	<P>
	<LI>Eliminating the need for C runtime library start-up code
</UL>

<P>Static library and DLL dependencies are removed by providing all of the source
code for the ATL libraries. The source code for ATL is a set of C++ class templates.
The small set of ATL code gets compiled into the COM server during the building process.
The overhead of ATL in an in-process COM server is less than 5K.
<H2><A NAME="Heading2"></A>Reaping Benefits of the ActiveX Template Library</H2>
<P>The ActiveX Template Library is the first attempt to create a C++ framework with
the sole intention of creating COM objects. Since COM object creation was the primary
goal of the framework, ATL has been trimmed of unnecessary baggage such as bloated
UI components. The use of ATL provides developers with a number of benefits including
the following:

<UL>
	<LI>Support for multiple types of COM servers, including in-process servers, local
	servers, service servers, and DCOM servers
	<P>
	<LI>Support for multiple-threading models, including the standard single-threading
	model, apartment-model threading, and free-threading
	<P>
	<LI>Various interface types, including custom COM interfaces, dual interfaces, tear-off
	interfaces, and <TT>IDispatch</TT> (OLE automation) interfaces
	<P>
	<LI>Enumeration support through the <TT>IEnumXXX</TT> interface
	<P>
	<LI>OLE error-handling through the <TT>IErrorInfo</TT> interface
</UL>

<H3><A NAME="Heading3"></A>Support for Multiple Server Types</H3>
<P>One of the biggest benefits of using ATL is the support for the creation of multiple
COM server types. When using the ATL wizard, the shell classes for each server type
are automatically created during project initialization. ATL provides support for
the following types of COM servers.

<UL>
	<LI>In-process server--An <I>in-process server</I> is implemented as a DLL that exists
	and can be accessed only on the computer in which the server is installed. In-process
	servers are typically small and fast and are the most common type of COM server.
	An example of an in-process server is a spelling-checker COM object.
	<P>
	<LI>Local server--A <I>local server</I> is implemented as an EXE. Like the in-process
	server, the local server can be accessed only on the computer in which the server
	is installed. The business charting application Visio is an example of a local server.
	<P>
	<LI>Service server--A <I>service server</I> is implemented as an EXE and can be run
	only on the Windows NT operating system. Services are analogous to UNIX daemons,
	which are background tasks that are running but not directly controlled by the system
	user. A service is accessible to all users of the system and is started during system
	boot-up, as opposed to traditional programs, which are started only <I>after</I>
	a user logs on to the computer. A database server that supports COM is an example
	of a service server.
	<P>
	<LI>Remote server--A <I>remote server</I> is implemented as an EXE and is accessible
	from remote computers using either DCOM or Remote Automation. Remote servers take
	advantage of the distributed computing by allowing the server to provide services
	to client applications not located on the same computer as the server. A database
	server is also a great example of a remote server.
</UL>

<H3><A NAME="Heading4"></A>Threading Models Supported by ATL</H3>
<P>ActiveX has different threading models that can be utilized by COM servers. The
ATL library provides built-in support for these different types of threading. Each
model provides different capabilities, and care must be taken when deciding which
model will be supported by the COM server.

<UL>
	<LI>Single-threading model--This model is by far the most restrictive of all models
	supported by ActiveX. This model provides support for only one thread to create,
	use, and access OLE objects. This model is obsolete and is supported only because
	the original OLE architecture was implemented on the 16-bit Windows 3.x platform,
	which did not support multiple threads. This is the default threading model for COM
	servers.
	<P>
	<LI>Apartment-model threading--This model fills the gap between the single-threaded
	model and the free-threaded model. While multiple threads can be utilized to access
	COM objects, care must be taken in how and when these objects are accessed. Each
	thread using COM objects must call the OLE initialization routines. In apartment-model
	threading, global variables accessed by each thread must be protected against simultaneous
	access.
	<P>
	<LI>Free-threading model--The free-threading model is by far the most flexible and
	unrestrictive. This model allows multiple threads to implement, access, and use COM
	objects. This mode of threading is supported <I>only</I> in the Windows NT 4.0 environment.
</UL>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>CAUTION:<BR>
	</B>When implementing free-threading servers, the burden for protecting data within
	a COM class from simultaneous updates or access by multiple threads falls on the
	programmer. Multiple threads may be attempting to access local data within the same
	instance of a COM object. ATL does <I>not</I> provide built-in data access synchronization.
	The use of Win32 synchronization objects such as events, semaphores, mutexes, and
	critical sections is needed for protecting COM class data.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading5"></A>Tear-Off Interfaces</H3>
<P>A <I>tear-off interface, </I>a new concept introduced in the ATL framework, is
an optimization of a regular COM interface in that it doesn't actually exist until
it is instantiated by a call to <TT>QueryInterface</TT> on your object for that interface.
Since the interface does not exist until asked for, it does not consume system memory
resources.</P>
<P>When the <TT>Release</TT> method is called on the interface and the reference
count on that interface returns to zero, the interface is removed from memory. Typically,
tear-off interfaces are used only for those interfaces that are expected to be used
less often than others, such as <TT>ISupportErrorInfo</TT>. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Tear-off interfaces should not be used for commonly used interfaces
	because the overhead of memory allocation and deallocation and memory fragmentation
	would outweigh the benefits of the interface.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
To implement tear-off interfaces, declare a class that inherits from all the interfaces
you want to implement in the tear-off, as well as from <TT>CComTearOffObjectBase&lt;class
Owner&gt;</TT>, where <I>Owner</I> is the class of the main object. Then provide
a normal <TT>BEGIN_COM_MAP...END_COM_MAP()</TT> specification of interfaces in the
tear-off, and use the <TT>COM_INTERFACE_ENTRY_TEAR_OFF</TT> macro in the main object's
COM map.
<H3><A NAME="Heading6"></A>Implementing Interface Aggregation</H3>
<P>You can implement aggregation in ATL servers with very little work. <I>Aggregation</I>
is when an object exposes another object's interface pointer as its own. For example,
if an application has a pointer to interface A and needs to access interface B, and
if interface A supports aggregation, the application can call <TT>QueryInterface</TT>
on interface A to obtain interface B. The only penalty imposed for supporting aggregation
is needing a somewhat larger server. The benefit is the flexibility to expose interfaces
from objects contained in the server.</P>
<P>In order to make a server aggregatable, use the macro <TT>DECLARE_AGGREGATABLE</TT>
in the COM object's class. If aggregration is not desired, use the macro <TT>DECLARE_NOT_AGGREGATABLE</TT>
to disable aggregration. By default, aggregration is supported by projects created
with the ATL COM AppWizard.
<H3><A NAME="Heading7"></A>Built-In Support for Error Handling</H3>
<P>ATL supports the OLE error reporting mechanism with the <TT>Error()</TT> member
function in the <TT>CComCoClass</TT> and <TT>CComISupportErrorInfoImpl</TT> classes.
These classes each have a member, <TT>InterfaceSupportsErrorInfo()</TT>, that indicates
whether returning rich error information is supported. By using this mechanism, custom
COM interfaces can provide helpful information to the end user if error situations
are encountered.
<H2><A NAME="Heading8"></A>Creating a COM Server Using ATL</H2>
<P>When using the ActiveX Template Library, the creation of COM servers is a trivial
task. The ATL installation creates an ATL COM AppWizard that can be accessed from
the Visual C++ development environment. The ATL COM AppWizard, like the MFC AppWizard,
presents the user with a step-by-step set of options for the creation of a COM server.
The end result of running the wizard is a ready-to-be-built project with all necessary
class template source code for the COM classes and interfaces that will be implemented
within the project. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> In <A HREF="ch12.htm">Chapter 12</A>, an interface library entitled
	<TT>IFish</TT> was created. The <TT>IFish</TT> and <TT>IBass</TT> interfaces built
	in that example will be constructed using the ATL library. The project <TT>AtlCustomBass</TT>
	will create a COM class <TT>CAtlCustomBass</TT>, used for accessing the <TT>IFish</TT>
	interfaces. The <TT>CAtlCustomBass</TT> class will be implemented as an in-process
	server.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading9"></A>Using the ATL COM Wizard to Create a COM Server</H3>
<P>To get started using the ATL COM AppWizard, a new project must be created. A new
project can be created by performing the following steps:

<OL>
	<LI>Select the <U>N</U>ew command from the <U>F</U>ile menu in the Visual C++ development
	environment.
	<P>
	<LI>From the New dialog, select the Projects tab.
	<P>
	<LI>From the Projects tab, select the ATL COM AppWizard (see fig. 13.1).
	<P><A HREF="art/13/jfig01.jpg"><B>FIG. 13.1</B></A> <I><BR>
	Select the ActiveX Template Library COM AppWizard to create an ATL-based COM server.</I><BR>
	
	<LI>Enter the name of the project in the Name edit box. For this project, enter the
	name <B>AtlCustomBass</B>. Then click the OK button.
	<P><BR>
	The ATL COM AppWizard is presented in Figure 13.2.<BR>
	<BR>
	<A HREF="art/13/jfig02.jpg"><B>FIG. 13.2</B></A> <I><BR>
	Choose the COM object options by using the ATL COM AppWizard.</I><BR>
	
	<LI>Select the type of COM server to create. The AtlCustomBass project is created
	as a DLL. It is good practice to select the option &quot;Allow merging of _proxy/stub
	code&quot; (AtlCustomBass selects this option). The stub code option provides parameter
	marshalling for the objects. If your server needs to support MFC, select the option
	Support <U>M</U>FC. Click the <U>F</U>inish button to create the ATL COM server.
	A New Project Information dialog is displayed (see fig. 13.3). Click OK, and the
	project is automatically created.
</OL>

<P><A HREF="art/13/jfig03.jpg"><B>FIG. 13.3</B></A> <BR>
<I>The New Project Information dialog box recaps the ATL COM server options.</I></P>
<P>After creating the project, a COM object needs to be added to the project. To
add a COM object, perform the following steps:

<OL>
	<LI>Select the <U>N</U>ew Class command from the <U>I</U>nsert menu of the Visual
	C++ development environment. The New Class dialog is displayed, as shown in Figure
	13.4.
	<P><A HREF="art/13/jfig04.jpg"><B>FIG. 13.4</B></A> <I><BR>
	Use the New Class dialog box to create COM classes.</I></P>
	<LI>Select ATL Class from the Class <U>t</U>ype drop-down list. Selecting ATL Class
	means that the new class will be derived from the ATL framework.
	<P>
	<LI>Type <B>AtlCustomBass1</B> in the <U>N</U>ame edit box.
	<P>
	<LI>Select the Cu<U>s</U>tom Interface type radio button. There are two interface
	type choices:
	<UL>
		<P>
		<LI>Dual Interface--Derives the COM interfaces within the server from the <TT>IDispatch</TT>
		interface used for OLE automation.
		<P>
		<LI>Custom Interface--Derives the COM interfaces from the <TT>IUnknown</TT> interface.
		If OLE automation is not needed, this is the recommended interface.
	</UL>
	<P>
	<LI>Specify 2 (two) in the N<U>u</U>mber of interfaces edit box. This setting determines
	how many interfaces the COM object will contain. The New Class dialog imposes a limit
	of 3. Again, this limit is imposed by the dialog, <I>not </I>the ATL library. The
	A<TT>tlCustomBass</TT> project will contain two interfaces (<TT>IFish</TT> and <TT>IBass</TT>)
	in the object.
	<P>
	<LI>Select the <U>E</U>dit button to change the default interface names. The Edit
	Interface Information dialog shown in Figure 13.5 is displayed.
	<P><A HREF="art/13/jfig05.jpg"><B>FIG. 13.5</B></A> <I><BR>
	The interface names can be changed from the Edit Interface Information dialog.</I></P>
	<LI>To change the names of the interfaces, click each interface shown in the Interface
	Na<U>m</U>es list. The <TT>CAtlCustonBass1</TT> class supports the <TT>IFish</TT>
	and <TT>IBass</TT> interfaces. Enter <B>IFish</B> and <B>IBass</B> in the Interface
	Na<U>m</U>es list. Click the OK button when finished.
	<P>
	<LI>Click the OK button in the New Class dialog box to create the class.
</OL>

<P>All the templates for the ATL COM server are now created. What remains is for
the server's specific implementations to be incorporated. Before performing the customizations,
you need to examine the results created by the ATL COM AppWizard.
<H3><A NAME="Heading10"></A>Examining the Results of the ATL COM Wizard</H3>
<P>A total of 11 files were created when the ATL COM AppWizard and New Class dialogs
were used to create the ATLCustomBass project. Table 13.1 shows the filenames and
purpose of each file created. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 13.1</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Files Created for the AtlCustomBass
		Project</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Filename</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Purpose</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Stdafx.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Contains the includes needed globally for the project. This usually generates precompiled
			headings used by all other c or cpp files.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">AtlCustomBass.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Contains the COM server entry point implementations and COM class registration function.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">AtlBass1.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Skeleton cpp file for the <TT>AtlCustomBass</TT> COM object. All class and interface
			implementations are placed in this file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">AtlCustomBass.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Export definition file for the COM object server.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">AtlCustomBassps.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Export definition file for the interface library. The interface library is used for
			generating proxy code for parameter marshaling.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">AtlBass1.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>AtlCustomBass</TT> COM object definition file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">AtlCustomBass.idl</TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>AtlCustomBass</TT> COM class and interface IDL definitions.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Resource.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard resource file used for icons, version information, and so on.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Stdafx.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Wrapper include file that includes all needed ATL header files.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Atlcustombassps.mk</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Makefile used for compiling the interface definition file. This file produces the
			parameter marshaling code for the COM interfaces.</TD>
	</TR>
</TABLE>
<BR>
<BR>
As you can see, the AppWizard and New Class dialog have been busy on your behalf
creating the templates necessary for creating COM objects. You now need to implement
the actual interfaces.
<H3><A NAME="Heading11"></A>Implementing the COM Server Access Functions</H3>
<P><A HREF="ch12.htm">Chapter 12</A> includes information about several access functions
that must be exported from the COM server. These functions are accessed by the COM
libraries to load, unload, and register the objects within the server. These functions
are shown in the definition file for the <TT>CAtlCustomBass</TT> server (see Listing
13.1).
<H3><A NAME="Heading12"></A>Listing 13.1 AtlCustomBass.def--Library Definition File
for CAtlCustomBass</H3>
<P><FONT COLOR="#0066FF"><TT>; AltCustomBass.def : Declares the module parameters.
<BR>
LIBRARY ALTCUSTOMBASS.DLL <BR>
EXPORTS <BR>
DllCanUnloadNow @1 PRIVATE <BR>
DllGetClassObject @2 PRIVATE <BR>
DllRegisterServer @3 PRIVATE <BR>
DllUnregisterServer @4 PRIVATE </TT></FONT></P>
<P>The ATL library provides all of the necessary code for implementing the DLL access
functions. For the <TT>CAtlCustomBass</TT> project, these functions are implemented
in the file (see Listing 13.2).
<H3><A NAME="Heading13"></A>Listing 13.2 AtlCustomBass.cpp--ATL Implementation of
DLL Access Functions for COM Server</H3>
<P><FONT COLOR="#0066FF"><TT>#include &quot;stdafx.h&quot; <BR>
#include &quot;resource.h&quot; <BR>
#include &quot;initguid.h&quot; <BR>
#include &quot;AltCustomBass.h&quot; <BR>
#include &quot;AltCustomBass1.h&quot; <BR>
#include &quot;dlldatax.h&quot; <BR>
#define IID_DEFINED <BR>
#include &quot;AltCustomBass_i.c&quot; <BR>
#ifdef _MERGE_PROXYSTUB <BR>
extern &quot;C&quot; HINSTANCE hProxyDll; <BR>
#endif <BR>
CComModule _Module; <BR>
BEGIN_OBJECT_MAP(ObjectMap) <BR>
OBJECT_ENTRY(CLSID_CAltCustomBass1, CAltCustomBass1) <BR>
END_OBJECT_MAP() <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// DLL Entry Point <BR>
extern &quot;C&quot; <BR>
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) <BR>
{ <BR>
lpReserved; <BR>
#ifdef _MERGE_PROXYSTUB <BR>
if (!PrxDllMain(hInstance, dwReason, lpReserved)) <BR>
return FALSE; <BR>
#endif <BR>
if (dwReason == DLL_PROCESS_ATTACH) <BR>
{ <BR>
_Module.Init(ObjectMap, hInstance); <BR>
DisableThreadLibraryCalls(hInstance); <BR>
} <BR>
else if (dwReason == DLL_PROCESS_DETACH) <BR>
_Module.Term(); <BR>
return TRUE; // ok <BR>
} <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// Used to determine whether the DLL can be unloaded by OLE <BR>
STDAPI DllCanUnloadNow(void) <BR>
{ <BR>
#ifdef _MERGE_PROXYSTUB <BR>
if (PrxDllCanUnloadNow() != S_OK) <BR>
return S_FALSE; <BR>
#endif <BR>
return (_Module.GetLockCount()==0) ? S_OK : S_FALSE; <BR>
} <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// Returns a class factory to create an object of the requested type <BR>
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) <BR>
{ <BR>
#ifdef _MERGE_PROXYSTUB <BR>
if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK) <BR>
return S_OK; <BR>
#endif <BR>
return _Module.GetClassObject(rclsid, riid, ppv); <BR>
} <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// DllRegisterServer - Adds entries to the system registry <BR>
STDAPI DllRegisterServer(void) <BR>
{ <BR>
#ifdef _MERGE_PROXYSTUB <BR>
HRESULT hRes = PrxDllRegisterServer(); <BR>
if (FAILED(hRes)) <BR>
return hRes; <BR>
#endif <BR>
// registers object, typelib and all interfaces in typelib <BR>
return _Module.RegisterServer(TRUE); <BR>
} <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// DllUnregisterServer - Removes entries from the system registry <BR>
STDAPI DllUnregisterServer(void) <BR>
{ <BR>
#ifdef _MERGE_PROXYSTUB <BR>
PrxDllUnregisterServer(); <BR>
#endif <BR>
_Module.UnregisterServer(); <BR>
return S_OK; <BR>
}</TT></FONT></P>
<H3><A NAME="Heading14"></A>Using IDL to Create Object Definitions</H3>
<P>All COM classes and interfaces are defined through IDL, the Interface Definition
Language. IDL is also used in the creation of RPC interfaces and Automation interfaces.
When the AtlCustomBass project was created, the COM AppWizard generated the file
AtlCustomBass.idl. This file contains template structures for the COM class and interfaces
specified when running the AppWizard. All methods for the custom interfaces must
be added to this file. Listing 13.3 illustrates the contents of AtlCustomBass.idl
with the methods for custom interface IFish and IBass.
<H3><A NAME="Heading15"></A>Listing 13.3 AtlCustomBass.idl--Adding Custom Interface
Methods to the Project Interface Definition File</H3>
<P><FONT COLOR="#0066FF"><TT>import &quot;unknwn.idl&quot;; <BR>
#define MAX_FISH_BSTR_LEN 255 <BR>
typedef [string] WCHAR FISH_BSTR[MAX_FISH_BSTR_LEN]; <BR>
// This file will be processed by the MIDL tool to <BR>
// produce the type library (AltCustomBass.tlb) and marshalling code. <BR>
[ <BR>
object, <BR>
uuid(F3C2DDA2-7434-11D0-B6FC-00008607092E), <BR>
helpstring(&quot;IFish Interface&quot;), <BR>
pointer_default(unique) <BR>
] <BR>
interface IFish : IUnknown <BR>
{ <BR>
import &quot;oaidl.idl&quot;; <BR>
HRESULT IsFreshwater([out] BOOL *pBool); <BR>
HRESULT GetFishName([out, string] FISH_BSTR p); <BR>
}; <BR>
[ <BR>
object, <BR>
uuid(F3C2DDA3-7434-11D0-B6FC-00008607092E), <BR>
helpstring(&quot;IFish Interface&quot;), <BR>
pointer_default(unique) <BR>
] <BR>
interface IBass : IUnknown <BR>
{ <BR>
import &quot;oaidl.idl&quot;; <BR>
HRESULT GetLocation([out, string] FISH_BSTR p); <BR>
HRESULT SetLocation([in, string] FISH_BSTR p); <BR>
HRESULT EatsOtherFish([out] BOOL *pBool); <BR>
}; [ <BR>
uuid(F3C2DDA0-7434-11D0-B6FC-00008607092E), <BR>
version(1.0), <BR>
helpstring(&quot;AltCustomBass 1.0 Type Library&quot;) <BR>
] <BR>
library ALTCUSTOMBASSLib <BR>
{ <BR>
importlib(&quot;stdole32.tlb&quot;); <BR>
[ <BR>
uuid(F3C2DDA6-7434-11D0-B6FC-00008607092E), <BR>
helpstring(&quot;AltCustomBass1 Class&quot;) <BR>
] <BR>
coclass CAltCustomBass1 <BR>
{ <BR>
[default] interface IFish; <BR>
interface IBass; <BR>
}; }; </TT></FONT></P>
<P>In the IDL file for <TT>AtlCustomBass</TT> are definitions for two interfaces,
<TT>IFish</TT> and <TT>IBass</TT>, and the COM class, <TT>CAltBass1</TT>. As you
can see from Listing 13.3, both the <TT>IFish</TT> and <TT>IBass</TT> interfaces
are derived from the <TT>IUnknown</TT> interface. In this example, a new type has
been defined, and that type is <TT>FISH_BSTR</TT>. <TT>FISH_BSTR</TT> is defined
as a wide-character string that is 255 characters in length. The wide-character string
is used so that the server can be compiled as either multibyte (default) or UNICODE.
The maximum length <I>must</I> be specified in the IDL definition. This is a requirement
of the MIDL compiler used to compile the IDL file. In order for the MIDL compiler
to produce code that handles parameter marshaling, the absolute length of the data
item passed into functions <I>must</I> be known.</P>
<P>The COM class <TT>CAltCustomBass1</TT> is a COM Object library that acts as a
container for the COM interfaces <TT>IFish</TT> and <TT>IBass</TT>. The specified
<TT>coclass</TT> identifies the definition as a COM class. As you can see from the
definition, the <TT>IFish</TT> interface is the default interface. This is the pointer
that is returned when the <TT>IID_IUnknown</TT> interface is queried.</P>
<P>The IDL file is compiled separately from the <TT>AtlCustomBass</TT> project. When
the <TT>AtlCustomBass</TT> project is built, the AtlCustomBass.idl file is compiled
with the MIDL compiler first. This step is automatically done as part of the build
process.</P>
<P>The IDL can also be compiled separately outside the IDE. The ATL COM AppWizard
generates a separate makefile for the IDL file (AtlCustomBassps.mk). The makefile
program <TT>nmake</TT> can be run from a command prompt to compile the IDL file.
The command line would look like this:</P>

<P><FONT COLOR="#0066FF"><TT>nmake -fatlcustombassps.mk </TT></FONT></P>
<H3><A NAME="Heading16"></A>Implementing the COM Interface</H3>
<P>Implementing the COM interface using the ATL library is a simple process. For
the programmer familiar with C++, this implementation is as simple as adding the
interface methods to the COM class. The ATL library takes care of handling all of
the <TT>IUnknown</TT> and <TT>IClassFactory</TT> interfaces, thus removing this burden
from the developer. Even the MFC framework requires that the <TT>IUnknown</TT> interface
must be handled by the programmer.</P>
<P>Listing 13.4 shows the COM class <TT>CAtlCustomBass</TT> definition file (AtlCustomBass.h).
The only modifications needed for the <TT>AtlCustomBass</TT> COM server is to add
the public interface methods and the variables needed by the class.
<H3><A NAME="Heading17"></A>Listing 13.4 AtlCustomBass.h--C++ Class Definition for
the AtlCustomBass COM Server</H3>
<P><FONT COLOR="#0066FF"><TT>class CAltCustomBass1 : <BR>
public IFish, <BR>
public IBass, <BR>
public CComObjectRoot, <BR>
public CComCoClass&lt;CAltCustomBass1,&amp;CLSID_CAltCustomBass1&gt; <BR>
{ <BR>
public: <BR>
CAltCustomBass1(); <BR>
BEGIN_COM_MAP(CAltCustomBass1) <BR>
COM_INTERFACE_ENTRY(IFish) <BR>
COM_INTERFACE_ENTRY(IBass) <BR>
END_COM_MAP() <BR>
//DECLARE_NOT_AGGREGATABLE(CAltCustomBass1) <BR>
// Remove the comment from the line above if you don't want your object to <BR>
// support aggregation. The default is to support it <BR>
DECLARE_REGISTRY(CAltCustomBass1, _T(&quot;AltCustomBass.AltCustomBass1.1&quot;),
_T(&quot;AltCustomBass.AltCustomBass1&quot;), IDS_ALTCUSTOMBASS1_DESC, THREADFLAGS_BOTH)
<BR>
// IFish <BR>
STDMETHOD(GetFishName)(FISH_BSTR pStr); <BR>
STDMETHOD(IsFreshwater)(BOOL* pBool); <BR>
// IBass <BR>
STDMETHOD(GetLocation)(FISH_BSTR p); <BR>
STDMETHOD(SetLocation)(FISH_BSTR p); <BR>
STDMETHOD(EatsOtherFish)(BOOL *pBool); <BR>
public: <BR>
WCHAR m_FishName[255]; <BR>
BOOL m_bFreshWater; <BR>
WCHAR m_Location[255]; <BR>
BOOL m_bEatsFish; }; </TT></FONT></P>
<P>To support the <TT>IFish</TT> and <TT>IBass</TT> interfaces, the custom methods
for each interface have been defined as standard C++ methods.</P>
<P>The ATL Template Library was developed to directly support and work with COM.
This is in contrast to the MFC framework, which does not directly use COM but has
hooks to manipulate COM. The COM class <TT>CAltCustomBass</TT> is derived from the
classes and interfaces shown in Table 13.2. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 13.2 Base Classes and Interfaces for <I>CAtlCustomBass1</I></B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Class</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IFish</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IFish</TT> COM interface, which is one of the custom interfaces supported by
			the class</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IBass</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Another custom interface specified during class construction</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>CComObjectRoot</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">ATL class that implements all reference counting and thread model-specific implementations</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>CComCoClass</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">ATL class that implements the class factory for the object, aggregation, and error
			handling</TD>
	</TR>
</TABLE>
<BR>
<BR>
The ATL library supports multiple interfaces through inheritance rather than through
nested classes. MFC uses nested classes for the support of multiple interfaces.</P>
<P>For a more thorough discussion of techniques used for supporting multiple interfaces,
refer to <A HREF="ch14.htm">Chapter 14</A>, which demonstrates the difference between
direct inheritance and nested classes.</P>
<P>Implementing the C++ method that will support the COM interface is a straightforward
matter. Listing 13.5 shows the implementation of the <TT>IFish</TT> and <TT>IBass</TT>
COM interfaces used in the <TT>CAltCustomBass1</TT> class.
<H3><A NAME="Heading18"></A>Listing 13.5 CAltCustomBass1.cpp--Listing of CAltCustomBass1.cpp,
Which Implements the COM Interfaces for IFish and IBass</H3>
<P><FONT COLOR="#0066FF"><TT>CAltCustomBass1::CAltCustomBass1(void) <BR>
{ <BR>
wcscpy( m_FishName, L&quot;Large Mouth Bass&quot;); <BR>
wcscpy( m_Location, L&quot;Under Lily Pads&quot;); <BR>
m_bEatsFish = TRUE; <BR>
m_bFreshWater = TRUE; <BR>
} <BR>
STDMETHODIMP CAltCustomBass1::GetFishName( FISH_BSTR pStr) <BR>
{ <BR>
// TRACE(&quot;CAltCustomBass1::GetFishName\n&quot;); <BR>
if (pStr) <BR>
wcscpy(pStr, m_FishName); <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
STDMETHODIMP CAltCustomBass1::IsFreshwater( BOOL *pBool ) <BR>
{ <BR>
// TRACE(&quot;CAltCustomBass1::IsFreshwater\n&quot;); <BR>
if (pBool) <BR>
{ <BR>
*pBool = m_bFreshWater; <BR>
return S_OK; <BR>
} <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
// CBass:Fish implementation of IFish STDMETHODIMP CAltCustomBass1::GetLocation(
FISH_BSTR pStr) <BR>
{ <BR>
// TRACE(&quot;CAltCustomBass1::GetLocation\n&quot;); <BR>
if (pStr) <BR>
wcscpy(pStr, m_Location); <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
STDMETHODIMP CAltCustomBass1::SetLocation( FISH_BSTR pStr) <BR>
{ <BR>
// TRACE(&quot;CAltCustomBass1::SetLocation\n&quot;); <BR>
if (pStr) <BR>
wcscpy(m_Location, pStr); <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
STDMETHODIMP CAltCustomBass1::EatsOtherFish( BOOL *pBool ) <BR>
{ <BR>
// TRACE(&quot;CAltCustomBass1::EatsOtherFish\n&quot;); <BR>
if (pBool) <BR>
{ <BR>
*pBool = m_bEatsFish; <BR>
return S_OK; <BR>
} <BR>
// return E_BADPOINTER; <BR>
return (HRESULT)NOERROR; <BR>
}</TT></FONT></P>
<P>Again, note that the ATL Template Library implements the <TT>IUnknown</TT> interface
for you, resulting in much fewer coding requirements for the developer. Now that
the method implementation is complete, the COM server can be compiled and built.
<H3><A NAME="Heading19"></A>Using Object Maps to Specify COM Objects</H3>
<P>The ATL library uses object maps to specify the COM objects that make up a particular
ATL server. <I>Object maps </I>are arrays of structures that tell ATL about the objects
implemented in a server. The members of an object map include the <TT>CLSID</TT>
of the object and the class of the object.</P>
<P>When a specific interface is requested through the <TT>QueryInterface</TT> method,
ATL uses COM maps to map interface IDs (<TT>IID</TT>s) to offsets in the interface.
COM maps are used by the class <TT>CComObjectRoot</TT>. When a user calls <TT>QueryInterface()</TT>,
the ATL library internally calls <TT>InternalQueryInterface()</TT> to return an interface
pointer based on an <TT>IID</TT> passed in.</P>
<P>Thirteen different types of entries can reside in a COM map (see Table 13.3).
<BR>

<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 13.3</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Types of Entries</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><B>COM Entry Type</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface where only the class name needs to be in. The <TT>IID</TT> is synthesized
			by prepending <TT>IID_</TT> to the class name. This is the basic and popular form
			of COM interfaces.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_IID</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface where the <TT>IID</TT> and the class name need to be passed in, for example,
			<TT>COM_INTERFACE_ENTRY_IID </TT>(<TT>IID_IFish</TT>, <TT>IFish</TT>).</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY2</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface where it is necessary to distinguish conflicting interfaces. For example,
			if you have dual interfaces (<TT>IFoo</TT> and <TT>IBar</TT>) in an object, specifying
			<TT>COM_INTERFACE_ENTRY </TT>(<TT>IDispatch</TT>) would be ambiguous because both
			<TT>IFoo</TT> and <TT>IBar</TT> derive from <TT>Idispatch</TT>. However, by specifying
			<TT>COM_INTERFACE_ENTRY2</TT> (<TT>IDispatch</TT>, <TT>IFoo</TT>), you can control
			which interface is returned.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM INTERFACE_ENTRY2_IID</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface where the <TT>IID</TT> and the class name need to be passed in and you
			need to disambiguate interfaces.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_TEAR_OFF</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface is a tear-off interface. Tear-off interfaces are generally created each
			time a client calls <TT>QueryInterface</TT> for a particular interface, even if a
			tear-off for that interface is already instantiated.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_CACHED_TEAR_OFF</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface is a tear-off interface; however, ATL creates an object implementing the
			tear-off interface only the first time the interface is requested. Subsequent <TT>QueryInterface</TT>
			calls will reuse the object previously instantiated.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_AGGREGATE</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Indicates that a <TT>QueryInterface</TT> call for a particular interface should go
			through the aggregate.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_AGGREGATE</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Indicates that a <TT>QueryInterface</TT> call for an interface <TT>_BLIND</TT> should
			be blindly forwarded to the aggregate.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_AUTOAGGREGATE</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Automatically creates the aggregate when a client performs a <TT>QueryInterface</TT>
			for a particular interface on the aggregate.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Automatically creates the aggregate when a client calls <TT>QueryInterface</TT> for
			an interface that cannot be found on the outer object.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_CHAIN</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Chains to the COM map of a base class.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_FUNC</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Allows you to programmatically hook the creation of a particular interface pointer.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="238" ALIGN="LEFT" VALIGN="TOP"><TT>COM_INTERFACE_ENTRY_FUNC_BLIND</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Allows you to programmatically hook the creation of a pointer to any interface, thus
			not found.</TD>
	</TR>
</TABLE>

<H2><A NAME="Heading20"></A>When to Use the ActiveX Template Librarys</H2>
<P>The ActiveX template library offers many advantages to builders of COM interfaces
and COM objects. The ATL library offers the advantage of building fast, lightweight
COM servers. However, using ATL may not be the best method of implementation depending
on the situation.</P>
<P>ATL is focused entirely on the creation of small, fast COM servers in C++. ATL
is optimized for the creation of objects that expose custom or dual-interfaces and
has absolutely no inherent support for more complex COM-based architectures, such
as ActiveX documents.</P>
<P>If you want to create generic COM objects or OLE automation objects with dual-interface
support or you want to support COM's free-threading model (available with Windows
NT 4.0 and later versions of Windows) and you don't have a significant user interface
in your object, ATL is the choice for producing the smallest, fastest code.</P>
<P>If you want to create complex servers that need to support user-interface items,
ActiveX controls, or ActiveX documents, then a more robust framework such as MFC
should be used.
<H2><A NAME="Heading21"></A>From Here...</H2>
<P>This chapter has illustrated some of the many benefits gained when using the ActiveX
Template Library. The ATL COM AppWizard was used to create a framework for a COM
server. The New Class dialog was used to create a COM object with multiple custom
interfaces. All that the user must implement is the custom functionality of the server.
<A HREF="ch12.htm">Chapter 12</A> uses the MFC framework to create COM servers. MFC
is a feature-rich application framework that can be used for building COM servers.
<A HREF="ch14.htm">Chapter 14</A> illustrates a custom COM architecture for building
COM servers. The custom architecture is not derived from ATL or MFC.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
