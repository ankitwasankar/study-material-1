<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 10:57 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 9</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 9<BR>
Advanced ActiveX Control Development with ATL</H1>

<UL>
	<LI><A HREF="#Heading1">Advanced ActiveX Control Development with ATL</A>
	<UL>
		<LI><A HREF="#Heading2">Properties</A>
		<UL>
			<LI><A HREF="#Heading3">Creating Asynchronous Properties</A>
			<LI><A HREF="#Heading4">Listing 9.1 ATLCONTROL.IDL--Change the dispid of the ReadyState
			Property to the Stock Property dispid--DISPID_READYSTATE</A>
			<LI><A HREF="#Heading5">Listing 9.2 ATLCONTROLWIN.H--Add the m_lReadyState Member
			to the CATLControlWin Class</A>
			<LI><A HREF="#Heading6">Listing 9.3 ATLCONTROLWIN.H--Initialize the m_lReadyState
			Member Variable in the Class Constructor</A>
			<LI><A HREF="#Heading7">Listing 9.4 ATLCONTROLWIN.CPP--Implement the get_ReadyState
			Function to Return the Current ReadyState Value</A>
			<LI><A HREF="#Heading8">Listing 9.5 ATLCONTROL.IDL--Add the ReadyStateChange Event
			to the IDL File</A>
			<LI><A HREF="#Heading9">Listing 9.6 ATLCONTROL.IDL--Add the dispidTextDataPath Enumeration
			to the IDL File</A>
			<LI><A HREF="#Heading10">Listing 9.7 ATLCONTROLWIN.H--The m_bstrTextDataPath Member
			Variable Is Added to the Class Declaration to Store the TextDataPath Property</A>
			<LI><A HREF="#Heading11">Listing 9.8 ATLCONTROLWIN.CPP--Implementation of the get_TextDataPath
			/put_TextDataPath Functions</A>
			<LI><A HREF="#Heading12">Listing 9.9 ATLCONTROLWIN.CPP--OnData Function Implementation</A>
			<LI><A HREF="#Heading13">Listing 9.10 ATLCONTROLWIN.H--TextDataPath Member Added
			to the Property Persistence Macro</A>
			<LI><A HREF="#Heading14">Static and Dynamic Property Enumeration</A>
			<LI><A HREF="#Heading15">Listing 9.11 ATLCONTROLWIN.H--IPerPropertyBrowsing Interface
			Function Prototypes Must Be Added to the Class Declaration</A>
			<LI><A HREF="#Heading16">Listing 9.12 ATLCONTROLWIN.CPP--MapPropertyToPage Implementation</A>
			<LI><A HREF="#Heading17">Listing 9.13 ATLCONTROLWIN.CPP--GetPredefinedStrings Implementation</A>
			<LI><A HREF="#Heading18">Listing 9.14 ATLCONTROLWIN.CPP--GetPredefinedValue Implementation</A>
			<LI><A HREF="#Heading19">Listing 9.15 ATLCONTROLWIN.CPP--GetDisplayString Implementation</A>
		</UL>
		<LI><A HREF="#Heading20">Drawing the Control</A>
		<UL>
			<LI><A HREF="#Heading21">Optimized Drawing</A>
			<LI><A HREF="#Heading22">Listing 9.16 ATLCONTROLWIN.H--Drawing Implementation Member
			Variables and Functions</A>
			<LI><A HREF="#Heading23">Listing 9.17 ATLCONTROLWIN.CPP--OnDestroy Implementation
			of Drawing Resource Cleanup</A>
			<LI><A HREF="#Heading24">Listing 9.18 ATLCONTROLWIN.CPP--OnDraw Function Updated
			to Support Optimized Drawing</A>
		</UL>
		<LI><A HREF="#Heading25">Adding Clipboard and Drag and Drop Support</A>
		<UL>
			<LI><A HREF="#Heading26">Clipboard Support</A>
			<LI><A HREF="#Heading27">Listing 9.19 ATLCONTROLWIN.H--WM_KEYDOWN and OnKeyDown Message
			Handler Added to the Class Declaration of the Control</A>
			<LI><A HREF="#Heading28">Listing 9.20 ATLCONTROLWIN.CPP--OnKeyDown Implementation</A>
			<LI><A HREF="#Heading29">Listing 9.21 ATLCONTROLWIN.H--Helper Functions and Member
			Variables for Clipboard Support</A>
			<LI><A HREF="#Heading30">Listing 9.22 ATLCONTROLWIN.H--IEnumFORMATETC Interface Added
			to theClass Inheritance Hierarchy</A>
			<LI><A HREF="#Heading31">Listing 9.23 ATLCONTROLWIN.H--Member Initialization in the
			Class Constructor</A>
			<LI><A HREF="#Heading32">Listing 9.24 ATLCONTROLWIN.CPP--CopyDataToClipboard Helper
			Function Implementation</A>
			<LI><A HREF="#Heading33">Listing 9.25 ATLCONTROLWIN.CPP--PrepareDataForTransfer Helper
			Function Implementation</A>
			<LI><A HREF="#Heading34">Listing 9.26 ATLCONTROLWIN.CPP--CopyStgMedium Helper Function
			Implementation</A>
			<LI><A HREF="#Heading35">Listing 9.27 ATLCONTROLWIN.CPP--IDataObject Interface Implementation</A>
			<LI><A HREF="#Heading36">Listing 9.28 ATLCONTROLWIN.CPP--IEnumFORMATETC Interface
			Implementation</A>
			<LI><A HREF="#Heading37">Listing 9.29 ATLCONTROLWIN.H--Clipboard Target Support Helper
			Function Prototypes</A>
			<LI><A HREF="#Heading38">Listing 9.30 MFCCONTROLWINCTL.CPP--GetDataFromClipboard
			Implementation</A>
			<LI><A HREF="#Heading39">Listing 9.31 MFCCONTROLWINCTL.CPP--GetDataFromTransfer Implementation</A>
			<LI><A HREF="#Heading40">Listing 9.32 ATLCONTROLWIN.CPP--OnKeyDown Implementation</A>
			<LI><A HREF="#Heading41">Drag and Drop Support</A>
			<LI><A HREF="#Heading42">Listing 9.33 ATLCONTROLWIN.H--IDropSource Interface Added
			to the CATLControlWin Class Declaration</A>
			<LI><A HREF="#Heading43">Listing 9.34 ATLCONTROLWIN.H--WM_LBUTTONDOWN and OnLButtonDown
			Message Handler Added to the Class Declaration of the Control</A>
			<LI><A HREF="#Heading44">Listing 9.35 ATLCONTROLWIN.CPP--OnLButtonDown Implementation</A>
			<LI><A HREF="#Heading45">Listing 9.36 ATLCONTROLWIN.CPP--IDropSource Implementation</A>
			<LI><A HREF="#Heading46">Listing 9.37 ATLCONTROLWIN.H--IDropTarget Interface Added
			to the CATLControlWin Class Declaration</A>
			<LI><A HREF="#Heading47">Listing 9.38 ATLCONTROLWIN.H--WM_CREATE Message Handler</A>
			<LI><A HREF="#Heading48">Listing 9.39 ATLCONTROLWIN.CPP--OnCreate Implementation</A>
			<LI><A HREF="#Heading49">Listing 9.40 ATLCONTROLWIN.CPP--OnDestroy Implementation
			Updated to Revoke the Control as a Valid Drop Target</A>
			<LI><A HREF="#Heading50">Listing 9.41 ATLCONTROLWIN.CPP--IDropTarget Interface Implementation</A>
			<LI><A HREF="#Heading51">Custom Clipboard and Drag and Drop Formats</A>
			<LI><A HREF="#Heading52">Listing 9.42 ATLCONTROLWIN.H--Custom Data Format Member
			Variables</A>
			<LI><A HREF="#Heading53">Listing 9.43 ATLCONTROLWIN.H--Register the Custom Format
			and Initialize the Member Variables in the Class Constructor</A>
			<LI><A HREF="#Heading54">Listing 9.44 ATLCONTROLWIN.CPP--PrepareDataForTransfer Update</A>
			<LI><A HREF="#Heading55">Listing 9.45 ATLCONTROLWIN.CPP--GetDataFromTransfer Update</A>
			<LI><A HREF="#Heading56">Listing 9.46 ATLCONTROLWIN.CPP--IEnumFORMATETC::Next Update</A>
			<LI><A HREF="#Heading57">Listing 9.47 TLCONTROLWIN.CPP--IEnumFORMATETC::GetData Update</A>
		</UL>
		<LI><A HREF="#Heading58">Subclassing Existing Windows Controls</A>
		<UL>
			<LI><A HREF="#Heading59">Listing 9.48 ATLCONTROLSUBWIN.H--CATLControlSubWin Class
			Implementation</A>
		</UL>
		<LI><A HREF="#Heading60">Dual-Interface Controls</A>
		<LI><A HREF="#Heading61">Other ActiveX Features</A>
		<UL>
			<LI><A HREF="#Heading62">Windowless Activation</A>
			<LI><A HREF="#Heading63">Flicker-Free Activation</A>
			<LI><A HREF="#Heading64">Mouse Pointer Notifications When Inactive</A>
			<LI><A HREF="#Heading65">Optimized Drawing Code</A>
			<LI><A HREF="#Heading66">Loads Properties Asynchronously</A>
		</UL>
		<LI><A HREF="#Heading67">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Advanced ActiveX Control Development with ATL</H1>

<UL>
	<LI><B>Asynchronous properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 ATL hides some of the implementation details making implementation easier.
	<P>
	<LI><B><BR>
	Property enumeratio</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Property enumeration allows you to restrict the set of values a property can contain
	and makes the property appear more professional in its implementation.
	<P>
	<LI><B>Optimized drawing</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Optimized drawing with ATL is easy and can have positive effects on the performance
	and appearance of the control.
	<P>
	<LI><B>Clipboard and Drag and Drop</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 With ATL, you can use a set of routines that includes support for custom data types.
	<P>
	<LI><B>Subclassing Windows controls</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Subclassing an existing Windows control with ATL can significantly reduce your development
	time when creating new controls.
	<P>
	<LI><B>Dual-interface controls</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Unlike MFC, ATL ActiveX controls are dual-interface by default and require no extra
	work to implement.
	<P>
	<LI><B>Advanced ActiveX</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The ATL framework provides advanced features by default.
</UL>

<P>This chapter expands upon the information in <A HREF="ch08.htm">Chapter 8</A>
about creating a basic ATL ActiveX control. In addition to the features that you
are familiar with, such as Clipboard and Drag and Drop support, you will learn how
to implement asynchronous properties and optimized drawing, which are the result
of the adoption of OLE Control 96 (OC 96) specification.
<H2><A NAME="Heading2"></A>Properties</H2>
<H2>Properties</H2>
<P>In <A HREF="ch08.htm">Chapter 8</A>, you learn how to add the various types of
properties to your control implementation. One type of property that has yet to be
examined in terms of ATL is asynchronous properties.
<H3><A NAME="Heading3"></A>Creating Asynchronous Properties</H3>
<P>Asynchronous properties are those properties that typically represent a large
amount of data, such as a text file or a bitmap, and are loaded as a background process
so as not to interfere with the normal processing of the control and the container.
This statement can be somewhat misleading. Asynchronous refers only to the call to
load the data; it does not refer to the actual loading.</P>
<P>For example, a control uses a bitmap as its background and has defined the bitmap
as an asynchronous property. If OLE determines that the bitmap is already on the
local machine, the data is considered to be available to the control and, subsequently,
will instruct the control that all of the data is available. If OLE determines that
the bitmap is not available on the local machine, OLE will load the data as fast
as possible and inform the control as data becomes available. After the data is in
a location that is considered accessible, the property essentially behaves as any
other property would. If you require the asynchronous loading of the data regardless
of its location, you must implement it yourself.</P>
<P>Before you can add your asynchronous property, you need to add the property <TT>ReadyState</TT>,
which is used by the container to determine the state that the control is in at any
given time relative to the loading of asynchronous properties. You also add the event
<TT>ReadyStateChange</TT>, which is used by the control to notify the container that
the <TT>ReadyState</TT> property of the control has changed.</P>
<P>Adding the <TT>ReadyState</TT> property is the same as adding any other property,
as is described in <A HREF="ch08.htm">Chapter 8</A>. From the ClassView tab in the
Project Workspace window, select the <TT>IATLControlWin</TT> interface, click the
right mouse button, and select the Add <U>P</U>roperty menu item.</P>
<P>In the Add Property to Interface dialog, set the Property <U>T</U>ype to <TT>long</TT>,
the Property <U>N</U>ame to <TT>ReadyState</TT>, uncheck the <U>P</U>ut Function
check box, and leave the remainder of the settings at their default values (see fig.
9.1). Click OK to confirm the entry, and close the dialog.</P>
<P>Before you proceed, open the ATLControl.idl file, and change the <TT>dispid</TT>
of the <TT>ReadyState</TT> property to <TT>DISPID_READYSTATE</TT> since <TT>ReadyState</TT>
is a stock property (see Listing 9.1). <B><BR>
<BR>
</B><A HREF="art/09/xfigs01.jpg"><B>FIG. 9.1</B></A> <BR>
<I>Add the <TT>ReadyState </TT>property to the control using the ATL Object Wizard
for your asynchronous property support.</I></P>
<P>
<H3><A NAME="Heading4"></A>Listing 9.1<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROL.IDL--Change
the dispid of the ReadyState Property to the Stock Property dispid--DISPID_READYSTATE</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
interface IATLControlWin : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method CaptionMethod&quot;)] HRESULT CaptionMethod( <BR>
[in] BSTR bstrCaption, [in, optional] VARIANT varAlignment, <BR>
[out, retval] long * lRetVal); <BR>
[propget, id(DISPID_READYSTATE), helpstring(&quot;property ReadyState&quot;)] <BR>
HRESULT ReadyState([out, retval] long *pVal); <BR>
[propget, id(DISPID_BACKCOLOR), helpstring(&quot;property BackColor&quot;)] <BR>
HRESULT BackColor([out, retval] OLE_COLOR *pVal); <BR>
[propput, id(DISPID_BACKCOLOR), helpstring(&quot;property BackColor&quot;)] <BR>
HRESULT BackColor([in] OLE_COLOR newVal); <BR>
[propget, id(dispidCaptionProp), helpstring(&quot;property CaptionProp&quot;)] <BR>
HRESULT CaptionProp([in, optional] VARIANT varAlignment, <BR>
[out, retval] BSTR *pVal); <BR>
[propput, id(dispidCaptionProp), helpstring(&quot;property CaptionProp&quot;)] <BR>
HRESULT CaptionProp([in, optional] VARIANT varAlignment, <BR>
[in] BSTR newVal); <BR>
[propget, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([out, retval] long *pVal); <BR>
[propput, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([in] long newVal); <BR>
}; <BR>
<BR>
. . . </TT></FONT></P>

<P>The implementation of the <TT>ReadyState</TT> property requires a member variable
to store the <TT>ReadyState</TT> value. Add the <TT>m_lReadyState</TT> member to
the class declaration of the <TT>CATLControlWin</TT> class (see Listing 9.2).
<H3><A NAME="Heading5"></A>Listing 9.2<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--Add
the m_lReadyState Member to the CATLControlWin Class</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
int iCharWidthArray[256]; <BR>
int iCharacterSpacing, iCharacterHeight; <BR>
// for the ReadyState property <BR>
long m_lReadyState; <BR>
}; <BR>
</TT></FONT></P>

<P>Add the initialization of the <TT>m_lReadyState</TT> member variable to the constructor
of the <TT>CATLControlWin</TT> class (see Listing 9.3).
<H3><A NAME="Heading6"></A>Listing 9.3 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--Initialize
the m_lReadyState Member Variable in the Class Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>CATLControlWin() <BR>
{ <BR>
. . . <BR>
// set the initial state of the ReadyState property <BR>
m_lReadyState = READYSTATE_LOADING; <BR>
} </TT></FONT></P>

<P>The last step to implement is the <TT>get_ReadyState</TT> function, which simply
returns the current value of the <TT>m_lReadyState</TT> member variable (see Listing
9.4).
<H3><A NAME="Heading7"></A>Listing 9.4 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--Implement
the get_ReadyState Function to Return the Current ReadyState Value</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::get_ReadyState(long * pVal)
<BR>
{ <BR>
// set the return value to the value of the member variable <BR>
*pVal = m_lReadyState; <BR>
return S_OK; <BR>
} </TT></FONT></P>

<P>The next step is to add support for the <TT>ReadyStateChange</TT> event. Open
the ATLControl.idl file, and add the <TT>ReadyStateChange</TT> function to the event
interface that is added in <A HREF="ch08.htm">Chapter 8</A> (see Listing 9.5).
<H3><A NAME="Heading8"></A>Listing 9.5<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROL.IDL--Add
the ReadyStateChange Event to the IDL File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
[ <BR>
uuid(C31D4C71-7AD7-11d0-BEF6-00400538977D), <BR>
helpstring(&quot;ATLControlWin Event Interface&quot;) <BR>
] <BR>
dispinterface _DATLControlWin <BR>
{ <BR>
properties: <BR>
methods: <BR>
[id(1)] void Change([in, out]BSTR * bstrCaption, <BR>
[in, out] long * lAlignment); <BR>
[id(DISPID_READYSTATECHANGE)] void ReadyStateChange(); <BR>
}; <BR>
<BR>
. . . </TT></FONT></P>

<P>Remember that support for events is not automatic in ATL, so you must manually
rebuild the CPATLControl.h file that was created in <A HREF="ch08.htm">Chapter 8</A>
for your connection point support by using the ATL Proxy Generator. To update the
file follow these steps:

<OL>
	<LI>Compile the IDL file since the event interface header file is built from the
	type library.
	<P>
	<LI>From the Project menu, select the Add to Project menu item, and then select the
	Components and Controls submenu item.
	<P>
	<LI>In the Components and Controls Gallery dialog, double-click the Developer Studio
	Components folder.
	<P>
	<LI>After the Components and Controls Gallery dialog is refreshed with data, double-click
	the ATL Proxy Generator icon.
	<P>
	<LI>Click OK to close the Insert the ProxyGen Component dialog.
	<P>
	<LI>Click the ... button to display the Open dialog. Select the ATLControl.tlb file,
	and click Open.
	<P>
	<LI>Select the <TT>_DATLControlWin</TT> entry in the <U>N</U>ot Selected list box,
	and click the &gt; button to move the entry to the <U>S</U>elected list box. Ensure
	that the Proxy <U>T</U>ype is set to Connection Point and click <U>I</U>nsert.
	<P>
	<LI>A Save dialog appears with the file CPATLControl.h in the File <U>n</U>ame edit
	box. Click <U>S</U>ave to continue. Click Yes to replace the existing CPATLControl.h
	file.
	<P>
	<LI>Click OK in the confirmation dialog that indicates the operation was successful.
	<P>
	<LI>Click Close in the ATL Proxy Generator and Components and Controls Gallery dialogs.
</OL>

<P>The <TT>Fire_ReadyStateChange</TT> method is now added to the <TT>CProxy_DATLControlWin</TT>
class.</P>
<P>Asynchronous properties are based on URLs and not on the data type of the data
to be downloaded, for example, a bitmap or text file. The URL is stored in a string
property of the control. For the sample implementation, you add the property called
<TT>TextDataPath</TT> to the control. From the ClassView tab in the Project Workspace
window, select the <TT>IATLControlWin</TT> interface, click the right mouse button,
and select the Add <U>P</U>roperty... menu item.</P>
<P>In the Add Property to Interface dialog, set the Property <U>T</U>ype to BSTR,
the Property <U>N</U>ame to <TT>TextDataPath</TT>, and leave the remainder of the
settings at their default values (see fig. 9.2). Click OK to confirm the entry and
close the dialog. <B><BR>
<BR>
</B><A HREF="art/09/xfigs02.jpg"><B>FIG. 9.2</B></A> <I><BR>
Add the <TT>TextDataPath </TT>property to the control using the ATL ClassWizard.</I></P>
<P>Add the <TT>dispidTextDataPath</TT> constant to the <TT>PROPDISPIDS</TT> enumeration
in the ATLControl.idl file, and update the <TT>TextDataPath</TT> function to use
the constant value (see Listing 9.6).
<H3><A NAME="Heading9"></A>Listing 9.6 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROL.IDL--Add
the dispidTextDataPath Enumeration to the IDL File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
typedef enum propdispids <BR>
{ <BR>
dispidAlignment = 2, <BR>
dispidCaptionProp = 3, <BR>
dispidTextDataPath = 4, <BR>
}PROPDISPIDS; <BR>
[ <BR>
object, <BR>
uuid(A19F6963-7884-11D0-BEF3-00400538977D), <BR>
dual, <BR>
helpstring(&quot;IATLControlWin Interface&quot;), <BR>
pointer_default(unique) <BR>
] <BR>
interface IATLControlWin : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method CaptionMethod&quot;)] HRESULT CaptionMethod( <BR>
[in] BSTR bstrCaption, [in, optional] VARIANT varAlignment, <BR>
[out, retval] long * lRetVal); <BR>
[propget, id(dispidTextDataPath), helpstring(&quot;property TextDataPath&quot;)]
<BR>
HRESULT TextDataPath([out, retval] BSTR *pVal); <BR>
[propput, id(dispidTextDataPath), helpstring(&quot;property TextDataPath&quot;)]
<BR>
HRESULT TextDataPath([in] BSTR newVal); <BR>
. . . </TT></FONT></P>

<P>The TextDataPath property is used to store the URL of the data that the property
represents. To complete your implementation of the property, add the member variable,
<TT>m_bstrTextDataPath</TT> (see Listing 9.7). The data for the member is declared
as the type <TT>CComBSTR</TT>, which is a <TT>BSTR</TT> wrapper class provided with
ATL. See the ATL documentation for more information. The use of the <TT>CComBSTR</TT>
data type versus a standard <TT>BSTR</TT> or <TT>LPTSTR</TT> is purely an arbitrary
decision on your part and is based on your implementation requirements. We used <TT>CComBSTR</TT>
to demonstrate the different implementation styles available to you with ATL. You
also add the member variable <TT>m_bstrText</TT>, also of the type <TT>CComBSTR</TT>,
to store the data as it is supplied to the control and the member function OnData,
which will be the callback function that receives the data as it is downloaded. We
will discuss these two members a little later in this chapter.
<H3><A NAME="Heading10"></A>Listing 9.7<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--The
m_bstrTextDataPath Member Variable Is Added to the Class Declaration to Store the
TextDataPath Property</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
//OnData will be used as a callback functin by the CBindStatusCallback object. <BR>
//OnData will be called periodically with data from the asynchronous transfer <BR>
void OnData(CBindStatusCallback&lt;CATLControlWin&gt;* pbsc, BYTE* pBytes, DWORD
dwSize); <BR>
protected: <BR>
. . . <BR>
// for the ReadyState property <BR>
long m_lReadyState; <BR>
// for the TextDataPath property <BR>
CComBSTR m_bstrTextDataPath; <BR>
// to hold the data as it is passed in <BR>
CComBSTR m_bstrText; <BR>
}; <BR>
#endif //__ATLCONTROLWIN_H_ </TT></FONT></P>
<P>The implementation of the <TT>get_TextDataPath/put_TextDataPath</TT> function
is where the asynchronous data transfer of the property takes place (see Listing
9.8). The <TT>get_TextDataPath</TT> function returns the current value stored in
the <TT>m_bstrTextDataPath</TT> member variable. The <TT>put_TextDataPath</TT> function
stores the new location of the data and then initiates a transfer of the data to
the control with a call to <TT>CBindStatusCallback&lt;CATLControlWin&gt;::Download
(. . .)</TT>. <TT>CBindStatusCallback</TT> is an ATL wrapper class that wraps the
<TT>IBindStatusCallback</TT> interface. <TT>CBindStatusCallback</TT> handles all
of the details of the data transfer and only requires that you implement a function,
in this case <TT>OnData</TT>, to receive the data as it is downloaded. The <TT>OnData</TT>
function is supplied as the second parameter to the <TT>Download</TT> function and
must conform to the prototype defined by ATL. See the ATL documentation on the <TT>Download</TT>
function for more information.
<H3><A NAME="Heading11"></A>Listing 9.8<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--Implementation
of the get_TextDataPath /put_TextDataPath Functions</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::get_TextDataPath(BSTR *
pVal) <BR>
{ <BR>
// return a copy of the member variable <BR>
*pVal = m_bstrTextDataPath.Copy(); <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::put_TextDataPath(BSTR newVal) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
// copy the new string to the member variable <BR>
m_bstrTextDataPath = newVal; <BR>
// clear the data buffer <BR>
m_bstrText = _T(&quot;&quot;); <BR>
// start the asynchronous download of the data <BR>
CBindStatusCallback&lt;CATLControlWin&gt;::Download(this, OnData, m_bstrTextDataPath,
<BR>
m_spClientSite, FALSE); <BR>
// let the container know that the property has changed <BR>
this-&gt;SetDirty(TRUE); <BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
return hResult; <BR>
} </TT></FONT></P>

<P><TT>OnData</TT> is a very basic implementation of the asynchronous data transfer
mechanism provided by the <TT>IBindStatusCallback</TT> interface and the <TT>CBindStatusCallback</TT>
class (see Listing 9.9). If the <TT>OnUData</TT> function is called, the new data
is appended to the <TT>m_bstrText</TT> member variable, and the <TT>CaptionMethod</TT>
is called. Throughout the <TT>OnData</TT> implementation, note the use of the <TT>CBindStatusCallback</TT>
members to determine the status of the current call to <TT>OnData</TT>. Also note
the use of the <TT>ReadyState</TT> property to indicate to the container application
that an asynchronous download is taking place and when it has finished. The BaseCtl
sample in <A HREF="ch10.htm">Chapters 10</A> and <A HREF="ch11.htm">11</A> demonstrates
how to implement asynchronous properties using the <TT>OnDataAvailable</TT> function.
<TT>OnDataAvailable</TT> gives you more information about the download of the data
and how it is taking place.
<H3><A NAME="Heading12"></A>Listing 9.9<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--OnData
Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>//OnData will be used as a callback functin by the CBindStatusCallback
object. <BR>
//OnData will be called periodically with data from the asynchronous transfer <BR>
void CATLControlWin::OnData(CBindStatusCallback&lt;CATLControlWin&gt;* pbsc, BYTE*
pBytes, <BR>
DWORD dwSize) <BR>
{ <BR>
// if we have not read any data yet <BR>
if(pbsc-&gt;m_dwTotalRead == 0) <BR>
{ <BR>
// clear the buffer <BR>
m_bstrText = _T(&quot;&quot;); <BR>
// set the ready state of the control <BR>
m_lReadyState = READYSTATE_LOADING; <BR>
// let the container know that the property has changed <BR>
this-&gt;Fire_ReadyStateChange(); <BR>
} <BR>
// add the data to our buffer <BR>
m_bstrText.Append((LPCSTR) pBytes); <BR>
long lRetVal; <BR>
VARIANT varAlignment; <BR>
// initialize the variant <BR>
::VariantInit(&amp;varAlignment); <BR>
<BR>
// defer to the CaptionMethod implementation <BR>
this-&gt;CaptionMethod(m_bstrText, varAlignment, &amp;lRetVal); <BR>
// if the function returned success <BR>
if(TRUE == lRetVal) <BR>
// let the control know that the property has changed <BR>
this-&gt;SetDirty(TRUE); <BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
// if there is nothing left <BR>
if(pbsc-&gt;m_dwAvailableToRead == 0) <BR>
{ <BR>
// set the ready state of the control <BR>
m_lReadyState = READYSTATE_COMPLETE; <BR>
// let the container know that the property has changed <BR>
this-&gt;Fire_ReadyStateChange(); <BR>
} <BR>
} </TT></FONT></P>
<P>The final touch of your asynchronous property implementation is to add the property
to the persistence macro in your class declaration (see Listing 9.10). Do not add
the <TT>ReadyState</TT> property to the persistence since its value is not valid
across execution lifetimes.
<H3><A NAME="Heading13"></A>Listing 9.10<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--TextDataPath
Member Added to the Property Persistence Macro</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_PROPERTY_MAP(CATLControlWin) <BR>
// PROP_ENTRY(&quot;Description&quot;, dispid, clsid) <BR>
PROP_ENTRY(&quot;TextDataPath&quot;, dispidTextDataPath, CLSID_ATLControlWinPPG)
<BR>
PROP_ENTRY(&quot;Alignment&quot;, dispidAlignment, CLSID_ATLControlWinPPG) <BR>
PROP_ENTRY(&quot;BackColor&quot;, DISPID_BACKCOLOR, CLSID_ATLControlWinPPG) <BR>
PROP_PAGE(CLSID_CColorPropPage) <BR>
END_PROPERTY_MAP() <BR>
. . . </TT></FONT></P>
<H3><A NAME="Heading14"></A>Static and Dynamic Property Enumeration</H3>
<P>Property enumeration is a way of restricting a property to a specific set of valid
values. An example of an enumeration is a property for determining the alignment
of a control's displayed text: left-justified, centered, and right-justified, in
your case. Another case is a property used to select the different languages a control
supports. A language-based property is a good candidate for both a static set, say
English and German, and a dynamic set, say for all the languages on a particular
machine.</P>
<P>As is pointed out in <A HREF="ch07.htm">Chapter 7</A>, property enumeration adds
a new level of sophistication to your control with very little effort.</P>
<P>You can take two approaches when creating an enumeration for a property: use a
static approach with an enumeration defined in the control's ODL or IDL file, or
use a dynamic approach with enumeration code implemented in the control itself. <B><BR>
<BR>
Static Property Enumeration</B><SPACER TYPE="HORIZONTAL" SIZE="10"> <I>Static property
enumeration</I> for an ATL-implemented control is no different than the MFC implementation.
Static enumeration is dependent on the ODL/IDL file and involves no control code
to implement. See <A HREF="ch07.htm">Chapter 7</A> for more information.</P>
<P><B>Dynamic Property Enumeration</B><SPACER TYPE="HORIZONTAL" SIZE="10"> As with
your MFC implementation, adding dynamic property enumeration to your ATL implementation
is straightforward. <I>Dynamic property enumeration</I> is based on the interface
<TT>IPerPropertyBrowsing</TT>. The ATL Object Wizard does not add this interface
to the control class automatically; you are required to add it yourself. The first
step is to add the <TT>IPerPropertyBrowsingImpl</TT> class to your control inheritance
structure:</P>

<P><FONT COLOR="#0066FF"><TT>public IPerPropertyBrowsingImpl&lt;CATLControlWin&gt;
</TT></FONT></P>

<P>And then add the <TT>IPerPropertyBrowsing</TT> interface to the COM interface
map:</P>

<P><FONT COLOR="#0066FF"><TT>COM_INTERFACE_ENTRY_IMPL(IPerPropertyBrowsing) </TT></FONT></P>

<P>The last step is to implement the <TT>IPerPropertyBrowsing</TT> interface functions.
First you add the function prototypes to the class declaration (see Listing 9.11).
<H3><A NAME="Heading15"></A>Listing 9.11<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--IPerPropertyBrowsing
Interface Function Prototypes Must Be Added to the Class Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid); <BR>
STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut, <BR>
CADWORD *pCaCookiesOut); <BR>
STDMETHOD(GetPredefinedValue)(DISPID dispID, DWORD dwCookie, VARIANT* pVarOut); <BR>
STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr); <BR>
. . . </TT></FONT></P>
<P><TT>MapPropertyToPage</TT> (see Listing 9.12) is used to identify a property to
a specific control or system-defined property page. In this case, you return <TT>E_NOTIMPL</TT>
if the <TT>dispid</TT> matches that of the <TT>Alignment</TT> property. By returning
<TT>E_NOTIMPL</TT>, you are preventing the container application from displaying
the property page associated with the property; instead, the container will use the
property enumeration that you have implemented. The connection between the property
and the property page is made in the property map macro in the class declaration.
Remember that one of the parameters in the macro was the <TT>CLSID</TT> of the property
page for the property.
<H3><A NAME="Heading16"></A>Listing 9.12<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--MapPropertyToPage
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::MapPropertyToPage(DISPID
dispID, CLSID *pClsid) <BR>
{ <BR>
// if this is the dispid property <BR>
if(dispID == dispidAlignment) <BR>
// defer to the property enumeration and not the property page <BR>
return E_NOTIMPL; <BR>
else <BR>
// defer to the base class implementation <BR>
return IPerPropertyBrowsingImpl&lt;CATLControlWin&gt;:: <BR>
MapPropertyToPage(dispID, pClsid); <BR>
} </TT></FONT></P>
<P><TT>GetPredefinedStrings</TT> is the first function to be called (see Listing
9.13). When this method is called, the <TT>dispid</TT> of the property that is currently
being referenced will be passed in. This method is called for all properties that
the control supports, so take care when adding code. If the function is called and
it is determined that the correct property is in context, the control is required
to create an array of strings and cookies. A <I>cookie</I> is any 32-bit value that
has meaning to the control implementation. In this case, the cookies that you supply
are the enumeration constants that you added in <A HREF="ch08.htm">Chapter 8</A>.
The strings are placed in a list from which the user of the control can select the
appropriate value to set the property.
<H3><A NAME="Heading17"></A>Listing 9.13 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--GetPredefinedStrings
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::GetPredefinedStrings(DISPID
dispid, <BR>
CALPOLESTR * lpcaStringsOut, CADWORD * lpcaCookiesOut) <BR>
{ <BR>
USES_CONVERSION; <BR>
HRESULT hResult = S_FALSE; <BR>
// we should have gotten two pointers if we didn't <BR>
if((lpcaStringsOut == NULL) || (lpcaCookiesOut == NULL)) <BR>
// we are out of here <BR>
return E_POINTER; <BR>
// if this is the property that we are looking for <BR>
if(dispid == dispidAlignment) <BR>
{ <BR>
ULONG ulElems = 3; <BR>
// allocate the memory for our string array <BR>
lpcaStringsOut-&gt;pElems = (LPOLESTR *) ::CoTaskMemAlloc( <BR>
sizeof(LPOLESTR) * ulElems); <BR>
// if we couldn't allocate the memory <BR>
if(lpcaStringsOut-&gt;pElems == NULL) <BR>
// were out of here <BR>
return E_OUTOFMEMORY; <BR>
// allocate the memory for our cookie array <BR>
lpcaCookiesOut-&gt;pElems = (DWORD*) ::CoTaskMemAlloc(sizeof(DWORD*) * ulElems);
<BR>
// if we couldn't allocate the memory <BR>
if (lpcaCookiesOut-&gt;pElems == NULL) <BR>
{ <BR>
// free the string array <BR>
::CoTaskMemFree(lpcaStringsOut-&gt;pElems); <BR>
// exit the function <BR>
return E_OUTOFMEMORY; <BR>
} <BR>
// store the number of elements in each array <BR>
lpcaStringsOut-&gt;cElems = ulElems; <BR>
lpcaCookiesOut-&gt;cElems = ulElems; <BR>
// allocate the strings <BR>
lpcaStringsOut-&gt;pElems[0] = ATLA2WHELPER((LPWSTR)::CoTaskMemAlloc( <BR>
(lstrlen(EALIGN_LEFT_TEXT) + 1) * 2), EALIGN_LEFT_TEXT, <BR>
lstrlen(EALIGN_LEFT_TEXT) + 1); <BR>
lpcaStringsOut-&gt;pElems[1] = ATLA2WHELPER((LPWSTR)::CoTaskMemAlloc( <BR>
(lstrlen(EALIGN_CENTER_TEXT) + 1) * 2), EALIGN_CENTER_TEXT, <BR>
lstrlen(EALIGN_CENTER_TEXT) + 1); <BR>
lpcaStringsOut-&gt;pElems[2] = ATLA2WHELPER((LPWSTR)::CoTaskMemAlloc( <BR>
(lstrlen(EALIGN_RIGHT_TEXT) + 1) * 2), EALIGN_RIGHT_TEXT, <BR>
lstrlen(EALIGN_RIGHT_TEXT) + 1); <BR>
// assign the cookie value <BR>
lpcaCookiesOut-&gt;pElems[0] = EALIGN_LEFT; <BR>
lpcaCookiesOut-&gt;pElems[1] = EALIGN_CENTER; <BR>
lpcaCookiesOut-&gt;pElems[2] = EALIGN_RIGHT; <BR>
hResult = S_OK; <BR>
} <BR>
return hResult; <BR>
} </TT></FONT></P>
<P><TT>GetPredefinedValue</TT> (see Listing 9.14) is the method that is called when
the property browser of the container needs the value associated with the particular
<TT>dispid</TT> and cookie. The value returned is the actual value that is stored
in the property and not the string that was used to represent it.
<H3><A NAME="Heading18"></A>Listing 9.14<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--GetPredefinedValue
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::GetPredefinedValue(DISPID
dispid, DWORD dwCookie, <BR>
VARIANT* lpvarOut) <BR>
{ <BR>
BOOL bResult = FALSE; <BR>
// which property is it <BR>
switch(dispid) <BR>
{ <BR>
case dispidAlignment: <BR>
// clear the variant <BR>
::VariantInit(lpvarOut); <BR>
// set the type to a long <BR>
lpvarOut-&gt;vt = VT_I4; <BR>
// set the value to the value that was stored with the string <BR>
lpvarOut-&gt;lVal = dwCookie; <BR>
// set the return value <BR>
bResult = TRUE; <BR>
break; <BR>
} <BR>
return bResult; <BR>
} </TT></FONT></P>
<P>After the property is set with its value, the property browser calls the function
<TT>GetDisplayString</TT> to get the string that is associated with the current property
setting (see Listing 9.15).
<H3><A NAME="Heading19"></A>Listing 9.15 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--GetDisplayString
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CATLControlWin::GetDisplayString(DISPID dispid, BSTR* lpbstr) <BR>
{ <BR>
USES_CONVERSION; <BR>
HRESULT hResult = S_FALSE; <BR>
// which property is it <BR>
switch(dispid) <BR>
{ <BR>
case dispidAlignment: <BR>
{ <BR>
switch(m_lAlignment) <BR>
{ <BR>
case EALIGN_LEFT: <BR>
*lpbstr = ::SysAllocString(T2OLE(EALIGN_LEFT_TEXT)); <BR>
break; <BR>
case EALIGN_CENTER: <BR>
*lpbstr = ::SysAllocString(T2OLE(EALIGN_CENTER_TEXT)); <BR>
break; <BR>
case EALIGN_RIGHT: <BR>
*lpbstr = ::SysAllocString(T2OLE(EALIGN_RIGHT_TEXT)); <BR>
break; <BR>
} <BR>
// set the return value <BR>
hResult = S_OK; <BR>
} <BR>
break; <BR>
} <BR>
return hResult; <BR>
} </TT></FONT></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Having the method <TT>GetDisplayString</TT> when the property browser
	already has the string for the value from the <TT>GetPredefinedStrings</TT> function
	may seem a little redundant. You do this because the <TT>GetDisplayString</TT> function
	can be implemented without implementing the other methods. Providing only the function
	<TT>GetDisplayString</TT> is done for those property types that do not use the standard
	property selection mechanism, for example, font selection that uses a font selection
	dialog and not a list of choices.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H2><A NAME="Heading20"></A>Drawing the Control</H2>
<P>Optimized drawing allows you to create drawing objects, such as pens or brushes.
Rather than removing them when you are finished drawing, you can store them as control
member variables and use them the next time your control draws itself. The benefit
is that you create a pen once for the drawing lifetime of your control, instead of
every time it draws. Here's one thing to remember, though: Optimized drawing does
not guarantee performance improvements. It simply supplies a framework for how drawing
should be performed and how drawing resources should be used. A poorly written control
is still poorly written, no matter how you slice it.</P>
<P>Standard and optimized drawings have a single tradeoff and that is size versus
speed. Standard drawing does not require member variables for the drawing objects
that are created and used-- thus requiring less instance data but more processing
time--whereas optimized code is the opposite.</P>
<P>An additional drawback to optimized drawing is that a container may not support
it. A control must, at the very least, support standard drawing functionality, deferring
to optimized only if it is available.</P>
<P>For ATL (like MFC), the scope of optimized drawing is very narrow compared to
the OC 96 specification, but it will, nonetheless, result in performance improvements
if taken advantage of. The OC 96 specification further breaks optimized drawing into
what is known as aspects. For more information on aspect drawing, please see the
OC 96 specification that ships with the ActiveX SDK.
<H3><A NAME="Heading21"></A>Optimized Drawing</H3>
<P>In <A HREF="ch08.htm">Chapter 8</A>, you learn how to implement standard drawing.
In this chapter, you enhance the original implementation to take advantage of drawing
optimization.</P>
<P>Add a message handler, <TT>OnDestroy</TT>, for the Windows message <TT>WM_DESTROY</TT>.
Also add an <TT>OnDestroy</TT> function prototype to the class declaration (see Listing
9.16). <TT>OnDestroy</TT> is used to clean up the drawing resources if any are still
around when the control is destroyed. This should happen <I>only</I> if the container
supports optimized drawing.
<H3><A NAME="Heading22"></A>Listing 9.16 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--Drawing
Implementation Member Variables and Functions</H3>
<P><FONT COLOR="#0066FF"><TT>BEGIN_MSG_MAP(CATLControlWin) <BR>
MESSAGE_HANDLER(WM_PAINT, OnPaint) <BR>
MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode) <BR>
MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus) <BR>
MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus) <BR>
MESSAGE_HANDLER(WM_DESTROY, OnDestroy) <BR>
END_MSG_MAP() <BR>
. . . <BR>
LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
. . . </TT></FONT></P>
<P>The next step is to add the <TT>OnDestroy</TT> implementation, which will clean
up the resources if they are still allocated (see Listing 9.17).
<H3><A NAME="Heading23"></A>Listing 9.17<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--OnDestroy
Implementation of Drawing Resource Cleanup</H3>
<P><FONT COLOR="#0066FF"><TT>LRESULT CATLControlWin::OnDestroy(UINT uMsg, WPARAM
wParam, LPARAM lParam, BOOL<BR>
&amp; bHandled) <BR>
{ <BR>
// if there is an old brush <BR>
if(hOldBrush) <BR>
{ <BR>
// get the DC <BR>
HDC hDC = this-&gt;GetDC(); <BR>
// select the old brush back <BR>
::SelectObject(hDC, hOldBrush); <BR>
// release the DC <BR>
this-&gt;ReleaseDC(hDC); <BR>
} <BR>
// if we created a brush <BR>
if(hBrush) <BR>
// destroy the brush we created <BR>
::DeleteObject(hBrush); <BR>
return TRUE; <BR>
} </TT></FONT></P>
<P>The last step is to update the <TT>OnDraw</TT> implementation to take advantage
of optimized drawing, if the container supports optimized drawing that is (see Listing
9.18). The only line that you need to add to the code is one that checks the <TT>bOptimize</TT>
member of the <TT>ATL_DRAWINFO</TT> structure to see if it is set to 0 (or <TT>FALSE</TT>),
which indicates that the container does not support optimized drawing. If that is
the case, you then clean up all of your allocated resources and restore any original
values. If the container does support optimized drawing, you ignore the cleanup and
reuse the allocated resources the next time around.
<H3><A NAME="Heading24"></A>Listing 9.18 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--OnDraw
Function Updated to Support Optimized Drawing</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CATLControlWin::OnDraw(ATL_DRAWINFO &amp; di)
<BR>
{ <BR>
. . . <BR>
// The container does not support optimized drawing. <BR>
if(!di.bOptimize) <BR>
{ <BR>
// select the old brush back <BR>
::SelectObject(di.hdcDraw, hOldBrush); <BR>
// destroy the brush we created <BR>
::DeleteObject(hBrush); <BR>
// clear the brush handles <BR>
hBrush = hOldBrush = NULL; <BR>
} <BR>
return S_OK; <BR>
} </TT></FONT></P>
<H2><A NAME="Heading25"></A>Adding Clipboard and Drag and Drop Support</H2>
<P>The basic OLE Clipboard and Drag and Drop interfaces are only partially implemented
within your control implementation. As for the <TT>IPerPropertyBrowsing</TT> interface,
you must implement the remaining required interfaces yourself. As is pointed out
in <A HREF="ch07.htm">Chapter 7</A>, Clipboard and Drag and Drop support can add
much to your control implementation while requiring very little work.
<H3><A NAME="Heading26"></A>Clipboard Support</H3>
<P><I>Clipboard support</I> is based on the <TT>IDataObject</TT> and <TT>IEnumFORMATETC</TT>
interfaces. <TT>IDataObject</TT> is the interface through which the data is retrieved
from your control when it has been placed on the Clipboard, and <TT>IEnumFORMATETC</TT>
is the interface that is used by an application to determine what types of data your
<TT>IDataObject</TT> interface supports. In a basic ATL control project, only the
<TT>IDataObject</TT> Interface is supported. The <TT>IEnumFORMATETC</TT> interface
must be added.</P>
<P>Before adding the specific interfaces required by ActiveX to enable Clipboard
transfers, you must first decide which keystroke combinations will be used to initiate
the cut, copy, or paste operations. Fortunately, the Windows operating system (OS)
already has a number of standards in this area. You use Ctrl+X and Shift+Delete for
Cut, Ctrl+C and Ctrl+Insert for Copy, and Ctrl+V and Shift+Insert for Paste.</P>
<P>To trap the keystroke combinations, you need to implement a message handler for
the <TT>WM_KEYDOWN</TT> message in the form of a method called <TT>OnKeyDown</TT>
(see Listing 9.19).
<H3><A NAME="Heading27"></A>Listing 9.19<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--WM_KEYDOWN
and OnKeyDown Message Handler Added to the Class Declaration of the Control</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_MSG_MAP(CATLControlWin) <BR>
MESSAGE_HANDLER(WM_PAINT, OnPaint) <BR>
MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode) <BR>
MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus) <BR>
MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus) <BR>
MESSAGE_HANDLER(WM_DESTROY, OnDestroy) <BR>
MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown) <BR>
END_MSG_MAP() <BR>
. . . <BR>
LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
. . . </TT></FONT></P>
<P>The <TT>OnKeyDown</TT> implementation looks for the particular keystroke combinations
listed in the preceding paragraph and upon finding them invokes the proper set of
functions to complete the requested Clipboard operation (see Listing 9.20). Note
that in addition to copying the data to the Clipboard, the Cut operation clears the
control's data.
<H3><A NAME="Heading28"></A>Listing 9.20<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--OnKeyDown
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>LRESULT CATLControlWin::OnKeyDown(UINT uMsg, WPARAM
wParam, LPARAM lParam, <BR>
BOOL &amp; bHandled) <BR>
{ <BR>
UINT nChar = wParam; <BR>
UINT nRepCnt = LOWORD(lParam); <BR>
UINT nFlags = HIWORD(lParam); <BR>
// find out if the shift key is being held down <BR>
short sShift = ::GetKeyState(VK_SHIFT); <BR>
// find out if the control key is being held down <BR>
short sControl = ::GetKeyState(VK_CONTROL); <BR>
switch(nChar) <BR>
{ <BR>
// COPY <BR>
case 0x43: // `C' <BR>
case 0x63: // `c' <BR>
case VK_INSERT: <BR>
// if the control key is being held down <BR>
if(sControl &amp; 0x8000) <BR>
{ <BR>
// copy the data to the clipboard <BR>
this-&gt;CopyDataToClipboard(); <BR>
// we don't need to pass this key to the base implementation <BR>
bHandled = TRUE; <BR>
} <BR>
break; <BR>
// CUT <BR>
case 0x58: // `X' <BR>
case 0x78: // `x' <BR>
case VK_DELETE: <BR>
// if this is a shift delete OR CTRL-X/x <BR>
if((nChar == VK_DELETE &amp;&amp; (sShift &amp; 0x8000)) || <BR>
((nChar == 0x58 || nChar == 0x78) &amp;&amp; (sControl &amp; 0x8000))) <BR>
{ <BR>
this-&gt;CopyDataToClipboard(); <BR>
// clear the string since this is a CUT operation <BR>
delete [] m_lptstrCaption; <BR>
// NULL terminate the string reference <BR>
m_lptstrCaption = new TCHAR[1]; <BR>
m_lptstrCaption[0] = `\0'; <BR>
// fire the global change event <BR>
this-&gt;FireChange(); <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
// we don't need to pass this key to the base implementation <BR>
bHandled = TRUE; <BR>
} <BR>
break; <BR>
} <BR>
return TRUE; <BR>
} </TT></FONT></P>
<P>In addition to the code that you added to trap the keystrokes, you need to add
four methods for dealing with the Clipboard transfers. You will examine these four
methods in detail in the next section.</P>
<P><TT>CopyDataToClipboard</TT> will, as the name implies, get the data from the
control and, using the helper function, <TT>PrepareDataForTransfer</TT>, package
the data and put it on the Clipboard.</P>
<P><TT>GetDataFromClipboard</TT> will open the Clipboard and look for data formats
that the control understands. Upon finding a suitable format, <TT>GetDataFromClipboard</TT>
will use the helper function <TT>GetDataFromTransfer</TT> to store the data in the
control.</P>
<P>When you enable the control for Drag and Drop support, you are aided by the fact
that the data transfer functions are separated into two separate methods for each
type of transfer, to and from the Clipboard, and then each type of transfer is further
broken into two separate steps. Because the basic data transfer mechanism is the
same between the Clipboard and Drag and Drop, you are able to rely on a large portion
of shared code for each implementation. <B><BR>
<BR>
Using Built-In Clipboard Formats</B> <SPACER TYPE="HORIZONTAL" SIZE="10">As we point
out in <A HREF="ch07.htm">Chapter 7</A>, the Windows OS supports a number of built-in
formats for transferring data via the Clipboard. Your first implementation is to
transfer the caption of your control by using the <TT>CF_TEXT</TT> format, which
is the built-in format for transferring ANSI text. There are two aspects to using
the Clipboard: being a Clipboard source and being a Clipboard target. Being a Clipboard
source refers to an application's capability to copy data <I>to</I> the Clipboard.
Being a Clipboard target refers to an applications capability to copy data <I>from</I>
the Clipboard. You first look at enabling your control as a Clipboard source. <B><I><BR>
<BR>
Enabling a Control as a Clipboard Source</I></B> <SPACER TYPE="HORIZONTAL" SIZE="10">A
<I>Clipboard source</I> is an application that puts data on the Clipboard for other
applications to copy. An application must support two COM interfaces, <TT>IDataObject</TT>
and <TT>IEnumFORMATETC</TT>, in order to qualify as a valid Clipboard source. When
copying data to the Clipboard, the <TT>OnKeyDown</TT> implementation takes advantage
of several helper functions: <TT>CopyDataToClipboard</TT>,<TT> PrepareDataForTransfer</TT>,
and <TT>CopyStgMedium</TT>. <TT>CopyStgMedium</TT>, <TT>CopyDataToClipboard</TT>,
and <TT>PrepareDataForTransfer</TT> are used to prepare your data structures--the
member variables <TT>sTextFormatEtc</TT> and <TT>sTextStgMedium</TT>--for a potential
paste operation. The member variable <TT>ulFORMATETCElement</TT> is the internal
counter for the <TT>IEnumFORMATETC</TT> interface. First you need to add the two
function prototypes to the <TT>CATLControlWin</TT> class declaration (see Listing
9.21).
<H3><A NAME="Heading29"></A>Listing 9.21<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--Helper
Functions and Member Variables for Clipboard Support</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
void CopyDataToClipboard(void); <BR>
void PrepareDataForTransfer(void); <BR>
void CopyStgMedium(LPSTGMEDIUM lpTargetStgMedium, <BR>
LPSTGMEDIUM lpSourceStgMedium, CLIPFORMAT cfSourceFormat); <BR>
ULONG ulFORMATETCElement; <BR>
private: <BR>
FORMATETC sTextFormatEtc; <BR>
STGMEDIUM sTextStgMedium; <BR>
}; </TT></FONT></P>
<P>When the user initiates a data transfer via the Clipboard, a reference to the
control's <TT>IDataObject</TT> interface is placed on the Clipboard. At the time
the interface is placed on the Clipboard, you have to take a snapshot of the data
that the control contains and place it in a <TT>STGMEDIUM</TT> object. You do this
because the data may not be copied from the Clipboard immediately; the data needs
to reflect the state of the control when the copy operation was initiated rather
than when the paste operation takes place. Once the <TT>IDataObject</TT> interface
is on the Clipboard, you simply wait until someone requests the data. If a supported
data format is requested, you copy the data from your <TT>STGMEDIUM</TT> structure
to the <TT>STGMEDIUM</TT> structure that was passed to you.</P>
<P>The <TT>IDataObject</TT> interface is already included in your control's inheritance
hierarchy. The <TT>IEnumFORMATETC</TT> interface, however, must be added (see Listing
9.22). Since you will be implementing various member functions of the <TT>IDataObject</TT>
and the <TT>IEnumFORMATETC</TT> interfaces, you must add the function prototypes
to the class declaration of your control. Note that you need to add prototypes for
only those functions that you intend to implement; the remainder are left to their
default implementations.
<H3><A NAME="Heading30"></A>Listing 9.22 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--IEnumFORMATETC
Interface Added to theClass Inheritance Hierarchy</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
public IPerPropertyBrowsingImpl&lt;CATLControlWin&gt;, <BR>
public IEnumFORMATETC <BR>
{ <BR>
public: <BR>
. . . <BR>
// IDataObject <BR>
STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM); <BR>
STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*); <BR>
// IEnumFORMATETC <BR>
STDMETHOD(Next)(ULONG celt, FORMATETC __RPC_FAR * rgelt, <BR>
ULONG __RPC_FAR * pceltFetched); <BR>
STDMETHOD(Skip)(ULONG celt); <BR>
STDMETHOD(Reset)(void); <BR>
STDMETHOD(Clone)(IEnumFORMATETC __RPC_FAR *__RPC_FAR * ppenum); <BR>
. . . </TT></FONT></P>
<P>The two member variables, <TT>sTextFormatEtc</TT> and <TT>sTextStgMedium</TT>,
must be initialized in the constructor of your class so that they will not contain
meaningless data the first time that they are used (see Listing 9.23).
<H3><A NAME="Heading31"></A>Listing 9.23 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--Member
Initialization in the Class Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// set the initial state of the ReadyState property <BR>
m_lReadyState = READYSTATE_LOADING; <BR>
// set to the first element <BR>
ulFORMATETCElement = 0; <BR>
// clear the storage medium <BR>
sTextStgMedium.hGlobal = NULL; <BR>
} <BR>
. . . </TT></FONT></P>
<P>The next step is to implement the member functions that will actually perform
the data preparation and copy operation to the Clipboard.</P>
<P><TT>CopyDataToClipboard</TT> is the function that is called to initiate the Clipboard
transfer (see Listing 9.24). You first check to see whether you are already the owner
of the Clipboard and set the Boolean variable accordingly. You then prepare your
data for the Clipboard, and finally if you are not the owner of the Clipboard, you
flush whatever data is on the Clipboard and set your <TT>IDataObject</TT> reference
on the Clipboard.
<H3><A NAME="Heading32"></A>Listing 9.24 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--CopyDataToClipboard
Helper Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::CopyDataToClipboard(void) <BR>
{ <BR>
BOOL bHaveClipboard = TRUE; <BR>
// if we don't have an IDataObject on the clipboard? <BR>
if(::OleIsCurrentClipboard((IDataObject *) this) != S_OK) <BR>
// set the flag <BR>
bHaveClipboard = FALSE; <BR>
// put data in the storage <BR>
this-&gt;PrepareDataForTransfer(); <BR>
// if we don't have the clipboard <BR>
if(!bHaveClipboard) <BR>
{ <BR>
// clear the clipboard <BR>
::OleFlushClipboard(); <BR>
// put the data on the clipboard <BR>
::OleSetClipboard(reinterpret_cast&lt;IDataObject*&gt; <BR>
(static_cast&lt;IDataObjectImpl&lt;CATLControlWin&gt;*&gt;(this))); <BR>
} <BR>
} </TT></FONT></P>
<P><TT>PrepareDataForTransfer</TT> is the function that you call when you want to
copy the data from your control to the <TT>STGMEDIUM</TT> structure that will represent
your data on the Clipboard (see Listing 9.25). First you need to allocate a block
of global memory that will contain your caption in ANSI format. Then you set up the
<TT>FORMATETC</TT> and <TT>STGMEDIUM</TT> structures to reflect the correct data
type and exit the function.
<H3><A NAME="Heading33"></A>Listing 9.25 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--PrepareDataForTransfer
Helper Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::PrepareDataForTransfer(void) <BR>
{ <BR>
// get the length of the data to copy <BR>
long lLength = lstrlen(m_lptstrCaption) + 1; <BR>
// create a global memory object <BR>
HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, <BR>
sizeof(TCHAR) * lLength); <BR>
// lock the memory down <BR>
LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(hGlobal); <BR>
// copy the string <BR>
for(long lCount = 0; lCount &lt; lLength - 1; lCount++) <BR>
lpTempBuffer[lCount] = m_lptstrCaption[lCount]; <BR>
// null terminate the string <BR>
lpTempBuffer[lCount] = `\0'; <BR>
// unlock the memory <BR>
::GlobalUnlock(hGlobal); <BR>
// copy all of the members <BR>
sTextFormatEtc.cfFormat = CF_TEXT; <BR>
sTextFormatEtc.ptd = NULL; <BR>
sTextFormatEtc.dwAspect = 0; <BR>
sTextFormatEtc.lindex = -1; <BR>
sTextFormatEtc.tymed = TYMED_HGLOBAL; <BR>
// if we have already allocated the data <BR>
if(sTextStgMedium.hGlobal) <BR>
// release it <BR>
::ReleaseStgMedium(&amp;sTextStgMedium); <BR>
sTextStgMedium.tymed = TYMED_HGLOBAL; <BR>
sTextStgMedium.hGlobal = hGlobal; <BR>
sTextStgMedium.pUnkForRelease = NULL; <BR>
} </TT></FONT></P>
<P><TT>CopyStgMedium</TT> is a general purpose helper function for copying one <TT>STGMEDIUM</TT>
to another <TT>STGMEDIUM</TT> (see Listing 9.26). This implementation is important
because the function allocates a new global data object instead of copying the reference
to the existing object.
<H3><A NAME="Heading34"></A>Listing 9.26<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--CopyStgMedium
Helper Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::CopyStgMedium(LPSTGMEDIUM lpTargetStgMedium,
<BR>
LPSTGMEDIUM lpSourceStgMedium, CLIPFORMAT cfSourceFormat) <BR>
{ <BR>
// copy the stgmedium members <BR>
lpTargetStgMedium-&gt;tymed = lpSourceStgMedium-&gt;tymed; <BR>
lpTargetStgMedium-&gt;pUnkForRelease = lpSourceStgMedium-&gt;pUnkForRelease; <BR>
lpTargetStgMedium-&gt;hGlobal = ::OleDuplicateData(lpSourceStgMedium-&gt;hGlobal,
<BR>
cfSourceFormat, GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT); <BR>
} </TT></FONT></P>
<P>The last step is to implement the <TT>IDataObject</TT> and <TT>IEnumFORMATETC</TT>
interfaces.</P>
<P>The <TT>IDataObject</TT> implementation is straightforward and involves only two
functions (see Listing 9.27). The remainder of the <TT>IDataObject</TT> functions
are already implemented by the ATL class <TT>IDataObjectImpl</TT>. <TT>GetData</TT>
will, if the format type matches that of a format that your control understands,
copy the control's current data to the <TT>STGMEDIUM</TT> parameter that is passed
to the control. If the format type is unrecognized, you must defer to the base class
implementation of <TT>GetData</TT>. Doing this is very important since the ATL class
<TT>CComControlBase</TT> does implement the <TT>IDataObject::GetData</TT> function
for copying <TT>metafile</TT> data formats. <TT>EnumFormatEtc</TT> is used to return
an <TT>IEnumFORMATETC</TT> reference to the requesting application so that it can
determine what types of data formats are supported by the control implementation.
Again, you must defer to the base class implementation to ensure that the control
implementation functions correctly; however, in this case, the default ATL implementation
of this function returns <TT>E_NOTIMPL</TT>.
<H3><A NAME="Heading35"></A>Listing 9.27 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--IDataObject
Interface Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
STDMETHODIMP CATLControlWin::GetData(LPFORMATETC lpFormatEtc, <BR>
LPSTGMEDIUM lpStgMedium) <BR>
{ <BR>
// if this is a format that we can deal with <BR>
if(lpFormatEtc-&gt;cfFormat == CF_TEXT &amp;&amp; lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL)
<BR>
{ <BR>
// get a copy of the current stgmedium <BR>
this-&gt;CopyStgMedium(lpStgMedium, &amp;sTextStgMedium, CF_TEXT); <BR>
return S_OK; <BR>
} <BR>
else <BR>
return IDataObjectImpl&lt;CATLControlWin&gt;::GetData(lpFormatEtc, lpStgMedium);
<BR>
} <BR>
STDMETHODIMP CATLControlWin::EnumFormatEtc(DWORD dwDirection, <BR>
LPENUMFORMATETC* ppenumFormatEtc) <BR>
{ <BR>
// we support &quot;get&quot; operations <BR>
if(dwDirection == DATADIR_GET) <BR>
{ <BR>
// make the assignment <BR>
*ppenumFormatEtc = (IEnumFORMATETC *) this; <BR>
<BR>
// increment the reference count <BR>
(*ppenumFormatEtc)-&gt;AddRef(); <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
return IDataObjectImpl&lt;CATLControlWin&gt;::EnumFormatEtc( <BR>
dwDirection, ppenumFormatEtc); <BR>
} <BR>
. . . </TT></FONT></P>
<P>The <TT>IEnumFORMATETC</TT> implementation is also simple (see Listing 9.28).
The one thing to note is that there is no default ATL implementation, so it is not
necessary to defer to the base class implementation in the case where you do not
handle the function. <TT>Next</TT> is used to retrieve the next element in the enumeration;
in this case, you need be concerned with only one element, <TT>CF_TEXT</TT>. After
filling in the <TT>FORMATETC</TT> structure with the appropriate data, you must increment
the counter and exit the function. The <TT>Skip</TT> method increments the counter
and exits the function, and <TT>Reset</TT> sets the counter back to 0.
<H3><A NAME="Heading36"></A>Listing 9.28 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--IEnumFORMATETC
Interface Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::Next(ULONG celt, FORMATETC_RPC_FAR
* rgelt, <BR>
ULONG RPC_FAR * pceltFetched) <BR>
{ <BR>
// if we are at the beginning of the enumeration <BR>
if(ulFORMATETCElement == 0 &amp;&amp; celt &gt; 0) <BR>
{ <BR>
// copy all of the members <BR>
rgelt-&gt;cfFormat = CF_TEXT; <BR>
rgelt-&gt;ptd = NULL; <BR>
rgelt-&gt;dwAspect = 0; <BR>
rgelt-&gt;lindex = -1; <BR>
rgelt-&gt;tymed = TYMED_HGLOBAL; <BR>
<BR>
// if the caller wants to know how many we copied <BR>
if(pceltFetched) <BR>
*pceltFetched = 1; <BR>
// increment the counter <BR>
ulFORMATETCElement++; <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
else <BR>
// return failure <BR>
return S_FALSE; <BR>
} <BR>
STDMETHODIMP CATLControlWin::Skip(ULONG celt) <BR>
{ <BR>
// move the counter by the number of elements supplied <BR>
ulFORMATETCElement += celt; <BR>
<BR>
// return success <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::Reset(void) <BR>
{ <BR>
// reset to the beginning of the enumerator <BR>
ulFORMATETCElement = 0; <BR>
<BR>
// return success <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::Clone( <BR>
IEnumFORMATETC_RPC_FAR *__RPC_FAR * /*ppenum*/) <BR>
{ <BR>
return E_NOTIMPL; <BR>
} </TT></FONT></P>
<P>Now that you know how to copy data to the Clipboard, you look at how to get data
from the Clipboard. <B><BR>
<BR>
Enabling a Control as a Clipboard Target</B> <SPACER TYPE="HORIZONTAL" SIZE="10">The
opposite of being a Clipboard source is being a Clipboard target. First you need
to update the <TT>CATLControlWin</TT> class declaration to include two new helper
functions (see Listing 9.29).
<H3><A NAME="Heading37"></A>Listing 9.29 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--Clipboard
Target Support Helper Function Prototypes</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
void CopyDataToClipboard(void); <BR>
void PrepareDataForTransfer(void); <BR>
void GetDataFromClipboard(void); <BR>
void GetDataFromTransfer(IDataObject * ipDataObj); <BR>
void CopyStgMedium(LPSTGMEDIUM lpTargetStgMedium, <BR>
LPSTGMEDIUM lpSourceStgMedium, CLIPFORMAT cfSourceFormat); <BR>
. . . </TT></FONT></P>
<P>Getting data from the Clipboard is almost as easy as putting the data on the Clipboard
in the first place. The first method is <TT>GetDataFromClipboard</TT>, which, as
the name implies, gets the data from the Clipboard and transfers it to the control.
The function first checks the Clipboard to see whether the control already owns the
Clipboard. If the control does own the Clipboard, it refreshes the control's data
with the data that is stored in the <TT>STGMEDIUM</TT> structure. The implementation
is written this way because the data stored in the control may have changed since
it was pasted to the Clipboard in the first place.</P>
<P>If you don't already own the Clipboard, you get the <TT>IDataObject</TT> reference
of the object that does, and you pass the reference on to the <TT>GetDataFromTransfer</TT>
function (see Listing 9.30).
<H3><A NAME="Heading38"></A>Listing 9.30<SPACER TYPE="HORIZONTAL" SIZE="10"> MFCCONTROLWINCTL.CPP--GetDataFromClipboard
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::GetDataFromClipboard(void) <BR>
{ <BR>
// get an IDataObject pointer <BR>
IDataObject * ipClipboardDataObj = NULL; <BR>
// do we have an IDataObject on the clipboard? <BR>
if(::OleIsCurrentClipboard((IDataObject *) this) == S_OK) <BR>
{ <BR>
// get the global data for this format and lock down the memory <BR>
LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(sTextStgMedium.hGlobal); <BR>
// if we have a string <BR>
if(m_lptstrCaption) <BR>
{ <BR>
// delete the existing string <BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe <BR>
m_lptstrCaption = NULL; <BR>
} <BR>
// allocate a new string <BR>
m_lptstrCaption = new TCHAR[lstrlen(lpTempBuffer) + 1]; <BR>
// assign the string to our member variable <BR>
lstrcpy(m_lptstrCaption, lpTempBuffer); <BR>
// unlock the memory <BR>
::GlobalUnlock(sTextStgMedium.hGlobal); <BR>
return; <BR>
} <BR>
else if(::OleGetClipboard(&amp;ipClipboardDataObj) == S_OK) <BR>
{ <BR>
// transfer the data to the control <BR>
this-&gt;GetDataFromTransfer(ipClipboardDataObj); <BR>
// release the IDataObject <BR>
ipClipboardDataObj-&gt;Release(); <BR>
} <BR>
} </TT></FONT></P>
<P><TT>GetDataFromTransfer</TT> requests the <TT>IEnumFORMATETC</TT> interface from
the <TT>IDataObject</TT> and cycles through all of the supported formats looking
for one that matches <TT>CF_TEXT</TT> (see Listing 9.31). Upon finding the appropriate
format, it requests the data from the <TT>IDataObject</TT> supplying a <TT>FORMATETC</TT>
and a <TT>STGMEDIUM</TT> structure. The data is transferred to the control, and the
<TT>STGMEDUIM</TT> is released. Finally you release the interface pointers and, if
you found a format, force the control to repaint itself reflecting the new state
of the control.
<H3><A NAME="Heading39"></A>Listing 9.31<SPACER TYPE="HORIZONTAL" SIZE="10"> MFCCONTROLWINCTL.CPP--GetDataFromTransfer
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::GetDataFromTransfer(IDataObject
* ipDataObj) <BR>
{ <BR>
IEnumFORMATETC * ipenumFormatetc; <BR>
BOOL bFound = FALSE; <BR>
// get a FORMATETC enumerator <BR>
if(ipDataObj-&gt;EnumFormatEtc(DATADIR_GET, &amp;ipenumFormatetc) == S_OK) <BR>
{ <BR>
// reset the enumerator just to be safe <BR>
ipenumFormatetc-&gt;Reset(); <BR>
FORMATETC etc; <BR>
// while there are formats to enumerate <BR>
while(ipenumFormatetc-&gt;Next(1, &amp;etc, NULL) == S_OK) <BR>
{ <BR>
// is this a format that we are looking for? <BR>
if(etc.cfFormat == CF_TEXT &amp;&amp; etc.tymed &amp; TYMED_HGLOBAL) <BR>
{ <BR>
STGMEDIUM sStgMediumData; <BR>
// get the data from the stgmedium <BR>
if(ipDataObj-&gt;GetData(&amp;etc, &amp;sStgMediumData) == S_OK) <BR>
{ <BR>
// get the global data for this format <BR>
// and lock down the memory <BR>
LPTSTR lpTempBuffer = (LPTSTR) <BR>
::GlobalLock(sStgMediumData.hGlobal); <BR>
// if we have a string <BR>
if(m_lptstrCaption) <BR>
{ <BR>
// delete the existing string <BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe <BR>
m_lptstrCaption = NULL; <BR>
} <BR>
// allocate a new string <BR>
m_lptstrCaption = new TCHAR[lstrlen(lpTempBuffer) + 1]; <BR>
// assign the string to our member variable <BR>
lstrcpy(m_lptstrCaption, lpTempBuffer); <BR>
// unlock the memory <BR>
::GlobalUnlock(sStgMediumData.hGlobal); <BR>
// release the storage medium <BR>
::ReleaseStgMedium(&amp;sStgMediumData); <BR>
// indicate success <BR>
bFound = TRUE; <BR>
} <BR>
} <BR>
} <BR>
<BR>
// release the enumerator <BR>
ipenumFormatetc-&gt;Release(); <BR>
} <BR>
// if we found a format <BR>
if(bFound == TRUE) <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
} </TT></FONT></P>
<P>Remember that earlier in the section, the <TT>OnKeyDown</TT> function was implemented
to support transferring data to the Clipboard. Now you must add the code to support
transferring from the Clipboard (see Listing 9.32).
<H3><A NAME="Heading40"></A>Listing 9.32 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--OnKeyDown
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>LRESULT CATLControlWin::OnKeyDown(UINT uMsg, WPARAM
wParam, LPARAM lParam, <BR>
BOOL &amp; bHandled) <BR>
{ <BR>
UINT nChar = wParam; <BR>
UINT nRepCnt = LOWORD(lParam); <BR>
UINT nFlags = HIWORD(lParam); <BR>
// find out if the shift key is being held down <BR>
short sShift = ::GetKeyState(VK_SHIFT); <BR>
// find out if the control key is being held down <BR>
short sControl = ::GetKeyState(VK_CONTROL); <BR>
switch(nChar) <BR>
{ <BR>
// PASTE <BR>
case 0x56: // `V' <BR>
case 0x76: // `v' <BR>
// if the control key is being held down <BR>
if(sControl &amp; 0x8000) <BR>
{ <BR>
// get any text from the clipboard <BR>
this-&gt;GetDataFromClipboard(); <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
// we don't need to pass this key to the base implementation <BR>
bHandled = TRUE; <BR>
} <BR>
break; <BR>
// COPY or PASTE <BR>
case 0x43: // `C' <BR>
case 0x63: // `c' <BR>
case VK_INSERT: <BR>
// if the control key is being held down <BR>
if(sControl &amp; 0x8000) <BR>
{ <BR>
// copy the data to the clipboard <BR>
this-&gt;CopyDataToClipboard(); <BR>
// we don't need to pass this key to the base implementation <BR>
bHandled = TRUE; <BR>
} <BR>
// if the shift key is being held down it is a PASTE <BR>
else if(sShift &amp; 0x8000 &amp;&amp; nChar == VK_INSERT) <BR>
{ <BR>
// get any text from the clipboard <BR>
this-&gt;GetDataFromClipboard(); <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
// we don't need to pass this key to the base implementation <BR>
bHandled = TRUE; <BR>
} <BR>
break; <BR>
// CUT <BR>
case 0x58: // `X' <BR>
case 0x78: // `x' <BR>
case VK_DELETE: <BR>
// if this is a shift delete OR CTRL-X/x <BR>
if((nChar == VK_DELETE &amp;&amp; (sShift &amp; 0x8000)) || <BR>
((nChar == 0x58 || nChar == 0x78) &amp;&amp; (sControl &amp; 0x8000))) <BR>
{ <BR>
this-&gt;CopyDataToClipboard(); <BR>
// clear the string since this is a CUT operation <BR>
delete [] m_lptstrCaption; <BR>
// NULL terminate the string reference <BR>
m_lptstrCaption = new TCHAR[1]; <BR>
m_lptstrCaption[0] = `\0'; <BR>
// fire the global change event <BR>
this-&gt;FireChange(); <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
// we don't need to pass this key to the base implementation <BR>
bHandled = TRUE; <BR>
} <BR>
break; <BR>
} <BR>
return TRUE; <BR>
} </TT></FONT></P>
<P><B>Custom Clipboard Formats</B><SPACER TYPE="HORIZONTAL" SIZE="10"> The Clipboard
is capable of supporting custom formats as well as built-in formats defined by the
operating system. Fortunately, the implementation of custom formats for the Clipboard
is the same as for Drag and Drop. First you learn how to support Drag and Drop and
then how to support custom formats.
<H3><A NAME="Heading41"></A>Drag and Drop Support</H3>
<P>The fundamentals of <I>Drag and Drop</I> are very similar to Clipboard support
and rely on the same set of interfaces for the actual data transfer as well as for
two new interfaces: <TT>IDropSource</TT> and <TT>IDropTarget</TT>. <TT>IDropSource</TT>
is for those controls that can create data that can be dropped onto another application.
<TT>IDropTarget</TT> is for those controls that can accept data that has been dropped
from another application. <B><BR>
<BR>
Using Built-In Drag and Drop Formats</B><SPACER TYPE="HORIZONTAL" SIZE="10"> Since
Drag and Drop is essentially a Clipboard transfer, with fewer steps involved, Drag
and Drop uses the same built-in data formats as the Clipboard transfers do. As with
Clipboard transfers, there are two sides to the Drag and Drop coin. An application
can be either a Drag and Drop source or a Drag and Drop target, or both. <B><I><BR>
<BR>
Enabling a Control as a Drag and Drop Source</I></B> <SPACER TYPE="HORIZONTAL" SIZE="10">The
first part of your implementation is to enable the control as a Drag and Drop source.
To be a Drag and Drop source, the control must implement the <TT>IDropSource</TT>
interface in addition to the <TT>IDataObject</TT> and <TT>IEnumFORMATETC</TT> interfaces.
The <TT>IDropSource</TT> interface is declared in the same manner as the other COM
interfaces (see Listing 9.33). The implementation is easy since the interface consists
of only two methods.
<H3><A NAME="Heading42"></A>Listing 9.33<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--IDropSource
Interface Added to the CATLControlWin Class Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
public IEnumFORMATETC, <BR>
public IDropSource <BR>
{ <BR>
public: <BR>
CATLControlWin() <BR>
. . . <BR>
COM_INTERFACE_ENTRY(IEnumFORMATETC) <BR>
COM_INTERFACE_ENTRY(IDropSource) <BR>
END_COM_MAP() <BR>
. . . <BR>
// IEnumFORMATETC <BR>
STDMETHOD(Next)(ULONG celt, FORMATETC __RPC_FAR * rgelt, <BR>
ULONG __RPC_FAR * pceltFetched); <BR>
STDMETHOD(Skip)(ULONG celt); <BR>
STDMETHOD(Reset)(void); <BR>
STDMETHOD(Clone)(IEnumFORMATETC __RPC_FAR *__RPC_FAR * ppenum); <BR>
// IDropSource <BR>
STDMETHOD(QueryContinueDrag)(BOOL fEscapePressed, DWORD dwKeyState); <BR>
STDMETHOD(GiveFeedback)(DWORD dwEffect); <BR>
. . . </TT></FONT></P>
<P>The first step is to initiate a Drag and Drop operation. You use the left mouse
button down event, which is implemented with the <TT>WM_LBUTTONDOWN </TT>message,
to initiate the Drag and Drop operation. You need to implement a message handler
for the <TT>WM_LBUTTONDOWN</TT> message (see Listing 9.34) in the form of a method
called <TT>OnLButtonDown</TT>.
<H3><A NAME="Heading43"></A>Listing 9.34 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--WM_LBUTTONDOWN
and OnLButtonDown Message Handler Added to the Class Declaration of the Control</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_MSG_MAP(CATLControlWin) <BR>
MESSAGE_HANDLER(WM_PAINT, OnPaint) <BR>
MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode) <BR>
MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus) <BR>
MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus) <BR>
MESSAGE_HANDLER(WM_DESTROY, OnDestroy) <BR>
MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown) <BR>
MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown) <BR>
END_MSG_MAP() <BR>
. . . <BR>
LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
. . . </TT></FONT></P>
<P>The <TT>OnLButtonDown</TT> implementation is similar to the Clipboard method <TT>CopyDataToClipboard</TT>
(see Listing 9.35) in that it prepares the data for the transfer and sets a reference
to the data. See <A HREF="ch07.htm">Chapter 7</A> and the Win32 documentation for
more information regarding the use of the function <TT>DoDragDrop</TT> and the drop
effect constants.
<H3><A NAME="Heading44"></A>Listing 9.35<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--OnLButtonDown
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>LRESULT CATLControlWin::OnLButtonDown(UINT uMsg, WPARAM
wParam, LPARAM lParam, <BR>
BOOL &amp; bHandled) <BR>
{ <BR>
// Un-comment these parameters if you need them <BR>
// UINT nFlags = wParam; <BR>
// short sHor = (short) LOWORD(lParam); <BR>
// short sVer = (short) HIWORD(lParam); <BR>
<BR>
// call the common data preparation function <BR>
this-&gt;PrepareDataForTransfer(); <BR>
DWORD dwDropEffect = DROPEFFECT_NONE; <BR>
<BR>
// start the Drag and Drop operation <BR>
::DoDragDrop(reinterpret_cast&lt;IDataObject*&gt; <BR>
(static_cast&lt;IDataObjectImpl&lt;CATLControlWin&gt;*&gt;(this)), <BR>
(IDropSource *) this, DROPEFFECT_COPY, &amp;dwDropEffect); <BR>
return TRUE; <BR>
} </TT></FONT></P>
<P>The last step is the <TT>IDropSource</TT> interface implementation (see Listing
9.36).</P>
<P><TT>QueryContinueDrag</TT> is used to instruct OLE as to how the Drag and Drop
operation should be handled at the time that the state of the keyboard or mouse changes.
This is usually indicative of a drop operation. In your case, you are looking to
see whether the left mouse button is no longer being held down. If that is the case,
the drop operation is completed. Otherwise, you just exit the method.</P>
<P><TT>GiveFeedback</TT> is used to instruct OLE as to what cursors should be used
while performing the Drag and Drop operation. In this case, you use the default cursors.
<H3><A NAME="Heading45"></A>Listing 9.36 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--IDropSource
Implementation</H3>
<P><FONT COLOR="#0066FF">STDMETHODIMP CATLControlWin::QueryContinueDrag(BOOL fEscapePressed,
<BR>
DWORD dwKeyState) <BR>
{ <BR>
// if the left button has been released <BR>
if(!(dwKeyState &amp; MK_LBUTTON)) <BR>
// it is OK to drop <BR>
return DRAGDROP_S_DROP; <BR>
else <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::GiveFeedback(DWORD dwEffect) <BR>
{ <BR>
// use the default cursors <BR>
return DRAGDROP_S_USEDEFAULTCURSORS; <BR>
} </FONT></P>
<P>Now that the control is enabled as a Drag and Drop source, it only makes sense
to enable the control as a Drag and Drop target. <B><I><BR>
<BR>
Enabling a Control as a Drag and Drop Target</I></B> <SPACER TYPE="HORIZONTAL" SIZE="10">To
qualify as a Drag and Drop target, a control must register itself as a Drag and Drop
target and must implement the <TT>IDropTarget</TT> interface. As with your Drag and
Drop source support, you build upon the interfaces you've already created and add
some new functionality. Again, you add the <TT>IDropTarget</TT> interface in the
same fashion as the other interfaces (see Listing 9.37).
<H3><A NAME="Heading46"></A>Listing 9.37 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--IDropTarget
Interface Added to the CATLControlWin Class Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
public IDropSource, <BR>
public IDropTarget <BR>
{ <BR>
public: <BR>
CATLControlWin() <BR>
. . . <BR>
COM_INTERFACE_ENTRY(IDropSource) <BR>
COM_INTERFACE_ENTRY(IDropTarget) <BR>
END_COM_MAP() <BR>
. . . <BR>
// IDropSource <BR>
STDMETHOD(QueryContinueDrag)(BOOL fEscapePressed, DWORD dwKeyState); <BR>
STDMETHOD(GiveFeedback)(DWORD dwEffect); <BR>
// IDropTarget <BR>
STDMETHOD(DragEnter)(LPDATAOBJECT pDataObject, DWORD dwKeyState, POINTL pt, <BR>
LPDWORD pdwEffect); <BR>
STDMETHOD(DragOver)(DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect); <BR>
STDMETHOD(DragLeave)(void); <BR>
STDMETHOD(Drop)(LPDATAOBJECT pDataObject, DWORD dwKeyState, POINTL pt, <BR>
LPDWORD pdwEffect); <BR>
. . . </TT></FONT></P>
<P>In order for the control to be a Drag and Drop target, you must do more than just
support the appropriate ActiveX interfaces. You must register the control as a drop
target with the Windows OS. You must call <TT>RegisterDragDrop</TT> to register the
control as a valid drop target. Before you can add the <TT>RegisterDragDrop</TT>
call, you must add a <TT>WM_CREATE</TT> message handler to the <TT>CATLControlWin</TT>
class declaration (see Listing 9.38).
<H3><A NAME="Heading47"></A>Listing 9.38<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--WM_CREATE
Message Handler</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown) <BR>
MESSAGE_HANDLER(WM_CREATE, OnCreate) <BR>
END_MSG_MAP() <BR>
. . . <BR>
LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled);
<BR>
LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled); <BR>
. . . </TT></FONT></P>
<P>The <TT>OnCreate</TT> implementation calls the <TT>RegisterDragDrop</TT> function
passing the window handle of the control (see Listing 9.39).
<H3><A NAME="Heading48"></A>Listing 9.39 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--OnCreate
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
LRESULT CATLControlWin::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, <BR>
BOOL &amp; bHandled) <BR>
{ <BR>
// if we have a window handle <BR>
if(m_hWnd) <BR>
// register the control as a drag and drop target <BR>
::RegisterDragDrop(m_hWnd, (IDropTarget *) this); <BR>
return TRUE; <BR>
} </TT></FONT></P>
<P>When the control is being destroyed, you need to call <TT>RevokeDragDrop</TT>
to remove the control as a valid drop target, which you will do in the <TT>OnDestroy</TT>
function (see Listing 9.40), which was added earlier in this chapter.
<H3><A NAME="Heading49"></A>Listing 9.40 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--OnDestroy
Implementation Updated to Revoke the Control as a Valid Drop Target</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
LRESULT CATLControlWin::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, <BR>
BOOL &amp; bHandled) <BR>
{ <BR>
// if we have a window handle <BR>
if(m_hWnd) <BR>
// revoke the control as a drag and drop target <BR>
::RevokeDragDrop(m_hWnd); <BR>
. . . </TT></FONT></P>
<P>Finally you implement the <TT>IDropTarget</TT> interface (see Listing 9.41).</P>
<P><TT>DragEnter</TT> is where you instruct OLE as to whether the current drag operation
that has entered the control is valid for the control's implementation. You first
look for the appropriate mouse or keyboard state, which, in your case, is the left
mouse button being held down. Next you use the <TT>IEnumFORMATETC</TT> interface
to see whether the <TT>IDataObject</TT> that was passed to you contains any formats
that you can use.</P>
<P><TT>DragOver</TT> is used to instruct windows as to the current state of the drag
operation while it is over the control. This implementation is very basic. One could,
however, implement the method to allow the Drag and Drop operation over only specific
portions of the control by checking the point structure that was passed in and comparing
it to various locations of the control. For example, a grid control might allow only
text data to be dropped on the headings, but both text and numeric data while over
the columns.</P>
<P><TT>DragLeave</TT> is used to clean up any state information that may have been
created locally to the control when the <TT>DragEnter</TT> was invoked. In your case,
you return <TT>E_NOTIMPL</TT> since you have no use for the function.</P>
<P><TT>Drop</TT> is the last function that you need to implement and is where you
copy the data from the <TT>IDataObject</TT> to the control using the <TT>GetDataFromTransfer</TT>
method.
<H3><A NAME="Heading50"></A>Listing 9.41 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--IDropTarget
Interface Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CATLControlWin::DragEnter(LPDATAOBJECT pDataObject, DWORD dwKeyState,
POINTL pt, LPDWORD pdwEffect) <BR>
{ <BR>
// if the left mouse button is being held down <BR>
if(dwKeyState &amp; MK_LBUTTON) <BR>
{ <BR>
IEnumFORMATETC * ipenumFormatetc; <BR>
BOOL bFound = FALSE; <BR>
// get a FORMATETC enumerator <BR>
if(pDataObject-&gt;EnumFormatEtc(DATADIR_GET, &amp;ipenumFormatetc) == S_OK) <BR>
{ <BR>
// reset the enumerator just to be safe <BR>
ipenumFormatetc-&gt;Reset(); <BR>
FORMATETC etc; <BR>
// while there are formats to enumerate <BR>
while(ipenumFormatetc-&gt;Next(1, &amp;etc, NULL) == S_OK &amp;&amp; !bFound) <BR>
{ <BR>
// is this a format that we are looking for? <BR>
if(etc.cfFormat == CF_TEXT &amp;&amp; etc.tymed &amp; TYMED_HGLOBAL) <BR>
bFound = TRUE; <BR>
} <BR>
// release the enumerator <BR>
ipenumFormatetc-&gt;Release(); <BR>
} <BR>
// is there a text format available <BR>
if(bFound) <BR>
*pdwEffect = DROPEFFECT_COPY; <BR>
// everything else we can't deal with <BR>
else <BR>
*pdwEffect = DROPEFFECT_NONE; <BR>
} <BR>
else <BR>
// not the left mouse <BR>
*pdwEffect = DROPEFFECT_NONE; <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::DragOver(DWORD dwKeyState, POINTL pt, <BR>
LPDWORD pdwEffect) <BR>
{ <BR>
// if the left mouse button is being held down <BR>
if(dwKeyState &amp; MK_LBUTTON) <BR>
// copy <BR>
*pdwEffect = DROPEFFECT_COPY; <BR>
else <BR>
// not the left mouse <BR>
*pdwEffect = DROPEFFECT_NONE; <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::DragLeave(void) <BR>
{ <BR>
return E_NOTIMPL; <BR>
} <BR>
STDMETHODIMP CATLControlWin::Drop(LPDATAOBJECT pDataObject, DWORD dwKeyState, <BR>
POINTL pt, LPDWORD pdwEffect) <BR>
{ <BR>
// transfer the data to the control <BR>
this-&gt;GetDataFromTransfer(pDataObject); <BR>
// return success <BR>
return S_OK; <BR>
} </TT></FONT></P>
<P>As with your MFC (and later BaseCtl), implementations adding Drag and Drop support
are straightforward. Now that you have addressed the built-in data transfer formats,
you can take a look at the next step, custom data formats.
<H3><A NAME="Heading51"></A>Custom Clipboard and Drag and Drop Formats</H3>
<P>A <I>custom data format</I> is one that is understood by the exchanging applications
but does not fall into the category of predefined formats. For your implementation,
you transfer the text <TT>Alignment</TT> property along with the <TT>Caption</TT>.
You are not restricted in any way in the types of data that can be transferred in
this manner.</P>
<P>Adding custom data formats is independent of the mechanism used to initiate the
data transfer. Since you have modeled your data transfer methods based on this principle,
you need to make only one set of changes to your application to accommodate both
custom Clipboard and Drag and Drop operations.</P>
<P>The first step is adding the member variables that you will use to implement the
custom format (see Listing 9.42). The member variable <TT>m_uiCustomFormat</TT> will
be used to hold the ID number of the registered custom format. The remaining members
are used to hold the data and its related formatting information.
<H3><A NAME="Heading52"></A>Listing 9.42<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.H--Custom
Data Format Member Variables</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
private: <BR>
FORMATETC sTextFormatEtc; <BR>
STGMEDIUM sTextStgMedium; <BR>
// custom format storage variables <BR>
UINT m_uiCustomFormat; <BR>
FORMATETC sCustomFormatEtc; <BR>
STGMEDIUM sCustomStgMedium; <BR>
}; </TT></FONT></P>
<P>The next step is to register the custom format and initialize the member variables
to valid values, which you do in the constructor (see Listing 9.43). When you register
the custom data format, you are actually registering the format in the Windows OS.
That way, whenever an application needs to use the format, that application will
get the same value as the application that registered the format in the first place.
All applications that need to use a custom format must call this method to retrieve
the ID associated with the custom format type.
<H3><A NAME="Heading53"></A>Listing 9.43 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.H--Register
the Custom Format and Initialize the Member Variables in the Class Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// set to the first element <BR>
ulFORMATETCElement = 0; <BR>
// clear the storage medium <BR>
sTextStgMedium.hGlobal = NULL; <BR>
// register a custom clipboard format <BR>
m_uiCustomFormat = <BR>
::RegisterClipboardFormat(&quot;BCFControlCtlCustomFormat&quot;); <BR>
// clear the storage medium <BR>
sCustomStgMedium.hGlobal = NULL; <BR>
} </TT></FONT></P>
<P>Next you update the <TT>PrepareDataForTransfer</TT> function to support the custom
data format (see Listing 9.44). In addition to the <TT>CF_TEXT</TT> format, you add
the creation of the custom data format, if there is one. You store the new format
in the custom storage variables so that you can support the formats on a granular
basis. If the application receiving the data understands only the text format, that
is all that the application needs to retrieve; but if the application understands
both, the application can get both.
<H3><A NAME="Heading54"></A>Listing 9.44 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--PrepareDataForTransfer
Update</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::PrepareDataForTransfer(void) <BR>
{ <BR>
. . . <BR>
// if we have custom clipboard format support <BR>
if(m_uiCustomFormat) <BR>
{ <BR>
// create a global memory object <BR>
HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, <BR>
sizeof(m_lAlignment)); <BR>
<BR>
// lock the memory down <BR>
LONG * lpTempBuffer = (LONG *) ::GlobalLock(hGlobal); <BR>
// set our data buffer <BR>
*lpTempBuffer = m_lAlignment; <BR>
// unlock the memory <BR>
::GlobalUnlock(hGlobal); <BR>
// copy all of the members <BR>
sCustomFormatEtc.cfFormat = m_uiCustomFormat; <BR>
sCustomFormatEtc.ptd = NULL; <BR>
sCustomFormatEtc.dwAspect = 0; <BR>
sCustomFormatEtc.lindex = -1; <BR>
sCustomFormatEtc.tymed = TYMED_HGLOBAL; <BR>
// if we have already allocated the data <BR>
if(sCustomStgMedium.hGlobal) <BR>
// release it <BR>
::ReleaseStgMedium(&amp;sCustomStgMedium); <BR>
sCustomStgMedium.tymed = TYMED_HGLOBAL; <BR>
sCustomStgMedium.hGlobal = hGlobal; <BR>
sCustomStgMedium.pUnkForRelease = NULL; <BR>
} <BR>
} </TT></FONT></P>
<P>Next you update the <TT>GetDataFromTransfer</TT> method (see Listing 9.45), which
you will use to copy the data from a <TT>SGTMEDUIM</TT> structure to the control.
As with the <TT>PrepareDataForTransfer</TT> method, you take a granular approach
and support the basic text transfer independent of the custom format. Note that you
change the <TT>while</TT> loop slightly so that you can look through all of the available
formats and stop only when you have looked at all of them. This way, you can get
the text format and the custom format independent of each other, thus preventing
them from being mutually exclusive.
<H3><A NAME="Heading55"></A>Listing 9.45 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--GetDataFromTransfer
Update</H3>
<P><FONT COLOR="#0066FF"><TT>void CATLControlWin::GetDataFromTransfer(IDataObject
* ipDataObj) <BR>
{ <BR>
IEnumFORMATETC * ipenumFormatetc; <BR>
BOOL bFound = FALSE; <BR>
// get a FORMATETC enumerator <BR>
if(ipDataObj-&gt;EnumFormatEtc(DATADIR_GET, &amp;ipenumFormatetc) == S_OK) <BR>
{ <BR>
// reset the enumerator just to be safe <BR>
ipenumFormatetc-&gt;Reset(); <BR>
FORMATETC etc; <BR>
// while there are formats to enumerate <BR>
while(ipenumFormatetc-&gt;Next(1, &amp;etc, NULL) == S_OK) <BR>
{ <BR>
// is this a format that we are looking for? <BR>
if(etc.cfFormat == CF_TEXT &amp;&amp; etc.tymed &amp; TYMED_HGLOBAL) <BR>
{ <BR>
STGMEDIUM sStgMediumData; <BR>
// get the data from the stgmedium <BR>
if(ipDataObj-&gt;GetData(&amp;etc, &amp;sStgMediumData) == S_OK) <BR>
{ <BR>
// get the global data for this format <BR>
// and lock down the memory <BR>
LPTSTR lpTempBuffer = (LPTSTR) <BR>
::GlobalLock(sStgMediumData.hGlobal); <BR>
// if we have a string <BR>
if(m_lptstrCaption) <BR>
{ <BR>
// delete the existing string <BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe <BR>
m_lptstrCaption = NULL; <BR>
} <BR>
// allocate a new string <BR>
m_lptstrCaption = new TCHAR[lstrlen(lpTempBuffer) + 1]; <BR>
// assign the string to our member variable <BR>
lstrcpy(m_lptstrCaption, lpTempBuffer); <BR>
// unlock the memory <BR>
::GlobalUnlock(sStgMediumData.hGlobal); <BR>
// release the storage medium <BR>
::ReleaseStgMedium(&amp;sStgMediumData); <BR>
// indicate success <BR>
bFound = TRUE; <BR>
} <BR>
} <BR>
// is this a format that we are looking for? <BR>
else if(m_uiCustomFormat &amp;&amp; etc.cfFormat == m_uiCustomFormat &amp;&amp; <BR>
etc.tymed &amp; TYMED_HGLOBAL) <BR>
{ <BR>
STGMEDIUM sStgMediumData; <BR>
// get the data from the stgmedium <BR>
if(ipDataObj-&gt;GetData(&amp;etc, &amp;sStgMediumData) == S_OK) <BR>
{ <BR>
// get the global data for this format and lock down the memory <BR>
LONG * lpTempBuffer = <BR>
(LONG *) ::GlobalLock(sStgMediumData.hGlobal); <BR>
// get the data <BR>
m_lAlignment = *lpTempBuffer; <BR>
// unlock the memory <BR>
::GlobalUnlock(sStgMediumData.hGlobal); <BR>
// release the storage medium <BR>
::ReleaseStgMedium(&amp;sStgMediumData); <BR>
// indicate success <BR>
bFound = TRUE; <BR>
} <BR>
} <BR>
} <BR>
<BR>
// release the enumerator <BR>
ipenumFormatetc-&gt;Release(); <BR>
} <BR>
// if we found a format <BR>
if(bFound == TRUE) <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
} </TT></FONT></P>
<P>Now that you have updated the basic data transfer routines, you need to update
the <TT>IEnumFORMATETC</TT> interface to publish the availability of the new format
to any application that wants it. You do this in the <TT>IEnumFORMATETC::Next</TT>
function (see Listing 9.46). The function looks to see whether the control supports
a custom format and whether the enumerator is at the second format. The function
will then fill in the <TT>FORMATETC</TT> structure that was passed in with the appropriate
information, letting any application that understands the custom format know that
the control can support the custom format, too.
<H3><A NAME="Heading56"></A>Listing 9.46<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLWIN.CPP--IEnumFORMATETC::Next
Update</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::Next(ULONG celt, FORMATETC
RPC_FAR * rgelt, <BR>
ULONG_RPC_FAR * pceltFetched) <BR>
{ <BR>
// if we are at the beginning of the enumeration <BR>
if(ulFORMATETCElement == 0 &amp;&amp; celt &gt; 0) <BR>
{ <BR>
// copy all of the members <BR>
rgelt-&gt;cfFormat = CF_TEXT; <BR>
rgelt-&gt;ptd = NULL; <BR>
rgelt-&gt;dwAspect = 0; <BR>
rgelt-&gt;lindex = -1; <BR>
rgelt-&gt;tymed = TYMED_HGLOBAL; <BR>
<BR>
// if the caller wants to know how many we copied <BR>
if(pceltFetched) <BR>
*pceltFetched = 1; <BR>
// increment the counter <BR>
ulFORMATETCElement++; <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
else if(m_uiCustomFormat &amp;&amp; ulFORMATETCElement == 1 &amp;&amp; celt &gt;
0) <BR>
{ <BR>
// copy all of the members <BR>
rgelt-&gt;cfFormat = m_uiCustomFormat; <BR>
rgelt-&gt;ptd = NULL; <BR>
rgelt-&gt;dwAspect = 0; <BR>
rgelt-&gt;lindex = -1; <BR>
rgelt-&gt;tymed = TYMED_HGLOBAL; <BR>
<BR>
// if the caller wants to know how many we copied <BR>
if(pceltFetched) <BR>
*pceltFetched = 1; <BR>
// increment the counter <BR>
ulFORMATETCElement++; <BR>
// return success <BR>
return S_OK; <BR>
} <BR>
else <BR>
// return failure <BR>
return S_FALSE; <BR>
} </TT></FONT></P>
<P>Last you need to update the routine that returns the custom format in the <TT>STGMEDIUM</TT>
structure, <TT>IEnumFORMATETC::GetData</TT> (see Listing 9.47). You can still use
the <TT>CopyStgMedium</TT> function; the only difference is which internal STGMEDIUM
structure is supplied to the function.
<H3><A NAME="Heading57"></A>Listing 9.47 <SPACER TYPE="HORIZONTAL" SIZE="10">ATLCONTROLWIN.CPP--IEnumFORMATETC::GetData
Update</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::GetData(LPFORMATETC lpFormatEtc,
LPSTGMEDIUM <BR>
lpStgMedium) <BR>
{ <BR>
// if this is a format that we can deal with <BR>
if(lpFormatEtc-&gt;cfFormat == CF_TEXT &amp;&amp; lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL)
<BR>
{ <BR>
// get a copy of the current stgmedium <BR>
this-&gt;CopyStgMedium(lpStgMedium, &amp;sTextStgMedium, CF_TEXT); <BR>
return S_OK; <BR>
} <BR>
else if(m_uiCustomFormat &amp;&amp; lpFormatEtc-&gt;cfFormat == m_uiCustomFormat
<BR>
&amp;&amp; lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL) <BR>
{ <BR>
// get a copy of the current stgmedium <BR>
this-&gt;CopyStgMedium(lpStgMedium, &amp;sCustomStgMedium, m_uiCustomFormat); <BR>
return S_OK; <BR>
} <BR>
else <BR>
return IDataObjectImpl&lt;CATLControlWin&gt;::GetData(lpFormatEtc, lpStgMedium);
<BR>
} </TT></FONT></P>
<P>That's all it takes to support custom formats. By taking a &quot;black box&quot;
approach to how you've created the basic data transfer routines, you can support
a large amount of functionality, while relying on a relatively small common code
base.
<H2><A NAME="Heading58"></A>Subclassing Existing Windows Controls</H2>
<P>As with your MFC implementation, ATL allows for the creation of controls that
subclass existing Windows controls. At the beginning of this chapter, you created
several controls in the application, one of which subclassed a Windows <TT>BUTTON</TT>
control. The <TT>CATLControlSubWin</TT> class varies little from the <TT>CATLControlWin</TT>
class. All of the differences are contained within the ATLControlSubWin.h header
file (see Listing 9.48).</P>
<P>ATL relies on the class <TT>CContainedWindow</TT> to implement its subclassing
feature. The constructor of the primary control is where the constructor of the contained
class is supplied with the name of the Windows control to use when performing the
actual subclassing routine. The ATL Object Wizard also adds a message handler for
the <TT>WM_CREATE</TT> message that instructs the contained window to create itself.</P>
<P>The function <TT>SetObjectRects</TT> is overloaded so that the contained control
will size itself correctly in tandem with the container control.
<H3><A NAME="Heading59"></A>Listing 9.48<SPACER TYPE="HORIZONTAL" SIZE="10"> ATLCONTROLSUBWIN.H--CATLControlSubWin
Class Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CATLControlSubWin <BR>
class ATL_NO_VTABLE CATLControlSubWin : <BR>
public CComObjectRootEx&lt;CComObjectThreadModel&gt;, <BR>
public CComCoClass&lt;CATLControlSubWin, &amp;CLSID_ATLControlSubWin&gt;, <BR>
public CComControl&lt;CATLControlSubWin&gt;, <BR>
public IDispatchImpl&lt;IATLControlSubWin, &amp;IID_IATLControlSubWin, <BR>
&amp;LIBID_ATLCONTROLLib&gt;, <BR>
public IProvideClassInfo2Impl&lt;&amp;CLSID_ATLControlSubWin, NULL, &amp;LIBID_ATLCONTROLLib&gt;,
<BR>
public IPersistStreamInitImpl&lt;CATLControlSubWin&gt;, <BR>
public IPersistStorageImpl&lt;CATLControlSubWin&gt;, <BR>
public IQuickActivateImpl&lt;CATLControlSubWin&gt;, <BR>
public IOleControlImpl&lt;CATLControlSubWin&gt;, <BR>
public IOleObjectImpl&lt;CATLControlSubWin&gt;, <BR>
public IOleInPlaceActiveObjectImpl&lt;CATLControlSubWin&gt;, <BR>
public IViewObjectExImpl&lt;CATLControlSubWin&gt;, <BR>
public IOleInPlaceObjectWindowlessImpl&lt;CATLControlSubWin&gt;, <BR>
public IDataObjectImpl&lt;CATLControlSubWin&gt;, <BR>
public ISupportErrorInfo, <BR>
public IConnectionPointContainerImpl&lt;CATLControlSubWin&gt;, <BR>
public ISpecifyPropertyPagesImpl&lt;CATLControlSubWin&gt; <BR>
{ <BR>
public: <BR>
CContainedWindow m_ctlButton; <BR>
<BR>
CATLControlSubWin() : <BR>
m_ctlButton(_T(&quot;Button&quot;), this, 1) <BR>
{ <BR>
<BR>
m_bWindowOnly = TRUE; <BR>
} <BR>
DECLARE_REGISTRY_RESOURCEID(IDR_ATLCONTROLSUBWIN) <BR>
BEGIN_COM_MAP(CATLControlSubWin) <BR>
COM_INTERFACE_ENTRY(IATLControlSubWin) <BR>
COM_INTERFACE_ENTRY(IDispatch) <BR>
COM_INTERFACE_ENTRY_IMPL(IViewObjectEx) <BR>
COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx) <BR>
COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx) <BR>
COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless) <BR>
COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
<BR>
COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless) <BR>
COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject) <BR>
COM_INTERFACE_ENTRY_IMPL(IOleControl) <BR>
COM_INTERFACE_ENTRY_IMPL(IOleObject) <BR>
COM_INTERFACE_ENTRY_IMPL(IQuickActivate) <BR>
COM_INTERFACE_ENTRY_IMPL(IPersistStorage) <BR>
COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit) <BR>
COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages) <BR>
COM_INTERFACE_ENTRY_IMPL(IDataObject) <BR>
COM_INTERFACE_ENTRY(IProvideClassInfo) <BR>
COM_INTERFACE_ENTRY(IProvideClassInfo2) <BR>
COM_INTERFACE_ENTRY(ISupportErrorInfo) <BR>
COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer) <BR>
END_COM_MAP() <BR>
BEGIN_PROPERTY_MAP(CATLControlSubWin) <BR>
// PROP_ENTRY(&quot;Description&quot;, dispid, clsid) <BR>
PROP_PAGE(CLSID_CColorPropPage) <BR>
END_PROPERTY_MAP() <BR>
BEGIN_CONNECTION_POINT_MAP(CATLControlSubWin) <BR>
END_CONNECTION_POINT_MAP() <BR>
BEGIN_MSG_MAP(CATLControlSubWin) <BR>
MESSAGE_HANDLER(WM_PAINT, OnPaint) <BR>
MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode) <BR>
MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus) <BR>
MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus) <BR>
MESSAGE_HANDLER(WM_CREATE, OnCreate) <BR>
ALT_MSG_MAP(1) <BR>
// Replace this with message map entries for subclassed Button <BR>
END_MSG_MAP() <BR>
LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <BR>
{ <BR>
RECT rc; <BR>
GetWindowRect(&amp;rc); <BR>
rc.right -= rc.left; <BR>
rc.bottom -= rc.top; <BR>
rc.top = rc.left = 0; <BR>
m_ctlButton.Create(m_hWnd, rc); <BR>
return 0; <BR>
} <BR>
STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip) <BR>
{ <BR>
IOleInPlaceObjectWindowlessImpl&lt;CATLControlSubWin&gt;::SetObjectRects( <BR>
prcPos, prcClip); <BR>
int cx, cy; <BR>
cx = prcPos-&gt;right - prcPos-&gt;left; <BR>
cy = prcPos-&gt;bottom - prcPos-&gt;top; <BR>
::SetWindowPos(m_ctlButton.m_hWnd, NULL, 0, <BR>
0, cx, cy, SWP_NOZORDER | SWP_NOACTIVATE); <BR>
return S_OK; <BR>
} <BR>
// ISupportsErrorInfo <BR>
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid); <BR>
// IViewObjectEx <BR>
STDMETHOD(GetViewStatus)(DWORD* pdwStatus) <BR>
{ <BR>
ATLTRACE(_T(&quot;IViewObjectExImpl::GetViewStatus\n&quot;)); <BR>
*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE; <BR>
return S_OK; <BR>
} <BR>
// IATLControlSubWin <BR>
public: <BR>
HRESULT OnDraw(ATL_DRAWINFO&amp; di); <BR>
};</TT></FONT></P>
<P>The ATL Sample Index provides access to several sample applications that subclass
Windows controls. Because subclassing is straightforward and easy to implement, there
is not much to the samples.</P>
<P>Subclassing is an easy way to add specialized controls to your application. Providing
list boxes or buttons that perform unique actions relative to your implementation
can save you a lot of development time, especially if there is use for the controls
in more than one instance. Subclassing involves very little work and provides a lot
of benefit.
<H2><A NAME="Heading60"></A>Dual-Interface Controls</H2>
<P>ATL control implementations, by default, support dual-interface, so no extra work
is needed. As we stated in previous chapters, however, currently no control containers
can or will use dual-interfaces within controls.<BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> <BR>
	Unclipped device context is an MFC-specific optimization and is not implemented in
	ATL.

</BLOCKQUOTE>

<H2><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
<A NAME="Heading61"></A>Other ActiveX Features</H2>
<P>As with your MFC implementation, ATL allows you to take advantage of some of the
available OC 96 or ActiveX features. <A HREF="ch06.htm">Chapter 6</A> contains a
detailed explanation of each feature, so we don't go into them here. We do, however,
look into the aspects of their specific implementation and how they relate to ATL.
<H3><A NAME="Heading62"></A>Windowless Activation</H3>
<P><I>Windowless activation</I> is supported through the <TT>IOleInPlaceObjectWindowless</TT>
interface and is implemented in the container. If the container doesn't support windowless
activation, the control must be able to create a window for itself. Windowless activation
is a request not a guarantee.</P>
<P>ATL support of windowless controls is easy to implement. The <TT>CComControl</TT>
class contains a member variable<TT> m_bWindowOnly</TT>, which, if set to <TT>TRUE</TT>,
instructs the control to use its windowless feature if the control supports it. If
set to <TT>FALSE</TT>, the control will always create a window handle. The class
<TT>CATLControlNoWin</TT>, which is the class of the control you created at the beginning
of the chapter to support windowless activation, sets the <TT>m_bWindowOnly</TT>
member to <TT>TRUE</TT> within its constructor. A number of member variables and
functions are related to windowless control creation; so you need to review the ATL
documentation thoroughly.
<H3><A NAME="Heading63"></A>Flicker-Free Activation</H3>
<P><I>Flicker-free</I> activation is based on the <TT>IOleInPlaceSiteEx</TT> interface.
The ATL framework automatically attempts to find this interface, so flicker-free
activation requires no implementation on the part of the developer.
<H3><A NAME="Heading64"></A>Mouse Pointer Notifications When Inactive</H3>
<P>Mouse pointer notifications when inactive are provided through the COM interface
<TT>IPointerInactive</TT>. To support the interface in your control, you must add
the ATL class <TT>IPointerInactiveImpl</TT> to your class declaration and override
the ATL implementations of the <TT>GetActivationPolicy</TT>, <TT>OnInactiveMouseMove</TT>,
and <TT>OnInactiveSetCursor</TT>.
<H3><A NAME="Heading65"></A>Optimized Drawing Code</H3>
<P>Optimized drawing is handled much as in MFC, as you saw in the optimized drawing
section earlier in this chapter. A parameter of the <TT>OnDraw</TT> method indicates
whether the control can draw using the optimized techniques you first saw in your
MFC implementation. In addition, the ATL implementation allows for <I>aspect </I>or
optimized drawing. Drawing with aspects is beyond the scope of this book. If you
want to implement this feature, please see the OC 96 specification included in the
ActiveX SDK.
<H3><A NAME="Heading66"></A>Loads Properties Asynchronously</H3>
<P>To support <I>asynchronous properties,</I> a control must support the stock property
<TT>ReadyState</TT> and the stock event <TT>ReadyStateChange</TT>. The control is
responsible for updating the property and notifying the container when it has changed.
Other than the <TT>OnData</TT> function, which is already provided by the ATL framework,
the implementation must be performed manually by the developer of the control, as
you saw in the asynchronous property section earlier in this chapter.
<H2><A NAME="Heading67"></A>From Here...</H2>
<P>This chapter focused on expanding the basic control implementation that you created
in <A HREF="ch08.htm">Chapter 8</A>. The advanced features and functionality that
you learned, such as asynchronous properties, Drag and Drop support, and many others,
will allow you to distinguish your control implementation as being a truly professional
implementation.</P>

<P>With the introduction of version 2.1, ATL has come full circle and provides you
with a complete and robust framework for developing ActiveX controls and ActiveX
components in general. The amount of support being put into this product both by
the industry and Microsoft should tell you that ATL is the way to do ActiveX development
in the future. <A HREF="ch10.htm">Chapters 10</A> and <A HREF="ch11.htm">11</A> examine
in detail how to create a similar control implementation using BaseCtl.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
