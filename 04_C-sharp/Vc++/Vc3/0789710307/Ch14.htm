<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 1:42 PM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 14</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 14<BR>
Creating ActiveX COM Objects and Custom Interfaces on Your Own</H1>

<UL>
	<LI><A HREF="#Heading1">Creating ActiveX COM Objects and Custom Interfaces on Your
	Own</A>
	<UL>
		<LI><A HREF="#Heading2">Creating a Basic In-Process Server</A>
		<UL>
			<LI><A HREF="#Heading3">Creating the Project Definition File</A>
			<LI><A HREF="#Heading4">Listing 14.1 CUSTOMBASS.DEF--DLL Library Definition File
			for CUSTOMBASS.DLL</A>
			<LI><A HREF="#Heading5">Custom COM Server Architecture</A>
		</UL>
		<LI><A HREF="#Heading6">Creating the COM Class COBass</A>
		<UL>
			<LI><A HREF="#Heading7">Listing 14.2 COBASS.H--COM Object COBass that Implements
			the IFish and IBass Interfaces</A>
			<LI><A HREF="#Heading8">Listing 14.3 COBASS.CPP--IUnknown Implementation for COBass</A>
			<LI><A HREF="#Heading9">Listing 14.4 COBASS.CPP--COBass Interface Implementations
			of the IFish and IBass Interfaces</A>
			<LI><A HREF="#Heading10">Listing 14.5 CUSTOMBASSID.H--Header File CUSTOMBASSID.H,
			which Contains the Implementation of CLSID for the COBass Class</A>
		</UL>
		<LI><A HREF="#Heading11">Implementing the COBass Class Factory</A>
		<UL>
			<LI><A HREF="#Heading12">Listing 14.6 FACTORY.H--Class Factory Definition File, FACTORY.H,
			for CFBass</A>
			<LI><A HREF="#Heading13">Listing 14.7 FACTORY.CPP--Implementation of the CFBass Class
			and IUnknown Interface</A>
			<LI><A HREF="#Heading14">Listing 14.8 FACTORY.CPP--IUnknown and IClassFactory Implementations
			in CImpIClassFactory</A>
		</UL>
		<LI><A HREF="#Heading15">Implementation of the Server Application</A>
		<UL>
			<LI><A HREF="#Heading16">Listing 14.9 SERVER.H--CServer Class Definition</A>
			<LI><A HREF="#Heading17">Listing 14.10 SERVER.CPP--CServer Object Implementation</A>
		</UL>
		<LI><A HREF="#Heading18">Implementation of the Server Access Functions</A>
		<UL>
			<LI><A HREF="#Heading19">Listing 14.11 CUSTOMBASS.CPP--Server Access Function Implementation</A>
		</UL>
		<LI><A HREF="#Heading20">Compiling and Testing the COM Server</A>
		<LI><A HREF="#Heading21">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Creating ActiveX COM Objects and Custom Interfaces on
Your Own</H1>

<UL>
	<LI><B>Writing a custom handler for registering components for regsvr32.exe</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The server can directly register all of the COM Objects that it supports.
	<P>
	<LI><B>Implementing a custom class factory (IClassFactory) interface</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Without the benefit of a COM framework, you must implement an IClassFactory interface
	for each COM Object created.
	<P>
	<LI><B>Building a DLL-based server for containing COM Objects</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Building COM servers without a framework requires implementing some basic COM APIs
	that are entry points into DLL-based servers.
	<P>
	<LI><B>Unloading DLLs from memory when instances of COM Objects are no longer being
	used</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 COM servers are responsible for removal of all COM components that are no longer
	being used.
	<P>
	<LI><B>Utilizing different strategies for implementing COM interfaces</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Multiple techniques can be used for implementing COM Objects.
</UL>

<P>A variety of methods are available for creating COM classes based upon the MFC
and ActiveX frameworks. In this chapter, you will examine methods for creating COM
classes without MFC or ActiveX frameworks.</P>
<P>How the COM class was defined or implemented does not matter to the client application
using the class. The use and function of the class are identical to the client. Defining
and implementing COM classes without a framework such as MFC or ActiveX is an easy
task, although additional work must be performed by the COM developer for object
creation and termination.</P>
<P>Although application frameworks tend to make the creation of COM components easier,
you will find several advantages to creating your own COM classes:

<UL>
	<LI>The component does not have to carry excess baggage (code) incurred from using
	a framework.
	<P>
	<LI>When using C++ without a framework, a particular base class is not required from
	which to derive COM classes. This removes excess baggage which is not needed from
	the implementation of the class.
	<LI>COM components not derived from a framework class can still be used and accessed
	from within a framework-based DLL or EXE.
</UL>

<P>Creating COM components without the benefit of a framework also has some disadvantages.
The biggest drawback is that you need to perform all of the detailed work such as
creating <TT>IClassFactory</TT> interfaces, which are normally supplied by the framework.
<H2><A NAME="Heading2"></A>Creating a Basic In-Process Server</H2>
<P>In <A HREF="ch12.htm">Chapter 12</A>, two COM interfaces are defined: <TT>IFish</TT>
and <TT>IBass</TT>. These interfaces are defined within a project called IFISH.DLL.
The <TT>IFish</TT> and <TT>IBass</TT> interfaces are accessed through a COM class
entitled <TT>CBass</TT>, which is derived from the MFC base class <TT>CCmdTarget</TT>.</P>
<P>In this chapter, the interfaces <TT>IFish</TT> and <TT>IBass</TT> will again be
used along with a new class entitled <TT>COBass</TT>, which is used to access the
interfaces. The <TT>COBass</TT> class will be implemented within a DLL and will not
be derived from a framework class.</P>
<P>To create the basic in-process server, the New dialog will be used. To create
the CUSTOMBASS project, perform the following steps:

<OL>
	<LI>From within the Visual C++ development environment, select the command <U>N</U>ew
	from the <U>F</U>ile menu.
	<P>
	<LI>Select Projects tab from the New dialog.
	<P>
	<LI>From the Projects tab, select Win32 Dynamic Link Library. Enter the project name
	<B>CUSTOMBASS</B> into the Project <U>n</U>ame edit box. Select the OK button.
	<P>
	<LI>The project CUSTOMBASS is now created.
</OL>

<H3><A NAME="Heading3"></A>Creating the Project Definition File</H3>
<P>When creating a generic dynamic link library (DLL), the New dialog does not create
a definition file (DEF). All DLLs must have a definition file that is used to define
information about the project, such as functions that are exported from the library.</P>
<P>All DLLs that support COM classes <I>must</I> export some basic functions in order
for the client applications to access the COM classes. From within the Visual C++
Developer Studio, create a file called CUSTOMBASS.DEF. Listing 14.1 illustrates the
contents of this file.
<H3><A NAME="Heading4"></A>Listing 14.1<SPACER TYPE="HORIZONTAL" SIZE="10"> CUSTOMBASS.DEF--DLL
Library Definition File for CUSTOMBASS.DLL</H3>
<P><FONT COLOR="#0066FF"><TT>LIBRARY CUSTOMBASS<BR>
DESCRIPTION `CUSTOMBASS Dynamic Link Library' <BR>
EXPORTS<BR>
DllGetClassObject<BR>
DllCanUnloadNow<BR>
DllRegisterServer<BR>
DllUnregisterServer</TT></FONT></P>
<P>The function <TT>DllGetClassObject</TT> is called to create an instance of a COM
Object. <TT>DLLCanUnloadNow</TT> is called periodically by the operating system to
remove unused DLLs from system memory. <TT>DllRegisterServer</TT> is used by the
program regsvr32.exe to allow the DLL to register all COM Objects with the Windows
Registry. The function <TT>DllUnregisterServer</TT> is called to remove all registry
settings for the COM Objects from the Windows Registry.
<H3><A NAME="Heading5"></A>Custom COM Server Architecture</H3>
<P>When creating a COM server without the aid of an application framework such as
MFC, you need to establish a system architecture for implementing the COM model.
The architecture used in the CUSTOMBASS project consists of three classes:

<UL>
	<LI><TT>CServer</TT>: A global class within CUSTOMBASS.DLL that acts as a reference
	manager for all COM Objects within the server. This class is responsible for unloading
	the DLL from memory and providing reference bookkeeping.
	<P>
	<LI><TT>CFBass</TT>: A class factory for the <TT>COBass</TT> COM Object. This class
	implements the <TT>IClassFactory</TT> interface for the server.
	<P>
	<LI><TT>COBass</TT>: The COM Object class that contains and implements the <TT>IFish</TT>
	and <TT>IBass</TT> interfaces.
</UL>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> While the CUSTOMBASS project utilizes three classes as its basic
	architecture, many different approaches can be used. The only requirement is that
	in all COM architectures there <I>must </I>be a COM Object class and a class factory
	for each COM class.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
When implementing COM Objects without the use of a framework, the interfaces supported
by the class can be implemented through several methods:

<UL>
	<LI>Single inheritance: In this scheme, each interface is implemented with a single
	C++ implementation class. One controlling object then contains pointers to all of
	the implementation classes. Although this mechanism works, it requires a significant
	amount of coding, and each additional interface supported by the COM class requires
	reprogramming of the COM Object.
	<P>
	<LI>Nested interface classes: This technique is similar to single inheritance, but
	instead of having a separate C++ class for each interface, the interface implementation
	classes are contained or nested within the COM Object. When a COM Object is created,
	it also creates each of the interface classes. This technique is the one that MFC
	uses for interface implementation within a class. Although this technique requires
	less code than the single inheritance technique, it still requires a fair amount
	of coding to implement. <TT>CFBass</TT><I>, </I>the class factory in CUSTOMBASS,
	uses this technique.
	<P>
	<LI>Multiple inheritance: This method is by far the easiest one for implementing
	and coding. The multiple inheritance technique requires that the COM Object class
	be derived from the interface classes. The ATL framework utilizes this method. This
	technique requires less code and consumes much less memory at runtime. The COM class
	<TT>COBass</TT> supports the <TT>IFish</TT> and <TT>IBass</TT> interfaces through
	multiple inheritance.
</UL>

<H2><A NAME="Heading6"></A>Creating the COM Class COBass</H2>
<P>In the CUSTOMBASS project, the COM class <TT>COBass,</TT> which will implement
the <TT>IFish</TT> and <TT>IBass</TT> COM interfaces, is created. You may want to
refer to <A HREF="ch12.htm">Chapter 12</A>, where the <TT>IFish</TT> and <TT>IBass</TT>
interfaces are implemented in the MFC-derived COM class <TT>CBass</TT>.</P>
<P>The class <TT>COBass</TT> is derived directly from the <TT>IFish</TT> and <TT>IBass</TT>
interfaces. By definition, this makes the interface methods of <TT>IFish</TT>, <TT>IBass</TT>,
and <TT>IUnknown</TT> an integral part of <TT>COBass</TT>. The class <TT>Cbass</TT>
is derived from the <TT>CCmdTarget</TT> class. The <TT>IFish</TT> and <TT>IBass</TT>
interfaces are added as members of the <TT>COBass</TT> class (nested interfaces).</P>
<P><TT>COBass</TT> is a C++ class that is derived from the <TT>IBass</TT> and <TT>IFish</TT>
interfaces. Listing 14.2 shows the class definition for <TT>COBass</TT>. This is
different from <TT>CBass</TT><I>,</I> which was derived from the MFC class <TT>CCmdTarget</TT>.
<H3><A NAME="Heading7"></A>Listing 14.2 <SPACER TYPE="HORIZONTAL" SIZE="10">COBASS.H--COM
Object COBass that Implements the IFish and IBass Interfaces</H3>
<P><FONT COLOR="#0066FF"><TT>#if !defined(COBASS_H)<BR>
#define COBASS_H <BR>
#ifdef __cplusplus <BR>
#include &quot;..\ifish\ifish.h&quot;<BR>
#include &quot;..\ifish\ibass.h&quot; <BR>
class COBass : public IFish , public IBass<BR>
{<BR>
public:<BR>
// Main Object Constructor &amp; Destructor.<BR>
COBass(IUnknown* pUnkOuter, CServer* pServer);<BR>
~COBass(void); <BR>
// shared IUnknown methods. Main object, non-delegating.<BR>
STDMETHODIMP QueryInterface(REFIID, PPVOID);<BR>
STDMETHODIMP_(ULONG) AddRef(void);<BR>
STDMETHODIMP_(ULONG) Release(void); <BR>
// IFish methods<BR>
STDMETHODIMP IsFreshwater(BOOL *);<BR>
STDMETHODIMP GetFishName( LPTSTR ); <BR>
// IBass methods<BR>
STDMETHODIMP GetLocation( LPTSTR );<BR>
STDMETHODIMP SetLocation( LPTSTR );<BR>
STDMETHODIMP EatsOtherFish( BOOL *); <BR>
private:<BR>
// We declare nested class interface implementations here. <BR>
// Main Object reference count.<BR>
ULONG m_cRefs; <BR>
// Outer unknown (aggregation &amp; delegation).<BR>
IUnknown* m_pUnkOuter; <BR>
// Pointer to this component server's control object.<BR>
CServer* m_pServer;<BR>
char m_zFishName[256];<BR>
char m_zLocation[256];<BR>
BOOL m_bEatsOtherFish;<BR>
BOOL m_bFreshwater;<BR>
};<BR>
typedef COBass* PCOBass;<BR>
#endif // __cplusplus <BR>
#endif // COBASS_H</TT></FONT></P>
<P>When deriving COM classes from multiple interfaces, less coding is needed to implement
the COM Object and the interfaces. One of the advantages of deriving a COM class
from multiple interfaces is that only one implementation of the <TT>IUnknown</TT>
interfaces is required. The delegation of the <TT>IUnknown</TT> interface is also
avoided. Listing 14.3 illustrates the implementation of the <TT>IUnknown</TT> interface
in the <TT>COBass</TT> class.
<H3><A NAME="Heading8"></A>Listing 14.3<SPACER TYPE="HORIZONTAL" SIZE="10"> COBASS.CPP--IUnknown
Implementation for COBass</H3>
<P><FONT COLOR="#0066FF"><TT>#include &lt;windows.h&gt;<BR>
#include &lt;ole2.h&gt;<BR>
#include &quot;comutil.h&quot;<BR>
#include &quot;..\ifish\ifish.h&quot;<BR>
#include &quot;..\ifish\ibass.h&quot;<BR>
#include &quot;custombassid.h&quot;<BR>
#include &quot;server.h&quot;<BR>
#include &quot;cobass.h&quot; <BR>
COBass::COBass(<BR>
IUnknown* pUnkOuter,<BR>
CServer* pServer) <BR>
{<BR>
// Zero the COM object's reference count.<BR>
m_cRefs = 0; <BR>
// No AddRef necessary if non-NULL, as we're nested.<BR>
m_pUnkOuter = pUnkOuter; <BR>
// Assign the pointer to the server control object.<BR>
m_pServer = pServer;<BR>
lstrcpy (m_zFishName, &quot;Bass&quot;);<BR>
lstrcpy (m_zLocation, &quot;Lilly Pads&quot;);<BR>
m_bEatsOtherFish = TRUE;<BR>
m_bFreshwater = TRUE;<BR>
} <BR>
COBass::~COBass(void)<BR>
{<BR>
} <BR>
STDMETHODIMP COBass::QueryInterface(<BR>
REFIID riid,<BR>
PPVOID ppv)<BR>
{<BR>
HRESULT hr = ResultFromScode(E_NOINTERFACE);<BR>
*ppv = NULL; <BR>
if (IID_IUnknown == riid || IID_IFish == riid)<BR>
{<BR>
*ppv = (IFish *)this;<BR>
}<BR>
else if (IID_IBass == riid)<BR>
{<BR>
*ppv = (IBass *)this;<BR>
} <BR>
if (NULL != *ppv)<BR>
{<BR>
// We've handed out a pointer to the interface so obey the COM rules<BR>
// and AddRef the reference count.<BR>
((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>
hr = NOERROR;<BR>
}<BR>
return (hr); <BR>
}</TT></FONT></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>CAUTION:</B><BR>
	One important fact to remember is that <I>this</I> pointer is not a direct object
	pointer to any interface, not even to the <TT>IUnknown</TT> interface. This fact
	means that the interface pointer returned must be explicitly type-cast to the correct
	pointer for each interface. Type-casting the pointer changes the pointer value. C++
	overloads the type-cast operators to allocate the right vtable for the interface
	type. Failure to <I>not</I> type-cast to the explicit interface yields unpredictable
	results.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
In looking at the <TT>QueryInterface</TT> implementation, the <TT>IFish</TT> interface
pointer is returned for the interface <TT>IID</TT>'s <TT>IFish</TT> and <TT>IUnknown</TT>.
Since the <TT>IFish</TT> interface is derived from <TT>Iunknown</TT>, it is perfectly
valid to return the <TT>IFish</TT> interface when the<TT> IUnknown</TT> interface
is asked for. <TT>IFish</TT> is a matter of preference; the <TT>IBass</TT> interface
can be chosen as well.</P>
<P>The other COM interfaces are implemented as methods of the <TT>COBass</TT> class.
Listing 14.4 illustrates the COM interface implementations.
<H3><A NAME="Heading9"></A>Listing 14.4 <SPACER TYPE="HORIZONTAL" SIZE="10">COBASS.CPP--COBass
Interface Implementations of the IFish and IBass Interfaces</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP_(ULONG) COBass::AddRef(void)<BR>
{<BR>
m_cRefs++;<BR>
return m_cRefs;<BR>
} <BR>
STDMETHODIMP_(ULONG) COBass::Release(void)<BR>
{<BR>
m_cRefs--; <BR>
if (0 == m_cRefs)<BR>
{<BR>
// We've reached a zero reference count for this COM object.<BR>
// So we tell the server housing to decrement its global object<BR>
// count so that the server will be unloaded if appropriate.<BR>
if (NULL != m_pServer)<BR>
m_pServer-&gt;ObjectsDown(); <BR>
delete this;<BR>
} <BR>
return m_cRefs;<BR>
} STDMETHODIMP COBass::GetFishName( char *pStr)<BR>
{<BR>
LOG(&quot;COBass::GetFishName\n&quot;); <BR>
if (pStr)<BR>
lstrcpy((char *)pStr, m_zFishName);<BR>
return (HRESULT)NOERROR;<BR>
} <BR>
STDMETHODIMP COBass::IsFreshwater( BOOL *pBool )<BR>
{<BR>
LOG(&quot;COBass::IsFreshwater\n&quot;); <BR>
if (pBool)<BR>
{<BR>
*pBool = m_bFreshwater;<BR>
return S_OK;<BR>
} <BR>
return (HRESULT)NOERROR;<BR>
} STDMETHODIMP COBass::GetLocation( char *pStr)<BR>
{<BR>
LOG(&quot;COBass::GetLocation\n&quot;); <BR>
if (pStr)<BR>
strcpy((char *)pStr, (LPCTSTR)m_zLocation);<BR>
return (HRESULT)NOERROR;<BR>
} <BR>
STDMETHODIMP COBass::SetLocation( char *pStr)<BR>
{<BR>
LOG(&quot;COBass::SetLocation\n&quot;); <BR>
if (pStr)<BR>
strcpy(m_zLocation, (char *)pStr);<BR>
return (HRESULT)NOERROR;<BR>
} <BR>
STDMETHODIMP COBass::EatsOtherFish( BOOL *pBool )<BR>
{<BR>
LOG(&quot;COBass::EatsOtherFish\n&quot;); <BR>
if (pBool)<BR>
{<BR>
*pBool = m_bEatsOtherFish;<BR>
return S_OK;<BR>
}<BR>
return (HRESULT)NOERROR; <BR>
}</TT></FONT></P>
<P>As shown in Listing 14.4, the interface implementations are straightforward C++
method implementations. Each method for the <TT>IFish</TT> and <TT>IBass</TT> interfaces
are implemented as a method of the <TT>COBass</TT> class. Unlike the MFC-based <TT>Cbass</TT>
implementation, there is no need to specify a specific interface for each method
since the <TT>COBass</TT> class is derived directly from the <TT>IFish</TT> and <TT>IBass</TT>
interfaces.</P>
<P>One final note on the <TT>COBass</TT> interface implementations concerns the <TT>AddRef</TT>
and <TT>Release</TT> methods implemented for the <TT>IUnknown</TT> interface. The
<TT>AddRef</TT> method simply increments a counter within the object, indicating
that another user is referencing the object.</P>
<P>When <TT>Release</TT> is called three actions are taken:

<UL>
	<LI>The internal reference count is decremented.
	<P>
	<LI>If the reference count is zero, the main application server object is signaled
	to decrement the global object counter.
	<P>
	<LI>If the internal reference count is zero, the object deletes itself; although
	this procedure may seem unusual, it follows the COM rules that the object be responsible
	for its own termination when it is no longer referenced.
</UL>

<P>The last piece of the <TT>COBass</TT> class is the unique <TT>CLSID</TT>. To create
the <TT>CLSID</TT>, run the tool GUIDGEN. Once the <TT>CLSID</TT> is created, it
must be placed in a header file that acts as a define for the class implementation.
For the <TT>COBass</TT> object, the file CUSTOMBASSID.H is created. The <TT>CLSID</TT>
is then pasted into the file and added to the macro <TT>DEFINE_GUID</TT> (see Listing
14.5).
<H3><A NAME="Heading10"></A>Listing 14.5<SPACER TYPE="HORIZONTAL" SIZE="10"> CUSTOMBASSID.H--Header
File CUSTOMBASSID.H, which Contains the Implementation of CLSID for the COBass Class</H3>
<P><FONT COLOR="#0066FF"><TT>#ifndef _CLSID_CustomBass<BR>
#define _CLSID_CustomBass <BR>
//{A1C19FC0-66D6-11d0-ABE6-D07900C10000}<BR>
DEFINE_GUID(CLSID_CustomBass,0xA1C19FC0,<BR>
0x66D6,0x11d0,0xAB,0xE6,0xD0,0x79,0x00,0xC1,0x00,0x00); <BR>
#endif</TT></FONT></P>
<P>The macro <TT>DEFINE_GUID</TT> assigns the name <TT>CLSID_CustomBass</TT> to the
class ID that was created via GUIDGEN. This macro is placed in a header file that
is used by all clients that need to invoke an instance of <TT>CLSID_CustomBass</TT>.
This file is <I>not</I> used by the server that implements the COM Object.
<H2><A NAME="Heading11"></A>Implementing the COBass Class Factory</H2>
<P>Now that the COM class <TT>COBass</TT> is implemented, a class factory that creates
the object must be implemented. A <I>class factory </I>is a COM interface (<TT>IClassFactory</TT>)
that is responsible for creating instances of <TT>COBass</TT>. When using a framework
such as MFC, the class factory for an object is implemented through the <TT>OLE_CREATE</TT>
macro. Without the benefit of a framework, this interface must be implemented by
the developer of the COM Object server.</P>
<P>The <TT>COBass</TT> class factory is implemented in the class <TT>CFBass</TT>
(see Listing 14.6).
<H3><A NAME="Heading12"></A>Listing 14.6<SPACER TYPE="HORIZONTAL" SIZE="10"> FACTORY.H--Class
Factory Definition File, FACTORY.H, for CFBass</H3>
<P><FONT COLOR="#0066FF"><TT>class CFBass : public IUnknown<BR>
{<BR>
public:<BR>
// Main Object Constructor &amp; Destructor.<BR>
CFBass(IUnknown* pUnkOuter, CServer* pServer);<BR>
~CFBass(void); <BR>
// IUnknown methods. Main object, non-delegating.<BR>
STDMETHODIMP QueryInterface(REFIID, PPVOID);<BR>
STDMETHODIMP_(ULONG) AddRef(void);<BR>
STDMETHODIMP_(ULONG) Release(void); <BR>
private:<BR>
// We declare nested class interface implementations here. <BR>
// We implement the IClassFactory interface (ofcourse) in this class<BR>
// factory COM object class.<BR>
class CImpIClassFactory : public IClassFactory<BR>
{<BR>
public:<BR>
// Interface Implementation Constructor &amp; Destructor.<BR>
CImpIClassFactory(<BR>
CFBass* pBackObj,<BR>
IUnknown* pUnkOuter,<BR>
CServer* pServer);<BR>
~CImpIClassFactory(void); <BR>
// IUnknown methods.<BR>
STDMETHODIMP QueryInterface(REFIID, PPVOID);<BR>
STDMETHODIMP_(ULONG) AddRef(void);<BR>
STDMETHODIMP_(ULONG) Release(void); <BR>
// IClassFactory methods.<BR>
STDMETHODIMP CreateInstance(IUnknown*, REFIID, PPVOID);<BR>
STDMETHODIMP LockServer(BOOL); <BR>
private:<BR>
// Data private to this interface implementation of IClassFactory.<BR>
ULONG m_cRefI; // Interface Ref Count (for debugging).<BR>
CFBass* m_pBackObj; // Parent Object back pointer.<BR>
IUnknown* m_pUnkOuter; // Outer unknown for Delegation.<BR>
CServer* m_pServer; // Server's control object.<BR>
}; <BR>
// Make the otherwise private and nested IClassFactory interface<BR>
// implementation a friend to COM object instantiations of this<BR>
// selfsame CFBass COM object class.<BR>
friend CImpIClassFactory; <BR>
// Private data of CFBass COM objects. <BR>
// Nested IClassFactory implementation instantiation.<BR>
CImpIClassFactory m_ImpIClassFactory; <BR>
// Main Object reference count.<BR>
ULONG m_cRefs; <BR>
// Outer unknown (aggregation &amp; delegation). Used when this<BR>
// CFBass object is being aggregated. Otherwise it is used<BR>
// for delegation if this object is reused via containment.<BR>
IUnknown* m_pUnkOuter; <BR>
// Pointer to this component server's control object.<BR>
CServer* m_pServer;<BR>
}; <BR>
typedef CFBass* PCFBass;</TT></FONT></P>
<P>The class <TT>CFBass</TT> uses the technique of nested interfaces to implement
the <TT>IUnknown</TT> and the <TT>IClassFactory</TT> interfaces. With nested interfaces,
the second class definition, in this case <TT>CImpIClassFactory</TT>, is defined
<I>within</I> the definition of the class <TT>CFBass</TT>. This technique allows
the <TT>CImpIClassFactory</TT> object to be created when the constructor of <TT>CFBass</TT>
is called. Each class implements its own interface.</P>
<P>When the <TT>CFBass</TT> class constructor is called, the constructor for the
class member <TT>m_ImpIClassFactory</TT>, which is of class <TT>CImpIClassFactory</TT>,
is also called. Listing 14.7 illustrates the <TT>CFBass</TT> constructor as well
as the <TT>IUnknown</TT> interfaces implemented in <TT>CFBass</TT>. Notice that if
the <TT>IUnknown</TT> interface is called with an interface ID of <TT>IID_IClassFactory</TT>,
the address of member <TT>CImpIClassFactory</TT> is returned.
<H3><A NAME="Heading13"></A>Listing 14.7 <SPACER TYPE="HORIZONTAL" SIZE="10">FACTORY.CPP--Implementation
of the CFBass Class and IUnknown Interface</H3>
<P><FONT COLOR="#0066FF"><TT>#include &lt;windows.h&gt;<BR>
#include &lt;ole2.h&gt;<BR>
#include &quot;comutil.h&quot;<BR>
#include &quot;server.h&quot;<BR>
#include &quot;factory.h&quot;<BR>
#include &quot;cobass.h&quot; <BR>
CFBass::CFBass(<BR>
IUnknown* pUnkOuter,<BR>
CServer* pServer) :<BR>
m_ImpIClassFactory(this, pUnkOuter, pServer)<BR>
{<BR>
// Zero the COM object's reference count.<BR>
m_cRefs = 0; <BR>
// No AddRef necessary if non-NULL, as we're nested.<BR>
m_pUnkOuter = pUnkOuter; <BR>
// Init the pointer to the server control object.<BR>
m_pServer = pServer;<BR>
} <BR>
CFBass::~CFBass(void)<BR>
{<BR>
return;<BR>
} <BR>
STDMETHODIMP CFBass::QueryInterface(<BR>
REFIID riid,<BR>
PPVOID ppv)<BR>
{<BR>
HRESULT hr = E_NOINTERFACE;<BR>
*ppv = NULL; <BR>
if (IID_IUnknown == riid)<BR>
{<BR>
*ppv = this;<BR>
LOG(&quot;S: CFBass::QueryInterface. `this' pIUnknown returned.&quot;);<BR>
}<BR>
else if (IID_IClassFactory == riid)<BR>
{<BR>
*ppv = &amp;m_ImpIClassFactory;<BR>
LOG(&quot;S: CFBass::QueryInterface. pIClassFactory returned.&quot;);<BR>
} <BR>
if (NULL != *ppv)<BR>
{<BR>
// We've handed out a pointer to the interface so obey the COM rules<BR>
// and AddRef the reference count.<BR>
((LPUNKNOWN)*ppv)-&gt;AddRef();<BR>
hr = NOERROR;<BR>
} <BR>
return (hr);<BR>
} <BR>
STDMETHODIMP_(ULONG) CFBass::AddRef(void)<BR>
{<BR>
m_cRefs++; <BR>
LOGF1(&quot;S: CFBass::AddRef. New cRefs=%i.&quot;, m_cRefs); <BR>
return m_cRefs;<BR>
} <BR>
STDMETHODIMP_(ULONG) CFBass::Release(void)<BR>
{<BR>
m_cRefs--; <BR>
LOGF1(&quot;S: CFBass::Release. New cRefs=%i.&quot;, m_cRefs); <BR>
if (0 == m_cRefs)<BR>
{<BR>
if (NULL != m_pServer)<BR>
m_pServer-&gt;ObjectsDown(); <BR>
delete this;<BR>
} <BR>
return m_cRefs; <BR>
}</TT></FONT></P>
<P>The <TT>IClassFactory</TT> interface is analogous to the C++ <TT>new</TT> operator.
<TT>IClassFactory</TT> is an interface used for creating COM classes. Each COM class
is created through an <TT>IClassFactory</TT> interface. The <TT>IClassFactory</TT>
interface is derived from <TT>IUnknown</TT> and contains the following methods:</P>
<P><FONT COLOR="#0066FF"><TT><BR>
// IClassFactory methods.<BR>
STDMETHODIMP CreateInstance(IUnknown*, REFIID, PPVOID);<BR>
STDMETHODIMP LockServer(BOOL);</TT></FONT></P>
<P>The method <TT>CreateInstance</TT> is used to create an instance of a COM class.
<TT>LockServer</TT> method increments or decrements a reference count within the
COM server. If the count is greater than 0, the server cannot be removed from memory.
Within the <TT>CFBass</TT> class, the <TT>IClassFactory</TT> is implemented through
the class <TT>CImpIClassFactory</TT>. The <TT>IUnknown</TT> and <TT>IClassFactory</TT>
implementations of <TT>CImpIClassFactory</TT> are shown in Listing 14.8.
<H3><A NAME="Heading14"></A>Listing 14.8<SPACER TYPE="HORIZONTAL" SIZE="10"> FACTORY.CPP--IUnknown
and IClassFactory Implementations in CImpIClassFactory</H3>
<P><FONT COLOR="#0066FF"><TT>CFBass::CImpIClassFactory::CImpIClassFactory(<BR>
CFBass* pBackObj,<BR>
IUnknown* pUnkOuter,<BR>
CServer* pServer)<BR>
{<BR>
// Init the Interface Ref Count (used for debugging only).<BR>
m_cRefI = 0; <BR>
// Init the Back Object Pointer to point to the parent object.<BR>
m_pBackObj = pBackObj; <BR>
// Init the pointer to the server control object.<BR>
m_pServer = pServer; <BR>
// Init the CImpIClassFactory interface's<BR>
//delegating Unknown pointer.<BR>
// We use the Back Object pointer for<BR>
// IUnknown delegation here if we are<BR>
// not being aggregated. If we are being<BR>
// aggregated we use the supplied<BR>
// pUnkOuter for IUnknown delegation.<BR>
// In either case the pointer<BR>
// assignment requires no AddRef<BR>
// because the CImpIClassFactory lifetime is<BR>
// quaranteed by the lifetime of the parent object in which<BR>
// CImpIClassFactory is nested.<BR>
if (NULL == pUnkOuter)<BR>
{<BR>
m_pUnkOuter = pBackObj;<BR>
LOG(&quot;S: CFBass::CImpIClassFactory Constructor.<BR>
Non-Aggregating.&quot;);<BR>
}<BR>
else<BR>
{<BR>
m_pUnkOuter = pUnkOuter;<BR>
LOG(&quot;S: CFBass::CImpIClassFactory Constructor.<BR>
Aggregating.&quot;);<BR>
} <BR>
return;<BR>
} <BR>
CFBass::CImpIClassFactory::~CImpIClassFactory(void)<BR>
{<BR>
LOG(&quot;S: CFBass::CImpIClassFactory Destructor.&quot;); <BR>
return;<BR>
} <BR>
STDMETHODIMP CFBass::CImpIClassFactory::QueryInterface(<BR>
REFIID riid,<BR>
PPVOID ppv)<BR>
{<BR>
LOG(&quot;S: CFBass::CImpIClassFactory::QueryInterface.<BR>
Delegating.&quot;); <BR>
// Delegate this call to the outer object's QueryInterface.<BR>
return m_pUnkOuter-&gt;QueryInterface(riid, ppv);<BR>
} <BR>
STDMETHODIMP_(ULONG) CFBass::CImpIClassFactory::AddRef(void)<BR>
{<BR>
// Increment the Interface Reference Count.<BR>
++m_cRefI; <BR>
LOGF1(&quot;S: CFBass::CImpIClassFactory::Addref.<BR>
Delegating. New cI=%i.&quot;,m_cRefI); <BR>
// Delegate this call to the outer object's AddRef.<BR>
return m_pUnkOuter-&gt;AddRef();<BR>
} <BR>
STDMETHODIMP_(ULONG) CFBass::CImpIClassFactory::Release(void)<BR>
{<BR>
// Decrement the Interface Reference Count.<BR>
--m_cRefI; <BR>
LOGF1(&quot;S: CFBass::CImpIClassFactory::Release.<BR>
Delegating. New cI=%i.&quot;,m_cRefI); <BR>
// Delegate this call to the outer object's Release.<BR>
return m_pUnkOuter-&gt;Release();<BR>
} <BR>
STDMETHODIMP CFBass::CImpIClassFactory::CreateInstance(<BR>
IUnknown* pUnkOuter,<BR>
REFIID riid,<BR>
PPVOID ppv)<BR>
{<BR>
HRESULT hr = E_FAIL;<BR>
COBass* pCob = NULL; <BR>
LOGF1(&quot;S: CFBass::CImpIClassFactory::CreateInstance.<BR>
pUnkOuter=0x%X.&quot;,pUnkOuter); <BR>
// NULL the output pointer.<BR>
*ppv = NULL; <BR>
// If the creation call is requesting aggregation<BR>
// (pUnkOuter != NULL),<BR>
// the COM rules state the IUnknown interface<BR>
// MUST also be concomitantly<BR>
// be requested. If it is not so requested<BR>
// (riid != IID_IUnknown) then<BR>
// an error must be returned indicating that<BR>
// no aggregate creation of<BR>
// the CFBass COM Object can be performed.<BR>
if (NULL != pUnkOuter &amp;&amp; riid != IID_IUnknown)<BR>
hr = CLASS_E_NOAGGREGATION;<BR>
else<BR>
{<BR>
pCob = new COBass(pUnkOuter, m_pServer);<BR>
if (NULL != pCob)<BR>
{<BR>
// We initially created the new COM object<BR>
// so tell the server<BR>
// to increment its global server object<BR>
// count to help ensure<BR>
// that the server remains loaded until<BR>
// this partial creation<BR>
// of a COM component is completed.<BR>
m_pServer-&gt;ObjectsUp(); <BR>
// We QueryInterface this new COM Object not<BR>
// only to deposit the<BR>
// main interface pointer to the caller's<BR>
// pointer variable, but to<BR>
// also automatically bump the Reference<BR>
// Count on the new COM<BR>
// Object after handing out this reference to it.<BR>
hr = pCob-&gt;QueryInterface(riid, (PPVOID)ppv);<BR>
if (FAILED(hr))<BR>
{<BR>
m_pServer-&gt;ObjectsDown();<BR>
delete pCob;<BR>
}<BR>
}<BR>
else<BR>
hr = E_OUTOFMEMORY;<BR>
} <BR>
if (SUCCEEDED(hr))<BR>
{<BR>
LOGF1(&quot;S: CFBass::CImpIClassFactory::CreateInstance<BR>
Succeeded. *ppv=0x%X.&quot;,*ppv);<BR>
}<BR>
else<BR>
{<BR>
LOG(&quot;S: CFBass::CImpIClassFactory::CreateInstance Failed.&quot;);<BR>
} <BR>
return hr;<BR>
} <BR>
STDMETHODIMP CFBass::CImpIClassFactory::LockServer(<BR>
BOOL fLock)<BR>
{<BR>
HRESULT hr = NOERROR; <BR>
LOG(&quot;S: CFBass::CImpIClassFactory::LockServer.&quot;); <BR>
if (fLock)<BR>
m_pServer-&gt;Lock();<BR>
else<BR>
m_pServer-&gt;Unlock(); <BR>
return hr; <BR>
}</TT></FONT></P>
<P>Three parameters are passed into the method <TT>CreateInstance</TT>:

<UL>
	<LI><TT>IUnknown* pUnkOuter</TT>: An outer <TT>IUnknown</TT> interface pointer. This
	pointer indicates that object aggregation is being requested by the client application.
	In order for aggregation to be successful, the <TT>IID</TT> passed into <TT>CreateInstance</TT>
	must be <TT>IID_IUnknown</TT>.
	<P>
	<LI><TT>REFIID riid</TT>: This variable is the interface ID (<TT>IID</TT>) that the
	client application is requesting when creating an instance of the COM class.
	<P>
	<LI><TT>PPVOID ppv</TT>: A double pointer used to store a pointer to the interface
	ID. PPVOID ppv is returned to the client application. In other words, the client
	passes in the address of the pointer to the interface ID. The server's responsibility
	is to create the interface pointer and return it to the calling program.
</UL>

<P>The <TT>CreateInstance</TT> method is not complicated. When this method is called,
an object of class <TT>COBass</TT> is created. After the object is created, <TT>QueryInterface</TT>
is called on the object using the interface ID passed to <TT>CreateInstance</TT>.
If the requested interface is contained within <TT>COBass</TT>, the interface pointer
is returned to the client. If the requested interface is not contained within <TT>COBass</TT>,
the <TT>COBass</TT> object is deleted and <TT>NULL</TT> is returned.
<H2><A NAME="Heading15"></A>Implementation of the Server Application</H2>
<P>The implementation of the COM server requires some global housekeeping. The class
<TT>CServer</TT> does this housekeeping. <TT>CServer</TT>, a global variable much
like an MFC <TT>CApplication</TT> object, keeps track of the number of object references
within the server (see Listing 14.9).
<H3><A NAME="Heading16"></A>Listing 14.9<SPACER TYPE="HORIZONTAL" SIZE="10"> SERVER.H--CServer
Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT>class CServer<BR>
{<BR>
public:<BR>
CServer(void);<BR>
~CServer(void); <BR>
void Lock(void);<BR>
void Unlock(void);<BR>
void ObjectsUp(void);<BR>
void ObjectsDown(void); <BR>
// A place to store the handle to loaded instance of this DLL module.<BR>
HINSTANCE m_hDllInst; <BR>
// Global DLL Server living Object count.<BR>
LONG m_cObjects; <BR>
// Global DLL Server Client Lock count.<BR>
LONG m_cLocks;<BR>
}; <BR>
extern CServer* g_pServer;</TT></FONT></P>
<P>The server application object is passed into the constructor of all classes implemented
within the COM server. The classes that accept the server application object in their
constructor include the COM Object <TT>COBass</TT>, the class factory <TT>CFBass,</TT>
and <TT>CImpIClassFactory</TT>. Using a central application object allows all object
instances to reference global counters within the COM server. The <TT>CServer</TT>
implementation is shown in Listing 14.10.
<H3><A NAME="Heading17"></A>Listing 14.10 <SPACER TYPE="HORIZONTAL" SIZE="10">SERVER.CPP--CServer
Object Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>CServer::CServer(void)<BR>
{<BR>
// Zero the Object and Lock counts for this attached process.<BR>
m_cObjects = 0;<BR>
m_cLocks = 0; <BR>
return;<BR>
} <BR>
CServer::~CServer(void)<BR>
{<BR>
return;<BR>
} <BR>
void CServer::Lock(void)<BR>
{<BR>
InterlockedIncrement((PLONG) &amp;m_cLocks); <BR>
LOGF1(&quot;S: CServer::Lock. New cLocks=%i.&quot;, m_cLocks); <BR>
return;<BR>
} <BR>
void CServer::Unlock(void)<BR>
{<BR>
InterlockedDecrement((PLONG) &amp;m_cLocks); <BR>
LOGF1(&quot;S: CServer::Unlock. New cLocks=%i.&quot;, m_cLocks); <BR>
return;<BR>
} <BR>
void CServer::ObjectsUp(void)<BR>
{<BR>
InterlockedIncrement((PLONG) &amp;m_cObjects); <BR>
LOGF1(&quot;S: CServer::ObjectsUp. New cObjects=%i.&quot;, m_cObjects); <BR>
return;<BR>
} <BR>
void CServer::ObjectsDown(void)<BR>
{<BR>
InterlockedDecrement((PLONG) &amp;m_cObjects); <BR>
LOGF1(&quot;S: CServer::ObjectsDown. New cObjects=%i.&quot;, m_cObjects); <BR>
return; <BR>
}</TT></FONT></P>
<P>Two variables used within the <TT>CServer</TT> object, <TT>m_cObjects</TT> and
<TT>m_cLocks</TT>, are accessed by the COM class factory and COM Object. The variable
<TT>m_cObjects</TT> is used to keep track of the number of interfaces requested from
the <TT>COBass</TT> objects. The variable <TT>m_cLocks</TT> is used to track the
number of locks issued on the COM server. When both of these variables are set to
zero, the COM server is removed from memory. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The variables <TT>m_cLocks</TT> and <TT>m_cObjects</TT> are incremented
	and decremented through the Win32 functions <TT>InterlockedIncrement</TT> and <TT>InterlockedDecrement</TT>.
	These functions are atomic operations that add and subtract 1 from the current value
	of the variable passed to the function. These functions are designed specifically
	for multithreaded applications to prevent multiple threads from modifying a value
	simultaneously.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H2><A NAME="Heading18"></A>Implementation of the Server Access Functions</H2>
<P>Now that the COM server internals are implemented, the server access functions
must be implemented. The code for all of the server access functions is shown in
Listing 14.11.</P>
<P>Five functions must be implemented:

<UL>
	<LI><TT>DllMain</TT>: This function <I>must</I> be included for all Win32 DLLs. This
	function is the entry point for loading libraries into memory. During loading of
	the DLL, a global <TT>CServer</TT> object is created. During unloading, the <TT>CServer</TT>
	object is deleted.
	<P>
	<LI><TT>DllRegisterServer</TT>: This function is used to register the COM classes
	within the server in the Windows Registry. The <TT>CLSID</TT> for the <TT>COBass</TT>
	is registered with the CUSTOMBASS DLL as the COM server.
	<P>
	<LI><TT>DLLUnregisterServer</TT>: This function removes any COM classes registered
	by the COM server from the Windows registry.
	<P>
	<LI><TT>DllCanUnloadNow</TT>: This function checks the <TT>CServer</TT> object to
	determine whether any objects or locks remain within the server. If the respective
	counts are zero, <TT>TRUE</TT> is returned to the calling application.
	<P>
	<LI><TT>DllGetClassObject</TT>: This is the main function for accessing COM interfaces.
	If the <TT>CLSID</TT> for the <TT>CUSTOMBASS</TT> object is passed in, a class factory
	<TT>CFBASS</TT> is created. A COM interface is then requested from the <TT>CFBass</TT>
	class factory.
</UL>

<H3><A NAME="Heading19"></A>Listing 14.11 <SPACER TYPE="HORIZONTAL" SIZE="10">CUSTOMBASS.CPP--Server
Access Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>#include &lt;ole2.h&gt;<BR>
#include &lt;initguid.h&gt;<BR>
#include &quot;..\ifish\ifish.h&quot;<BR>
#include &quot;..\ifish\ibass.h&quot;<BR>
#include &quot;custombassid.h&quot;<BR>
#include &quot;comutil.h&quot;<BR>
#define _DLLEXPORT_<BR>
#include &quot;custombass.h&quot;<BR>
#include &quot;server.h&quot;<BR>
#include &quot;factory.h&quot;<BR>
<BR>
// We encapsulate the control of this<BR>
// COM server (eg, lock and object<BR>
// counting) in a server control C++ object.<BR>
// Here is it's pointer. <BR>
CServer* g_pServer = NULL; <BR>
BOOL WINAPI DllMain(<BR>
HINSTANCE hDllInst,<BR>
DWORD fdwReason,<BR>
LPVOID lpvReserved)<BR>
{<BR>
BOOL bResult = TRUE; <BR>
// Dispatch this main call based on the reason it was called.<BR>
switch (fdwReason)<BR>
{<BR>
case DLL_PROCESS_ATTACH:<BR>
// The DLL is being loaded for the first time<BR>
// by a given process.<BR>
// Perform per-process initialization here.<BR>
// If the initialization<BR>
// is successful, return TRUE;<BR>
// if unsuccessful, return FALSE.<BR>
bResult = FALSE;<BR>
// Instantiate the CServer utility class.<BR>
g_pServer = new CServer;<BR>
if (NULL != g_pServer)<BR>
{<BR>
// Remember the DLL Instance handle.<BR>
g_pServer-&gt;m_hDllInst = hDllInst;<BR>
bResult = TRUE;<BR>
}<BR>
break; <BR>
case DLL_PROCESS_DETACH:<BR>
// The DLL is being unloaded by<BR>
// a given process. Do any<BR>
// per-process clean up here,<BR>
// such as undoing what was done in<BR>
// DLL_PROCESS_ATTACH. <BR>
// The return value is ignored.<BR>
DELETE_POINTER(g_pServer);<BR>
break; <BR>
case DLL_THREAD_ATTACH:<BR>
// A thread is being created in a process<BR>
// that has already loaded<BR>
// this DLL. Perform any per-thread<BR>
// initialization here. The<BR>
// return value is ignored.<BR>
break; <BR>
case DLL_THREAD_DETACH:<BR>
// A thread is exiting cleanly in a<BR>
// process that has already<BR>
// loaded this DLL. Perform any<BR>
// per-thread clean up here. The<BR>
// return value is ignored.<BR>
break; <BR>
default:<BR>
break;<BR>
} <BR>
return (bResult);<BR>
} <BR>
STDAPI DllGetClassObject(<BR>
REFCLSID rclsid,<BR>
REFIID riid,<BR>
PPVOID ppv)<BR>
{<BR>
HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;<BR>
IUnknown* pCob = NULL; <BR>
if (CLSID_CustomBass == rclsid)<BR>
{<BR>
LOG(&quot;S: DllGetClassObject: Requesting COBass.&quot;);<BR>
hr = E_OUTOFMEMORY;<BR>
pCob = new CFBass(NULL, g_pServer);<BR>
} <BR>
if (NULL != pCob)<BR>
{<BR>
g_pServer-&gt;ObjectsUp();<BR>
hr = pCob-&gt;QueryInterface(riid, ppv);<BR>
if (FAILED(hr))<BR>
{<BR>
g_pServer-&gt;ObjectsDown();<BR>
DELETE_POINTER(pCob);<BR>
}<BR>
} <BR>
return hr;<BR>
} <BR>
STDAPI DllCanUnloadNow(void)<BR>
{<BR>
HRESULT hr; <BR>
LOGF2(&quot;S: DllCanUnloadNow. cObjects=%i,<BR>
cLocks=%i.&quot;, g_pServer-&gt;m_cObjects, g_pServer-&gt;m_cLocks); <BR>
// We return S_OK of there are<BR>
//no longer any living objects AND<BR>
// there are no outstanding client locks on this server.<BR>
hr = (0L==g_pServer-&gt;m_cObjects &amp;&amp;<BR>
0L==g_pServer-&gt;m_cLocks) ? S_OK : S_FALSE; <BR>
return hr;<BR>
} <BR>
STDAPI DllRegisterServer(void)<BR>
{<BR>
HRESULT hr = NOERROR;<BR>
TCHAR szID[GUID_SIZE+1];<BR>
TCHAR szCLSID[GUID_SIZE+1];<BR>
TCHAR szModulePath[MAX_PATH]; <BR>
// Obtain the path to this module's<BR>
// executable file for later use.<BR>
GetModuleFileName(<BR>
g_pServer-&gt;m_hDllInst,<BR>
szModulePath,<BR>
sizeof(szModulePath)/sizeof(TCHAR)); <BR>
// Create some base key strings.<BR>
StringFromGUID2(CLSID_CustomBass, szID, GUID_SIZE);<BR>
lstrcpy(szCLSID, TEXT(&quot;CLSID\\&quot;));<BR>
lstrcat(szCLSID, szID); <BR>
// Create entries under CLSID.<BR>
SetRegKeyValue(<BR>
szCLSID,<BR>
NULL,<BR>
TEXT(&quot;CustomBass Class&quot;));<BR>
<BR>
SetRegKeyValue(<BR>
szCLSID,<BR>
TEXT(&quot;InprocServer32&quot;),<BR>
szModulePath); <BR>
return hr;<BR>
} <BR>
STDAPI DllUnregisterServer(void)<BR>
{<BR>
HRESULT hr = NOERROR;<BR>
TCHAR szID[GUID_SIZE+1];<BR>
TCHAR szCLSID[GUID_SIZE+1];<BR>
TCHAR szTemp[GUID_SIZE+1]; <BR>
//Create some base key strings.<BR>
StringFromGUID2(CLSID_CustomBass, szID, GUID_SIZE);<BR>
lstrcpy(szCLSID, TEXT(&quot;CLSID\\&quot;));<BR>
lstrcat(szCLSID, szID); <BR>
wsprintf(szTemp, TEXT(&quot;%s\\%s&quot;), <BR>
szCLSID, TEXT(&quot;InprocServer32&quot;));<BR>
RegDeleteKey(HKEY_CLASSES_ROOT, szTemp); <BR>
RegDeleteKey(HKEY_CLASSES_ROOT, szCLSID); <BR>
return hr;<BR>
}<BR>
BOOL SetRegKeyValue(<BR>
LPTSTR pszKey,<BR>
LPTSTR pszSubkey,<BR>
LPTSTR pszValue)<BR>
{<BR>
BOOL bOk = FALSE;<BR>
LONG ec;<BR>
HKEY hKey;<BR>
TCHAR szKey[MAX_STRING_LENGTH]; <BR>
lstrcpy(szKey, pszKey); <BR>
if (NULL != pszSubkey)<BR>
{<BR>
lstrcat(szKey, TEXT(&quot;\\&quot;));<BR>
lstrcat(szKey, pszSubkey);<BR>
} <BR>
ec = RegCreateKeyEx(<BR>
HKEY_CLASSES_ROOT,<BR>
szKey,<BR>
0,<BR>
NULL,<BR>
REG_OPTION_NON_VOLATILE,<BR>
KEY_ALL_ACCESS,<BR>
NULL,<BR>
&amp;hKey,<BR>
NULL); <BR>
if (NULL != pszValue &amp;&amp; ERROR_SUCCESS == ec)<BR>
{<BR>
ec = RegSetValueEx(<BR>
hKey,<BR>
NULL,<BR>
0,<BR>
REG_SZ,<BR>
(BYTE *)pszValue,<BR>
(lstrlen(pszValue)+1)*sizeof(TCHAR));<BR>
if (ERROR_SUCCESS == ec)<BR>
bOk = TRUE;<BR>
RegCloseKey(hKey);<BR>
}<BR>
return bOk; <BR>
}</TT></FONT></P>
<H2><A NAME="Heading20"></A>Compiling and Testing the COM Server</H2>
<P>Now that the COM server is complete, it is time to compile and test the server.
Compiling the server is a trivial task. Simply select the command <U>B</U>uild CUSTOMBASS.DLL
from the <U>B</U>uild menu. This command will build the entire project.</P>
<P>After the server is built, it needs to be registered in the Windows Registry.
You can accomplish this by selecting the command <U>R</U>egister Control from the
<U>T</U>ools menu. <U>R</U>egister Control will invoke the application <TT>regsvr32.exe</TT>,
which will then call the function <TT>DllRegisterServer</TT> in CUSTOMBASS.DLL.</P>
<P>After registration is complete, the server is ready for use. In <A HREF="ch12.htm">Chapter
12</A>, a COM test application was created for testing the <TT>IFish</TT> and <TT>IBass</TT>
interfaces. This application can be used to test the <TT>IFish</TT> and <TT>IBass</TT>
interfaces built in CUSTOMBASS. To test CUSTOMBASS, change the <TT>CLSID</TT> referenced
from <TT>CLSID_Bass</TT> to <TT>CLSID_CustomBass</TT>. When the COM test application
is run, the new server will be used for accessing the <TT>IFish</TT> and <TT>IBass</TT>
interfaces.
<H2><A NAME="Heading21"></A>From Here...</H2>
<P>Creating your own COM classes without using a framework requires more programming
than when using a framework. However, no excessive baggage from the framework is
carried within the COM server, and several implementation strategies can be used
during implementation. For an in-depth look at using a lightweight COM framework,
refer to Chapter 13, which illustrates the development of COM Objects using the ActiveX
Template Library. The ATL framework is composed of lightweight templates for designing
and implementing COM Objects. Conversely, in <A HREF="ch12.htm">Chapter 12</A>, COM
Objects are developed using the MFC application framework. The MFC framework is feature
rich but can be overkill for COM Objects that do not need to support a user interface.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
