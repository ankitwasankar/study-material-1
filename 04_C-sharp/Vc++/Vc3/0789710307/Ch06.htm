<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 10:07 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 6</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 6<BR>
Using MFC to Create a Basic ActiveX Control</H1>

<UL>
	<LI><A HREF="#Heading1">Using MFC to Create a Basic ActiveX Control</A>
	<UL>
		<LI><A HREF="#Heading2">Creating the Basic Control Project</A>
		<LI><A HREF="#Heading3">Control Registration</A>
		<UL>
			<LI><A HREF="#Heading4">Listing 6.1 MFCCONTROLWINCTL.CPP--Default UpdateRegistry
			Implementation</A>
		</UL>
		<LI><A HREF="#Heading5">Creating Methods</A>
		<UL>
			<LI><A HREF="#Heading6">Listing 6.2 MFCCONTROLWINCTL.H--Alignment Enumeration Include
			File and Member Variables Added to Class Definition</A>
			<LI><A HREF="#Heading7">Listing 6.3 ALIGNMENTENUMS.H--Alignment Enumeration Include
			File</A>
			<LI><A HREF="#Heading8">Listing 6.4 MFCCONTROLWINCTL.CPP--Initialize the m_lAlignment
			Member Variable in the Class Constructor</A>
			<LI><A HREF="#Heading9">Listing 6.5 MFCCONTROLWINCTL.CPP--CaptionMethod Implementation</A>
			<LI><A HREF="#Heading10">Listing 6.6 MFCCONTROL.ODL--Keyword [optional] Added to
			the CaptionMethod ODL Definition</A>
		</UL>
		<LI><A HREF="#Heading11">Properties</A>
		<UL>
			<LI><A HREF="#Heading12">Creating Normal User Defined Properties</A>
			<LI><A HREF="#Heading13">Listing 6.7 MFCCONTROLWINCTL.CPP--Alignment Property Get/Set
			Method Implementation</A>
			<LI><A HREF="#Heading14">Creating Parameterized User Defined Properties</A>
			<LI><A HREF="#Heading15">Listing 6.8 MFCCONTROLWINCTL.CPP--GetCaptionProp Implementation</A>
			<LI><A HREF="#Heading16">Listing 6.9 MFCCONTROLWINCTL.CPP--SetCaptionProp Implementation</A>
			<LI><A HREF="#Heading17">Listing 6.10 MFCCONTROL.ODL--[optional] Keyword Added to
			the ODL File</A>
			<LI><A HREF="#Heading18">Creating Stock Properties</A>
			<LI><A HREF="#Heading19">Using Ambient Properties</A>
			<LI><A HREF="#Heading20">Creating Property Sheets</A>
			<LI><A HREF="#Heading21">Listing 6.11 MFCCONTROLWINPPG.CPP--New Member Variables
			Added to the DoDataExchange Function</A>
			<LI><A HREF="#Heading22">Listing 6.12 MFCCONTROLWINPPG.CPP--Updated DoDataExchange
			Function; Alignment Enumeration Added</A>
			<LI><A HREF="#Heading23">Listing 6.13 MFCCONTROLWINCTL.CPP--BoundPropertyChanged
			Function within the SetAlignment Implementation</A>
			<LI><A HREF="#Heading24">Listing 6.14 MFCCONTROLWINPPG.CPP--m_AlignmentValue Class
			Member Initialized in the Class Constructor</A>
		</UL>
		<LI><A HREF="#Heading25">Adding Events</A>
		<UL>
			<LI><A HREF="#Heading26">Listing 6.15 MFCCONTROLWINCTL.H--FireChange Function Prototype
			Added to the Class Definition</A>
			<LI><A HREF="#Heading27">Listing 6.16 MFCCONTROLWINCTL.CPP--FireChange Implementation
			Added to the MFControlWinCtl.cpp Source File</A>
			<LI><A HREF="#Heading28">Listing 6.17 MFCCONTROWINCTL.CPP--FireChange Event Added
			to the CaptionMethod Implementation</A>
		</UL>
		<LI><A HREF="#Heading29">Persistence</A>
		<UL>
			<LI><A HREF="#Heading30">Listing 6.18 MFCCONTROLWINCTL.CPP--Simple DoPropExchange
			Implementation</A>
			<LI><A HREF="#Heading31">Listing 6.19 MFCCONTROLWINCTL.CPP--DoPropExchange Implementation
			Separated into Distinct Operations</A>
			<LI><A HREF="#Heading32">Listing 6.20 EXAMPLE--Example Implementation of the Code
			Needed to Support Stock Property Persistence</A>
		</UL>
		<LI><A HREF="#Heading33">Drawing the Control</A>
		<UL>
			<LI><A HREF="#Heading34">Standard Drawing</A>
			<LI><A HREF="#Heading35">Listing 6.21 MFCCONTROLWINCTL.H--CBrush Member Variable
			Added to CMFCControlWinCtrl</A>
			<LI><A HREF="#Heading36">Listing 6.22 MFCCONTROLWINCTL.CPP--Standard Drawing Added
			to the OnDraw Function</A>
		</UL>
		<LI><A HREF="#Heading37">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Using MFC to Create a Basic ActiveX Control</H1>

<UL>
	<LI><B>Registration</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Registration is probably the most important aspect of creating a control. MFC registration
	is robust and easy to understand.
	<P>
	<LI><B>Adding methods and properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The method is the basis for all communication to the control. Like methods, properties
	are a way to expose information about a control implementation to the control's user.
	The MFC ClassWizard makes adding methods and properties easy.
	<P>
	<LI><B>Adding events</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The control uses events to communicate information and conditions to the control's
	user.
	<P>
	<LI><B>Persistence</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Persistence is the control's means to remember information about itself across execution
	lifetimes. MFC persistence is based on a set of macros.
	<P>
	<LI><B>Drawing the control</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Drawing the User Interface can make or break a control implementation.
</UL>

<P>Visual C++ and MFC are powerful and flexible tools for creating ActiveX controls.
In terms of rapid development and ease of use, these two win hands down. In this
chapter, you will see just how powerful these tools are. You will create an ActiveX
control with all the basics: methods, properties, events, persistence, and drawing.
And you will explore some of the more advanced features and lesser known aspects
of control development, such as methods with optional parameters, asynchronous properties,
Clipboard support, and optimized drawing, to name just a few. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> MFC controls are linked dynamically to the MFC DLLs for support and
	implementation. Linking dynamically can impair the control's load time because the
	MFC DLLs are loaded in addition to the control itself. Even though the MFC DLLs may
	already be in memory, you still have DLL address fix-ups and memory swapping issues.
	When developing an ActiveX control, the developer is prudent to remove as much dependence
	on MFC as possible. This practice serves two purposes: First, this practice makes
	it much easier to port the control to an alternative framework such as ATL or BaseCtl;
	second, it improves the overall performance of the control because you don't have
	the overhead of the MFC DLLs to contend with. As a general rule, components that
	are performance-sensitive should avoid using DLLs of any kind. The last thing you
	want is a component that is disk-bound.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H2><A NAME="Heading2"></A>Creating the Basic Control Project</H2>
<P>To create an MFC ActiveX control, you want to take advantage of the AppWizard
provided by Visual C++. Run the Visual C++ development environment, and from the
<U>F</U>ile menu select, <U>N</U>ew. When the New dialog displays (see fig. 6.1),
select the Projects tab. The Projects tab allows you the opportunity to define several
aspects of how the application will be created, for example, the type of application
to create, the name of the application, and the location where you want the project
created. For the type, select MFC ActiveX ControlWizard; enter the Project <U>N</U>ame
<B>MFCControl</B>, and the Lo<U>c</U>ation will be C:\que\ActiveX\MFCControl. Click
the OK button to start the ControlWizard so you can define the properties of your
control. <BR>
<BR>
<A HREF="art/06/f_fig01.jpg"><B>FIG. 6.1</B></A> <I><BR>
Define the new MFC control project with the New dialog.</I></P>
<P>The first step in the ControlWizard allows you to define how many controls will
exist within your project (see fig. 6.2). Using the up and down arrow buttons, select
3 for the number of controls, and leave the remainder of the properties set to their
default values. Click the <U>N</U>ext button to continue. <B><BR>
<BR>
</B><A HREF="art/06/f_fig02.jpg"><B>FIG. 6.2</B></A> <BR>
<I>MFC ActiveX ControlWizard -- Step 1 of 2 is where you define the number of controls
in your project.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> If you have a requirement to create more than one control, and the
	controls are often used together within the same application, we recommend combining
	the controls into a single .ocx file--because of .ocx load times. A single .ocx always
	loads faster than two .ocxs of comparable size. Code sharing can also be an advantage,
	and the end result is a control that's smaller and loads faster than the two individual
	controls combined.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Step 2 of the ControlWizard allows you to change the name of the control, some of
its features, and whether the control will be a subclass of an existing window's
control (see fig. 6.3). <B><BR>
<BR>
</B><A HREF="art/06/f_fig03.jpg"><B>FIG. 6.3</B></A> <I><BR>
Use the ControlWizard -- Step 2 of 2 to further define your control.</I></P>
<P>Because you have instructed the Control Wizard that you want 3 controls for this
project, you will rename <TT>MFCControl1</TT>, <TT>MFCControl2</TT>, and <TT>MFCControl3</TT>
to <TT>MFCControlWin</TT>, <TT>MFCControlNoWin</TT>, and <TT>MFCControlSubWin</TT>,
respectively. To rename a class, select the name in the drop-down list box and click
the <U>E</U>dit Names button. Enter the new name of the control in the <U>S</U>hort
Name edit box (see fig. 6.4). The names of the other files and classes will change
automatically to conform to the new <U>S</U>hort Name. Click OK to close the Edit
Names dialog. <B><BR>
<BR>
</B><A HREF="art/06/f_fig04.jpg"><B>FIG. 6.4</B></A> <I><BR>
Edit the names of the control using the Edit Names dialog.</I></P>
<P>The A<U>d</U>vanced button is used to display a dialog for selecting the ActiveX
enhancements that you want for the control (see fig. 6.5). Ensure that the <TT>MFCControlWin</TT>
class is selected, and click the A<U>d</U>vanced button. <BR>
<BR>
<A HREF="art/06/f_fig05.jpg"><B>FIG. 6.5</B></A> <BR>
<I>Select from the Advanced ActiveX Features dialog for your control.</I></P>
<P>All of the advanced features in the dialog are the result of the OC 96 specification
referred to in <A HREF="ch01.htm">Chapter 1</A>. Now take a minute to look at the
features in detail, as shown in Table 6.1. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 6.1</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Advanced ActiveX Features</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>ActiveX Feature</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><U>W</U>indowless activation</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Allows the control to be instantiated without having to create a window for itself--relies
			on the container to do so.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><U>U</U>nclipped device context</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Used for controls that guarantee they will not draw outside their client area and
			results in disabling MFC clipping tests for the control. Cannot be used with a windowless
			control.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><U>F</U>licker-free activation</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Used for controls that appear the same to the user whether the control is in an active
			or inactive state. Selecting this feature eliminates some of the flicker associated
			with changing states between the active and inactive states of a control. Cannot
			be used with a windowless control.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><U>M</U>ouse pointer notifications when inactive</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Enables control to receive mouse messages, even though the control is in an inactive
			state.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><U>O</U>ptimized drawing code</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Allows the control to draw its User Interface in an optimized fashion if the container
			supports optimized drawing; otherwise, the control must be drawn using standard drawing
			techniques.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><U>L</U>oads properties asynchronously</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Asynchronous properties are properties that load in thebackground and involve the
			transfer of a large amount of data. The properties are loaded in the background to
			prevent the container and the control from being disabled or inactive for too long
			while waiting for the data to load.</TD>
	</TR>
</TABLE>
<BR>
<BR>
From the Advanced ActiveX Features dialog, select only the following options (refer
to fig. 6.5):

<UL>
	<LI><U>U</U>nclipped device context
	<LI><U>F</U>licker-free activation
	<LI><U>M</U>ouse pointer notifications when inactive
	<LI><U>O</U>ptimized drawing code
	<LI><U>L</U>oads properties asynchronously
</UL>

<P>Click OK to confirm the selection and close the dialog.</P>
<P>Select the <TT>MFCControlNoWin</TT> control, and click the A<U>d</U>vanced button
again. You are going to implement <TT>MFCControlNoWin</TT> as a windowless control
just to get a feel for the difference between the windowed and windowless control
implementations in MFC. From the Advanced ActiveX Features dialog, select only the
following options (refer to fig. 6.5):

<UL>
	<LI><U>W</U>indowless activation
	<LI><U>M</U>ouse pointer notifications when inactive
	<LI><U>O</U>ptimized drawing code
	<LI><U>L</U>oads properties asynchronously
</UL>

<P>Click OK to confirm the selections and close the dialog.</P>
<P>For your third and final control, you subclass an existing window's control. Be
sure to select the control <TT>MFCControlSubWin</TT>, and in the subclassing list
box, select BUTTON. Do not define any advanced ActiveX features for this control.</P>
<P>The MFC ActiveX ControlWizard -- Step 2 of 2 dialog also provides other features
for further defining your control project. For the sample project, leave the values
in their default state. See the VC++ documentation for more information regarding
other available options.</P>
<P>Click the Finish button on the ControlWizard dialog to complete the feature selection
process (refer to fig. 6.3). The New Project Information dialog displays to let you
confirm the choices you made (see fig. 6.6). Click OK to generate the source files
and the MFC control project. <B><BR>
<BR>
</B><A HREF="art/06/f_fig06.jpg"><B>FIG. 6.6</B></A> <I><BR>
Make your confirmations in the New Project Information dialog.</I></P>
<P>The first step in any control project is to ensure that it contains registration
support. Without registration, the control cannot be used by any application.
<H2><A NAME="Heading3"></A>Control Registration</H2>
<P>Control registration and unregistration support is provided for you by MFC. You
are not required to make any code changes or additions to support it. Listing 6.1
shows the <TT>UpdateRegistry</TT> function that was created for the control by the
AppWizard; each control will have its own registration function.</P>
<P>One thing of interest is the comment from Microsoft regarding apartment model
threading and how you should register your control if you know it doesn't conform
to apartment model rules. Other than that, you will not have to make any changes
to your application or this function when it comes to control registration.
<H3><A NAME="Heading4"></A>Listing 6.1 MFCCONTROLWINCTL.CPP--Default UpdateRegistry
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CMFCControlWinCtrl::CMFCControlWinCtrlFactory::UpdateRegistry - <BR>
// Adds or removes system registry entries for CMFCControlWinCtrl <BR>
BOOLCMFCControlWinCtrl::CMFCControlWinCtrlFactory::UpdateRegistry(BOOLbRegister)
{ <BR>
// TODO: Verify that your control follows apartment-model threading rules. <BR>
// Refer to MFC TechNote 64 for more information. <BR>
// If your control does not conform to the apartment-model rules, then <BR>
// you must modify the code below, changing the 6th parameter from <BR>
// afxRegApartmentThreading to 0. <BR>
if (bRegister) <BR>
return AfxOleRegisterControlClass( <BR>
AfxGetInstanceHandle(), <BR>
m_clsid, <BR>
m_lpszProgID, <BR>
IDS_MFCCONTROLWIN, <BR>
IDB_MFCCONTROLWIN, <BR>
afxRegApartmentThreading, <BR>
_dwMFCControlWinOleMisc, <BR>
_tlid, <BR>
_wVerMajor, <BR>
_wVerMinor); <BR>
else <BR>
return AfxOleUnregisterClass(m_clsid, m_lpszProgID); <BR>
}</TT></FONT></P>
<P>You can now compile and register the control you've created, but it won't be of
much use because it doesn't contain methods, properties, or events, which are the
basis of every ActiveX Control.
<H2><A NAME="Heading5"></A>Creating Methods</H2>
<P>Now that you've successfully created your ActiveX control project, you can start
off by adding a <I>method, </I>which is one of the basic aspects of component development.</P>
<P>For the purposes of the sample control, you are going to add a method called <TT>CaptionMethod</TT>.
The method will accept two parameters, the second one being optional. The first parameter
is a string that the control will display within its client area, and the second,
optional parameter is the alignment of the caption within the client area, either
left, right, or center. From the <U>V</U>iew menu, select Class<U>W</U>izard, and
in the MFC ClassWizard dialog (see fig. 6.7), select the Automation tab. <B><BR>
<BR>
</B><A HREF="art/06/f_fig07.jpg"><B>FIG. 6.7</B></A> <BR>
<I>Adding a method is done through the MFC ClassWizard.</I></P>
<P>From the Class <U>N</U>ame drop-down list box, select the <TT>CMFCControlWinCtrl</TT>
class, and click the <U>A</U>dd Method button to create a new method. Type CaptionMethod
in the <U>E</U>xternal Name combo box (see fig. 6.8), and set the Return <U>t</U>ype
to a <TT>long</TT>. Add two parameters--by clicking the appropriate column in the
<U>P</U>arameter List control--the first called <TT>lpctstrCaption</TT> of type <TT>LPCTSTR</TT>,
and the second, as your optional parameter, called <TT>varAlignment</TT> of type
<TT>VARIANT</TT>. Click OK to add the method to the class. Next click OK to close
the ClassWizard dialog. <BR>
<BR>
<A HREF="art/06/f_fig08.jpg"><B>FIG. 6.8</B></A> <I><BR>
Add the <TT>CaptionMethod</TT> method to the control class.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> All optional parameters must be of type <TT>VARIANT</TT>, and they
	must fall at the end of the parameter list. Optional parameters are not managed in
	any way by OLE. It is the server application's responsibility to determine whether
	the <TT>VARIANT</TT> parameter passed to the method contains data and

	<UL>
	<LI>to either use the data passed to the method or convert the data to a useful type,
	if possible, or
	<P>
	<LI>to ignore the parameter if invalid data was passed and use the default value
	if appropriate, or
	<P>
	<LI>to inform the user of an error condition if one of the above conditions was not
	met.
	</UL>


</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
To aid your <TT>CaptionMethod</TT> implementation, you need to add an enumeration
for all the valid alignment settings and two member variables to your class definition
(see Listing 6.2). The enumeration is included in the header file Alignmentenums.h
(see Listing 6.3). The two member variables, <TT>m_cstrCaption</TT> and <TT>m_lAlignment</TT>,
are used to store the caption string and the alignment setting while the control
is being used.</P>
<P>Note the type used for the <TT>m_lAlignment</TT> member variable. The variable
is declared as type <TT>long</TT> and not as the enumeration type because of the
data type restrictions that are imposed upon you by ActiveX Automation. Remember
that only data types that can be passed in a <TT>VARIANT</TT> can be used in methods
and properties. By declaring the <TT>m_lAlignment</TT> member as <TT>long</TT>, you
do not have to explicitly convert the value by casting to the enumerated type when
it is retrieved from the <TT>VARIANT</TT> parameter in the caption method. On the
other hand, casting the value to the enumerated type is a trivial issue and is completely
up to you to implement if you desire to do so.
<H3><A NAME="Heading6"></A>Listing 6.2 MFCCONTROLWINCTL.H--Alignment Enumeration
Include File and Member Variables Added to Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// MFCControlWinCtl.h : Declaration oftheCMFCControlWinCtrlActiveXControl <BR>
#include &quot;alignmentenums.h&quot; <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// CMFCControlWinCtrl : See MFCControlWinCtl.cpp for implementation. <BR>
class CMFCControlWinCtrl : public COleControl <BR>
{ <BR>
. . . <BR>
protected: <BR>
// storage variable for the caption <BR>
CString m_cstrCaption; <BR>
// storage variable for the alignment <BR>
long m_lAlignment; <BR>
}; <BR>
<BR>
. . . </TT></FONT></P>
<P>The enumeration is added as an include file (see Listing 6.3) so that it can be
referenced by other files, which will be necessary as you proceed through the chapter.
<H3><A NAME="Heading7"></A>Listing 6.3 ALIGNMENTENUMS.H--Alignment Enumeration Include
File</H3>
<P><FONT COLOR="#0066FF"><TT>#if !defined _ALIGNMENTENUMS_H <BR>
#define _ALIGNMENTENUMS_H <BR>
// caption alignment enumeration <BR>
typedef enum tagAlignmentEnum <BR>
{ <BR>
EALIGN_LEFT = 0, <BR>
EALIGN_CENTER = 1, <BR>
EALIGN_RIGHT = 2, <BR>
}EALIGNMENT; <BR>
<BR>
#endif // #if !defined _ALIGNMENTENUMS_H </TT></FONT></P>
<P>Open the MFCCOntrolWinCtl.cpp file, and in the constructor initialize the <TT>m_Alignment</TT>
member variable to the value <TT>EALIGN_LEFT</TT> (see Listing 6.4).
<H3><A NAME="Heading8"></A>Listing 6.4 MFCCONTROLWINCTL.CPP--Initialize the m_lAlignment
Member Variable in the Class Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CMFCControlWinCtrl::CMFCControlWinCtrl - Constructor <BR>
CMFCControlWinCtrl::CMFCControlWinCtrl() <BR>
{ <BR>
InitializeIIDs(&amp;IID_DMFCControlWin, &amp;IID_DMFCControlWinEvents); <BR>
m_lReadyState = READYSTATE_LOADING; <BR>
// TODO: Call InternalSetReadyState when the readystate changes. <BR>
// set the alignment to the default of left <BR>
m_lAlignment = EALIGN_LEFT; <BR>
} </TT></FONT></P>
<P>The <TT>CaptionMethod</TT> contains all of the code for setting the caption and
the alignment style (see Listing 6.5) and does several things of interest that need
to be pointed out.</P>
<P>First the method tries to deal with the optional parameter by looking for the
data type you really want, <TT>VT_I4</TT>, which is a data type of <TT>long</TT>.</P>
<P>If the <TT>VARIANT</TT> parameter doesn't contain a <TT>long</TT>, the method
then checks to see if any data was passed at all, by checking for <TT>VT_ERROR</TT>
or <TT>VT_EMPTY</TT>. This is necessary because the parameter is optional. A variant
parameter can either contain data or not. It is important to check <TT>VARIANT</TT>
data types not only for valid data but also for the actual existence of data. If
no data was supplied, the method relies on the value already contained in the <TT>m_lAligmnent</TT>
class member variable. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>Automation Controllers and Optional Parameters</B><BR>
	Some automation controllers, such as Visual Basic, do not require that any or all
	of the optional parameters be supplied when calling a method, for example, the <TT>CaptionMethod</TT>
	can be called as

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<PRE><FONT COLOR="#0066FF">MyObject.CaptionMethod &quot;Hello&quot;</FONT></PRE>
	<P>or

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<PRE><FONT COLOR="#0066FF">MyObject.CaptionMethod &quot;Hello&quot;, True</FONT></PRE>
	<P>from Visual Basic. Visual Basic automatically passes in a<TT>VARIANT</TT> set
	to the type <TT>VT_ERROR</TT> for any parameters that are omitted from a method call.
	For automation controllers that call the standard OLE <TT>Invoke</TT> method, such
	as C++, all the parameters <I>must</I> be defined, even though they may not be used.
	In this case, when calling the method, the programmer has the option of setting the
	<TT>VARIANT</TT> type to <TT>VT_ERROR</TT> or <TT>VT_EMPTY</TT>.

</BLOCKQUOTE>


<DL>
	<DL>
		<DT>When processing optional parameters, relying on the OLE <TT>VARIANT</TT> conversion
		routines in addition to looking for specific <TT>VARIANT</TT> data types guarantees
		that your control can handle any data passed to it.</DT>
	</DL>
</DL>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
If the <TT>VARIANT</TT> is of a valid data type other than <TT>VT_I4</TT>, the method
tries to convert it to a <TT>VT_I4</TT> type. This is for cases where a user passes
valid data in the form of a different data type, for example, a short or a string.</P>
<P>One thing to note is the use of the function <TT>VariantInit</TT>. It is very
important that <I>all</I> <TT>VARIANT</TT> variables be initialized prior to their
use. This practice will guarantee that the <TT>VARIANT</TT> does not contain invalid
data type information or invalid values. This follows the basic C++ tenet of initializing
all member variables to ensure that they do not contain invalid information.</P>
<P>If the requirements of your control demand that you deal with only specific data
types, you can also add code (error messages, exceptions, and so on) to deal with
the fact that the method did not receive a valid data type. If the function <TT>VariantChangeType</TT>
was unable to convert the data, the method exits and returns a value of <TT>FALSE</TT>.
A<TT> </TT>return of<TT> FALSE</TT> indicates to the caller of the method that the
method didn't succeed. Again, you can add additional error handling code to the method
to give the user more information about the error that occurred. See <A HREF="ch03.htm">Chapters
3</A> through <A HREF="ch05.htm">5</A> on generating OLE exceptions for more information.</P>
<P>Before proceeding, the method ensures that the <TT>m_lAlignment</TT> member variable
contains valid data.</P>
<P>If the method received valid data, or converted the data to a valid value, as
indicated by the variable <TT>lResult</TT> equaling <TT>TRUE</TT>, it stores the
caption and the alignment values in the class member variables, invalidates the control
so it will redraw its User Interface (UI) based on the new information, and exits
the function.
<H3><A NAME="Heading9"></A>Listing 6.5 MFCCONTROLWINCTL.CPP--CaptionMethod Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>long CMFCControlWinCtrl::CaptionMethod(LPCTSTR lpctstrCaption,
const VARIANT FAR&amp; varAlignment) <BR>
{ <BR>
// return value initialized to failure result <BR>
long lResult = FALSE; <BR>
// if the variant is a long just use the value <BR>
if(VT_I4 == varAlignment.vt) <BR>
{ <BR>
// assign the value to our member variable <BR>
m_lAlignment = varAlignment.lVal; <BR>
// set the return value <BR>
lResult = TRUE; <BR>
} <BR>
// if the user didn't supply an alignment parameter we will use whatever is already
there <BR>
else if(VT_ERROR == varAlignment.vt || VT_EMPTY == varAlignment.vt) <BR>
{ <BR>
// set the return value <BR>
lResult = TRUE; <BR>
} <BR>
else <BR>
{ <BR>
// get a variant that we can use for conversion purposes <BR>
VARIANT varConvertedValue; <BR>
// initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); <BR>
// see if we can convert the data type to something useful - VariantChangeTypeEx()
could also be used <BR>
if(S_OK == ::VariantChangeType(&amp;varConvertedValue, (VARIANT *) &amp;varAlignment,
0, VT_I4)) <BR>
{ <BR>
// assign the value to our member variable <BR>
switch(varConvertedValue.lVal) <BR>
{ <BR>
case EALIGN_CENTER: <BR>
m_lAlignment = EALIGN_CENTER; <BR>
break; <BR>
case EALIGN_RIGHT: <BR>
m_lAlignment = EALIGN_RIGHT; <BR>
break; <BR>
default: <BR>
m_lAlignment = EALIGN_LEFT; <BR>
break; <BR>
} <BR>
// set the return value <BR>
lResult = TRUE; <BR>
} <BR>
else <BR>
{ <BR>
// at this point we could either throw an error indicating there was a problem converting
<BR>
// the data or change the return type of the method and return the HRESULT value
from the <BR>
// the &quot;VariantChangeType&quot; call. <BR>
} <BR>
} <BR>
// if the alignment value is invalid <BR>
if(m_lAlignment &lt; EALIGN_LEFT || m_lAlignment &gt; EALIGN_RIGHT) <BR>
// set to the default value <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// if everything was OK <BR>
if(TRUE == lResult) <BR>
{ <BR>
// if we have a string <BR>
if(lpctstrCaption != NULL) <BR>
// assign the string to our member variable <BR>
m_cstrCaption = lpctstrCaption; <BR>
<BR>
// did they pass us bad data? <BR>
if(m_lAlignment &lt; EALIGN_LEFT || m_lAlignment &gt; EALIGN_RIGHT) <BR>
// sure did, lets fix their little red wagon <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// force the control to repaint itself <BR>
this-&gt;InvalidateControl(); <BR>
} <BR>
// return the result of the function call <BR>
return lResult; <BR>
} </TT></FONT></P>
<P>To complete your implementation of the <TT>CaptionMethod</TT>, you need to modify
the ODL file. When methods, properties, and events are added to a class with the
ControlWizard, the ODL file is also updated with the new entries. The ODL file is
compiled into a type library, which is essentially a description of the component
and its interfaces that can be used by other applications to access the component.
You need to add the keyword <TT>[optional]</TT> to the last parameter in the <TT>CaptionMethod</TT>
as in Listing 6.6. Doing so lets the container application know that the last parameter
is optional and should be dealt with accordingly. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Take care when modifying the ODL file by hand. The ODL file must
	match your implemen- tation exactly. If the file is changed incorrectly, it can introduce
	strange bugs and/or implementation problems with your component. <BR>
	<BR>
	The ClassWizard automatically updates the ODL file when methods, properties, and
	events are added or removed. Adding or removing information from the ODL could prevent
	the ClassWizard from correctly managing the file. <BR>
	<BR>
	Keywords such as <TT>[optional]</TT> do not affect the ClassWizard and its capability
	to automatically update the file when changes are made to a class.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading10"></A>Listing 6.6 MFCCONTROL.ODL--Keyword [optional] Added
to the CaptionMethod ODL Definition</H3>
<P><FONT COLOR="#0066FF"><TT>methods: <BR>
// NOTE - ClassWizard will maintain method information here. <BR>
// Use extreme caution when editing this section. <BR>
//{{AFX_ODL_METHOD(CMFCControlWinCtrl) <BR>
[id(1)] long CaptionMethod(BSTR lpctstrCaption, [optional] VARIANT varAlignment);
<BR>
//}}AFX_ODL_METHOD </TT></FONT></P>
<H2><A NAME="Heading11"></A>Properties</H2>
<P><I>Properties</I> can be categorized as user defined, stock, or ambient.</P>
<P><I>User defined properties</I> are properties that are implementation-specific
and have meaning only to the component that contains them. User defined properties
can be further broken into those properties that are defined only as their specific
data type (<I>normal</I> properties) and those with additional parameters (<I>parameterized</I>
properties).</P>
<P><I>Stock properties</I> are a set of properties that are already defined by OLE
in terms of the basic meaning. Stock properties are not implemented in the control
of the container by default. They still require implementation by the control developer.
They are predefined only to imply a certain level of uniformity between various control
implementations.</P>
<P><I>Ambient properties,</I> on the other hand, are properties that are supported
by the container to provide a default value to the control that uses them.</P>
<P>In the remainder of the chapter, you will create three types of properties: normal,
parameterized, and stock. You will also learn how to use ambient properties.
<H3><A NAME="Heading12"></A>Creating Normal User Defined Properties</H3>
<P>A <I>normal property</I> is a property that is declared as a single type, for
example, <TT>long</TT> or <TT>BSTR</TT>, and has no parameters. You will expose your
controls' Alignment member variable through a property.</P>
<P>Properties are added in much the same way as methods. Open the ClassWizard, select
the class <TT>CMFCControlWinCtrl</TT>, switch to the Automation tab, and click the
Add P<U>r</U>operty button.</P>
<P>In the Add Property dialog (see fig. 6.9), set the <U>E</U>xternal name to <TT>Alignment</TT>,
the <U>T</U>ype to <TT>long</TT>, and the Implementation to <TT>Get/Set</TT> <U>m</U>ethods.
Click OK to confirm the entry and close the dialog. <B><BR>
<BR>
</B><A HREF="art/06/f_fig09.jpg"><B>FIG. 6.9</B></A> <BR>
<I>Add the Alignment property to the Class Definition.</I></P>
<P>Double-click the <TT>Alignment</TT> property entry in the <U>E</U>xternal name
list box to open the source file so you can add your code to the <TT>Get/Set</TT>
<U>m</U>ethods.</P>
<P>As you can see, Listing 6.7 takes advantage of the member variable <TT>m_Alignment</TT><I>,
</I>which you added earlier, and uses it to get and set the property value.</P>
<P>The <TT>GetAlignment</TT> function is simple in that it returns only the value
stored in the <TT>m_lAlignment</TT> member variable.</P>
<P>The <TT>SetAlignment</TT> function does a little more. This function checks to
see if the value is within the valid ranges of values and, if so, stores the value
in the <TT>m_lAlignment</TT> member variable. The function then calls the <TT>SetModifiedFlag</TT>
and the <TT>BoundPropertyChanged</TT> functions to notify the control and the container,
respectively, that the value of the property has changed. <TT>BoundPropertyChanged</TT>
has the effect of forcing the container to refresh its property browser to reflect
the new value. This is very important because the value of the property could change
without the container's knowledge, either through the control's property sheet or,
in some cases, in response to another function call. You might be asking yourself,
&quot;Why didn't I add <TT>BoundPropertyChanged</TT> to the <TT>CaptionMethod</TT>?&quot;
Well, you could have, but it wouldn't do much because the <TT>CaptionMethod</TT>
can never be executed while the control is in design mode, which is the purpose of
<TT>BoundPropertyChanged</TT>.</P>
<P>The last thing the <TT>SetAlignment</TT> method does is invalidate the control's
UI so it will repaint using the new information. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Even though a property appears as a single member of an object, it
	is really a pair of related functions used to operate on a single piece of data.
	The ODL entries for a property will differ depending on its implementation. <BR>
	<BR>
	For interfaces inherited from a <TT>dispinterface</TT> class, it is enough to have
	a single entry in the properties section of the class. <TT>IDispatch</TT> inherited
	interfaces will define two separate functions: one declared as <TT>propertyget</TT>,
	and the other defined as <TT>propertyput</TT>, both sharing the same dispid. Parameterized
	properties are always defined by using the latter method because it is impossible
	to define the additional parameters without a method declaration. <BR>
	<BR>
	The <TT>dispinterface</TT> keyword is a specific convention for defining <TT>IDispatch</TT>-based
	interfaces in a more C++-like fashion, as opposed to the standard <TT>IDispatch</TT>
	style, which would be entered as one variable entry versus two method entries. For
	more information regarding the use of <TT>dispinterface</TT> and other ODL keywords,
	see the ODL documentation provided with the VC++ compiler.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading13"></A>Listing 6.7 MFCCONTROLWINCTL.CPP--Alignment Property
Get/Set Method Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>long CMFCControlWinCtrl::GetAlignment() <BR>
{ <BR>
// return our current setting <BR>
return m_lAlignment; <BR>
} <BR>
void CMFCControlWinCtrl::SetAlignment(long nNewValue) <BR>
{ <BR>
// if we are in the valid range for the property <BR>
if(nNewValue &gt;= EALIGN_LEFT &amp;&amp; nNewValue &lt;= EALIGN_RIGHT) <BR>
{ <BR>
// set the new property value <BR>
m_lAlignment = nNewValue; <BR>
// let the control know that the property has changed <BR>
this-&gt;SetModifiedFlag(); <BR>
// refresh the property browser <BR>
this-&gt;BoundPropertyChanged(dispidAlignment); <BR>
// redraw the control <BR>
this-&gt;InvalidateControl(); <BR>
} <BR>
} </TT></FONT></P>
<P>MFC and the ClassWizard provide another option when declaring properties-- that
is, by member variable. MFC will add a member variable of the appropriate type to
the class declaration and will provide a notification function if the data changes.
The notification message is defined as <TT>Onvariable</TT><I>_</I><TT>nameChanged</TT>
and is added to the source file of the control. If you had chosen this method for
the <TT>Alignment</TT> member, the function would have been called <TT>OnAlignmentChanged</TT>
and would have been implemented in the MFCControlWinCtl.cpp file. The variable style
results in less code to write, but it also results in less flexibility because MFC
manages all of the <TT>Get/Set</TT> property code for you. Feel free to experiment
with both methods of property creation to get a feel for your best option.
<H3><A NAME="Heading14"></A>Creating Parameterized User Defined Properties</H3>
<P>A <I>parameterized property</I> is a property that, in addition to being of a
specific type (for example, <TT>BSTR</TT> or <TT>long</TT>), accepts one or more
additional parameters to further define the data of the property. Parameterized properties
can be useful for properties that represent collections of data where the additional
parameter is the index into the collection.</P>
<P>You are going to expose the controls <TT>m_cstrCaption</TT> member variable as
a parameterized property in addition to your <TT>CaptionMethod</TT> function.</P>
<P>In the Add Property dialog (see fig. 6.10), define the <U>E</U>xternal name as
<TT>CaptionProp</TT>, its <U>T</U>ype as <TT>BSTR</TT>, and its Implementation as
<TT>Get/Set</TT> <U>m</U>ethods. In addition, add a parameter called <TT>varAlignment</TT>
of type <TT>VARIANT</TT> to the <U>P</U>arameter list box. Click OK to add the property
to the class. Close the ClassWizard so you can add some code to your property. <BR>
<BR>
<A HREF="art/06/f_fig10.jpg"><B>FIG. 6.10</B></A> <I><BR>
Add the Caption property with the Add Property dialog.</I></P>
<P>The implementation of the property <TT>CaptionProp</TT> has two methods: <TT>GetCaptionProp</TT>
and <TT>SetCaptionProp</TT>.</P>
<P><TT>GetCaptionProp</TT> is the method that is called to return data from the property.
In your implementation, you ignore the alignment parameter because it is of no use
to you in this context; you simply return the caption (see Listing 6.8). <TT>GetCaptionProp</TT>
uses the <TT>CString</TT> function <TT>AllocSysString</TT> to create a <TT>BSTR</TT>,
which is essentially a UNICODE string, that is returned from the function call.
<H3><A NAME="Heading15"></A>Listing 6.8 MFCCONTROLWINCTL.CPP--GetCaptionProp Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BSTR CMFCControlWinCtrl::GetCaptionProp(const VARIANT
FAR&amp; varAlignment) <BR>
{ <BR>
// return the caption as a BSTR <BR>
return m_cstrCaption.AllocSysString(); <BR>
} </TT></FONT></P>
<P><TT>SetCaptionProp</TT> simply defers to the <TT>CaptionMethod</TT> implementation
because the <TT>CaptionMethod</TT> already does everything that you need (see Listing
6.9).
<H3><A NAME="Heading16"></A>Listing 6.9 MFCCONTROLWINCTL.CPP--SetCaptionProp Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::SetCaptionProp(const VARIANT
FAR&amp; varAlignment, LPCTSTR lpszNewValue) <BR>
{ <BR>
// use the &quot;CaptionMethod&quot; implementation <BR>
if(TRUE == this-&gt;CaptionMethod(lpszNewValue, varAlignment)) <BR>
// let the container know that the property has changed <BR>
this-&gt;SetModifiedFlag(); <BR>
} </TT></FONT></P>
<P>Your final detail is the ODL file (see Listing 6.10). You are going to make the
<TT>VARIANT</TT>, <TT>varAlignment</TT>, an optional parameter for the <TT>GetCaptionProp</TT>
and <TT>SetCaptionProp </TT>implementations. You can make the <TT>varAlignment</TT>
parameter optional for the <TT>SetCaptionProp</TT> implementation because the <TT>varAlignment</TT>
variable is the last in the list of actual parameters. The <TT>BSTR lpszNewValue</TT>
variable is actually the data type of the property function pairs and does not affect
the parameter definition rules.
<H3><A NAME="Heading17"></A>Listing 6.10 MFCCONTROL.ODL--[optional] Keyword Added
to the ODL File</H3>
<P><FONT COLOR="#0066FF"><TT>methods: <BR>
// NOTE - ClassWizard will maintain method information here. // Use extreme caution
when editing this section. <BR>
//{{AFX_ODL_METHOD(CMFCControlWinCtrl) <BR>
[id(2)] long CaptionMethod(BSTR lpctstrCaption, [optional] VARIANT varAlignment);
<BR>
[id(3), propget] BSTR CaptionProp([optional] VARIANT varAlignment); <BR>
[id(3), propput] void CaptionProp([optional] VARIANT varAlignment, BSTR lpszNewValue);
<BR>
//}}AFX_ODL_METHOD</TT></FONT></P>
<PRE><FONT COLOR="#0066FF"><TT></TT></FONT></PRE>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Because of the parameters they contain, parameterized properties
	are defined in the methods section of the <TT>dispinterface</TT> declaration of an
	object. All properties are implemented using the dual method style in <TT>IDispatch</TT>-based
	interfaces regardless of whether the property is parameterized or not. Only <TT>dispinterfaces</TT>
	contain a separate property and method section in the ODL. And only <TT>dispinterfaces</TT>
	allow for properties to be declared as a single line entry in the ODL file.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading18"></A>Creating Stock Properties</H3>
<P>A <I>stock property</I> is a property that is understood by both a control and
its container and that has a predefined meaning to both. Stock properties are intended
to provide basic uniform functionality to all the controls and containers that implement
them. Stock properties do not require you to implement a lot of code; you just hook
into the existing property.</P>
<P>Adding stock properties is similar to adding user defined properties. Open the
ClassWizard, select the Automation tab, select the class <TT>CMFCControlWinCtrl</TT>,
and click the Add P<U>r</U>operty button. Instead of typing an <U>E</U>xternal name
this time, you select one from the list provided. Your stock property will be the
<TT>BackColor</TT> property (see fig. 6.11). Select the Stoc<U>k</U> Implementation,
and click OK to add the property to the class. <BR>
<BR>
<A HREF="art/06/f_fig11.jpg"><B>FIG. 6.11</B></A> <BR>
<I>Add <TT>BackColor</TT> stock property to the class definition.</I></P>
<P>That's all there is to it. The <TT>BackColor</TT> property now appears in your
property list and will persist with all your other properties. Whenever you need
the value of a stock property, you can query the container for the property with
one of the stock property functions. In your case, you will use the function <TT>GetBackColor</TT>.
All of the stock properties have an associated <TT>Get/Set</TT> function pair. See
the MFC documentation for more information.</P>
<P>In addition to the default stock implementation style, you can support a member
variable implementation. This option eliminates the need to query the container for
the property but forces you to carry the value with you at all times, adding to your
instance size.</P>
<P>You can also support the <TT>Get/Set</TT> implementation method and store or use
the value in anyway you see fit, but this option also requires additional code.</P>
<P>The default stock implementation is obviously the easiest because MFC does all
the work for you.
<H3><A NAME="Heading19"></A>Using Ambient Properties</H3>
<P><I>Ambient properties</I> are properties implemented in the container in which
the control resides, as opposed to <I>stock properties, </I>which are implemented
in the control and not the container. Ambient properties share the same set of predefined
meanings and dispids as those of stock properties. A <I>dispid</I> is the unique
identifier that is used to identify the property within an interface. To use an ambient
property, the control need request only the property value from the container and
apply it in whatever manner is appropriate for the property type. The use of ambient
properties allows the control to conform to the same settings as those of the container
in which it resides. This provides much better integration between the control and
its container.</P>
<P>Take the previous example of adding the <TT>BackColor</TT> stock property to the
sample control implementation. Defined as a stock property, the user of the control
can change the background color of the control or leave it as is. If the color is
different from that of the container or if the container's background color changes
for some reason, the colors won't match, giving the appearance of a poorly integrated
and written application. However, if the control simply used the ambient background
color of its container, the control's background will always match that of the container.
The specific requirements of your control implementation will decide which route
you choose when implementing the properties your control supports.</P>
<P>To access an ambient property, you can call one of the many ambient property functions
defined in the <TT>COleContro</TT>l class, for example, <TT>AmbientBackColor()</TT>,
or use the function</P>
<P><FONT COLOR="#0066FF"><TT>this-&gt;GetAmbientProperty(DISPID_BACKCOLOR, VT_COLOR,
&amp;varBackColor);</TT></FONT></P>
<P>to access the value. The <TT>GetAmbientProperty()</TT> function takes a dispid
as its first parameter. The dispid must be one of those defined by MFC. A complete
list of dispids can be found in the MFC source files. The second parameter is the
<TT>VARIANT</TT> data type that is being requested, and the third parameter is a
<TT>VARIANT</TT> variable into which the data is stored.
<H3><A NAME="Heading20"></A>Creating Property Sheets</H3>
<P>Property sheets are a way for a control to display its properties for review and
editing and are typically implemented in a tabbed dialog format. The original intent
of property sheets was for use in cases when a control container did not support
property browsing facilities. While property sheets have their purpose, they are
probably not necessary for all implementations.</P>
<P>Removing the property sheets from your control implementation definitely reduces
the size of your control and does not take away from its implementation.</P>
<P>Because property sheets are tabbed dialogs, most of your work will be done with
the dialog editor and the ClassWizard. Select the Resource View in the Project Workspace
window. From the list of dialogs, select <TT>IDD_PROPPAGE_MFCCONTROLWIN</TT>, and
double-click the entry to open the resource editor.</P>
<P>Using the resource editor, remove the static text control with the caption TODO,
and place a static text control and a combo box control on the dialog (see fig. 6.12).
<B><BR>
<BR>
</B><A HREF="art/06/f_fig12.jpg"><B>FIG. 6.12</B></A> <I><BR>
Use the resource editor to add controls to the Property Sheet dialog.</I></P>
<P>Using the mouse, select the label control on the form, and click the right mouse
button. In the menu that appears, select the Properties menu item. On the General
tab, set the <U>I</U>D of the control to <TT>IDC_ALIGNMENTLABEL</TT> and set the
<U>C</U>aption to <TT>Alignment</TT>. Select the Styles tab and set the Align Te<U>x</U>t
property to <TT>Right</TT>. Close the dialog to save the information.</P>
<P>Again, using the mouse, select the combo box, use the right mouse to click on
the control, and in the menu that appears, select the Properties menu item.</P>
<P>On the General tab, set the <U>I</U>D of the control to <TT>IDC_ALIGNMENTCOMBO</TT>.</P>
<P>On the Styles tab, set the T_ype to drop-down list box, and uncheck the S<U>o</U>rt
check box. Close the dialog to save the information.</P>
<P>You have placed your two controls onto the property sheets and successfully modified
their properties. Now you need to add some code to complete the implementation. Close
the resource editor, and open the ClassWizard. Select the <TT>CMFCControlWinPropPage</TT>
class, and select the Member Variables tab. In the Control ID's combo box, select
<TT>IDC_ALIGNMENTCOMBO</TT>, and click the Add Variable button.</P>
<P>In the Add Member Variable dialog (see fig. 6.13), set the Member variable <U>n</U>ame
to <TT>m_AlignmentCombo</TT> and the <U>C</U>ategory to <TT>Control</TT>. Click OK
to confirm the information, and close the dialog. <BR>
<BR>
<A HREF="art/06/f_fig13.jpg"><B>FIG. 6.13</B></A> <I><BR>
Add the<TT> m_AlignmentCombo</TT> member variable to the class definition.</I></P>
<P>You've added a member variable for the control. Now you add one for the data.
Click the Add Variable button again, and set the Member variable <U>n</U>ame to <TT>m_AlignmentValue</TT>
(see fig. 6.14). Set the <U>C</U>ategory to <TT>Value</TT> and the Variable <U>t</U>ype
to <TT>int</TT>. Click OK to confirm the changes, and close the dialog. <B><BR>
<BR>
</B><A HREF="art/06/f_fig14.jpg"><B>FIG. 6.14</B></A> <I><BR>
Add the <TT>m_AlignmentValue</TT> member variable to the class definition.</I></P>
<P>Close the MFC ClassWizard dialog to confirm the new member variables. <TT>DoDataExchange</TT>
is where you are going to add the code to manage the data between the control and
the property sheet. Open the source file MFCControlWinPpg.cpp, and locate the <TT>DoDataExchange</TT>
function. Notice that the ClassWizard added two lines of code to the original implementation
of <TT>DoDataExchange</TT> (see Listing 6.11).
<H3><A NAME="Heading21"></A>Listing 6.11 MFCCONTROLWINPPG.CPP--New Member Variables
Added to the DoDataExchange Function</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinPropPage::DoDataExchange(CDataExchange*
pDX) <BR>
{ <BR>
//{{AFX_DATA_MAP(CMFCControlWinPropPage) <BR>
DDX_Control(pDX, IDC_ALIGNMENTCOMBO, m_AlignmentCombo); <BR>
DDX_CBIndex(pDX, IDC_ALIGNMENTCOMBO, m_AlignmentValue); <BR>
//}}AFX_DATA_MAP <BR>
DDP_PostProcessing(pDX); <BR>
} </TT></FONT></P>
<P><TT>DDX_Control</TT> is the standard MFC macro for loading a control into an MFC
class member. <TT>DDX_CBIndex</TT> is a standard MFC function for getting and setting
the current index in a combo box using the variable supplied, in this case <TT>m_AlignmentValue</TT>.
You need to change this implementation slightly to fully bind your control and property
sheet (see Listing 6.12).</P>
<P>First you load the combo box with valid property data so that the property sheet
matches the property values in the control and the property browser. The function
loads the combo box with only the valid choices if the <TT>DoDataExchange</TT> function
is being executed the first time by checking the <TT>m_bSaveAndValidate</TT> member
variable; in other words, the property dialog is not saving and validating the data
it contains.</P>
<P>To support communication between the control and the property sheet, you need
to add <TT>DDP_CBIndex</TT> before the <TT>DDX_CBIndex</TT> line. <TT>DDP_CBIndex</TT>
instructs MFC to obtain the <TT>Alignment</TT> property value from the control and
store it in the <TT>m_lAlignment</TT> member variable of the property dialog when
the dialog is loading. When the property dialog is unloading, <TT>DDP_CBIndex</TT>
retrieves the current index of the combo box and sets the <TT>Alignment</TT> property
of the control to the new value. <TT>DDP_CBIndex</TT> must be before the <TT>DDX_CBIndex</TT>
function; otherwise, the property sheet will not correctly reflect the values of
the properties in the control. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Because of the specific implementation requirements of this property
	dialog (that is, the list box control is being loaded into the member variable, <TT>m_AlignmentCombo</TT>,
	of the class, and it is necessary to load the combo box selection list prior to setting
	the current selected entry in the list), the <TT>DDP_CBIndex</TT> and <TT>DDX_CBIndex</TT>
	lines had to be removed from between the MFC <TT>AFX_DATA_MAP</TT> macros to allow
	the setting of the entries to occur. Separating the lines in this fashion is not
	required in order to implement the <TT>DDX_CBIndex</TT> and <TT>DDP_CBIndex</TT>
	lines. It is, however, the only way to solve this particular problem. <BR>
	<BR>
	When the <TT>DDX_CBIndex</TT> and <TT>DDPCBIndex</TT> lines are removed from between
	the MFC macros, they no longer appear as a member variable in the ClassWizard and
	are not managed automatically by VC++ and the ClassWizard.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading22"></A>Listing 6.12 MFCCONTROLWINPPG.CPP--Updated DoDataExchange
Function; Alignment Enumeration Added</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinPropPage::DoDataExchange(CDataExchange*
pDX) <BR>
{ <BR>
//{{AFX_DATA_MAP(CMFCControlWinPropPage) <BR>
DDX_Control(pDX, IDC_ALIGNMENTCOMBO, m_AlignmentCombo); <BR>
//}}AFX_DATA_MAP <BR>
if(!pDX-&gt;m_bSaveAndValidate) <BR>
{ <BR>
// make sure that we have cleared the list <BR>
m_AlignmentCombo.ResetContent(); <BR>
m_AlignmentCombo.AddString(_T(&quot;Left&quot;)); <BR>
m_AlignmentCombo.AddString(_T(&quot;Center&quot;)); <BR>
m_AlignmentCombo.AddString(_T(&quot;Right&quot;)); <BR>
} <BR>
DDP_CBIndex(pDX, IDC_ALIGNMENTCOMBO, m_AlignmentValue, _T(&quot;Alignment&quot;));
<BR>
DDX_CBIndex(pDX, IDC_ALIGNMENTCOMBO, m_AlignmentValue); <BR>
DDP_PostProcessing(pDX); <BR>
this-&gt;SetModifiedFlag(); <BR>
} </TT></FONT></P>
<P>As was pointed out earlier in this chapter, in order for the property browser
within the IDE (for example, Microsoft Visual Basic's property list window) to accurately
reflect the property value after it has been changed by the Property Sheet, you must
add a <TT>BoundPropertyChanged</TT> call to your <TT>SetAlignment</TT> function (see
Listing 6.13). This action notifies the property browser that the value has changed
and that it should be retrieved again.
<H3><A NAME="Heading23"></A>Listing 6.13 MFCCONTROLWINCTL.CPP--BoundPropertyChanged
Function within the SetAlignment Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::SetAlignment(long nNewValue)
<BR>
{ <BR>
// if we are in the valid range for the property <BR>
if(nNewValue &gt;= EALIGN_LEFT &amp;&amp; nNewValue &lt;= EALIGN_RIGHT) <BR>
{ <BR>
// set the new property value <BR>
m_lAlignment = nNewValue; <BR>
// let the control know that the property has changed <BR>
this-&gt;SetModifiedFlag(); <BR>
// refresh the property browser <BR>
this-&gt;BoundPropertyChanged(dispidAlignment); <BR>
// redraw the control <BR>
this-&gt;InvalidateControl(); <BR>
} <BR>
} </TT></FONT></P>
<P>The only thing remaining is to set the default value of the member variable <TT>m_AlignmentValue</TT>
to a meaningful value (see Listing 6.14). Add the include file entry</P>
<P><FONT COLOR="#0066FF"><TT>#include :MFCControlWinCtl.h&quot;</TT></FONT></P>
<P>to the source file to resolve the <TT>EALIGN_LEFT</TT> constant. Initialize the
<TT>m_AlignmentValue</TT> member variable in the constructor to a value of <TT>EALIGN_LEFT</TT>.
<H3><A NAME="Heading24"></A>Listing 6.14 MFCCONTROLWINPPG.CPP--m_AlignmentValue Class
Member Initialized in the Class Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>// MFCControlWinPpg.cpp : Implementation of the CMFCControlWinPropPage
property page class. <BR>
#include &quot;stdafx.h&quot; <BR>
#include &quot;MFCControl.h&quot; <BR>
#include &quot;MFCControlWinCtl.h&quot; <BR>
#include &quot;MFCControlWinPpg.h&quot; <BR>
. . . <BR>
CMFCControlWinPropPage::CMFCControlWinPropPage() : <BR>
COlePropertyPage(IDD, IDS_MFCCONTROLWIN_PPG_CAPTION) <BR>
{ <BR>
//{{AFX_DATA_INIT(CMFCControlWinPropPage) <BR>
m_AlignmentValue = EALIGN_LEFT; <BR>
//}}AFX_DATA_INIT <BR>
} </TT></FONT></P>
<H2><A NAME="Heading25"></A>Adding Events</H2>
<P>Properties and methods are a way for a programmer to communicate with a control
from within the container application. Events are a way for the control to communicate
with the container. For ActiveX controls, events are nothing more than <TT>IDispatch</TT>
interfaces that are implemented on the container side of the container/control relationship.
The mechanism that events are based on is known as a connection point. A <I>connection
point</I> is simply a description of the type of interface that is required in order
to communicate with the container. Connection points are not restricted to only <TT>IDispatch</TT>
interfaces, but rather they can be of any COM interface that is understood by both
components. For that matter, connection points/events are not restricted only to
controls, they can be used in any COM implementation. Controls were simply the first
to take advantage of them. For more information regarding connection points, refer
to the documentation in the OLE online help or to Kraig Brockschmidt's <I>Inside
OLE,</I> <I>Second</I> <I>Edition</I>, from Microsoft Press.</P>
<P>As with methods and properties, events are added and removed with the ClassWizard.
Open the ClassWizard, and select the ActiveX Events tab. Select the <TT>CMFCControlWinCtrl</TT>
class, and click the <U>A</U>dd Event button.</P>
<P>You can choose from a list of predefined events or add your own. You are going
to add a <TT>Change</TT> event (see fig. 6.15), and it will have two parameters.
The first parameter will be a string, passed by reference (<TT>BSTR *</TT>), called
<TT>cstrCaption</TT>. The second will be a <TT>long</TT>, also passed by reference
(<TT>long *</TT>), called <TT>lAlignment</TT>. You are passing the parameters by
reference to allow the container application the opportunity to change the values
if necessary.</P>
<P>Click OK to add the event to the class. Before you use your event, you are going
to create a common <TT>FireChange</TT> function that will encapsulate the code that
deals with the cases where the program has changed the data passed to the event.
Close the MFC ClassWizard dialog to confirm the addition of the event to the class.</P>
<P>You need to add your function prototype to the class definition in the header
file (see Listing 6.15). And you need to add the implementation to the source file
(see Listing 6.16). <B><BR>
<BR>
</B><A HREF="art/06/f_fig15.jpg"><B>FIG. 6.15</B></A> <I><BR>
Here is where you add the <TT>Change</TT> event.</I></P>
<P>
<H3><A NAME="Heading26"></A>Listing 6.15 MFCCONTROLWINCTL.H--FireChange Function
Prototype Added to the Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
protected: <BR>
// storage variable for the caption <BR>
CString m_cstrCaption; <BR>
// storage variable for the alignment <BR>
long m_lAlignment; <BR>
void FireChange(void); <BR>
}; </TT></FONT></P>
<H3><A NAME="Heading27"></A>Listing 6.16 MFCCONTROLWINCTL.CPP--FireChange Implementation
Added to the MFControlWinCtl.cpp Source File</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::FireChange(void) <BR>
{ <BR>
// get a BSTR that can be passed via the event <BR>
BSTR bstrCaption = m_cstrCaption.AllocSysString(); <BR>
// fire the change event <BR>
this-&gt;FireChange(&amp;bstrCaption, &amp;m_lAlignment); <BR>
// let's see what the user gave us <BR>
m_cstrCaption = bstrCaption; <BR>
// free the data that was passed back <BR>
::SysFreeString(bstrCaption); <BR>
} </TT></FONT></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The control is responsible for the data that is passed in to the
	event, so be sure to free the <TT>BSTR</TT> that was passed in when the function
	has returned to prevent a memory leak.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The common <TT>FireChange</TT> function allows you to hide the details surrounding
the change event from the rest of the program. If you decide in the future to change
its implementation, it will impact only one function rather than a number of them.</P>
<P>The <TT>CaptionMethod</TT> will require that you fire a Change event if the data
changes, so you will add your new event there (see Listing 6.17). You also want to
add it to the <TT>SetAlignment</TT> function, but do not add <TT>FireChange</TT>
to the <TT>SetCaptionProp</TT> function because it defers to the <TT>CaptionMethod</TT>
function. Also, do not forget to add the function to any new functions or features
that are added to the control as its implementation progresses.
<H3><A NAME="Heading28"></A>Listing 6.17 MFCCONTROWINCTL.CPP--FireChange Event Added
to the CaptionMethod Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// if everything was OK <BR>
if(TRUE == lResult) <BR>
{ <BR>
// if we have a string <BR>
if(lpctstrCaption != NULL) <BR>
// assign the string to our member variable <BR>
m_cstrCaption = lpctstrCaption; <BR>
<BR>
// did they pass us bad data? <BR>
if(m_lAlignment &lt; EALIGN_LEFT || m_lAlignment &gt; EALIGN_RIGHT) <BR>
// sure did, lets fix their little red wagon <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// fire the global change event <BR>
this-&gt;FireChange(); <BR>
// force the control to repaint itself <BR>
this-&gt;InvalidateControl(); <BR>
} <BR>
// return the result of the function call <BR>
return lResult; <BR>
} </TT></FONT></P>
<H2><A NAME="Heading29"></A>Persistence</H2>
<P><I>Persistence</I> refers to the capability of a component to retain its state
across execution lifetimes. In other words, regardless of the number of times that
the control is started and stopped, it remembers that you changed its background
color from white to mauve (even if it finds the color mauve revolting).</P>
<P>The implementation of persistence, for MFC controls, is a no-brainer consisting
of very little code. Simply add a single line to the <TT>DoPropExchange</TT> method
of your control for each one of your properties, and you are finished. You can get
a little more fancy and persist the properties differently, depending on whether
you are saving or loading the properties, but that isn't real complicated either.</P>
<P>Now modify your <TT>DoPropExchange</TT> function to persist the two properties,
<TT>m_lAlignment</TT> and <TT>m_cstrCaption</TT>. The persistence can be implemented
two ways. The first, and the simplest, is to add one entry for each property without
regard for order or dependencies. <I>Dependencies</I> refers to the fact that as
your control implementation gets more complicated or requires a larger number of
properties, you may find that how or when certain properties are persisted can depend
on other properties. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> When specifying the default value in your persistence entries, never
	use the same variable as the one that is going to receive the data. The MFC persistence
	functions are optimized so that if the value being persisted has not changed compared
	to the default value, it will not be persisted. This is to save time and space when
	loading or saving the persistence information. If you use the same variable, MFC
	will think that the value has never changed because the MFC persistence routines
	perform simple address and memory comparisons. Use constants for your default persistence
	information because that is what the routines expect.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Listing 6.18 demonstrates the simplest way to persist the properties. The same method
is used for each property regardless of the direction of the persistence; when you
are loading or saving, MFC handles all those details for you.
<H3><A NAME="Heading30"></A>Listing 6.18 MFCCONTROLWINCTL.CPP--Simple DoPropExchange
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::DoPropExchange(CPropExchange*
pPX) <BR>
{ <BR>
ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor)); <BR>
COleControl::DoPropExchange(pPX); <BR>
// TODO: Call PX_ functions for each persistent custom property. <BR>
PX_Long(pPX, _T(&quot;Alignment&quot;), m_lAlignment, EALIGN_LEFT); <BR>
PX_String(pPX, _T(&quot;CaptionProp&quot;), m_cstrCaption, _T(&quot;&quot;)); <BR>
} </TT></FONT></P>
<P>Listing 6.19 demonstrates how you would implement your persistence if you wanted
to load your properties first and then perform some implementation specific action--and
conversely when saving the properties. The requirement to specifically order the
persistence process is highly subjective and will depend greatly on your implementation.
Listing 6.19 merely demonstrates the possibility of doing so.
<H3><A NAME="Heading31"></A>Listing 6.19 MFCCONTROLWINCTL.CPP--DoPropExchange Implementation
Separated into Distinct Operations</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::DoPropExchange(CPropExchange*
pPX) <BR>
{ <BR>
ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor)); <BR>
COleControl::DoPropExchange(pPX); <BR>
// TODO: Call PX_ functions for each persistent custom property. <BR>
// if we are loading the properties <BR>
if(pPX-&gt;IsLoading()) <BR>
{ <BR>
PX_Long(pPX, _T(&quot;Alignment&quot;), m_lAlignment, EALIGN_LEFT); <BR>
PX_String(pPX, _T(&quot;CaptionProp&quot;), m_cstrCaption, _T(&quot;&quot;)); <BR>
} <BR>
// if we are saving the properties <BR>
if(!pPX-&gt;IsLoading()) <BR>
{ <BR>
PX_Long(pPX, _T(&quot;Alignment&quot;), m_lAlignment, EALIGN_LEFT); <BR>
PX_String(pPX, _T(&quot;CaptionProp&quot;), m_cstrCaption, _T(&quot;&quot;)); <BR>
} <BR>
} </TT></FONT></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> If your control contains stock properties, you must call the base
	class implementation <TT>COleControl::DoPropExchange</TT> to support their persistence.
	The base class implementation does not allow much room for flexibility, though, and
	you may find yourself in more need of control than is allowed. <BR>
	<BR>
	One option is to persist the stock properties yourself and ignore the base class
	implementation. Listing 6.20 shows what code is necessary to persist the <TT>BackColor</TT>
	property and supply a different default value. In this case, the default value is
	the system defined <TT>WindowText</TT> color and not the ambient color of the container.
	There is a minor difference between MFC versions 4.1 and 4.2 in how the stock mask
	is retrieved, but other than that, the remainder of the code is copied verbatim from
	the MFC source files and has not been altered in any way. <BR>
	<BR>
	The one major drawback to this is that you are now required to maintain your stock
	property persistence code by hand and can no longer rely on the base class implementation
	provided by MFC.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading32"></A>Listing 6.20 EXAMPLE--Example Implementation of the Code
Needed to Support Stock Property Persistence</H3>
<P><FONT COLOR="#0066FF"><TT>void CSOTABaseCtrl::DoPropExchange(CPropExchange* pPX)
<BR>
{ <BR>
// ****** Taken from &quot;void COleControl::DoPropExchange(CPropExchange* pPX)&quot;
ctlcore.cpp <BR>
// ** <BR>
ASSERT_POINTER(pPX, CPropExchange); <BR>
// ** <BR>
// ****** Taken from &quot;void COleControl::DoPropExchange(CPropExchange* pPX)&quot;
<BR>
ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor)); <BR>
// COleControl::DoPropExchange(pPX); <BR>
// ****** Taken from &quot;void COleControl::DoPropExchange(CPropExchange* pPX)&quot;
ctlcore.cpp <BR>
// ** <BR>
ExchangeExtent(pPX); <BR>
// ** <BR>
// ****** Taken from &quot;void COleControl::DoPropExchange(CPropExchange* pPX)&quot;
ctlcore.cpp <BR>
// ****** Taken from &quot;void COleControl::ExchangeStockProps(CPropExchange* pPX)&quot;
ctlprop.cpp <BR>
// ** <BR>
BOOL bLoading = pPX-&gt;IsLoading(); <BR>
// VC++ 4.2 <BR>
DWORD dwPersistMask = GetStockPropMask(); <BR>
// VC++ 4.1 <BR>
// DWORD dwPersistMask = m_dwStockPropMask; <BR>
PX_ULong(pPX, _T(&quot;_StockProps&quot;), dwPersistMask); <BR>
if (dwPersistMask &amp; STOCKPROP_BACKCOLOR) <BR>
{ <BR>
if (dwPersistMask &amp; STOCKPROP_BACKCOLOR) <BR>
PX_Color(pPX, _T(&quot;BackColor&quot;), m_clrBackColor, 0x80000000 | COLOR_WINDOW
/*AmbientBackColor()*/); <BR>
else if (bLoading) <BR>
m_clrBackColor = 0x80000000 | COLOR_WINDOW /*AmbientBackColor()*/ <BR>
} <BR>
// ** <BR>
// ****** Taken from &quot;void COleControl::ExchangeStockProps(CPropExchange* pPX)&quot;
ctlprop.cpp <BR>
</TT></FONT></P>
<H2><A NAME="Heading33"></A>Drawing the Control</H2>
<P>Most controls will have some form of UI. Although since the release of the OC
96 specification and ActiveX, that is no longer a requirement.</P>
<P>Drawing the UI of a control has long been regarded as one of the most critical
aspects of a control, in terms of both appearance and performance. A control that
flashes or flickers a lot appears poorly developed regardless of its internal implementation.
The same is true for how fast the control draws. With the advent of the Internet
and ActiveX, it is even more crucial that a control draw fast and draw well.</P>
<P>Drawing can be broken into two major categories: standard and optimized. In this
chapter, you focus only on standard drawing. <A HREF="ch07.htm">Chapter 7</A> introduces
optimized drawing.
<H3><A NAME="Heading34"></A>Standard Drawing</H3>
<P><I>Standard drawing </I>is just that: standard. You have complete freedom to draw
the control any way you see fit, using any method that is appropriate. You can use
pens and brushes, rectangles and circles. Remember that drawing <I>smart</I> is the
goal of any application with UI. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> Probably the greatest sources of flicker and flash are overlapped
	painting and unnecessary drawing--drawing areas of the control that do not need to
	be drawn. Try to draw only to the areas of the control that have been invalidated.
	Doing so will save time and will prevent annoying flash. For example, if your control
	has a white background and a black border, draw only the white portion where it is
	going to be seen. Don't draw over the border as this causes the control to flash
	every time it gets a paint message.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Before adding the <TT>OnDraw</TT> implementation to your source file, add a <TT>CBrush</TT>
member variable to the <TT>CMFCControlWinCtrl</TT> class (see Listing 6.21). The
new member variable will hold a <TT>CBrush</TT> object and will be used more fully
in the optimized drawing section you find in <A HREF="ch07.htm">Chapter 7</A>. For
now, the <TT>CBrush</TT> object will be re-created every time the <TT>OnDraw</TT>
function executes.
<H3><A NAME="Heading35"></A>Listing 6.21 MFCCONTROLWINCTL.H--CBrush Member Variable
Added to CMFCControlWinCtrl</H3>
<P><FONT COLOR="#0066FF"><TT>protected: <BR>
// storage variable for the caption <BR>
CString m_cstrCaption; <BR>
// storage variable for the alignment <BR>
long m_lAlignment; <BR>
void FireChange(void); <BR>
// brush <BR>
CBrush m_Brush; <BR>
}; </TT></FONT></P>
<P>Listing 6.22 contains the code for drawing the control. The <TT>OnDraw</TT> implementation
is fairly straightforward. Select the font into the DC, get all of the colors that
you are going to use, draw the background, draw the text, and draw the border. Then
reset everything back to the way it was when you started.
<H3><A NAME="Heading36"></A>Listing 6.22 MFCCONTROLWINCTL.CPP--Standard Drawing Added
to the OnDraw Function</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::OnDraw( <BR>
CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid) <BR>
{ <BR>
// ****** Get the text font ****** <BR>
// ** <BR>
CFont * pOldFont; <BR>
<BR>
// get the stock font <BR>
pOldFont = this-&gt;SelectStockFont(pdc); <BR>
// ** <BR>
// ****** Get the text font ****** <BR>
// ****** Get the colors ****** <BR>
// ** <BR>
// use the window color as the background color <BR>
COLORREF clrTextBackgroundColor = this-&gt;TranslateColor(this- &gt;GetBackColor());
<BR>
// then use the normal windows color for the text <BR>
COLORREF clrTextForegroundColor = this-&gt;TranslateColor(this- &gt;GetForeColor());
<BR>
// set to the system color <BR>
COLORREF clrEdgeBackgroundColor = ::GetSysColor(COLOR_3DFACE); <BR>
COLORREF clrEdgeForegroundColor = ::GetSysColor(COLOR_3DFACE); <BR>
// ** <BR>
// ****** Get the colors ****** <BR>
// ****** Draw the background ****** <BR>
// ** <BR>
// set the text color <BR>
COLORREF clrOldBackgroundColor = pdc-&gt;SetBkColor(clrTextBackgroundColor); <BR>
COLORREF clrOldForegroundColor = pdc &gt;SetTextColor(clrTextForegroundColor); <BR>
// if we don't have a brush <BR>
if(m_Brush.m_hObject == NULL) <BR>
// create a solid brush <BR>
m_Brush.CreateSolidBrush(clrTextBackgroundColor); <BR>
// select the brush and save the old one <BR>
CBrush * pOldBrush = pdc-&gt;SelectObject(&amp;m_Brush); <BR>
// draw the background <BR>
pdc-&gt;Rectangle(&amp;rcBounds); <BR>
// ** <BR>
// ****** Draw the background ****** <BR>
// ****** Draw the text ****** <BR>
// ** <BR>
int iHor, iVer; <BR>
// get the size of the text for this DC <BR>
CSize oSize = pdc-&gt;GetTextExtent(m_cstrCaption); <BR>
switch(m_lAlignment) <BR>
{ <BR>
case EALIGN_CENTER: <BR>
iHor = (rcBounds.right - oSize.cx) / 2; <BR>
iVer = rcBounds.top + 3; <BR>
break; <BR>
case EALIGN_RIGHT: <BR>
iHor = rcBounds.right - oSize.cx - 3; <BR>
iVer = rcBounds.top + 3; <BR>
break; <BR>
// case EALIGN_LEFT: <BR>
default: <BR>
iHor = rcBounds.left + 3; <BR>
iVer = rcBounds.top + 3; <BR>
break; <BR>
} <BR>
// output our text <BR>
pdc-&gt;ExtTextOut(iHor, iVer, ETO_CLIPPED | ETO_OPAQUE, rcBounds, m_cstrCaption,
m_cstrCaption.GetLength(), NULL); <BR>
// ** <BR>
// ****** Draw the text ****** <BR>
// ****** Draw the border ****** <BR>
// ** <BR>
// set the edge style and flags <BR>
UINT uiBorderStyle = EDGE_SUNKEN; <BR>
UINT uiBorderFlags = BF_RECT; <BR>
// set the edge color <BR>
pdc-&gt;SetBkColor(clrEdgeBackgroundColor); <BR>
pdc-&gt;SetTextColor(clrEdgeForegroundColor); <BR>
// draw the 3D edge <BR>
pdc-&gt;DrawEdge((LPRECT)(LPCRECT) rcBounds, uiBorderStyle, uiBorderFlags); <BR>
// ** <BR>
// ****** Draw the border ****** <BR>
// ****** Reset the colors ****** <BR>
// ** <BR>
// restore the original colors <BR>
pdc-&gt;SetBkColor(clrOldBackgroundColor); <BR>
pdc-&gt;SetTextColor(clrOldForegroundColor); <BR>
// ** <BR>
// ****** Reset the colors ****** <BR>
// ****** release the text font ****** <BR>
// ** <BR>
// set the old font back <BR>
pdc-&gt;SelectObject(pOldFont); <BR>
// ** <BR>
// ****** Get the text font ****** <BR>
// select the old brush back <BR>
pdc-&gt;SelectObject(pOldBrush); <BR>
}</TT></FONT></P>
<H2><A NAME="Heading37"></A>From Here...</H2>
<P>This chapter focused on creating a basic MFC control implementation. Methods,
properties, and events are the basis for any control implementation, and using MFC
makes it truly easy to add them in a short period of time. This chapter also addressed
the issues of persistence and drawing, which are necessary for a complete control
implementation.</P>
<P>MFC was the first tool available from Microsoft for doing ActiveX development--back
then it was called OLE. MFC was meant to hide all the details of implementing ActiveX/COM
components from you so that you wouldn't have to learn a whole new way of developing
MFC applications just to support ActiveX/COM. The fact that MFC hides all of the
details is exactly its limitation. You may be able to create ActiveX controls in
a short period of time, but their size and performance may not be that desirable.
MFC does have a distinct advantage in the area of maturity of integration with the
IDE since the IDE seems to be designed around making it as easy as possible to create
applications when using MFC.</P>

<P><A HREF="ch07.htm">Chapter 7</A> expands on the things you learned in this chapter
about creating controls. It also shows you how to add new features to your control
implementation that can make it truly unique and interesting.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
