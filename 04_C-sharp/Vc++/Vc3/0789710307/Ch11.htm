<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 11:35 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 11</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 11<BR>
Advanced ActiveX Control Development with BaseCtl</H1>

<UL>
	<LI><A HREF="#Heading1">Advanced ActiveX Control Development with BaseCtl</A>
	<UL>
		<LI><A HREF="#Heading2">Creating Properties</A>
		<UL>
			<LI><A HREF="#Heading3">Creating Asynchronous Properties</A>
			<LI><A HREF="#Heading4">Listing 11.1 BCFCONTROLCTL.H--Modified BCFControlControl
			Class Definition</A>
			<LI><A HREF="#Heading5">Listing 11.2 BCFCONTROLCTL.CPP--BCFControlControl Constructor
			Implementation Change</A>
			<LI><A HREF="#Heading6">Listing 11.3 BCFCONTROLCTL.CPP--OnData Function</A>
			<LI><A HREF="#Heading7">Listing 11.4 DISPIDS.H--Add Data Path Property Dispid</A>
			<LI><A HREF="#Heading8">Listing 11.5 BCFCONTROL.ODL--BCFControl ODL Implementation</A>
			<LI><A HREF="#Heading9">Listing 11.6 BCFCONTROLCTL.H--ReadyState Property Prototype</A>
			<LI><A HREF="#Heading10">Listing 11.7 BCFCONTROLCTL.CPP--Member Initialization</A>
			<LI><A HREF="#Heading11">Listing 11.8 BCFCONTROLCTL.CPP--Property Implementation</A>
			<LI><A HREF="#Heading12">Listing 11.9 BCFCONTROLCTL.CPP--OnData Implementation</A>
			<LI><A HREF="#Heading13">Static and Dynamic Property Enumeration</A>
			<LI><A HREF="#Heading14">Listing 11.10 PERPROPERTYBROWSING.H--IPerPropertyBrowsing
			Interface Macro</A>
			<LI><A HREF="#Heading15">Listing 11.11 BCFCONTROLCTL.H--IPerPropertyBrowsing Interface
			Declaration</A>
			<LI><A HREF="#Heading16">Listing 11.12 BCFCONTROLCTL.CPP--QueryInterface Implementation
			of IPerPropertyBrowsing</A>
			<LI><A HREF="#Heading17">Listing 11.13 BCFCONTROLCTL.CPP--IPerPropertyBrowsing Implementation</A>
		</UL>
		<LI><A HREF="#Heading18">Drawing the Control</A>
		<UL>
			<LI><A HREF="#Heading19">Optimized Drawing</A>
			<LI><A HREF="#Heading20">Listing 11.14 BCFCONTROLCTL.CPP--Optimized Drawing</A>
			<LI><A HREF="#Heading21">Listing 11.15 BCFCONTROLCTL.CPP--BeforeDestroyWindow Implementation</A>
		</UL>
		<LI><A HREF="#Heading22">Adding Clipboard and Drag and Drop Support</A>
		<UL>
			<LI><A HREF="#Heading23">Clipboard Support</A>
			<LI><A HREF="#Heading24">Listing 11.16 IDATAOBJECT.H--IDataObject Interface Macro</A>
			<LI><A HREF="#Heading25">Listing 11.17 IENUMFORMATETC--IEnumFORMATETC Interface Macro</A>
			<LI><A HREF="#Heading26">Listing 11.18 BCFCONTROLCTL.H--Clipboard Support Implementation--Header
			File</A>
			<LI><A HREF="#Heading27">Listing 11.19 BCFCONTROLCTL.CPP--Constructor Member Initialization</A>
			<LI><A HREF="#Heading28">Listing 11.20 BCFCONTROLCTL.CPP--QueryInterface Update</A>
			<LI><A HREF="#Heading29">Listing 11.21 BCFCONTROLCTL.CPP--WM_KEYDOWN Message Handler</A>
			<LI><A HREF="#Heading30">Listing 11.22 BCFCONTROLCTL.CPP--CopyDataToClipboard Implementation</A>
			<LI><A HREF="#Heading31">Listing 11.23 BCFCONTROLCTL.CPP--PrepareDataForTransfer
			Implementation</A>
			<LI><A HREF="#Heading32">Listing 11.24 BCFCONTROLCTL.CPP--CopyStgMedium Implementation</A>
			<LI><A HREF="#Heading33">Listing 11.25 BCFCONTROLCTL.CPP--IDataObject Implementation</A>
			<LI><A HREF="#Heading34">Listing 11.26 BCFCONTROLCTL.CPP--IEnumFORMATETC Implementation</A>
			<LI><A HREF="#Heading35">Listing 11.27 BCFCONTROLCTL.CPP--OnKeyDown Implementation</A>
			<LI><A HREF="#Heading36">Listing 11.28 BCFCONTROCTL.H--Clipboard Target Implementation--
			Header File</A>
			<LI><A HREF="#Heading37">Listing 11.29 BCFCONTROLCTL.CPP--GetDataFromClipboard Implementation</A>
			<LI><A HREF="#Heading38">Listing 11.30 BCFCONTROLCTL.CPP--GetDataFromTransfer Implementation</A>
			<LI><A HREF="#Heading39">Listing 11.31 BCFCONTROCTL.CPP--OnKeyDown Implementation</A>
			<LI><A HREF="#Heading40">Adding Drag and Drop Support</A>
			<LI><A HREF="#Heading41">Listing 11.32 IDROPSOURCE.H--IDropSource Interface</A>
			<LI><A HREF="#Heading42">Listing 11.33 BCFCONTROCTL.H--IDropSource Interface Implementation</A>
			<LI><A HREF="#Heading43">Listing 11.34 BCFCONTROLCTL.CPP--QueryInterface Update</A>
			<LI><A HREF="#Heading44">Listing 11.35 BCFCONTROLCTL.CPP--WindowProc Implementation</A>
			<LI><A HREF="#Heading45">Listing 11.36 BCFCONTROLCTL.CPP--Drop Source Implementation</A>
			<LI><A HREF="#Heading46">Listing 11.37 IDROPTARGET.H--IDropTarget Interface</A>
			<LI><A HREF="#Heading47">Listing 11.38 BCFCONTROLCTL.H--IDropTarget Implementation</A>
			<LI><A HREF="#Heading48">Listing 11.39 BCFCONTROLCTL.CPP--QueryInterface Update</A>
			<LI><A HREF="#Heading49">Listing 11.40 BCFCONTROLCTL.CPP--AfterCreateWindow Implementation</A>
			<LI><A HREF="#Heading50">Listing 11.41 BCFCONTROLCTL.CPP--IDropTarget Implementation</A>
			<LI><A HREF="#Heading51">Custom Clipboard and Drag and Drop Formats</A>
			<LI><A HREF="#Heading52">Listing 11.42 BCFCONTROLCTL.H--Custom Data Format Member
			Variables</A>
			<LI><A HREF="#Heading53">Listing 11.43 BCFCONTROLCTL.CPP--Register the Custom Format</A>
			<LI><A HREF="#Heading54">Listing 11.44 BCFCONTROCTL.CPP--PrepareDataForTransfer Update</A>
			<LI><A HREF="#Heading55">Listing 11.45 BCFCONTROLCTL.CPP--GetDataFromTransfer Update</A>
			<LI><A HREF="#Heading56">Listing 11.46 BCFCONTROLCTL.CPP--IEnumFORMATETC::Next Update</A>
			<LI><A HREF="#Heading57">Listing 11.47 BCFCONTROLCTL.CPP--IEnumFORMATETC::GetData
			Update</A>
		</UL>
		<LI><A HREF="#Heading58">Subclassing Existing Windows Controls</A>
		<UL>
			<LI><A HREF="#Heading59">Listing 11.48 BCFCONTROLSUBCTL.CPP--RegisterClassData Implementation</A>
		</UL>
		<LI><A HREF="#Heading60">Dual-Interface Controls</A>
		<LI><A HREF="#Heading61">Other ActiveX Features</A>
		<UL>
			<LI><A HREF="#Heading62">Windowless Activation</A>
			<LI><A HREF="#Heading63">Listing 11.49 BCFCONTROLCTL.H--BCFControControl ActiveX
			Implementation</A>
			<LI><A HREF="#Heading64">Listing 11.50 BCFCONTROLNOWIN.H--BCFControlNoWinControl
			ActiveX Implementation</A>
			<LI><A HREF="#Heading65">Unclipped Device Context</A>
			<LI><A HREF="#Heading66">Flicker-Free Activation</A>
			<LI><A HREF="#Heading67">Mouse Pointer Notifications When Inactive</A>
			<LI><A HREF="#Heading68">Listing 11.51 BCFCONTROLNOWIN.H--Mouse Notifications</A>
			<LI><A HREF="#Heading69">Optimized Drawing Code</A>
			<LI><A HREF="#Heading70">Loads Properties Asynchronously</A>
		</UL>
		<LI><A HREF="#Heading71">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Advanced ActiveX Control Development with BaseCtl</H1>

<UL>
	<LI><B>Asynchronous properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Supporting asynchronous properties in the BaseCtl sample shows what is happening
	behind the scenes when properties are loaded asynchronously.
	<P>
	<LI><B>Property enumeration</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Property enumeration is exposed through a simple COM interface, which is easy to
	add given the BaseCtl architecture.
	<P>
	<LI><B>Optimized drawing</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Optimized drawing has positive effects on the performance of the control. Like MFC
	and ATL, BaseCtl support of optimized drawing is trivial.
	<P>
	<LI><B>Clipboard and Drag and Drop</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Adding Clipboard and Drag and Drop support to your BaseCtl implementation is similar
	to the MFC and ATL implementations.
	<P>
	<LI><B>Windows and dual-interface controls</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Subclassing an existing Windows control reduces development time when creating new
	control implementations. Like ATL, BaseCtl ActiveX control implementations support
	dual-interface by default.
	<P>
	<LI><B>Advanced ActiveX</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The BaseCtl framework supports the advanced ActiveX features in this chapter.
</UL>

<P>This chapter expands upon the information in <A HREF="ch10.htm">Chapter 10</A>
about creating a basic BaseCtl ActiveX control, so reading Chapter 10 prior to this
chapter is necessary. In addition to the features that you are familiar with, such
as Clipboard and Drag and Drop support, you will learn how to implement asynchronous
properties and optimized drawing, which are the result of the adoption of OC 96 specification.
<H2><A NAME="Heading2"></A>Creating Properties</H2>
<P><A HREF="ch10.htm">Chapter 10</A> tells you how to add the various types of properties
to your control implementation. One type of property has yet to be examined: asynchronous
properties.
<H3><A NAME="Heading3"></A>Creating Asynchronous Properties</H3>
<P><I>Asynchronous properties </I>are those properties that typically represent a
large amount of data, such as a text or bitmap file, and are loaded as a background
process so as not to interfere with the normal processing of the control and the
container. This statement can be somewhat misleading. Asynchronous refers only to
the <I>call</I> to load the data; it does not refer to the actual loading.</P>

<P>For example, a control uses a bitmap as its background and has defined the bitmap
as an asynchronous property. If OLE determines that the bitmap is already on the
local machine, the data is considered to be available to the control and, subsequently,
will instruct the control that <I>all </I>of the data is available. If OLE determines
that the bitmap is not available on the local machine, OLE will load the data as
fast as possible and inform the control as data becomes available. After the data
is in a location that is considered accessible, the property essentially behaves
as any other property would. If you require the asynchronous loading of the data
regardless of its location, you must implement it yourself.</P>

<P>To allow for asynchronous property support, you have to modify your class definition
slightly. Listing 11.1 shows the changes that were made to your <TT>BCFControlControl</TT>
class header file.</P>

<P>The BaseCtl class <TT>COleControl</TT> does not provide support for asynchronous
properties. You need to take advantage of the BaseCtl class <TT>CInternetControl</TT>
in order to do that.</P>

<P>You need to include the Internet.h file and derive the class <TT>BCFControlControl</TT>
from <TT>CInternetControl</TT>, which is derived from the base class <TT>COleControl</TT>.
You also add the method <TT>OnData</TT> as your callback function. The callback function
is what OLE uses to notify your control that data is being downloaded and is required
for asynchronous property support.
<H3><A NAME="Heading4"></A>Listing 11.1 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--Modified
BCFControlControl Class <TT>Definition</TT></H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// class declaration for the BCFControl control.<BR>
//<BR>
#ifndef _BCFCONTROLCONTROL_H_ <BR>
#include &quot;IPServer.H&quot;<BR>
#include &quot;CtrlObj.H&quot;<BR>
#include &quot;BCFControlInterfaces.H&quot;<BR>
#include &quot;Dispids.H&quot;<BR>
#include &quot;internet.h&quot; <BR>
#include &quot;alignmentenums.h&quot; <BR>
typedef struct tagBCFCONTROLCTLSTATE<BR>
{<BR>
long lCaptionLength;<BR>
long lAlignment;<BR>
OLE_COLOR ocBackColor;<BR>
} BCFCONTROLCTLSTATE; <BR>
//=-------------------------------------------------------------------------=<BR>
// CBCFControlControl<BR>
//=-------------------------------------------------------------------------=<BR>
// our control.<BR>
//<BR>
class CBCFControlControl : public CInternetControl, public IBCFControl, public ISupportErrorInfo<BR>
{ <BR>
. . . <BR>
// OnData is called asynchronously as data for an <BR>
// object or property arrives...<BR>
virtual HRESULT OnData(DISPID propId, DWORD bscfFlag, IStream * strm, <BR>
DWORD dwSize); <BR>
// private state information.<BR>
//<BR>
BCFCONTROLCTLSTATE m_state; <BR>
. . .<BR>
</TT></FONT></P>

<P>Listing 11.2 shows your changes to the implementation of your constructor to enable
asynchronous property support. Your constructor implementation is trivial since your
only change is to replace the <TT>COleControl</TT> constructor declaration with <TT>CInternetControl</TT>.
Note the pearls of wisdom from the authors of the BaseCtl sample.
<H3><A NAME="Heading5"></A>Listing 11.2<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--BCFControlControl
Constructor Implementation Change</H3>
<P><FONT COLOR="#0066FF"><TT>//=-------------------------------------------------------------------------=<BR>
// CBCFControlControl::CBCFControlControl<BR>
//=-------------------------------------------------------------------------=<BR>
// &quot;Being born is like being kidnapped. And then sold into slavery.&quot;<BR>
// - andy warhol (1928 - 87)<BR>
//<BR>
// Parameters:<BR>
// IUnknown * - [in]<BR>
//<BR>
// Notes:<BR>
//<BR>
#pragma warning(disable:4355) // using `this' in constructor<BR>
CBCFControlControl::CBCFControlControl<BR>
(<BR>
IUnknown *pUnkOuter<BR>
)<BR>
: CInternetControl(pUnkOuter, OBJECT_TYPE_CTLBCFCONTROL, (IDispatch *)this)<BR>
{<BR>
// initialize anything here <BR>
...<BR>
</TT></FONT></P>

<P>Listing 11.3 shows the <TT>OnData</TT> function that you added to your source
file. For now, you just add the function shell; you will add the specific implementation
after you add your data path property.
<H3><A NAME="Heading6"></A>Listing 11.3 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--OnData
Function</H3>
<P><FONT COLOR="#0066FF"><TT>... <BR>
HRESULT CBCFControlControl::OnData(DISPID propId, DWORD bscfFlag, IStream * strm,
<BR>
DWORD dwSize)<BR>
{<BR>
HRESULT hr = NOERROR; <BR>
return(hr); <BR>
}<BR>
</TT></FONT></P>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> We experienced some link problems when compiling our BCFControl sample
	code, as follows: <TT>Unresolved external: CreateURLMoniker</TT> <TT>Unresolved external:
	RegisterBindStatusCallback</TT> Even though the functions are declared in urlmon.h
	and should be implemented in uuid.lib, we found that we had to link with Urlmon.lib
	to resolve the functions.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Before you add your specific implementation code to support the asynchronous property,
you need to add the stock property <TT>ReadyState</TT> to your control.</P>
<P>You also need to add a user-defined property for your data path variable. This
property is used to store the location of the asynchronous properties data. This
location can be any valid pathname, including URL and UNC paths.</P>
<P>First you need to declare a dispid for your data path property (see Listing 11.4).
You use the OLE defined dispid for the <TT>ReadyState</TT> property.
<H3><A NAME="Heading7"></A>Listing 11.4 <SPACER TYPE="HORIZONTAL" SIZE="10">DISPIDS.H--Add
Data Path Property Dispid</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
//=-------------------------------------------------------------------------=<BR>
// for the BCFControl control<BR>
// properties &amp; methods<BR>
// <BR>
#define dispidAlignment 1<BR>
#define dispidCaptionMethod 2<BR>
#define dispidCaptionProp 3 <BR>
#define dispidTextDataPath 4 <BR>
. . .</TT></FONT></P>

<P>Next you add the two new properties to your ODL file (see Listing 11.5). Note
that you add only a method for getting the <TT>ReadyState</TT> property, and not
a method for setting the property, which has the effect of creating a read-only property.
<H3><A NAME="Heading8"></A>Listing 11.5 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.ODL--BCFControl
ODL Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
[uuid(317512F1-3E75-11d0-BEBE-00400538977D), helpstring(&quot;BCFControl Control&quot;),<BR>
hidden, dual, odl]<BR>
interface IBCFControl : IDispatch<BR>
{<BR>
// properties<BR>
[id(dispidAlignment), propget] HRESULT Alignment([out, retval] long * Value);<BR>
[id(dispidAlignment), propput] HRESULT Alignment([in] long Value);<BR>
[id(DISPID_BACKCOLOR), propget] HRESULT BackColor([out, retval] OLE_COLOR * Value);<BR>
[id(DISPID_BACKCOLOR), propput] HRESULT BackColor([in] OLE_COLOR Value);<BR>
[id(DISPID_READYSTATE), propget] HRESULT ReadyState([out, retval] long * Value);<BR>
[id(dispidTextDataPath), propget] HRESULT TextDataPath([out, retval] BSTR * Value);<BR>
[id(dispidTextDataPath), propput] HRESULT TextDataPath([in] BSTR Value); <BR>
// methods . . .<BR>
</TT></FONT></P>

<P>You need to add a member variable to your state structure to store the state of
the control's asynchronous properties, and you also add a string length member that
will be used later in your persistence routines.</P>

<P>You also need to add your function prototypes of the property <TT>get/set</TT>
methods to your class header file (see Listing 11.6). Remember that the prototype
is generated automatically when the ODL file is compiled.</P>

<P>Finally you add a string member to hold the value of the property.
<H3><A NAME="Heading9"></A>Listing 11.6 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--ReadyState
Property Prototype</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
typedef struct tagBCFCONTROLCTLSTATE<BR>
<BR>
{<BR>
<BR>
long lCaptionLength;<BR>
<BR>
long lAlignment;<BR>
<BR>
OLE_COLOR ocBackColor;<BR>
<BR>
long lReadyState;<BR>
<BR>
long lTextDataPathLength;<BR>
<BR>
} BCFCONTROLCTLSTATE; <BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// CBCFControlControl<BR>
<BR>
//=-------------------------------------------------------------------------= <BR>
. . . <BR>
// IBCFControl methods<BR>
<BR>
//<BR>
<BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* Value);<BR>
<BR>
STDMETHOD(put_Alignment)(THIS_ long Value);<BR>
<BR>
STDMETHOD(get_BackColor)(THIS_ OLE_COLOR FAR* Value);<BR>
<BR>
STDMETHOD(put_BackColor)(THIS_ OLE_COLOR Value);<BR>
<BR>
STDMETHOD(get_ReadyState)(THIS_ long FAR* Value);<BR>
<BR>
STDMETHOD(get_TextDataPath)(THIS_ BSTR FAR* bstrRetVal);<BR>
<BR>
STDMETHOD(put_TextDataPath)(THIS_ BSTR Value);<BR>
<BR>
STDMETHOD(CaptionMethod)(THIS_ BSTR bstrCaption, VARIANT varAlignment, <BR>
<BR>
long FAR* lRetVal);<BR>
<BR>
STDMETHOD(get_CaptionProp)(THIS_ VARIANT varAlignment, BSTR FAR* bstrRetVal);<BR>
<BR>
STDMETHOD(put_CaptionProp)(THIS_ VARIANT varAlignment, BSTR lpszNewValue);<BR>
<BR>
STDMETHOD_(void, AboutBox)(THIS); <BR>
. . . <BR>
// private state information.<BR>
<BR>
//<BR>
<BR>
BCFCONTROLCTLSTATE m_state; <BR>
protected:<BR>
<BR>
LPTSTR m_lptstrCaption;<BR>
<BR>
LPTSTR m_lptstrTextDataPath; <BR>
};<BR>
</TT></FONT></P>
<P>Listing 11.7 shows your member variable initialization in your constructor. You
don't need to set any default values since the <TT>ReadyState</TT> will not be persisted
across execution lifetimes.
<H3><A NAME="Heading10"></A>Listing 11.7<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--Member
Initialization</H3>
<P><FONT COLOR="#0066FF"><TT>#pragma warning(disable:4355) // using `this' in constructor<BR>
<BR>
CBCFControlControl::CBCFControlControl<BR>
<BR>
(<BR>
<BR>
IUnknown *pUnkOuter<BR>
<BR>
)<BR>
<BR>
: CInternetControl(pUnkOuter, OBJECT_TYPE_CTLBCFCONTROL, (IDispatch *)this)<BR>
<BR>
{<BR>
<BR>
// initialize anything here ...<BR>
<BR>
// <BR>
... <BR>
// set the ready state of the control<BR>
<BR>
m_state.lReadyState = READYSTATE_LOADING; <BR>
// NULL terminate the string reference<BR>
<BR>
m_lptstrTextDataPath = new TCHAR[1];<BR>
<BR>
m_lptstrTextDataPath[0] = `\0'; <BR>
} <BR>
#pragma warning(default:4355) // using `this' in constructor<BR>
</TT></FONT></P>
<P>Last you add your implementation of the <TT>ReadyState</TT> and <TT>TextDataPath</TT>
methods to your class source file (see Listing 11.8). You initiate the asynchronous
download of your data within your <TT>put_TextDataPath</TT> method. You do this through
a call to <TT>SetupDownload</TT>, where you pass in the path of the data to be downloaded
and the dispid of the property that the data is bound to. As data becomes available,
your <TT>OnData</TT> method is called.
<H3><A NAME="Heading11"></A>Listing 11.8 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Property
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::get_ReadyState(long
* Value)<BR>
<BR>
{<BR>
<BR>
// make sure that we have a good pointer<BR>
<BR>
CHECK_POINTER(Value); <BR>
// set the return value<BR>
<BR>
*Value = m_state.lReadyState; <BR>
// return the result<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::get_TextDataPath(BSTR FAR * bstrRetVal)<BR>
<BR>
{<BR>
<BR>
// if there is a string<BR>
<BR>
if(*bstrRetVal);<BR>
<BR>
{<BR>
<BR>
// free the string because we are going to replace it<BR>
<BR>
::SysFreeString(*bstrRetVal); <BR>
// clear the reference just to be safe<BR>
<BR>
*bstrRetVal = NULL;<BR>
<BR>
} <BR>
// return the caption as a BSTR<BR>
<BR>
*bstrRetVal = ::SysAllocString(OLESTRFROMANSI(m_lptstrTextDataPath)); <BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::put_TextDataPath(BSTR bstrNewValue)<BR>
<BR>
{<BR>
<BR>
HRESULT hResult = S_OK; <BR>
// get a ANSI string from the BSTR<BR>
<BR>
MAKE_ANSIPTR_FROMWIDE(lpctstrTextDataPath, bstrNewValue); <BR>
// if we have a string<BR>
<BR>
if(lpctstrTextDataPath != NULL)<BR>
<BR>
{<BR>
<BR>
// if we have a string<BR>
<BR>
if(m_lptstrTextDataPath)<BR>
<BR>
{<BR>
<BR>
// delete the existing string<BR>
<BR>
delete [] m_lptstrTextDataPath; <BR>
// clear the reference just to be safe<BR>
<BR>
m_lptstrTextDataPath = NULL;<BR>
<BR>
} <BR>
// allocate a new string<BR>
<BR>
m_lptstrTextDataPath = new TCHAR[lstrlen(lpctstrTextDataPath) + 1]; <BR>
// assign the string to our member variable<BR>
<BR>
lstrcpy(m_lptstrTextDataPath, lpctstrTextDataPath);<BR>
<BR>
} <BR>
// start the asynchronous download of the data<BR>
<BR>
this-&gt;SetupDownload(OLESTRFROMANSI(m_lptstrTextDataPath), dispidTextDataPath);
<BR>
// let the container know that the property has changed<BR>
<BR>
m_fDirty = TRUE;<BR>
<BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
return hResult; <BR>
}<BR>
</TT></FONT></P>
<P>Listing 11.9 shows your implementation of your <TT>OnData</TT> method, which will
progressively render the caption of your control from the <TT>IStream</TT> supplied.
It is possible to receive the <I>first </I>and<I> last</I> notification messages
within a single call to <TT>OnData</TT>, which is the reason for the separation between
the <TT>BSCF_FIRSTDATANOTIFICATION</TT> and <TT>BSCF_LASTDATANOTIFICATION</TT> messages.
Another flag that can be passed to the function is <TT>BSCF_INTERMEDIATEDATANTIFICATION</TT>,
which indicates that additional data is to be passed and that you have not received
it all. Your <TT>OnData</TT> function assumes that multiple calls to load data will
be made and checks for only the first and last notification messages.
<H3><A NAME="Heading12"></A>Listing 11.9<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--OnData
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CBCFControlControl::OnData(DISPID propId, DWORD
bscfFlag, IStream * strm, DWORD dwSize)<BR>
<BR>
{<BR>
<BR>
HRESULT hr = NOERROR; <BR>
// if this is the first notification<BR>
<BR>
if(bscfFlag &amp; BSCF_FIRSTDATANOTIFICATION)<BR>
<BR>
{<BR>
<BR>
// if we have a reference<BR>
<BR>
if(m_lptstrCaption)<BR>
<BR>
{<BR>
<BR>
// delete the string buffer<BR>
<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
<BR>
m_lptstrCaption = NULL;<BR>
<BR>
}<BR>
<BR>
} <BR>
// alloc a temp buffer<BR>
<BR>
LPTSTR lptstrTempBuffer = new TCHAR[dwSize + 1];<BR>
<BR>
<BR>
<BR>
ULONG ulBytesRead;<BR>
<BR>
// read the data to a temp buffer<BR>
<BR>
hr = strm-&gt;Read(lptstrTempBuffer, dwSize, &amp;ulBytesRead); <BR>
// if we read in any data<BR>
<BR>
if(hr == S_OK &amp;&amp; ulBytesRead)<BR>
<BR>
{<BR>
<BR>
// null terminate the amount of data the was actually read in<BR>
<BR>
lptstrTempBuffer[ulBytesRead] = `\0'; <BR>
// get a new buffer with enough space to hold all of the data<BR>
<BR>
LPTSTR lptstrNewBuffer = new TCHAR[lstrlen(m_lptstrCaption) + ulBytesRead + 1]; <BR>
// copy the existing data to the new buffer<BR>
<BR>
lstrcpy(lptstrNewBuffer, m_lptstrCaption); <BR>
// add the new data to the buffer<BR>
<BR>
lstrcat(lptstrNewBuffer, lptstrTempBuffer); <BR>
// remove the existing string<BR>
<BR>
delete [] m_lptstrCaption; <BR>
// copy the data to the buffer<BR>
<BR>
m_lptstrCaption = lptstrNewBuffer; <BR>
// set the dirty flag<BR>
<BR>
m_fDirty = TRUE; <BR>
// redraw the control<BR>
<BR>
this-&gt;InvalidateControl(NULL);<BR>
<BR>
} <BR>
// if this is our last notification<BR>
<BR>
if(bscfFlag &amp; BSCF_LASTDATANOTIFICATION)<BR>
<BR>
{<BR>
<BR>
// set the ready state of the control<BR>
<BR>
m_state.lReadyState = READYSTATE_COMPLETE; <BR>
// set the dirty flag<BR>
<BR>
m_fDirty = TRUE;<BR>
<BR>
} <BR>
// return the result<BR>
<BR>
return(hr); <BR>
}<BR>
</TT></FONT></P>
<P>Potentially, any type of data can be rendered in this fashion. The BaseCtl framework
provides a sample implementation, called WebImage, that demonstrates the rendering
of bitmap data progressively as an asynchronous property.
<H3><A NAME="Heading13"></A>Static and Dynamic Property Enumeration</H3>
<P><I>Property enumeration</I> is a way of restricting a property to a specific set
of valid values. An example of an enumeration is a property for determining the alignment
of a control's displayed text: left-justified, centered, and right-justified, in
your case. Another case is a property used to select the different languages a control
supports. Language selection properties are good candidates for both a static set,
say for English and German, and a dynamic set, say for all the languages on a particular
machine.</P>
<P>As is pointed out in <A HREF="ch07.htm">Chapters 7</A> and <A HREF="ch09.htm">9</A>,
property enumeration adds, with very little effort, a new level of sophistication
to your control implementation. <BR>
<BR>
<B>Static Property Enumeration </B><SPACER TYPE="HORIZONTAL" SIZE="10">Static Property
Enumeration for a BaseCtl implemented control is no different than your MFC and ATL
implementations. Static enumeration is dependent on the ODL and requires no control
code to implement it. See <A HREF="ch07.htm">Chapter 7</A> for the implementation
details.</P>
<P><B>Dynamic Property Enumeration </B><SPACER TYPE="HORIZONTAL" SIZE="10">As with
your MFC and ATL implementations, adding Dynamic Property Enumeration to your BaseCtl
implementation is straightforward. Unfortunately, the BaseCtl does not provide the
basic OLE interface for Dynamic Property Enumeration support that you found in MFC,
so you must add it yourself. <I>Dynamic Property Enumeration</I> is based on the
interface <TT>IPerPropertyBrowsing</TT>. You will create a macro in a style similar
to that of the BaseCtl that will provide the necessary code to implement the interface.
Listing 11.10 shows the macro and the definition that you added. Essentially, the
macro is just a collection of functions that need to be supported in order to use
a specific interface. You are not required to implement the interface with a macro
as your are doing here. The macro just makes your control class code a little bit
easier to read and manage.
<H3><A NAME="Heading14"></A>Listing 11.10 <SPACER TYPE="HORIZONTAL" SIZE="10">IPERPROPERTYBROWSING.H--IPerPropertyBrowsing
Interface Macro</H3>
<P><FONT COLOR="#0066FF"><TT>#define DECLARE_STANDARD_PERPROPERTYBROWSING() \<BR>
<BR>
STDMETHOD(MapPropertyToPage)(DISPID Dispid, LPCLSID lpclsid); \<BR>
<BR>
STDMETHOD(GetPredefinedStrings)(DISPID Dispid, CALPOLESTR* lpcaStringsOut,\ <BR>
<BR>
CADWORD* lpcaCookiesOut); \<BR>
<BR>
STDMETHOD(GetPredefinedValue)(DISPID Dispid, DWORD dwCookie, VARIANT* lpvarOut);
\ <BR>
STDMETHOD(GetDisplayString)(DISPID Dispid, BSTR* lpbstr); \<BR>
</TT></FONT></P>
<P>In order for your control to support <TT>IPerPropertyBrowsing</TT>, you need to
include the header file for your <TT>IPerPropertyBrowsing</TT> macro, inherit from
the <TT>IPerPropertyBrowsing</TT> interface, and add the macro to your class declaration
(see Listing 11.11).
<H3><A NAME="Heading15"></A>Listing 11.11<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--IPerPropertyBrowsing
Interface Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>#include &quot;Dispids.H&quot;<BR>
<BR>
#include &quot;internet.h&quot;<BR>
<BR>
#include &quot;IPerPropertyBrowsing.h&quot; <BR>
#include &quot;alignmentenums.h&quot; <BR>
typedef struct tagBCFCONTROLCTLSTATE<BR>
<BR>
{<BR>
<BR>
long lCaptionLength;<BR>
<BR>
long lAlignment;<BR>
<BR>
OLE_COLOR ocBackColor;<BR>
<BR>
long lReadyState;<BR>
<BR>
long lTextDataPathLength;<BR>
<BR>
} BCFCONTROLCTLSTATE; <BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// CBCFControlControl<BR>
<BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// our control.<BR>
<BR>
//<BR>
<BR>
class CBCFControlControl : public CInternetControl, public IBCFControl, <BR>
<BR>
public ISupportErrorInfo, public IPerPropertyBrowsing<BR>
<BR>
{<BR>
<BR>
public:<BR>
<BR>
// IUnknown methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_UNKNOWN(); <BR>
// IDispatch methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_DISPATCH(); <BR>
// ISupportErrorInfo methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_SUPPORTERRORINFO(); <BR>
// IPerPropertyBrowsing methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_PERPROPERTYBROWSING(); <BR>
// IBCFControl methods<BR>
<BR>
// <BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* lRetValue);<BR>
</TT></FONT></P>
<P>When an application needs to use an interface in a control (or any component for
that matter), the application has to call <TT>QueryInterface</TT> to locate the correct
interface pointer within the component. This requirement is also true for the <TT>IPerPropertyBrowsing</TT>
interface. Listing 11.12 shows the change that you must make to your <TT>InternalQueryInterface</TT>
function in order to support the new interface. This change is required because the
control will not function correctly without it.
<H3><A NAME="Heading16"></A>Listing 11.12 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--QueryInterface
Implementation of IPerPropertyBrowsing</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CBCFControlControl::InternalQueryInterface(REFIID
riid, void **ppvObjOut) <BR>
<BR>
{<BR>
<BR>
IUnknown *pUnk; <BR>
*ppvObjOut = NULL; <BR>
// TODO: if you want to support any additional interfaces, then you should<BR>
<BR>
// indicate that here. never forget to call COleControl's version in the<BR>
<BR>
// case where you don't support the given interface.<BR>
<BR>
//<BR>
<BR>
if(DO_GUIDS_MATCH(riid, IID_IBCFControl))<BR>
<BR>
pUnk = (IUnknown *)(IBCFControl *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IPerPropertyBrowsing))<BR>
<BR>
pUnk = (IUnknown *)(IPerPropertyBrowsing *)this;<BR>
<BR>
else<BR>
<BR>
return COleControl::InternalQueryInterface(riid, ppvObjOut); <BR>
pUnk-&gt;AddRef();<BR>
<BR>
*ppvObjOut = (void *)pUnk;<BR>
<BR>
return S_OK; <BR>
}<BR>
</TT></FONT></P>
<P>Your last requirement is to implement the functions of the interface (see Listing
11.13).</P>
<P><TT>MapPropertyToPage</TT> is not required for your implementation, so you just
return the constant <TT>E_NOTIMPL</TT>. <TT>MapPropertyToPage</TT> is used to connect
the property to a property page that is implemented either in the container or in
the control.</P>
<P><TT>GetPredefinedStrings</TT> is the first function to be called. When this method
is called, the dispid of the property that is currently being referenced will be
passed in. This method is called for all properties that the control supports, so
take care when adding code. If the function is called and it is determined that the
correct property is in context, the control is required to create an array of strings
and cookies. A cookie is any 32-bit value that has meaning to the control implementation.
The strings are placed in a list from which the user of the control can select the
appropriate value to set the property to. In this case, the cookie value that is
supplied is also the value that will be stored in the control's property.</P>
<P><TT>GetPredefinedValue</TT> is the method that is called when the property browser
of the container needs the value that is associated with the particular dispid and
cookie. The value that is returned will be the actual value that is stored in the
property and not the string that was used to represent it.</P>
<P>After the property has been set with its value, the property browser calls the
function <TT>GetDisplayString</TT> to get the string that is associated with the
current property setting. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> It may seem a little redundant to have the method <TT>GetDisplayString</TT>
	when the property browser already has the string for the value from the <TT>GetPredefinedStrings</TT>
	function. The <TT>GetDisplayString</TT> function can be implemented without implementing
	the other methods. Implementing <TT>GetDisplayString</TT> without implementing the
	other functions in the <TT>IPerPropertyBrowsing</TT> interface is for those property
	types that do not use the standard property selection mechanism, for example, font
	selection, which uses a color selection dialog rather than a list of choices. The
	name of the font is retrieved via the <TT>GetDisplayString</TT> function, but the
	property selection facility is provided through a standard font dialog.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading17"></A>Listing 11.13 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--IPerPropertyBrowsing
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::MapPropertyToPage(DISPID,
LPCLSID)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::GetPredefinedStrings(DISPID Dispid, <BR>
<BR>
CALPOLESTR * lpcaStringsOut, CADWORD * lpcaCookiesOut)<BR>
<BR>
{<BR>
<BR>
HRESULT hResult = S_FALSE; <BR>
// we should have gotten two pointers if we didn't<BR>
<BR>
if((lpcaStringsOut == NULL) || (lpcaCookiesOut == NULL))<BR>
<BR>
// we are out of here<BR>
<BR>
return E_POINTER; <BR>
// if this is the property that we are looking for<BR>
<BR>
if(Dispid == dispidAlignment)<BR>
<BR>
{<BR>
<BR>
ULONG ulElems = 3; <BR>
// allocate the memory for our string array<BR>
<BR>
lpcaStringsOut-&gt;pElems = <BR>
<BR>
(LPOLESTR *) ::CoTaskMemAlloc(sizeof(LPOLESTR) * ulElems); <BR>
// if we couldn't allocate the memory<BR>
<BR>
if(lpcaStringsOut-&gt;pElems == NULL)<BR>
<BR>
// were out of here<BR>
<BR>
return E_OUTOFMEMORY; <BR>
// allocate the memory for our cookie array<BR>
<BR>
lpcaCookiesOut-&gt;pElems = <BR>
<BR>
(DWORD*) ::CoTaskMemAlloc(sizeof(DWORD*) * ulElems); <BR>
// if we couldn't allocate the memory<BR>
<BR>
if (lpcaCookiesOut-&gt;pElems == NULL)<BR>
<BR>
{<BR>
<BR>
// free the string array<BR>
<BR>
::CoTaskMemFree(lpcaStringsOut-&gt;pElems); <BR>
// exit the function<BR>
<BR>
return E_OUTOFMEMORY;<BR>
<BR>
} <BR>
// store the number of elements in each array<BR>
<BR>
lpcaStringsOut-&gt;cElems = ulElems;<BR>
<BR>
lpcaCookiesOut-&gt;cElems = ulElems; <BR>
// allocate the strings<BR>
<BR>
lpcaStringsOut-&gt;pElems[0] = OLESTRFROMANSI(EALIGN_LEFT_TEXT);<BR>
<BR>
lpcaStringsOut-&gt;pElems[1] = OLESTRFROMANSI(EALIGN_CENTER_TEXT);<BR>
<BR>
lpcaStringsOut-&gt;pElems[2] = OLESTRFROMANSI(EALIGN_RIGHT_TEXT); <BR>
// assign the cookie value<BR>
<BR>
lpcaCookiesOut-&gt;pElems[0] = EALIGN_LEFT;<BR>
<BR>
lpcaCookiesOut-&gt;pElems[1] = EALIGN_CENTER;<BR>
<BR>
lpcaCookiesOut-&gt;pElems[2] = EALIGN_RIGHT; <BR>
hResult = S_OK;<BR>
<BR>
} <BR>
return hResult;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::GetPredefinedValue(DISPID Dispid, DWORD dwCookie,
<BR>
<BR>
VARIANT* lpvarOut)<BR>
<BR>
{<BR>
<BR>
BOOL bResult = FALSE; <BR>
// which property is it<BR>
<BR>
switch(Dispid)<BR>
<BR>
{<BR>
<BR>
case dispidAlignment:<BR>
<BR>
// clear the variant<BR>
<BR>
::VariantInit(lpvarOut);<BR>
<BR>
// set the type to a long<BR>
<BR>
lpvarOut-&gt;vt = VT_I4;<BR>
<BR>
// set the value to the value that was stored with the string<BR>
<BR>
lpvarOut-&gt;lVal = dwCookie;<BR>
<BR>
// set the return value<BR>
<BR>
bResult = TRUE;<BR>
<BR>
break;<BR>
<BR>
} <BR>
return bResult;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::GetDisplayString(DISPID Dispid, BSTR* lpbstr)<BR>
<BR>
{<BR>
<BR>
HRESULT hResult = S_FALSE; <BR>
// which property is it<BR>
<BR>
switch(Dispid)<BR>
<BR>
{<BR>
<BR>
case dispidAlignment:<BR>
<BR>
{<BR>
<BR>
switch(m_state.lAlignment)<BR>
<BR>
{<BR>
<BR>
case EALIGN_LEFT:<BR>
<BR>
*lpbstr = BSTRFROMANSI(EALIGN_LEFT_TEXT);<BR>
<BR>
break;<BR>
<BR>
case EALIGN_CENTER:<BR>
<BR>
*lpbstr = BSTRFROMANSI(EALIGN_CENTER_TEXT);<BR>
<BR>
break;<BR>
<BR>
case EALIGN_RIGHT:<BR>
<BR>
*lpbstr = BSTRFROMANSI(EALIGN_RIGHT_TEXT);<BR>
<BR>
break;<BR>
<BR>
} <BR>
// set the return value<BR>
<BR>
hResult = S_OK;<BR>
<BR>
}<BR>
<BR>
break;<BR>
<BR>
} <BR>
return hResult; <BR>
}<BR>
</TT></FONT></P>
<H2><A NAME="Heading18"></A>Drawing the Control</H2>
<P>Optimized drawing allows you to create drawing objects, such as pens or brushes.
Rather than remove them when you are finished drawing, you can store them as control
member variables and use them the next time your control draws itself. The benefit
is that you create a pen once for the drawing lifetime of your control, instead of
every time it draws. One thing to remember, though, is that optimized drawing does
not guarantee performance improvements. It simply supplies a framework for how drawing
should be performed and how drawing resources should be used. A poorly written control
is still poorly written, no matter how you slice it.</P>
<P>Standard and optimized drawings have a single tradeoff, and that is size versus
speed. Standard drawing does not require member variables for the drawing objects
that are created and used-- thus requiring less instance data but more processing
time--whereas optimized code is the opposite.</P>
<P>An additional drawback to optimized drawing is that a container may not support
it. A control must, at the very least, support standard drawing functionality, deferring
to optimized only if it is available.</P>
<P>For BaseCtl (like MFC and ATL), the scope of optimized drawing is very narrow
compared to the OC 96 specification, but its use can nonetheless result in performance
improvements. The OC 96 specification further breaks optimized drawing into what
is known as <I>aspects</I>. For more information on aspect drawing, please see the
OC 96 specification that ships with the ActiveX SDK.
<H3><A NAME="Heading19"></A>Optimized Drawing</H3>
<P>In <A HREF="ch10.htm">chapter 10</A>, you learn how to implement standard drawing.
In this chapter, you will enhance the original implementation to take advantage of
drawing optimization.</P>
<P>Listing 11.14 shows the optimized portion of your drawing implementation. If the
container doesn't support optimized drawing, you select the original brush back into
the Device Context (DC), and you destroy the brush you created. The next time that
the <TT>OnDraw</TT> function is executed, you re-create the brush. When using optimized,
you simply reuse the existing brush.
<H3><A NAME="Heading20"></A>Listing 11.14<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--Optimized
Drawing</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// **<BR>
<BR>
if(hOldFont)<BR>
<BR>
// select the old object<BR>
<BR>
::SelectObject(hdcDraw, hOldFont); <BR>
// increment the ref count so the font doesn't drop<BR>
<BR>
// out from under us<BR>
<BR>
if(m_pFont &amp;&amp; hFont)<BR>
<BR>
m_pFont-&gt;ReleaseHfont(hFont);<BR>
<BR>
// **<BR>
<BR>
// ****** Get the text font ****** <BR>
// The container does not support optimized drawing.<BR>
<BR>
if(!fOptimize)<BR>
<BR>
{<BR>
<BR>
// select the old brush back<BR>
<BR>
::SelectObject(hdcDraw, hOldBrush); <BR>
// destroy the brush we created<BR>
<BR>
::DeleteObject(hBrush); <BR>
// clear the brush handles<BR>
<BR>
hBrush = hOldBrush = NULL;<BR>
<BR>
} <BR>
return S_OK;<BR>
<BR>
}</TT></FONT></P>
<P>If the container supports optimized drawing, the final implementation detail is
to destroy any resources that may still be active, which you do in the <TT>BeforeDestroyWindow</TT>
function. Listing 11.15 shows the implementation that restores the original brush
and destroys the brush that you created.
<H3><A NAME="Heading21"></A>Listing 11.15 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--BeforeDestroyWindow
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::BeforeDestroyWindow(void)<BR>
<BR>
{<BR>
<BR>
// if there is an old brush<BR>
<BR>
if(hOldBrush)<BR>
<BR>
{<BR>
<BR>
// get the DC<BR>
<BR>
HDC hDC = this-&gt;OcxGetDC(); <BR>
// select the old brush back<BR>
<BR>
::SelectObject(hDC, hOldBrush); <BR>
// release the DC<BR>
<BR>
this-&gt;OcxReleaseDC(hDC);<BR>
<BR>
} <BR>
// if we created a brush<BR>
<BR>
if(hBrush)<BR>
<BR>
// destroy the brush we created<BR>
<BR>
::DeleteObject(hBrush); <BR>
}<BR>
</TT></FONT></P>
<P>The fact is the user will not care how great your code is written or how many
whiz-bang features it supports if it doesn't draw well. You'll be wise to spend some
time on your drawing implementation and get it right.
<H2><A NAME="Heading22"></A>Adding Clipboard and Drag and Drop Support</H2>
<P>The basic OLE Clipboard and Drag and Drop interfaces are not implemented within
the BaseCtl framework. As with the <TT>IPerPropertyBrowsing</TT> interface (see the
section &quot;Dynamic Property Enumeration&quot;), you must implement the required
interfaces yourself. As is pointed out in <A HREF="ch07.htm">Chapters 7</A> and <A
HREF="ch09.htm">9</A>, Clipboard and Drag and Drop support can add much to your control
implementation, while requiring very little work.
<H3><A NAME="Heading23"></A>Clipboard Support</H3>
<P>Clipboard support is based on the <TT>IDataObject</TT> and <TT>IEnumFORMATETC</TT>
interfaces. <TT>IDataObject</TT> is the interface through which the data is retrieved
from your object when it has been placed on the Clipboard, and <TT>IEnumFORMATETC</TT>
is the interface that is used by an application to determine what types of data your
<TT>IDataObject</TT> interface supports. <B><BR>
<BR>
Using Built-In Clipboard Formats </B><SPACER TYPE="HORIZONTAL" SIZE="10">As is pointed
out in <A HREF="ch07.htm">Chapter 7</A>, the Windows operating system (OS) supports
a number of built-in formats for transferring data via the Clipboard. Your first
implementation will be to transfer your caption using the <TT>CF_TEXT</TT><B> </B>format,
which is the built-in format for transferring <TT>ANSI</TT> text. There are two aspects
to using the Clipboard: being a Clipboard source and being a Clipboard target. You
will first look at enabling your control as a Clipboard source. <B><I><BR>
<BR>
Enabling a Control as a Clipboard Source </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">A
Clipboard source is an application that puts data on the Clipboard for other applications
to copy. You need to support two interfaces to enable your control as a Clipboard
source: <TT>IDataObject</TT><B><I> </I></B>and<B><I> </I></B><TT>IEnumFORMATETC</TT>.
When the user initiates a data transfer via the Clipboard, a reference to the control's
<TT>IDataObject</TT> interface is placed on the Clipboard. At the time the interface
is placed on the Clipboard, you must take a snapshot of the data that the control
contains and place it in a <TT>STGMEDIUM</TT> object. You have to do this because
the data may not be copied from the Clipboard immediately and the data needs to reflect
the state of the control when the copy operation was initiated rather than when the
paste operation takes place. Once the <TT>IDataObject</TT> interface is on the Clipboard,
you simply wait until someone requests the data. If a supported data format is requested,
you copy the data from your <TT>STGMEDIUM</TT> structure to the <TT>STGMEDIUM</TT>
structure that was passed to you.</P>
<P>First you need to declare your COM interfaces for supporting the <TT>IDataObject</TT>
and <TT>IEnumFORMATETC</TT> interfaces (see Listings 11.16 and 11.17).
<H3><A NAME="Heading24"></A>Listing 11.16 <SPACER TYPE="HORIZONTAL" SIZE="10">IDATAOBJECT.H--IDataObject
Interface Macro</H3>
<P><FONT COLOR="#0066FF"><TT>#define DECLARE_STANDARD_DATAOBJECT() \<BR>
STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM); \<BR>
STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM); \<BR>
STDMETHOD(QueryGetData)(LPFORMATETC); \<BR>
STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC); \<BR>
STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL); \<BR>
STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*); \<BR>
STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD); \<BR>
STDMETHOD(DUnadvise)(DWORD); \ <BR>
STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);<BR>
</TT></FONT></P>
<H3><A NAME="Heading25"></A>Listing 11.17<SPACER TYPE="HORIZONTAL" SIZE="10"> IENUMFORMATETC--IEnumFORMATETC
Interface Macro</H3>
<P><FONT COLOR="#0066FF"><TT>#define DECLARE_STANDARD_ENUMFORMATETC() \<BR>
STDMETHOD(Next)(ULONG celt, FORMATETC RPC_FAR * rgelt, \<BR>
ULONG_RPC_FAR * pceltFetched); \<BR>
STDMETHOD(Skip)(ULONG celt); \<BR>
STDMETHOD(Reset)(void); \ <BR>
STDMETHOD(Clone)(IEnumFORMATETC __RPC_FAR *__RPC_FAR * ppenum);<BR>
</TT></FONT></P>

<P>You need to include the header files of your new interface macros, add the <TT>IDataObject</TT>
and <TT>IEnumFORMATETC</TT> interfaces to your inheritance structure, and add the
interface macros to your control declaration. You also need to add some functions
and member variables to aid in your Clipboard support implementation (see Listing
11.18).</P>

<P>You use the functions <TT>CopyStgMedium</TT>, <TT>CopyDataToClipboard</TT>, and
<TT>PrepareDataForTransfer</TT> to prepare your data structures--the member variables
<TT>sTextFormatEtc</TT> and <TT>sTextStgMedium</TT>-- for a potential paste operation.
The member variable <TT>ulFORMATETCElement</TT> is the internal counter for the <TT>FORMATETC</TT>
enumerator interface, and <TT>OnKeyDown</TT> is where all of your Clipboard operations
are initiated.
<H3><A NAME="Heading26"></A>Listing 11.18<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--Clipboard
Support Implementation--Header File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;IPerPropertyBrowsing.h&quot;<BR>
#include &quot;IDataObject.h&quot;<BR>
#include &quot;IEnumFORMATETC.h&quot; <BR>
#include &quot;alignmentenums.h&quot; <BR>
typedef enum<BR>
{<BR>
BCFControlEvent_Change = 0,<BR>
} BCFCONTROLEVENTS; <BR>
. . . <BR>
//<BR>
class CBCFControlControl : public CInternetControl, public IBCFControl,<BR>
public ISupportErrorInfo, public IPerPropertyBrowsing, public IDataObject,<BR>
public IEnumFORMATETC<BR>
{<BR>
public: <BR>
. . . // ISupportErrorInfo methods<BR>
//<BR>
<BR>
DECLARE_STANDARD_SUPPORTERRORINFO(); <BR>
// IPerPropertyBrowsing methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_PERPROPERTYBROWSING(); <BR>
// IDataObject methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_DATAOBJECT(); <BR>
// IEnumFORMATETC methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_ENUMFORMATETC(); <BR>
// IBCFControl methods<BR>
<BR>
//<BR>
<BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* lRetValue);<BR>
<BR>
STDMETHOD(put_Alignment)(THIS_ long lNewValue);<BR>
<BR>
STDMETHOD(get_BackColor)(THIS_ OLE_COLOR FAR* ocRetValue); <BR>
. . . <BR>
void GetTextExtent(HDC hDC, LPCTSTR lpctstrString, int &amp; cx, int &amp; cy);<BR>
<BR>
BOOL bRetrievedDimensions;<BR>
<BR>
int iCharWidthArray[256];<BR>
<BR>
int iCharacterSpacing, iCharacterHeight;<BR>
<BR>
void CopyStgMedium(LPSTGMEDIUM lpTargetStgMedium, LPSTGMEDIUM lpSourceStgMedium,
<BR>
<BR>
CLIPFORMAT cfSourceFormat);<BR>
<BR>
void CopyDataToClipboard(void);<BR>
<BR>
void PrepareDataForTransfer(void);<BR>
<BR>
ULONG ulFORMATETCElement;<BR>
<BR>
void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags); <BR>
private:<BR>
<BR>
FORMATETC sTextFormatEtc;<BR>
<BR>
STGMEDIUM sTextStgMedium; <BR>
};<BR>
</TT></FONT></P>

<P>You need to update the constructor to initialize your enumerator to the beginning
of the enumeration (see Listing 11.19).
<H3><A NAME="Heading27"></A>Listing 11.19 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Constructor
Member Initialization</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
hOldBrush = hBrush = NULL; <BR>
// clear the flag<BR>
<BR>
bRetrievedDimensions = FALSE; <BR>
// set to the first element<BR>
<BR>
ulFORMATETCElement = 0; <BR>
// clear the storage medium<BR>
<BR>
sTextStgMedium.hGlobal = NULL;<BR>
<BR>
} <BR>
#pragma warning(default:4355) // using `this' in constructor<BR>
</TT></FONT></P>
<P>Since you have added two additional COM interfaces to your control, you also need
to update your <TT>QueryInterface</TT> implementation (see Listing 11.20).
<H3><A NAME="Heading28"></A>Listing 11.20<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--QueryInterface
Update</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CBCFControlControl::InternalQueryInterface(REFIID
riid, void **ppvObjOut)<BR>
<BR>
{<BR>
<BR>
IUnknown *pUnk; <BR>
*ppvObjOut = NULL; <BR>
// TODO: if you want to support any additional interfaces, then you should<BR>
<BR>
// indicate that here. never forget to call COleControl's version in the<BR>
<BR>
// case where you don't support the given interface.<BR>
<BR>
//<BR>
<BR>
if(DO_GUIDS_MATCH(riid, IID_IBCFControl))<BR>
<BR>
pUnk = (IUnknown *)(IBCFControl *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IPerPropertyBrowsing))<BR>
<BR>
pUnk = (IUnknown *)(IPerPropertyBrowsing *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IDataObject))<BR>
<BR>
pUnk = (IUnknown *)(IDataObject *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IEnumFORMATETC))<BR>
<BR>
pUnk = (IUnknown *)(IEnumFORMATETC *)this;<BR>
<BR>
else<BR>
<BR>
return COleControl::InternalQueryInterface(riid, ppvObjOut); <BR>
pUnk-&gt;AddRef();<BR>
<BR>
*ppvObjOut = (void *)pUnk;<BR>
<BR>
return S_OK; <BR>
}<BR>
</TT></FONT></P>
<P>You also need to update your <TT>WindowProc</TT> function to look for the <TT>WM_KEYDOWN</TT>
message so that you can process the keystrokes that will initiate your Clipboard
data transfer (see Listing 11.21). <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Listing 11.21 contains a <TT>switch</TT> statement that is used to
	route Windows messages to the proper message handler. The default handler will call
	the method <TT>OcxDefWindowProc</TT>. Whenever you want to use the default implementation
	for a message, you call <TT>OcxDefWindowProc</TT>. <TT>OcxDefWindowProc</TT> is designed
	to deal with the cases when the control does not have a window handle, because the
	control may have been created as windowless. Remember that the control will not have
	its own window handle when it is created windowless, so you should never use the
	handle directly. Always allow the default BaseCtl implementation to handle the windowless
	processing of messages.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading29"></A>Listing 11.21<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--WM_KEYDOWN
Message Handler</H3>
<P><FONT COLOR="#0066FF"><TT>LRESULT CBCFControlControl::WindowProc<BR>
<BR>
(<BR>
<BR>
UINT msg,<BR>
<BR>
WPARAM wParam,<BR>
<BR>
LPARAM lParam<BR>
<BR>
)<BR>
<BR>
{<BR>
<BR>
// TODO: handle any messages here, like in a normal window<BR>
<BR>
// proc. note that for special keys, you'll want to override and<BR>
<BR>
// implement OnSpecialKey.<BR>
<BR>
// if you're a windowed OCX, you should be able to use any of the<BR>
<BR>
// win32 API routines except for SetFocus. you should always use<BR>
<BR>
// OcxSetFocus()<BR>
<BR>
// <BR>
LRESULT lRetVal = FALSE; <BR>
switch(msg)<BR>
<BR>
{<BR>
<BR>
case WM_KEYDOWN:<BR>
<BR>
this-&gt;OnKeyDown(wParam, LOWORD(lParam), HIWORD(lParam));<BR>
<BR>
break;<BR>
<BR>
default:<BR>
<BR>
lRetVal = OcxDefWindowProc(msg, wParam, lParam);<BR>
<BR>
break;<BR>
<BR>
} <BR>
return lRetVal; <BR>
}<BR>
</TT></FONT></P>
<P>Finally you need to add all of the code for the methods that you declared in your
header file. Take a look at all of the methods in detail.</P>
<P>The <TT>CopyDataToClipboard</TT> is function called to initiate a Clipboard transfer
(see Listing 11.22). You first check to see whether you are the owner of the Clipboard
and set the Boolean variable accordingly. You then prepare your data for the Clipboard,
and if you are not the owner of the Clipboard, you flush the data on it and set your
<TT>IDataObject</TT> reference on the Clipboard.
<H3><A NAME="Heading30"></A>Listing 11.22 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--CopyDataToClipboard
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::CopyDataToClipboard(void)<BR>
<BR>
{<BR>
<BR>
BOOL bHaveClipboard = TRUE; <BR>
// if we don't have an IDataObject on the clipboard?<BR>
<BR>
if(::OleIsCurrentClipboard((IDataObject *) this) != S_OK)<BR>
<BR>
// set the flag<BR>
<BR>
bHaveClipboard = FALSE; <BR>
// put data in the storage<BR>
<BR>
this-&gt;PrepareDataForTransfer(); <BR>
// if we don't have the clipboard<BR>
<BR>
if(!bHaveClipboard)<BR>
<BR>
{<BR>
<BR>
// clear the clipboard<BR>
<BR>
::OleFlushClipboard(); <BR>
// put the data on the clipboard<BR>
<BR>
::OleSetClipboard((IDataObject *) this);<BR>
<BR>
} <BR>
}<BR>
</TT></FONT></P>
<P><TT>PrepareDataForTransfer</TT> (see Listing 11.23) is the function you call when
you want to copy the data from your control to the <TT>STGMEDIUM</TT> structure that
will represent your data on the Clipboard. First you allocate a block of global memory
that will contain your caption in <TT>ANSI</TT> format. Then you set up your <TT>FORMATETC</TT>
and <TT>STGMEDIUM</TT> structures to reflect the correct data type.
<H3><A NAME="Heading31"></A>Listing 11.23<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--PrepareDataForTransfer
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::PrepareDataForTransfer(void)<BR>
<BR>
{<BR>
<BR>
// get the length of the data to copy<BR>
<BR>
long lLength = lstrlen(m_lptstrCaption) + 1; <BR>
// create a global memory object<BR>
<BR>
HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,<BR>
<BR>
sizeof(TCHAR) * lLength);<BR>
<BR>
<BR>
<BR>
// lock the memory down<BR>
<BR>
LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(hGlobal); <BR>
// copy the string<BR>
<BR>
for(long lCount = 0; lCount &lt; lLength - 1; lCount++)<BR>
<BR>
lpTempBuffer[lCount] = m_lptstrCaption[lCount]; <BR>
// null terminate the string<BR>
<BR>
lpTempBuffer[lCount] = `\0'; <BR>
// unlock the memory<BR>
<BR>
::GlobalUnlock(hGlobal); <BR>
// copy all of the members<BR>
<BR>
sTextFormatEtc.cfFormat = CF_TEXT;<BR>
<BR>
sTextFormatEtc.ptd = NULL;<BR>
<BR>
sTextFormatEtc.dwAspect = 0;<BR>
<BR>
sTextFormatEtc.lindex = -1;<BR>
<BR>
sTextFormatEtc.tymed = TYMED_HGLOBAL; <BR>
// if we have already allocated the data<BR>
<BR>
if(sTextStgMedium.hGlobal)<BR>
<BR>
// release it<BR>
<BR>
::ReleaseStgMedium(&amp;sTextStgMedium); <BR>
sTextStgMedium.tymed = TYMED_HGLOBAL;<BR>
<BR>
sTextStgMedium.hGlobal = hGlobal;<BR>
<BR>
sTextStgMedium.pUnkForRelease = NULL; <BR>
}<BR>
</TT></FONT></P>
<P><TT>CopyStgMedium</TT> (see Listing 11.24) is a simple helper function to copy
one <TT>STGMEDIUM</TT> structure to another. The function relies on the <TT>OleDuplicateData</TT>
function to create a new copy of the global memory stored in the source <TT>STGMEDIUM</TT>.
The copied data is then stored in the target <TT>STGMEDIUM</TT> structure.
<H3><A NAME="Heading32"></A>Listing 11.24 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--CopyStgMedium
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::CopyStgMedium(LPSTGMEDIUM lpTargetStgMedium,
<BR>
<BR>
LPSTGMEDIUM lpSourceStgMedium, CLIPFORMAT cfSourceFormat)<BR>
<BR>
{<BR>
<BR>
// copy the stgmedium members<BR>
<BR>
lpTargetStgMedium-&gt;tymed = lpSourceStgMedium-&gt;tymed;<BR>
<BR>
lpTargetStgMedium-&gt;pUnkForRelease = lpSourceStgMedium-&gt;pUnkForRelease;<BR>
<BR>
lpTargetStgMedium-&gt;hGlobal = ::OleDuplicateData(lpSourceStgMedium-&gt;hGlobal,
<BR>
<BR>
cfSourceFormat, GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT); <BR>
}<BR>
</TT></FONT></P>
<P>The next set of functions (see Listing 11.25) are implemented for the <TT>IDataObject</TT>
interface that you declared in your header file. A number of methods are not implemented
and return the value <TT>E_NOTIMPL</TT> because they are not needed for this implementation.</P>
<P><TT>GetData</TT> is the function called when you need to copy the data in your
<TT>STGMEDIUM</TT> structure to the <TT>STGMEDIUM</TT> structure that is supplied.
You first see whether the format that is requested matches the data that you support
and, if so, copy the data using your helper function.</P>
<P><TT>EnumFormatEtc</TT> is the method called when the requesting application wants
to enumerate your supported formats. You support only the <TT>DATADIR_GET</TT> direction,
which means you can support only the <TT>GetData</TT> function and not the <TT>SetData</TT>
function of the <TT>IDataObject</TT> interface.</P>
<P>The remainder of the functions are not implemented and simply return the constant
<TT>E_NOTIMPL</TT>.
<H3><A NAME="Heading33"></A>Listing 11.25 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--IDataObject
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::GetData(LPFORMATETC
lpFormatEtc, <BR>
<BR>
LPSTGMEDIUM lpStgMedium)<BR>
<BR>
{<BR>
<BR>
// if this is a format that we can deal with<BR>
<BR>
if(lpFormatEtc-&gt;cfFormat == CF_TEXT &amp;&amp; lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL)<BR>
<BR>
{<BR>
<BR>
// get a copy of the current stgmedium<BR>
<BR>
this-&gt;CopyStgMedium(lpStgMedium, &amp;sTextStgMedium, CF_TEXT); <BR>
return S_OK;<BR>
<BR>
}<BR>
<BR>
else<BR>
<BR>
return DATA_E_FORMATETC;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::GetDataHere(LPFORMATETC /*lpFormatEtc*/, <BR>
<BR>
LPSTGMEDIUM /*lpStgMedium*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::QueryGetData(LPFORMATETC /*lpFormatEtc*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::GetCanonicalFormatEtc(LPFORMATETC /*lpFormatEtcIn*/,<BR>
<BR>
LPFORMATETC /*lpFormatEtcOut*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::SetData(LPFORMATETC /*lpFormatEtc*/,<BR>
<BR>
LPSTGMEDIUM /*lpStgMedium*/,<BR>
<BR>
BOOL /*bRelease*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::EnumFormatEtc(DWORD dwDirection, <BR>
<BR>
LPENUMFORMATETC * ppenumFormatEtc)<BR>
<BR>
{<BR>
<BR>
// we support &quot;get&quot; operations<BR>
<BR>
if(dwDirection == DATADIR_GET)<BR>
<BR>
{<BR>
<BR>
// make the assignment<BR>
<BR>
*ppenumFormatEtc = (IEnumFORMATETC *) this;<BR>
<BR>
<BR>
<BR>
// increment the reference count<BR>
<BR>
(*ppenumFormatEtc)-&gt;AddRef(); <BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::DAdvise(FORMATETC * /*pFormatEtc*/, DWORD /*advf*/,<BR>
<BR>
LPADVISESINK /*pAdvSink*/, DWORD * /*pdwConnection*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::DUnadvise(DWORD /*dwConnection*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::EnumDAdvise(LPENUMSTATDATA * /*ppenumAdvise*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL; <BR>
}<BR>
</TT></FONT></P>
<P>The next set of functions (see Listing 11.26) are implemented for the <TT>IEnumFORMATETC</TT>
interface that you declared in your header file. Cloning is not supported and will
return the value <TT>E_NOTIMPL</TT>.</P>
<P>The <TT>Next</TT> function is used to enumerate through the entire list of supported
formats. You first check to see whether your counter is set to the first element
and that the user asked for at least one entry. If so, you set the <TT>FORMATETC</TT>
structure to your supported format, and if appropriate, you set the number of elements
that you are returning and increment the counter.</P>
<P>The <TT>Skip</TT> function advances the enumerator by the number of elements specified.</P>
<P>The <TT>Reset</TT> function sets the enumerator back to the beginning of the enumeration.
<H3><A NAME="Heading34"></A>Listing 11.26<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--IEnumFORMATETC
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::Next(ULONG celt, FORMATETC_RPC_FAR
* rgelt, <BR>
<BR>
ULONG RPC_FAR * pceltFetched)<BR>
<BR>
{<BR>
<BR>
// if we are at the beginning of the enumeration<BR>
<BR>
if(ulFORMATETCElement == 0 &amp;&amp; celt &gt; 0)<BR>
<BR>
{<BR>
<BR>
// copy all of the members<BR>
<BR>
rgelt-&gt;cfFormat = CF_TEXT;<BR>
<BR>
rgelt-&gt;ptd = NULL;<BR>
<BR>
rgelt-&gt;dwAspect = 0;<BR>
<BR>
rgelt-&gt;lindex = -1;<BR>
<BR>
rgelt-&gt;tymed = TYMED_HGLOBAL;<BR>
<BR>
<BR>
<BR>
// if the caller wants to know how many we copied<BR>
<BR>
if(pceltFetched)<BR>
<BR>
*pceltFetched = 1; <BR>
// increment the counter<BR>
<BR>
ulFORMATETCElement++; <BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
}<BR>
<BR>
else<BR>
<BR>
// return failure<BR>
<BR>
return S_FALSE;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::Skip(ULONG celt)<BR>
<BR>
{<BR>
<BR>
// move the counter by the number of elements supplied<BR>
<BR>
ulFORMATETCElement += celt;<BR>
<BR>
<BR>
<BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::Reset(void)<BR>
<BR>
{<BR>
<BR>
// reset to the beginning of the enumerator<BR>
<BR>
ulFORMATETCElement = 0;<BR>
<BR>
<BR>
<BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::Clone(IEnumFORMATETC RPC_FAR *__RPC_FAR * /*ppenum*/)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL; <BR>
}<BR>
</TT></FONT></P>
<P>Finally you are at the end of your implementation: the <TT>OnKeyDown</TT> function
(see Listing 11.27). The <TT>OnKeyDown</TT> contains all of the code that is necessary
to look for the common keystroke combinations used to initiate Clipboard operations.
<H3><A NAME="Heading35"></A>Listing 11.27 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--OnKeyDown
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::OnKeyDown(UINT nChar, UINT
nRepCnt, UINT nFlags)<BR>
<BR>
{<BR>
<BR>
BOOL bHandled = FALSE; <BR>
// find out if the shift key is being held down<BR>
<BR>
short sShift = ::GetKeyState(VK_SHIFT);<BR>
<BR>
// find out if the control key is being held down<BR>
<BR>
short sControl = ::GetKeyState(VK_CONTROL); <BR>
switch(nChar)<BR>
<BR>
{<BR>
<BR>
// COPY or PASTE<BR>
<BR>
case 0x43: // `C'<BR>
<BR>
case 0x63: // `c' <BR>
<BR>
// if the control key is being held down<BR>
<BR>
if(sControl &amp; 0x8000)<BR>
<BR>
{<BR>
<BR>
// copy the data to the clipboard<BR>
<BR>
this-&gt;CopyDataToClipboard(); <BR>
// we don't need to pass this key to the base implementation<BR>
<BR>
bHandled = TRUE;<BR>
<BR>
}<BR>
<BR>
break;<BR>
<BR>
case 0x58: // `X'<BR>
<BR>
case 0x78: // `x'<BR>
<BR>
case VK_DELETE:<BR>
<BR>
// if this is a shift delete OR CTRL-X/x<BR>
<BR>
if((nChar == VK_DELETE &amp;&amp; (sShift &amp; 0x8000)) || <BR>
<BR>
((nChar == 0x58 || nChar == 0x78) &amp;&amp; (sControl &amp; 0x8000)))<BR>
<BR>
{<BR>
<BR>
this-&gt;CopyDataToClipboard(); <BR>
// clear the string since this is a CUT operation<BR>
<BR>
delete [] m_lptstrCaption; <BR>
// NULL terminate the string reference<BR>
<BR>
m_lptstrCaption = new TCHAR[1];<BR>
<BR>
m_lptstrCaption[0] = `\0'; <BR>
// fire the global change event<BR>
<BR>
this-&gt;FireChange(); <BR>
// force the control to repaint itself<BR>
<BR>
this-&gt;InvalidateControl(NULL); <BR>
// we don't need to pass this key to the base implementation<BR>
<BR>
bHandled = TRUE;<BR>
<BR>
}<BR>
<BR>
break;<BR>
<BR>
} <BR>
// if we didn't handle the character<BR>
<BR>
if(!bHandled)<BR>
<BR>
{<BR>
<BR>
// and the control key is not being held down<BR>
<BR>
if(!(sControl &amp; 0x8000))<BR>
<BR>
// send to the default handler<BR>
<BR>
this-&gt;OcxDefWindowProc(WM_KEYDOWN, (WPARAM) nFlags, <BR>
<BR>
MAKELPARAM(nRepCnt, nFlags));<BR>
<BR>
} <BR>
}<BR>
</TT></FONT></P>
<P>Now that you know how to put data on the Clipboard, take a look at how you get
data off the Clipboard. <B><I><BR>
<BR>
Enabling a Control as a Clipboard Target </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">The
opposite of being a Clipboard source is being a Clipboard target. The first step
in enabling your control as a Clipboard target is to update your header file with
two additional member functions: <TT>GetDataFromClipboard</TT><B><I> </I></B>and
<TT>GetDataFromTransfer</TT> (see Listing 11.28).
<H3><A NAME="Heading36"></A>Listing 11.28 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROCTL.H--Clipboard
Target Implementation-- Header File</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
<BR>
void CopyDataToClipboard(void);<BR>
<BR>
void PrepareDataForTransfer(void);<BR>
<BR>
void GetDataFromClipboard(void);<BR>
<BR>
void GetDataFromTransfer(IDataObject * ipDataObj);<BR>
<BR>
ULONG ulFORMATETCElement;<BR>
<BR>
void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags); <BR>
private:<BR>
<BR>
FORMATETC sTextFormatEtc; <BR>
. . .<BR>
</TT></FONT></P>
<P>The next step is to update your source file with the <TT>GetDataFromClipboard</TT>
and <TT>GetDataFromTransfer</TT> implementations (see Listing 11.29). The first method,
<TT>GetDataFromClipboard</TT>, which, as the name implies, gets the data from the
Clipboard and transfers it to your control. <TT>GetDataFromClipboard</TT> first checks
the Clipboard to see whether you already own it. If you do, you refresh the control's
data with the data that is stored in the <TT>STGMEDIUM </TT>structure. You do this
because the data stored in the control may have changed since the data was originally
pasted to the Clipboard.</P>
<P>If you don't already own the Clipboard, you get the <TT>IDataObject</TT> reference
of the object that does and pass it on to your <TT>GetDataFromTransfer</TT> function.
<H3><A NAME="Heading37"></A>Listing 11.29<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--GetDataFromClipboard
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::GetDataFromClipboard(void)<BR>
<BR>
{<BR>
<BR>
// get an IDataObject pointer<BR>
<BR>
IDataObject * ipClipboardDataObj = NULL; <BR>
// do we have an IDataObject on the clipboard?<BR>
<BR>
if(::OleIsCurrentClipboard((IDataObject *) this) == S_OK)<BR>
<BR>
{<BR>
<BR>
// get the global data for this format and lock down the memory<BR>
<BR>
LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(sTextStgMedium.hGlobal); <BR>
// if we have a string<BR>
<BR>
if(m_lptstrCaption)<BR>
<BR>
{<BR>
<BR>
// delete the existing string<BR>
<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
<BR>
m_lptstrCaption = NULL;<BR>
<BR>
} <BR>
// allocate a new string<BR>
<BR>
m_lptstrCaption = new TCHAR[lstrlen(lpTempBuffer) + 1]; <BR>
// assign the string to our member variable<BR>
<BR>
lstrcpy(m_lptstrCaption, lpTempBuffer); <BR>
// unlock the memory<BR>
<BR>
::GlobalUnlock(sTextStgMedium.hGlobal); <BR>
return;<BR>
<BR>
}<BR>
<BR>
else if(::OleGetClipboard(&amp;ipClipboardDataObj) == S_OK)<BR>
<BR>
{<BR>
<BR>
// transfer the data to the control<BR>
<BR>
this-&gt;GetDataFromTransfer(ipClipboardDataObj); <BR>
// release the IDataObject<BR>
<BR>
ipClipboardDataObj-&gt;Release();<BR>
<BR>
} <BR>
}<BR>
</TT></FONT></P>
<P><TT>GetDataFromTransfer</TT> requests the <TT>IEnumFORMATETC</TT> interface from
the <TT>IDataObject</TT> and cycles through all of the supported formats looking
for one that matches yours (see Listing 11.30). Upon finding the appropriate format,
it requests the data from the <TT>IDataObject</TT> supplying a <TT>FORMATETC</TT>
and <TT>STGMEDIUM</TT> structure. The data is transferred to the control, and the
<TT>STGMEDUIM</TT> is released. The next thing you do is release your interface pointers.
The last step, if you find a format, is to force the control to repaint itself reflecting
the new state of the control.
<H3><A NAME="Heading38"></A>Listing 11.30 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--GetDataFromTransfer
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::GetDataFromTransfer(IDataObject
* ipDataObj)<BR>
<BR>
{ <BR>
<BR>
IEnumFORMATETC * ipenumFormatetc;<BR>
<BR>
BOOL bFound = FALSE; <BR>
// get a FORMATETC enumerator<BR>
<BR>
if(ipDataObj-&gt;EnumFormatEtc(DATADIR_GET, &amp;ipenumFormatetc) == S_OK)<BR>
<BR>
{<BR>
<BR>
// reset the enumerator just to be safe<BR>
<BR>
ipenumFormatetc-&gt;Reset(); <BR>
FORMATETC etc; <BR>
// while there are formats to enumerate<BR>
<BR>
while(ipenumFormatetc-&gt;Next(1, &amp;etc, NULL) == S_OK &amp;&amp; !bFound)<BR>
<BR>
{<BR>
<BR>
// is this a format that we are looking for?<BR>
<BR>
if(etc.cfFormat == CF_TEXT &amp;&amp; etc.tymed &amp; TYMED_HGLOBAL)<BR>
<BR>
{<BR>
<BR>
STGMEDIUM sStgMediumData; <BR>
// get the data from the stgmedium<BR>
<BR>
if(ipDataObj-&gt;GetData(&amp;etc, &amp;sStgMediumData) == S_OK)<BR>
<BR>
{<BR>
<BR>
// get the global data for this format and lock down the memory<BR>
<BR>
LPTSTR lpTempBuffer = <BR>
<BR>
(LPTSTR) ::GlobalLock(sStgMediumData.hGlobal); <BR>
// if we have a string<BR>
<BR>
if(m_lptstrCaption)<BR>
<BR>
{<BR>
<BR>
// delete the existing string<BR>
<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
<BR>
m_lptstrCaption = NULL;<BR>
<BR>
} <BR>
// allocate a new string<BR>
<BR>
m_lptstrCaption = new TCHAR[lstrlen(lpTempBuffer) + 1]; <BR>
// assign the string to our member variable<BR>
<BR>
lstrcpy(m_lptstrCaption, lpTempBuffer); <BR>
// unlock the memory<BR>
<BR>
::GlobalUnlock(sStgMediumData.hGlobal); <BR>
// release the storage medium<BR>
<BR>
::ReleaseStgMedium(&amp;sStgMediumData); <BR>
// terminate the loop<BR>
<BR>
bFound = TRUE;<BR>
<BR>
}<BR>
<BR>
}<BR>
<BR>
}<BR>
<BR>
<BR>
<BR>
// release the enumerator<BR>
<BR>
ipenumFormatetc-&gt;Release();<BR>
<BR>
} <BR>
// if we found a format<BR>
<BR>
if(bFound == TRUE)<BR>
<BR>
// force the control to repaint itself<BR>
<BR>
this-&gt;InvalidateControl(NULL); <BR>
}<BR>
</TT></FONT></P>
<P>Last you add the code that will initiate the transfer; you do this in your <TT>OnKeyDown</TT>
function (see Listing 11.31).
<H3><A NAME="Heading39"></A>Listing 11.31 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROCTL.CPP--OnKeyDown
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::OnKeyDown(UINT nChar, UINT
nRepCnt, UINT nFlags)<BR>
<BR>
{<BR>
<BR>
BOOL bHandled = FALSE; <BR>
// find out if the shift key is being held down<BR>
<BR>
short sShift = ::GetKeyState(VK_SHIFT);<BR>
<BR>
// find out if the control key is being held down<BR>
<BR>
short sControl = ::GetKeyState(VK_CONTROL); <BR>
switch(nChar)<BR>
<BR>
{<BR>
<BR>
// PASTE<BR>
<BR>
case 0x56: // `V'<BR>
<BR>
case 0x76: // `v' <BR>
<BR>
// if the control key is being held down<BR>
<BR>
if(sControl &amp; 0x8000)<BR>
<BR>
{<BR>
<BR>
// get any text from the clipboard<BR>
<BR>
this-&gt;GetDataFromClipboard(); <BR>
// force the control to redraw itself<BR>
<BR>
this-&gt;InvalidateControl(NULL); <BR>
// we don't need to pass this key to the base implementation<BR>
<BR>
bHandled = TRUE;<BR>
<BR>
}<BR>
<BR>
break;<BR>
<BR>
// COPY or PASTE<BR>
<BR>
case 0x43: // `C'<BR>
<BR>
case 0x63: // `c' <BR>
<BR>
case VK_INSERT:<BR>
<BR>
// if the control key is being held down<BR>
<BR>
if(sControl &amp; 0x8000)<BR>
<BR>
{<BR>
<BR>
// copy the data to the clipboard<BR>
<BR>
this-&gt;CopyDataToClipboard(); <BR>
// we don't need to pass this key to the base implementation<BR>
<BR>
bHandled = TRUE;<BR>
<BR>
}<BR>
<BR>
// if the shift key is being held down it is a PASTE<BR>
<BR>
else if(sShift &amp; 0x8000 &amp;&amp; nChar == VK_INSERT)<BR>
<BR>
{<BR>
<BR>
// get any text from the clipboard<BR>
<BR>
this-&gt;GetDataFromClipboard(); <BR>
// force the control to redraw itself<BR>
<BR>
this-&gt;InvalidateControl(NULL); <BR>
// we don't need to pass this key to the base implementation<BR>
<BR>
bHandled = TRUE;<BR>
<BR>
}<BR>
<BR>
break;<BR>
<BR>
case 0x58: // `X'<BR>
<BR>
case 0x78: // `x'<BR>
<BR>
case VK_DELETE:<BR>
<BR>
// if this is a shift delete OR CTRL-X/x <BR>
. . .</TT></FONT></P>
<P>While not as simple to implement as MFC, Clipboard support in a BaseCtl implementation
can be added in a relatively short period of time with very satisfying results.</P>
<P>To round out your implementation, you take the next logical step, which is Drag
and Drop support.
<H3><A NAME="Heading40"></A>Adding Drag and Drop Support</H3>
<P>The fundamentals of <I>Drag and Drop</I> are very similar to Clipboard support.
In addition to the Clipboard interfaces, Drag and Drop requires two new interfaces:
<TT>IDropSource</TT> and <TT>IDropTarget</TT>. <TT>IDropSource</TT> is for those
controls that can create data that can be dropped onto another application. <TT>IDropTarget</TT>
is for those controls that can accept data that has been dropped from another application.
<B><BR>
<BR>
Using Built-In Drag and Drop Formats</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>Since
Drag and Drop is similar to a Clipboard transfer, it relies on the same built-in
data formats as Clipboard transfers. See the section entitled &quot;Using Built-In
Clipboard Formats&quot; for more information regarding the types of formats available.
Enabling a BaseCtl control implementation for Drag and Drop support is similar in
complexity to the work you did to enable Clipboard transfers. <B><I><BR>
<BR>
Enabling a Control as a Drag and Drop Source </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">The
first part of your implementation is to enable your control as a Drag and Drop source.
To be a Drag and Drop source, the control must implement the <TT>IDropSource</TT>
interface in addition to the <TT>IDataObject</TT> and<B><I> </I></B><TT>IEnumFORMATETC</TT>
interfaces. The <TT>IDropSource</TT> interface is declared in the same manner as
your other COM interfaces (see Listing 11.32). The implementation is fairly simple
since the interface consists of only two methods.
<H3><A NAME="Heading41"></A>Listing 11.32<SPACER TYPE="HORIZONTAL" SIZE="10"> IDROPSOURCE.H--IDropSource
Interface</H3>
<P><FONT COLOR="#0066FF"><TT>#define DECLARE_STANDARD_DROPSOURCE() \<BR>
STDMETHOD(QueryContinueDrag)(BOOL fEscapePressed, DWORD dwKeyState); \<BR>
STDMETHOD(GiveFeedback)(DWORD dwEffect);</TT></FONT></P>
<P>Next you add the include file for the new interface, inherit your control from
the interface, and add your interface macro to your control implementation (see Listing
11.33). You also add the prototype for <TT>OnLButtonDown</TT>, which is the function
that initiates your Drag and Drop operation.
<H3><A NAME="Heading42"></A>Listing 11.33 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROCTL.H--IDropSource
Interface Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;IEnumFORMATETC.h&quot;<BR>
<BR>
#include &quot;IDropSource.h&quot; <BR>
#include &quot;alignmentenums.h&quot; <BR>
. . . <BR>
class CBCFControlControl : public CInternetControl, public IBCFControl,<BR>
<BR>
public ISupportErrorInfo, public IPerPropertyBrowsing, public IDataObject,<BR>
<BR>
public IEnumFORMATETC, public IDropSource<BR>
<BR>
{<BR>
<BR>
public: <BR>
. . . <BR>
// IDropSource methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_DROPSOURCE(); <BR>
// IBCFControl methods<BR>
<BR>
//<BR>
<BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* lRetValue);<BR>
<BR>
STDMETHOD(put_Alignment)(THIS_ long lNewValue); <BR>
. . . <BR>
ULONG ulFORMATETCElement;<BR>
<BR>
void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);<BR>
<BR>
void OnLButtonDown(UINT nFlags, short sHor, short sVer); <BR>
private:<BR>
<BR>
FORMATETC sTextFormatEtc;<BR>
<BR>
STGMEDIUM sTextStgMedium;<BR>
<BR>
}; . . .<BR>
</TT></FONT></P>
<P>Since you added a new interface, you also need to update your <TT>QueryInterface</TT>
function (see Listing 11.34).
<H3><A NAME="Heading43"></A>Listing 11.34 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--QueryInterface
Update</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CBCFControlControl::InternalQueryInterface(REFIID
riid, void <BR>
**ppvObjOut)<BR>
<BR>
{<BR>
<BR>
IUnknown *pUnk; <BR>
*ppvObjOut = NULL; <BR>
// TODO: if you want to support any additional interfaces, then you should<BR>
<BR>
// indicate that here. never forget to call COleControl's version in the<BR>
<BR>
// case where you don't support the given interface.<BR>
<BR>
//<BR>
<BR>
if(DO_GUIDS_MATCH(riid, IID_IBCFControl))<BR>
<BR>
pUnk = (IUnknown *)(IBCFControl *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IPerPropertyBrowsing))<BR>
<BR>
pUnk = (IUnknown *)(IPerPropertyBrowsing *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IDataObject))<BR>
<BR>
pUnk = (IUnknown *)(IDataObject *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IEnumFORMATETC))<BR>
<BR>
pUnk = (IUnknown *)(IEnumFORMATETC *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IDropSource))<BR>
<BR>
pUnk = (IUnknown *)(IDropSource *)this;<BR>
<BR>
else<BR>
<BR>
return COleControl::InternalQueryInterface(riid, ppvObjOut); <BR>
pUnk-&gt;AddRef();<BR>
<BR>
*ppvObjOut = (void *)pUnk;<BR>
<BR>
return S_OK; <BR>
}<BR>
</TT></FONT></P>
<P>You have to update your <TT>WindowProc</TT> function to route the <TT>WM_LBUTTONDOWN</TT>
messages to your <TT>OnLButtonDown</TT> function (see Listing 11.35).
<H3><A NAME="Heading44"></A>Listing 11.35<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--WindowProc
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>LRESULT CBCFControlControl::WindowProc(UINT msg, WPARAM
wParam, LPARAM lParam)<BR>
<BR>
{<BR>
<BR>
LRESULT lRetVal = FALSE; <BR>
switch(msg)<BR>
<BR>
{<BR>
<BR>
case WM_KEYDOWN:<BR>
<BR>
this-&gt;OnKeyDown(wParam, LOWORD(lParam), HIWORD(lParam));<BR>
<BR>
break;<BR>
<BR>
case WM_LBUTTONDOWN:<BR>
<BR>
this-&gt;OnLButtonDown(wParam, (short) LOWORD(lParam), (short) HIWORD(lParam));<BR>
<BR>
this-&gt;OcxDefWindowProc(msg, wParam, lParam);<BR>
<BR>
break;<BR>
<BR>
default:<BR>
<BR>
lRetVal = this-&gt;OcxDefWindowProc(msg, wParam, lParam);<BR>
<BR>
break;<BR>
<BR>
} <BR>
return lRetVal; <BR>
}<BR>
</TT></FONT></P>
<P>Next you need to implement your <TT>OnLButtonDown</TT> function and the two interface
functions for your <TT>IDropSource</TT> interface (see Listing 11.36).</P>
<P>When <TT>OnLButtonDown</TT> is called, the control calls your <TT>PrepareDataForTransfer</TT>
function to set up the data in your <TT>IDataObject</TT> interface. You then call
<TT>DoDragDrop</TT> supplying the <TT>IDataObject</TT> and <TT>IDropSource</TT> interfaces
and the drop effect that you want to display. See the VC++ documentation for more
information about the <TT>IDataObject</TT> and <TT>IDataSource</TT> interfaces and
the types of drop effects that you have at your disposal.</P>
<P><TT>QueryContinueDrag</TT> is used to instruct OLE as to how the Drag and Drop
operation should be handled at the time the state of the keyboard or mouse changes.
When the keyboard or mouse state changes, it is usually indicative of a drop operation.
In your case, you look to see whether the left mouse button is no longer being held
down. If that is the case, the drop operation is completed. Otherwise, you just exit
the method.</P>
<P><TT>GiveFeedback</TT> is used to instruct OLE as to what cursors should be used
while performing the Drag and Drop operation. In your case, you use the default cursors.
See the VC++ documentation for more information on how to support different cursors.
<H3><A NAME="Heading45"></A>Listing 11.36<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--Drop
Source Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::OnLButtonDown(UINT nFlags,
short sHor, short sVer)<BR>
<BR>
{<BR>
<BR>
// call the common data preparation function<BR>
<BR>
this-&gt;PrepareDataForTransfer(); <BR>
DWORD dwDropEffect = DROPEFFECT_NONE;<BR>
<BR>
<BR>
<BR>
// start the Drag and Drop operation<BR>
<BR>
::DoDragDrop((IDataObject *) this, (IDropSource *) this, DROPEFFECT_COPY, <BR>
<BR>
&amp;dwDropEffect);<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::QueryContinueDrag(BOOL fEscapePressed, <BR>
<BR>
DWORD dwKeyState)<BR>
<BR>
{<BR>
<BR>
// if the left button has been released<BR>
<BR>
if(!(dwKeyState &amp; MK_LBUTTON))<BR>
<BR>
// it is OK to drop<BR>
<BR>
return DRAGDROP_S_DROP;<BR>
<BR>
else<BR>
<BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::GiveFeedback(DWORD dwEffect)<BR>
<BR>
{<BR>
<BR>
// use the default cursors<BR>
<BR>
return DRAGDROP_S_USEDEFAULTCURSORS;<BR>
<BR>
}</TT></FONT></P>
<P>As you can see, very little code is required to be a Drag and Drop source, but
being a Drag and Drop source is only half the battle. To develop a truly complete
implementation, you need to include support as a Drag and Drop target. <B><I><BR>
<BR>
Enabling a Control as a Drag and Drop Target </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">As
with your Drag and Drop source support, you build upon the interfaces you've already
created and add some new functionality. To be a Drag and Drop target, a control must
implement the <TT>IDropTarget</TT> interface (see Listing 11.37).
<H3><A NAME="Heading46"></A>Listing 11.37 <SPACER TYPE="HORIZONTAL" SIZE="10">IDROPTARGET.H--IDropTarget
Interface</H3>
<P><FONT COLOR="#0066FF"><TT>#define DECLARE_STANDARD_IDROPTARGET() \<BR>
<BR>
STDMETHOD(DragEnter)(LPDATAOBJECT pDataObject, DWORD dwKeyState, POINTL pt, <BR>
<BR>
LPDWORD pdwEffect); \<BR>
<BR>
STDMETHOD(DragOver)(DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect); \<BR>
<BR>
STDMETHOD(DragLeave)(void); \<BR>
<BR>
STDMETHOD(Drop)(LPDATAOBJECT pDataObject, DWORD dwKeyState, POINTL pt, \ <BR>
LPDWORD pdwEffect);<BR>
</TT></FONT></P>
<P>Now that you have your interface macro declared, you need to add the interface
to your control implementation. To do this, you need to add your macro include file,
inherit from the COM interface, and add the <TT>IDropTarget</TT> macro to your control
(see Listing 11.38). You also add the <TT>AfterCreateWindow</TT> function, which
is defined in the <TT>COleControl</TT> base class. <TT>AfterCreateWindow</TT> is
where you register your control as a valid Drag and Drop target.
<H3><A NAME="Heading47"></A>Listing 11.38<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--IDropTarget
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;IDataObject.h&quot;<BR>
<BR>
#include &quot;IEnumFORMATETC.h&quot;<BR>
<BR>
#include &quot;IDropSource.h&quot;<BR>
<BR>
#include &quot;IDropTarget.h&quot; <BR>
#include &quot;alignmentenums.h&quot; <BR>
. . . <BR>
class CBCFControlControl : public CInternetControl, public IBCFControl,<BR>
<BR>
public ISupportErrorInfo, public IPerPropertyBrowsing, public IDataObject,<BR>
<BR>
public IEnumFORMATETC, public IDropSource, public IDropTarget<BR>
<BR>
{<BR>
<BR>
public: <BR>
. . . <BR>
// IDropTarget methods<BR>
<BR>
//<BR>
<BR>
DECLARE_STANDARD_IDROPTARGET(); <BR>
// IBCFControl methods<BR>
<BR>
// <BR>
. . . <BR>
virtual HRESULT InternalQueryInterface(REFIID, void **);<BR>
<BR>
virtual BOOL BeforeCreateWindow(DWORD *pdwWindowStyle, DWORD *pdwExWindowStyle, <BR>
<BR>
LPSTR pszWindowTitle);<BR>
<BR>
virtual void BeforeDestroyWindow(void);<BR>
<BR>
virtual BOOL AfterCreateWindow(void); <BR>
/// OnData is called asynchronously as data for an object or property arrives...<BR>
<BR>
virtual HRESULT OnData(DISPID propId, DWORD bscfFlag, IStream * strm, DWORD dwSize);
<BR>
// private state information.<BR>
<BR>
// . . .<BR>
</TT></FONT></P>
<P>Since you have a COM interface, you also need to update your <TT>QueryInterface</TT>
function (see Listing 11.39).
<H3><A NAME="Heading48"></A>Listing 11.39<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--QueryInterface
Update</H3>
<P>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
HRESULT CBCFControlControl::InternalQueryInterface(REFIID riid, void **ppvObjOut)<BR>
<BR>
{<BR>
<BR>
IUnknown *pUnk; <BR>
*ppvObjOut = NULL; <BR>
// TODO: if you want to support any additional interfaces, then you should<BR>
<BR>
// indicate that here. never forget to call COleControl's version in the<BR>
<BR>
// case where you don't support the given interface.<BR>
<BR>
//<BR>
<BR>
if(DO_GUIDS_MATCH(riid, IID_IBCFControl))<BR>
<BR>
pUnk = (IUnknown *)(IBCFControl *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IPerPropertyBrowsing))<BR>
<BR>
pUnk = (IUnknown *)(IPerPropertyBrowsing *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IDataObject))<BR>
<BR>
pUnk = (IUnknown *)(IDataObject *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IEnumFORMATETC))<BR>
<BR>
pUnk = (IUnknown *)(IEnumFORMATETC *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IDropSource))<BR>
<BR>
pUnk = (IUnknown *)(IDropSource *)this;<BR>
<BR>
else if(DO_GUIDS_MATCH(riid, IID_IDropTarget))<BR>
<BR>
pUnk = (IUnknown *)(IDropTarget *)this;<BR>
<BR>
else<BR>
<BR>
return COleControl::InternalQueryInterface(riid, ppvObjOut); <BR>
pUnk-&gt;AddRef();<BR>
<BR>
*ppvObjOut = (void *)pUnk;<BR>
<BR>
return S_OK; <BR>
}<BR>
</TT></FONT></P>
<P>In order for your control to be a Drop Target, it must do more than just support
the appropriate interfaces. You must register your control as a Drop Target. You
do this in the <TT>AfterCreateWindow</TT> function you added earlier. Listing 11.40
shows your implementation of your <TT>Register</TT> and, correspondingly, your <TT>Revoke</TT>
implementation. For this reason alone, your control must have a window. Controls
that support Windowless Activation can still be Drag and Drop targets, but they must
create a window when a Drag and Drop operation occurs. See the VC++ documentation
for more information on supporting Drag and Drop operations in windowless controls.
<H3><A NAME="Heading49"></A>Listing 11.40 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--AfterCreateWindow
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CBCFControlControl::AfterCreateWindow(void)<BR>
<BR>
{<BR>
<BR>
// if we have a window handle<BR>
<BR>
if(m_hwnd)<BR>
<BR>
// register the control as a drag and drop target<BR>
<BR>
::RegisterDragDrop(m_hwnd, (IDropTarget *) this); <BR>
return TRUE;<BR>
<BR>
} <BR>
void CBCFControlControl::BeforeDestroyWindow(void)<BR>
<BR>
{<BR>
<BR>
// if we have a window handle<BR>
<BR>
if(m_hwnd)<BR>
<BR>
// revoke the control as a drag and drop target<BR>
<BR>
::RevokeDragDrop(m_hwnd); <BR>
// if there is an old brush<BR>
<BR>
if(hOldBrush)<BR>
<BR>
{<BR>
<BR>
// get the DC<BR>
<BR>
HDC hDC = this-&gt;OcxGetDC(); <BR>
// select the old brush back<BR>
<BR>
::SelectObject(hDC, hOldBrush); <BR>
// release the DC<BR>
<BR>
this-&gt;OcxReleaseDC(hDC);<BR>
<BR>
} <BR>
// if we created a brush<BR>
<BR>
if(hBrush)<BR>
<BR>
// destroy the brush we created<BR>
<BR>
::DeleteObject(hBrush); <BR>
}<BR>
</TT></FONT></P>
<P>Last you implement your <TT>IDropTarget</TT> interface (see Listing 11.41).</P>
<P><TT>DragEnter</TT> is where you instruct OLE as to whether the current drag operation
that has entered your control is valid for your implementation. You first look for
the appropriate mouse or keyboard state, which, in your case, is the left mouse button
being held down. Next you use the <TT>IEnumFORMATETC</TT> interface to see if the
<TT>IDataObject</TT> that was passed to you contains formats that you can use.</P>
<P><TT>DragOver</TT> is used to instruct Windows as to the current state that the
drag operation is in while it is over your control. Your implementation is very easy.
One could, however, implement the method to allow the Drag and Drop operation over
only specific portions of the control by checking the point structure that was passed
in and comparing it to various locations of the control. For example, a grid control
might allow only text data to be dropped on the headings but allow text and numeric
data to be dropped over the columns.</P>
<P><TT>DragLeave</TT> is used to clean up any state information that may have been
created locally to the control when the <TT>DragEnter</TT> was invoked. In your case,
you return <TT>E_NOTIMPL</TT> since you have no use for the function.</P>
<P><TT>Drop</TT> is the last function that you need to implement and is where you
copy the data from the <TT>IDataObject</TT> to your control using the <TT>GetDataFromTransfer</TT>
method.
<H3><A NAME="Heading50"></A>Listing 11.41<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--IDropTarget
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::DragEnter(LPDATAOBJECT
pDataObject, DWORD<BR>
dwKeyState, <BR>
<BR>
POINTL pt, LPDWORD pdwEffect)<BR>
<BR>
{<BR>
<BR>
// if the left mouse button is being held down<BR>
<BR>
if(dwKeyState &amp; MK_LBUTTON)<BR>
<BR>
{<BR>
<BR>
IEnumFORMATETC * ipenumFormatetc;<BR>
<BR>
BOOL bFound = FALSE; <BR>
// get a FORMATETC enumerator<BR>
<BR>
if(pDataObject-&gt;EnumFormatEtc(DATADIR_GET, &amp;ipenumFormatetc) == S_OK)<BR>
<BR>
{<BR>
<BR>
// reset the enumerator just to be safe<BR>
<BR>
ipenumFormatetc-&gt;Reset(); <BR>
FORMATETC etc; <BR>
// while there are formats to enumerate<BR>
<BR>
while(ipenumFormatetc-&gt;Next(1, &amp;etc, NULL) == S_OK &amp;&amp; !bFound)<BR>
<BR>
{<BR>
<BR>
// is this a format that we are looking for?<BR>
<BR>
if(etc.cfFormat == CF_TEXT &amp;&amp; etc.tymed &amp; TYMED_HGLOBAL)<BR>
<BR>
bFound = TRUE;<BR>
<BR>
} <BR>
// release the enumerator<BR>
<BR>
ipenumFormatetc-&gt;Release();<BR>
<BR>
} <BR>
// is there a text format available<BR>
<BR>
if(bFound)<BR>
<BR>
*pdwEffect = DROPEFFECT_COPY;<BR>
<BR>
// everything else we can't deal with<BR>
<BR>
else<BR>
<BR>
*pdwEffect = DROPEFFECT_NONE;<BR>
<BR>
}<BR>
<BR>
else<BR>
<BR>
// not the left mouse<BR>
<BR>
*pdwEffect = DROPEFFECT_NONE; <BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::DragOver(DWORD dwKeyState, POINTL pt, <BR>
<BR>
LPDWORD pdwEffect)<BR>
<BR>
{<BR>
<BR>
// if the left mouse button is being held down<BR>
<BR>
if(dwKeyState &amp; MK_LBUTTON)<BR>
<BR>
// copy<BR>
<BR>
*pdwEffect = DROPEFFECT_COPY;<BR>
<BR>
else<BR>
<BR>
// not the left mouse<BR>
<BR>
*pdwEffect = DROPEFFECT_NONE; <BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::DragLeave(void)<BR>
<BR>
{<BR>
<BR>
return E_NOTIMPL;<BR>
<BR>
} <BR>
STDMETHODIMP CBCFControlControl::Drop(LPDATAOBJECT pDataObject, DWORD dwKeyState,
<BR>
<BR>
POINTL pt, LPDWORD pdwEffect)<BR>
<BR>
{<BR>
<BR>
// transfer the data to the control<BR>
<BR>
this-&gt;GetDataFromTransfer(pDataObject); <BR>
// return success<BR>
<BR>
return S_OK; <BR>
}<BR>
</TT></FONT></P>
<P>As with your MFC and ATL implementations, adding Drag and Drop support is straightforward.
Now that you have addressed the built-in formats, take a look at the next step, custom
formats.
<H3><A NAME="Heading51"></A>Custom Clipboard and Drag and Drop Formats</H3>
<P>A <I>custom data format</I> is one that is understood by the exchanging applications
but does not fall into the category of predefined formats. For your implementation,
you transfer the text <TT>Alignment</TT> property along with your <TT>Caption</TT>.
You are not restricted in any way in the types of data that can be transferred in
this manner.</P>
<P>Adding custom data formats is independent of the mechanism used to initiate the
data transfer. Since you have modeled your data transfer methods based on this principle,
you need to make only one set of changes to your application to accommodate both
Clipboard and Drag and Drop operations.</P>
<P>The first step is adding the member variables that you will use to implement your
custom format (see Listing 11.42). <TT>m_uiCustomFormat</TT> is used to hold the
<TT>ID</TT> number of the registered custom format. The remaining members are used
to hold the data and its related formatting information.
<H3><A NAME="Heading52"></A>Listing 11.42<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--Custom
Data Format Member Variables</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
private:<BR>
<BR>
FORMATETC sTextFormatEtc;<BR>
<BR>
STGMEDIUM sTextStgMedium;<BR>
<BR>
// custom format storage variables<BR>
<BR>
UINT m_uiCustomFormat;<BR>
<BR>
FORMATETC sCustomFormatEtc;<BR>
<BR>
STGMEDIUM sCustomStgMedium; <BR>
};<BR>
</TT></FONT></P>
<P>The next step is to initialize your member variables to valid values, which you
do in your constructor (see Listing 11.43). When you register the format, you are
actually registering the format in the Windows OS. That way, whenever an application
needs to use the format, it will get the same value as that of the application that
registered the format in the first place. All applications that need to use a custom
format must call this method to retrieve the <TT>ID</TT> associated with the custom
format type.
<H3><A NAME="Heading53"></A>Listing 11.43 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Register
the Custom Format</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// set to the first element<BR>
<BR>
ulFORMATETCElement = 0; <BR>
// clear the storage medium<BR>
<BR>
sTextStgMedium.hGlobal = NULL; <BR>
// register a custom clipboard format<BR>
<BR>
m_uiCustomFormat = ::RegisterClipboardFormat(&quot;BCFControlCtlCustomFormat&quot;);
<BR>
// clear the storage medium<BR>
<BR>
sCustomStgMedium.hGlobal = NULL;<BR>
<BR>
} <BR>
#pragma warning(default:4355) // using `this' in constructor<BR>
</TT></FONT></P>
<P>Next you update your <TT>PrepareDataForTransfer</TT> function (see Listing 11.44).
In addition to the <TT>CF_TEXT</TT> format, you add the creation of your custom data
format, if there is one. You store the new format in your custom storage variables
so that you can support the formats on a granular basis. If the application receiving
the data understands only your text format, that is all that it needs to retrieve.
<H3><A NAME="Heading54"></A>Listing 11.44 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROCTL.CPP--PrepareDataForTransfer
Update</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::PrepareDataForTransfer(void)<BR>
<BR>
{ <BR>
. . . <BR>
// if we have custom clipboard format support<BR>
<BR>
if(m_uiCustomFormat)<BR>
<BR>
{<BR>
<BR>
// create a global memory object<BR>
<BR>
HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, <BR>
<BR>
sizeof(m_state.lAlignment));<BR>
<BR>
<BR>
<BR>
// lock the memory down<BR>
<BR>
LONG * lpTempBuffer = (LONG *) ::GlobalLock(hGlobal); <BR>
// set our data buffer<BR>
<BR>
*lpTempBuffer = m_state.lAlignment; <BR>
// unlock the memory<BR>
<BR>
::GlobalUnlock(hGlobal); <BR>
// copy all of the members<BR>
<BR>
sCustomFormatEtc.cfFormat = m_uiCustomFormat;<BR>
<BR>
sCustomFormatEtc.ptd = NULL;<BR>
<BR>
sCustomFormatEtc.dwAspect = 0;<BR>
<BR>
sCustomFormatEtc.lindex = -1;<BR>
<BR>
sCustomFormatEtc.tymed = TYMED_HGLOBAL; <BR>
// if we have already allocated the data<BR>
<BR>
if(sCustomStgMedium.hGlobal)<BR>
<BR>
// release it<BR>
<BR>
::ReleaseStgMedium(&amp;sCustomStgMedium); <BR>
sCustomStgMedium.tymed = TYMED_HGLOBAL;<BR>
<BR>
sCustomStgMedium.hGlobal = hGlobal;<BR>
<BR>
sCustomStgMedium.pUnkForRelease = NULL;<BR>
<BR>
} <BR>
}<BR>
</TT></FONT></P>
<P>Next you update the <TT>GetDataFromTransfer</TT> method, which you will use to
copy the data from a <TT>SGTMEDUIM</TT> structure to your control (see Listing 11.45).
As with your <TT>PrepareDataForTransfer</TT> method, you take a granular approach
and support the basic text transfer independent of your custom format. Note that
you change your <TT>while..loop</TT> slightly to look through all of the available
formats and stop only when you have looked at them all. This way, you can support
the text format and the custom format independent of each other and ensure that they
are not mutually exclusive.
<H3><A NAME="Heading55"></A>Listing 11.45<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--GetDataFromTransfer
Update</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::GetDataFromTransfer(IDataObject
* ipDataObj)<BR>
<BR>
{ <BR>
<BR>
IEnumFORMATETC * ipenumFormatetc;<BR>
<BR>
BOOL bFound = FALSE; <BR>
// get a FORMATETC enumerator<BR>
<BR>
if(ipDataObj-&gt;EnumFormatEtc(DATADIR_GET, &amp;ipenumFormatetc) == S_OK)<BR>
<BR>
{<BR>
<BR>
// reset the enumerator just to be safe<BR>
<BR>
ipenumFormatetc-&gt;Reset(); <BR>
FORMATETC etc; <BR>
// while there are formats to enumerate<BR>
<BR>
while(ipenumFormatetc-&gt;Next(1, &amp;etc, NULL) == S_OK)<BR>
<BR>
{<BR>
<BR>
// is this a format that we are looking for?<BR>
<BR>
if(etc.cfFormat == CF_TEXT &amp;&amp; etc.tymed &amp; TYMED_HGLOBAL)<BR>
<BR>
{<BR>
<BR>
STGMEDIUM sStgMediumData; <BR>
// get the data from the stgmedium<BR>
<BR>
if(ipDataObj-&gt;GetData(&amp;etc, &amp;sStgMediumData) == S_OK)<BR>
<BR>
{<BR>
<BR>
// get the global data for this format and lock down the memory<BR>
<BR>
LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(sStgMediumData.hGlobal); <BR>
// if we have a string<BR>
<BR>
if(m_lptstrCaption)<BR>
<BR>
{<BR>
<BR>
// delete the existing string<BR>
<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
<BR>
m_lptstrCaption = NULL;<BR>
<BR>
} <BR>
// allocate a new string<BR>
<BR>
m_lptstrCaption = new TCHAR[lstrlen(lpTempBuffer) + 1]; <BR>
// assign the string to our member variable<BR>
<BR>
lstrcpy(m_lptstrCaption, lpTempBuffer); <BR>
// unlock the memory<BR>
<BR>
::GlobalUnlock(sStgMediumData.hGlobal); <BR>
// release the storage medium<BR>
<BR>
::ReleaseStgMedium(&amp;sStgMediumData); <BR>
// indicate success<BR>
<BR>
bFound = TRUE;<BR>
<BR>
}<BR>
<BR>
}<BR>
<BR>
// is this a format that we are looking for?<BR>
<BR>
else if(m_uiCustomFormat &amp;&amp; etc.cfFormat == m_uiCustomFormat &amp;&amp; etc.tymed
&amp; TYMED_HGLOBAL)<BR>
<BR>
{<BR>
<BR>
STGMEDIUM sStgMediumData; <BR>
// get the data from the stgmedium<BR>
<BR>
if(ipDataObj-&gt;GetData(&amp;etc, &amp;sStgMediumData) == S_OK)<BR>
<BR>
{<BR>
<BR>
// get the global data for this format and lock down the memory<BR>
<BR>
LONG * lpTempBuffer = (LONG *) ::GlobalLock(sStgMediumData.hGlobal); <BR>
// get the data<BR>
<BR>
m_state.lAlignment = *lpTempBuffer; <BR>
// unlock the memory<BR>
<BR>
::GlobalUnlock(sStgMediumData.hGlobal); <BR>
// release the storage medium<BR>
<BR>
::ReleaseStgMedium(&amp;sStgMediumData); <BR>
// indicate success<BR>
<BR>
bFound = TRUE;<BR>
<BR>
}<BR>
<BR>
}<BR>
<BR>
}<BR>
<BR>
<BR>
<BR>
// release the enumerator<BR>
<BR>
ipenumFormatetc-&gt;Release();<BR>
<BR>
} <BR>
// if we found a format<BR>
<BR>
if(bFound == TRUE)<BR>
<BR>
// force the control to repaint itself<BR>
<BR>
this-&gt;InvalidateControl(NULL); <BR>
}<BR>
</TT></FONT></P>
<P>Now that you have updated your basic data transfer routines, you need to update
your <TT>IEnumFORMATETC</TT> interface to essentially publish the availability of
the new format to any application that wants it. You do this in your <TT>IEnumFORMATETC::Next</TT>
function (see Listing 11.46). If you support a custom format and are at the second
format in your enumerator, you fill in the <TT>FORMATETC</TT> structure that was
passed in with the appropriate information. Doing this will let any application that
understands your custom format know that you can also support the custom format.
Note that the implementation will return only a single format, even if the caller
asked for more than one. You can add code to deal with the cases where more than
one format is requested, but adding the additional code doesn't add anything to the
sample, so that topic is not addressed here.
<H3><A NAME="Heading56"></A>Listing 11.46 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--IEnumFORMATETC::Next
Update</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::Next(ULONG celt, FORMATETC
RPC_FAR * rgelt, <BR>
<BR>
ULONG RPC_FAR * pceltFetched)<BR>
<BR>
{<BR>
<BR>
// if we are at the beginning of the enumeration<BR>
<BR>
if(ulFORMATETCElement == 0 &amp;&amp; celt &gt; 0)<BR>
<BR>
{<BR>
<BR>
// copy all of the members<BR>
<BR>
rgelt-&gt;cfFormat = CF_TEXT;<BR>
<BR>
rgelt-&gt;ptd = NULL;<BR>
<BR>
rgelt-&gt;dwAspect = 0;<BR>
<BR>
rgelt-&gt;lindex = -1;<BR>
<BR>
rgelt-&gt;tymed = TYMED_HGLOBAL;<BR>
<BR>
<BR>
<BR>
// if the caller wants to know how many we copied<BR>
<BR>
if(pceltFetched)<BR>
<BR>
*pceltFetched = 1; <BR>
// increment the counter<BR>
<BR>
ulFORMATETCElement++; <BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
}<BR>
<BR>
else if(m_uiCustomFormat &amp;&amp; ulFORMATETCElement == 1 &amp;&amp; celt &gt;
0)<BR>
<BR>
{<BR>
<BR>
// copy all of the members<BR>
<BR>
rgelt-&gt;cfFormat = m_uiCustomFormat;<BR>
<BR>
rgelt-&gt;ptd = NULL;<BR>
<BR>
rgelt-&gt;dwAspect = 0;<BR>
<BR>
rgelt-&gt;lindex = -1;<BR>
<BR>
rgelt-&gt;tymed = TYMED_HGLOBAL;<BR>
<BR>
<BR>
<BR>
// if the caller wants to know how many we copied<BR>
<BR>
if(pceltFetched)<BR>
<BR>
*pceltFetched = 1; <BR>
// increment the counter<BR>
<BR>
ulFORMATETCElement++; <BR>
// return success<BR>
<BR>
return S_OK;<BR>
<BR>
}<BR>
<BR>
else<BR>
<BR>
// return failure<BR>
<BR>
return S_FALSE; <BR>
}<BR>
</TT></FONT></P>
<P>Last you need to update the routine that returns the custom format in the <TT>STGMEDIUM</TT>
structure, <TT>IEnumFORMATETC::GetData</TT> (see Listing 11.47). You can still use
the <TT>CopyStgMedium</TT> function; the only difference is which internal <TT>STGMEDIUM</TT>
structure is supplied to the function.
<H3><A NAME="Heading57"></A>Listing 11.47 BCFCONTROLCTL.CPP--IEnumFORMATETC::GetData
Update</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::GetData(LPFORMATETC
lpFormatEtc, LPSTGMEDIUM <BR>
lpStgMedium)<BR>
<BR>
{<BR>
<BR>
// if this is a format that we can deal with<BR>
<BR>
if(lpFormatEtc-&gt;cfFormat == CF_TEXT &amp;&amp; lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL)<BR>
<BR>
{<BR>
<BR>
// get a copy of the current stgmedium<BR>
<BR>
this-&gt;CopyStgMedium(lpStgMedium, &amp;sTextStgMedium, CF_TEXT); <BR>
return S_OK;<BR>
<BR>
}<BR>
<BR>
else if(m_uiCustomFormat &amp;&amp; lpFormatEtc-&gt;cfFormat == m_uiCustomFormat
&amp;&amp; <BR>
<BR>
lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL)<BR>
<BR>
{<BR>
<BR>
// get a copy of the current stgmedium<BR>
<BR>
this-&gt;CopyStgMedium(lpStgMedium, &amp;sCustomStgMedium, m_uiCustomFormat); <BR>
return S_OK;<BR>
<BR>
}<BR>
<BR>
else<BR>
<BR>
return DATA_E_FORMATETC; <BR>
}<BR>
</TT></FONT></P>
<P>That is all it takes to support custom formats. By taking a &quot;black box&quot;
approach to creating your data transfer routines (meaning that you create routines
that manipulate basic data structures and remove the specific data transfer details
from your code), you can support a large amount of functionality relying on a common
code base.</P>
<P>Adding Clipboard and Drag and Drop support to your control can improve its overall
appearance and integration with other controls and the container in which it resides.
<H2><A NAME="Heading58"></A>Subclassing Existing Windows Controls</H2>
<P>As with your MFC and ATL implementations, you can support the subclassing of existing
Windows controls with the BaseCtl framework. At the beginning of <A HREF="ch10.htm">Chapter
10</A>, you created several controls in your application, one of which subclassed
a Windows <TT>BUTTON</TT> control, <TT>CBCFControlSubControl</TT>. Take a look at
the additional code that is required to support subclassing. Listing 11.48 shows
the extent of your implementation.</P>
<P><TT>RegisterClassData</TT> retrieves the class information for the <TT>BUTTON</TT>
control and uses it for your control.</P>
<P><TT>OnDraw</TT> delegates the painting of the control to the <TT>DoSuperClassPaint</TT>
function.</P>
<P><TT>WindowProc</TT> delegates the standard windows message handling to the subclassed
control.
<H3><A NAME="Heading59"></A>Listing 11.48 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLSUBCTL.CPP--RegisterClassData
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>//=-------------------------------------------------------------------------=<BR>
<BR>
// CBCFControlSubWinControl:RegisterClassData<BR>
<BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// register the window class information for your control here.<BR>
<BR>
// this information will automatically get cleaned up for you on DLL shutdown.<BR>
<BR>
//<BR>
<BR>
// Output:<BR>
<BR>
// BOOL - FALSE means fatal error.<BR>
<BR>
//<BR>
<BR>
// Notes:<BR>
<BR>
//<BR>
<BR>
BOOL CBCFControlSubWinControl::RegisterClassData<BR>
<BR>
(<BR>
<BR>
void<BR>
<BR>
)<BR>
<BR>
{<BR>
<BR>
WNDCLASS wndclass; <BR>
// subclass a windows BUTTON control.<BR>
<BR>
//<BR>
<BR>
if (!::GetClassInfo(g_hInstance, &quot;BUTTON&quot;, &amp;wndclass))<BR>
<BR>
return FALSE; <BR>
// this doesn't need a critical section for apartment threading support<BR>
<BR>
// since it's already in a critical section in CreateInPlaceWindow<BR>
<BR>
//<BR>
<BR>
SUBCLASSWNDPROCOFCONTROL(OBJECT_TYPE_CTLBCFCONTROLSUBWIN) = <BR>
<BR>
(WNDPROC)wndclass.lpfnWndProc;<BR>
<BR>
wndclass.lpfnWndProc = COleControl::ControlWindowProc;<BR>
<BR>
wndclass.lpszClassName = WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_CTLBCFCONTROLSUBWIN);
<BR>
return RegisterClass(&amp;wndclass);<BR>
<BR>
} <BR>
. . . <BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// CBCFControlSubWinControl::OnDraw<BR>
<BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// &quot;I don't very much enjoy looking at paintings in general. i know too<BR>
<BR>
// much about them. i take them apart.&quot;<BR>
<BR>
// - georgia o'keeffe (1887-1986)<BR>
<BR>
//<BR>
<BR>
// Parameters:<BR>
<BR>
// DWORD - [in] drawing aspect<BR>
<BR>
// HDC - [in] HDC to draw to<BR>
<BR>
// LPCRECTL - [in] rect we're drawing to<BR>
<BR>
// LPCRECTL - [in] window extent and origin for meta-files<BR>
<BR>
// HDC - [in] HIC for target device<BR>
<BR>
// BOOL - [in] can we optimize DC handling?<BR>
<BR>
//<BR>
<BR>
// Output:<BR>
<BR>
// HRESULT<BR>
<BR>
//<BR>
<BR>
// Notes:<BR>
<BR>
//<BR>
<BR>
HRESULT CBCFControlSubWinControl::OnDraw<BR>
<BR>
(<BR>
<BR>
DWORD dvAspect,<BR>
<BR>
HDC hdcDraw,<BR>
<BR>
LPCRECTL prcBounds,<BR>
<BR>
LPCRECTL prcWBounds,<BR>
<BR>
HDC hicTargetDevice,<BR>
<BR>
BOOL fOptimize<BR>
<BR>
)<BR>
<BR>
{<BR>
<BR>
// TODO: put your drawing code here ...<BR>
<BR>
//<BR>
<BR>
return DoSuperClassPaint(hdcDraw, prcBounds);<BR>
<BR>
} <BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// CBCFControlSubWinControl::WindowProc<BR>
<BR>
//=-------------------------------------------------------------------------=<BR>
<BR>
// window procedure for this control. nothing terribly exciting.<BR>
<BR>
//<BR>
<BR>
// Parameters:<BR>
<BR>
// see win32sdk on window procs [except HWND -- it's in m_hwnd]<BR>
<BR>
//<BR>
<BR>
// Notes:<BR>
<BR>
//<BR>
<BR>
LRESULT CBCFControlSubWinControl::WindowProc<BR>
<BR>
(<BR>
<BR>
UINT msg,<BR>
<BR>
WPARAM wParam,<BR>
<BR>
LPARAM lParam<BR>
<BR>
)<BR>
<BR>
{<BR>
<BR>
// TODO: handle any messages here, like in a normal window<BR>
<BR>
// proc. note that for special keys, you'll want to override and<BR>
<BR>
// implement OnSpecialKey.<BR>
<BR>
//<BR>
<BR>
return CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(<BR>
<BR>
OBJECT_TYPE_CTLBCFCONTROLSUBWIN), m_hwnd, msg, wParam, lParam); <BR>
}<BR>
</TT></FONT></P>
<P>As you can see, subclassing an existing control is easy. Subclassing can significantly
reduce your development effort and presents enormous potential in your ability to
create powerful derivations of pre-existing controls.
<H2><A NAME="Heading60"></A>Dual-Interface Controls</H2>
<P>BaseCtl control implementations, by default, support dual-interface so no extra
work is needed. As we stated in previous chapters, however, currently no control
containers can or will use dual-interfaces on controls.
<H2><A NAME="Heading61"></A>Other ActiveX Features</H2>
<P>As with your MFC and ATL implementations, the BaseCtl framework allows you to
take advantage of some of the available OC 96 or ActiveX features. <A HREF="ch06.htm">Chapter
6</A> contains a detailed explanation of each feature, so you don't go into them
here. You will, however, look into their specification implementation aspects.</P>
<P>All of the unique information about the control and how it is created is defined
in a structure called <TT>CONTROLOBJECTINFO</TT>. This structure contains the control's
name, help file, flags, and so on--all of the required information for the control
to be created. This structure is wrapped in four macros that are used when defining
a specific type of control (see Table 11.1). Each control implementation must declare
one of these macros in its header file to define the control's implementation details.
Some of the ActiveX features pointed out in previous chapters are defined in this
structure (refer to <A HREF="ch06.htm">Chapter 6</A> for more information). 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 11.1 </B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>Windowing Macros</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Macro</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>DEFINE_CONTROLOBJECT</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This is the standard macro used for declaring a windowed control.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>DEFINE_WINDOWLESSCONTROLOBJECT</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This is the standard macro used for declaring a windowless control.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>DEFINE_CONTROLOBJECT2</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This is an extended macro used for declaring a windowed control. It is similar to
			the standard macro but allows more control over the definition.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>DEFINE_WINDOWLESSCONTROLOBJECT2</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This is an extended macro used for declaring a windowless control. It is similar
			to the standard macro but allows more control over the definition.</TD>
	</TR>
</TABLE>

<H3><A NAME="Heading62"></A>Windowless Activation</H3>
<P><I>Windowless activation</I> is supported through the <TT>IOleInPlaceObjectWindowless</TT>
interface and is implemented in the container. If the container doesn't support windowless
activation, the control must be able to create a window for itself. Windowless activation
is a request not a guarantee. Listing 11.49 shows your control definition for <TT>BCFControlControl</TT>,
which is your standard windowed ActiveX control.
<H3><A NAME="Heading63"></A>Listing 11.49<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--BCFControControl
ActiveX Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>// TODO: if you have an array of verbs, then add an
extern here with the name<BR>
<BR>
// of it, so that you can include it in the DEFINE_CONTROLOBJECT.<BR>
<BR>
// ie. extern VERBINFO m_BCFControlCustomVerbs [];<BR>
<BR>
//<BR>
<BR>
extern const GUID *rgBCFControlPropPages [];<BR>
<BR>
DEFINE_CONTROLOBJECT(BCFControl,<BR>
<BR>
&amp;CLSID_BCFControl,<BR>
<BR>
&quot;BCFControlCtl&quot;,<BR>
<BR>
CBCFControlControl::Create,<BR>
<BR>
1,<BR>
<BR>
&amp;IID_IBCFControl,<BR>
<BR>
&quot;BCFControl.HLP&quot;,<BR>
<BR>
&amp;DIID_DBCFControlEvents,<BR>
<BR>
OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | <BR>
<BR>
OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT,<BR>
<BR>
0, // no IPointerInactive policy by default<BR>
<BR>
RESID_TOOLBOX_BITMAP1,<BR>
<BR>
&quot;BCFControlWndClass&quot;,<BR>
<BR>
1,<BR>
<BR>
rgBCFControlPropPages,<BR>
<BR>
0, <BR>
NULL);<BR>
</TT></FONT></P>
<P>Listing 11.50 shows the control definition for <TT>BCFControlNoWinControl</TT>,
a windowless control. The only difference between your windowed and windowless control
is this macro. Embedded within the macro is the value indicating that this control
is windowed or windowless; you just use the correct macro to get the required behavior.
The <TT>DEFINE_WINDOWLESSCONTROLOBJECT</TT> macro contains one additional parameter:
the highlighted <TT>TRUE</TT> value in Listing 11.50, which is used to define whether
the control is 100 percent opaque. In other words, does the control draw over its
entire client area, or are there some transparent parts?
<H3><A NAME="Heading64"></A>Listing 11.50<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLNOWIN.H--BCFControlNoWinControl
ActiveX Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>extern const GUID *rgBCFControlNoWinPropPages [];<BR>
<BR>
DEFINE_WINDOWLESSCONTROLOBJECT(BCFControlNoWin,<BR>
<BR>
&amp;CLSID_BCFControlNoWin,<BR>
<BR>
&quot;BCFControlNoWinCtl&quot;,<BR>
<BR>
CBCFControlNoWinControl::Create,<BR>
<BR>
1,<BR>
<BR>
&amp;IID_IBCFControlNoWin,<BR>
<BR>
&quot;BCFControlNoWin.HLP&quot;,<BR>
<BR>
&amp;DIID_DBCFControlNoWinEvents,<BR>
<BR>
OLEMISC_IGNOREACTIVATEWHENVISIBLE | OLEMISC_SETCLIENTSITEFIRST | <BR>
<BR>
OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE
| <BR>
<BR>
OLEMISC_INSIDEOUT | OLEMISC_ACTSLIKEBUTTON,<BR>
<BR>
POINTERINACTIVE_ACTIVATEONENTRY | POINTERINACTIVE_DEACTIVATEONLEAVE | <BR>
<BR>
POINTERINACTIVE_ACTIVATEONDRAG,<BR>
<BR>
TRUE, // control is opaque<BR>
<BR>
RESID_TOOLBOX_BITMAP2,<BR>
<BR>
&quot;BCFControlNoWinWndClass&quot;,<BR>
<BR>
1,<BR>
<BR>
rgBCFControlNoWinPropPages,<BR>
<BR>
0, <BR>
NULL);<BR>
</TT></FONT></P>
<H3><A NAME="Heading65"></A>Unclipped Device Context</H3>
<P><I>Unclipped device context</I> is an MFC specific optimization. The flag results
in only a single operation</P>
<P><FONT COLOR="#0066FF"><TT>if (nFlags &amp; clipPaintDC)<BR>
dc.IntersectClipRect(rcClient);</TT></FONT></P>
<P>which can be found in the <TT>COleControl::OnPaint()</TT> function. The net result
of this function call is to reduce the size of the area that will be drawn to.
<H3><A NAME="Heading66"></A>Flicker-Free Activation</H3>
<P><I>Flicker-free activation</I> is based on the <TT>IOleInPlaceSiteEx</TT> interface.
The BaseCtl frame -work automatically attempts to find this interface, so it requires
no implementation on the part of the developer. See the VC++ documentation for more
information about the <TT>IOleInPlaceSiteEx</TT> interface.
<H3><A NAME="Heading67"></A>Mouse Pointer Notifications When Inactive</H3>
<P>Only the windowless control <TT>BCFControlNoWin</TT> will take advantage of mouse
pointer notifications when inactive. To enable mouse pointer notifications, you must
declare your control, as in Listing 11.51.
<H3><A NAME="Heading68"></A>Listing 11.51<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLNOWIN.H--Mouse
Notifications</H3>
<P><FONT COLOR="#0066FF"><TT>extern const GUID *rgBCFControlNoWinPropPages [];<BR>
DEFINE_WINDOWLESSCONTROLOBJECT(BCFControlNoWin,<BR>
&amp;CLSID_BCFControlNoWin,<BR>
&quot;BCFControlNoWinCtl&quot;,<BR>
CBCFControlNoWinControl::Create,<BR>
1,<BR>
&amp;IID_IBCFControlNoWin,<BR>
&quot;BCFControlNoWin.HLP&quot;,<BR>
&amp;DIID_DBCFControlNoWinEvents,<BR>
OLEMISC_IGNOREACTIVATEWHENVISIBLE | OLEMISC_SETCLIENTSITEFIRST | <BR>
OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE
| <BR>
OLEMISC_INSIDEOUT | OLEMISC_ACTSLIKEBUTTON,<BR>
POINTERINACTIVE_ACTIVATEONENTRY | POINTERINACTIVE_DEACTIVATEONLEAVE | <BR>
POINTERINACTIVE_ACTIVATEONDRAG,<BR>
TRUE, // control is opaque<BR>
RESID_TOOLBOX_BITMAP2,<BR>
&quot;BCFControlNoWinWndClass&quot;,<BR>
1,<BR>
rgBCFControlNoWinPropPages,<BR>
0, <BR>
NULL);<BR>
</TT></FONT></P>

<P>The flags for a windowless control also differ slightly from its windowed counterpart.
For your implementation, specifying <TT>OLEMISC_ACTIVATEWHENVISIBLE</TT> indicates
that the control should become active as soon as it is visible. By specifying <TT>OLEMISC_IGNOREACTIVATEWHENVISIBLE</TT>,
you instruct the control not to become active until some form of user action on the
control takes place--that is, provided that the container supports the <TT>IPointerInactive</TT>
interface. If the container does not provide the <TT>IPointerInactive</TT> interface,
your control will be active the entire time it is visible.
<H3><A NAME="Heading69"></A>Optimized Drawing Code</H3>
<P>Optimized drawing is handled much the same way it is in MFC and ATL. (Refer to
the section on optimized drawing at the beginning of this chapter for more information.)
A parameter of the <TT>OnDraw</TT> method indicates whether the control can draw
using the optimized techniques first shown in the MFC implementation. In addition,
the BaseCtl implementation allows for <I>aspect </I>or optimized drawing. Drawing
with aspects is beyond the scope of this book. If you want to implement aspects,
please see the OC 96 specification included in the ActiveX SDK.
<H3><A NAME="Heading70"></A>Loads Properties Asynchronously</H3>
<P>To support asynchronous properties, a control must support the stock property
<TT>ReadyState</TT>. The control is responsible for updating the property and notifying
the container when it has changed. (See the section on asynchronous properties at
the beginning of this chapter for more information.)
<H2><A NAME="Heading71"></A>From Here...</H2>
<P>The BaseCtl framework provides a sound platform for control development. The lack
of common functionality support that is equivalent to that of MFC is probably its
biggest weakness. The amount of control and flexibility over your development is
probably its greatest strength. It is interesting to note that the shortcomings of
the BaseCtl framework are conversely proportional to the strengths of MFC, and vice
versa.</P>
<P>Creating a control using MFC and then porting it to the BaseCtl framework will
give you a true appreciation and understanding of control and container development
and architecture. It will also aid greatly in other areas of ActiveX/COM development.</P>
<P>As far as ATL is concerned, BaseCtl is very similar in its style of implementation.
The COM interfaces are the root of your control implementation, as it should be,
and not a set of all-encompassing classes (as in MFC). A large number of parallels
can be drawn between ATL and BaseCtl. For those developers who are really interested
in how ActiveX and COM works in a control implementation, the best choice is to take
a look at the BaseCtl.</P>

<P>Probably the greatest limitation to using the BaseCtl is that it's considered
to be an unsupported tool and is provided by its authors merely as a sample of how
to do control development. You need to take this into consideration when deciding
which method to use when developing your ActiveX components.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
