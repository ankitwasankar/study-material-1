<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 10:22 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 8</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 8<BR>
Using ATL to Create a Basic ActiveX Control</H1>

<UL>
	<LI><A HREF="#Heading1">Using ATL to Create a Basic ActiveX Control</A>
	<UL>
		<LI><A HREF="#Heading2">Creating the Basic Control Project</A>
		<LI><A HREF="#Heading3">Control Registration</A>
		<UL>
			<LI><A HREF="#Heading4">Listing 8.1 ATLCONTROLWIN.RGS--Sample Registry Script File
			for the CATLControlWin Control Class</A>
		</UL>
		<LI><A HREF="#Heading5">Creating Methods</A>
		<UL>
			<LI><A HREF="#Heading6">Listing 8.2 ATLCONTROLWIN.H--Alignment Enumeration Include
			File and Member Variables Added to Class Definition</A>
			<LI><A HREF="#Heading7">Listing 8.3 ALIGNMENTENUMS.H--Alignment Enumeration Include
			File</A>
			<LI><A HREF="#Heading8">Listing 8.4 ATLCONTROLWIN.H--Member Variable Initialization</A>
			<LI><A HREF="#Heading9">Listing 8.5 ATLCONTROLWIN.CPP--CaptionMethod Implementation</A>
		</UL>
		<LI><A HREF="#Heading10">Properties</A>
		<UL>
			<LI><A HREF="#Heading11">Creating Normal User Defined Properties</A>
			<LI><A HREF="#Heading12">Listing 8.6 ATLCONTROL.IDL--Dispid Enumeration Added to
			the IDL File to Aid in the Support of Properties in the Control</A>
			<LI><A HREF="#Heading13">Listing 8.7 ATLCONTROLWIN.CPP--Alignment Property Get/Put
			Method Implementation</A>
			<LI><A HREF="#Heading14">Creating Parameterized User Defined Properties</A>
			<LI><A HREF="#Heading15">Listing 8.8 ATLCONTROL.IDL--Update the IDL File to Support
			the Parameterized Property</A>
			<LI><A HREF="#Heading16">Listing 8.9 ATLCONTROLWIN.CPP--get_CaptionProp Implementation</A>
			<LI><A HREF="#Heading17">Listing 8.10 ATLCONTROLWIN.CPP--SetCaptionProp Implementation</A>
			<LI><A HREF="#Heading18">Creating Stock Properties</A>
			<LI><A HREF="#Heading19">Listing 8.11 ATLCONTROL.IDL--Add the Constant DISPID_BACKCOLOR
			to the IDL to Support the BackColor Stock Property</A>
			<LI><A HREF="#Heading20">Listing 8.12 ATLCONTROLWIN.H--m_BackColor Member Variable
			Added to the Class Declaration</A>
			<LI><A HREF="#Heading21">Listing 8.13 ATLCONTROLWIN.CPP--BackColor Property Source
			File Implementation</A>
			<LI><A HREF="#Heading22">Listing 8.14 ATLCONTROLWIN.H--Initialize the BackColor Property
			to an Initial Value</A>
			<LI><A HREF="#Heading23">Using Ambient Properties</A>
			<LI><A HREF="#Heading24">Creating Property Sheets</A>
			<LI><A HREF="#Heading25">Listing 8.15 ATLCONTROLWINPPG.H--Add the Necessary Include
			Files to the Property Page Header File</A>
			<LI><A HREF="#Heading26">Listing 8.16 ATLCONTROLWINPPG.H--Add the OnInitDialog Message
			Handler so the Property Page Can Be Initialized</A>
			<LI><A HREF="#Heading27">Listing 8.17 ATLCONTROLWINPPG.H--Modify the Apply Function
			to Update All of the Properties in the Control When the Property Page Exits</A>
			<LI><A HREF="#Heading28">Listing 8.18 ATLCONTROLWIN.H--Add the Property Page Reference
			to the </A><A HREF="#Heading29">Control Class Declaration to Complete the Property
			Page Implementation</A>
		</UL>
		<LI><A HREF="#Heading30">Adding Events</A>
		<UL>
			<LI><A HREF="#Heading31">Listing 8.19 ATLCONTROL.IDL--Add the Event Interface and
			the Change Method to the ATLControl.IDL File</A>
			<LI><A HREF="#Heading32">Listing 8.20 ATLCONTROLWIN.CPP--FireChange Helper Function
			Added to the Control</A>
			<LI><A HREF="#Heading33">Listing 8.21 ATLCONTROLWIN.CPP--FireChange Event Added to
			the CaptionMethod Implementation</A>
		</UL>
		<LI><A HREF="#Heading34">Persistence</A>
		<UL>
			<LI><A HREF="#Heading35">Listing 8.22 ATLCONTROLWIN.H--BackColor Property Added to
			the Property Map for Persistence</A>
		</UL>
		<LI><A HREF="#Heading36">Drawing the Control</A>
		<UL>
			<LI><A HREF="#Heading37">Standard Drawing</A>
			<LI><A HREF="#Heading38">Listing 8.23 ATLCONTROLWIN.H--Drawing Implementation Member
			Variables and Functions</A>
			<LI><A HREF="#Heading39">Listing 8.24 ATLCONTROLWIN.H--Initialize the New Member
			Variables in the Constructor</A>
			<LI><A HREF="#Heading40">Listing 8.25 ATLCONTROLWIN.CPP--Drawing Helper Functions</A>
			<LI><A HREF="#Heading41">Listing 8.26 ATLCONTROLWIN.CPP--Standard Drawing Added to
			the OnDraw Function</A>
		</UL>
		<LI><A HREF="#Heading42">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Using ATL to Create a Basic ActiveX Control</H1>

<UL>
	<LI><B>Registration</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 ATL's support of registration scripts makes registration support even easier to
	implement and use.
	<P>
	<LI><B>Adding methods</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The ATL Object Wizards, while a little rudimentary, provide the necessary IDE integration
	that makes ATL appealing for rapid development.
	<P>
	<LI><B>Adding properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The ATL Object Wizard makes adding properties a snap.
	<P>
	<LI><B>Adding events</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Unfortunately, event support is not as easy to implement as that of MFC, but this
	chapter sheds some light on the subject that should make it as easy as is possible.
	<P>
	<LI><B>Persistence</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 ATL persistence support makes up for events in terms of ease of implementation.
	<P>
	<LI><B>Drawing the control</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 ATL deviates very little from the norm when it comes to drawing the control and
	requires no special knowledge to implement.
</UL>

<P>With the coming of Visual C++ 5.0, the ActiveX Template Library (ATL) has matured
to the level necessary for a complete ActiveX development framework. The two releases
of ATL, versions 1.0 and 1.1, that came before VC++ 5.0 introduced ATL to the growing
ActiveX development community as an alternative to MFC. However, the first two versions
of ATL allowed only for the creation of ActiveX COM Objects and ActiveX Automation
Servers (no small feats in their own right). ATL version 2.1, the version that ships
with VC++ 5.0, now supports the creation of ActiveX Controls.</P>
<P>Versions 1.0 and 1.1 included an AppWizard for creating a basic ATL project. Version
2.1 includes a number of AppWizards that can be used to create various ActiveX components,
thus furthering ATL's capability to compete with MFC as a rapid development tool.</P>
<P>In this chapter, you will create an ActiveX control with all the basics: methods,
properties, events, persistence, and drawing. Also, in this chapter and <A HREF="ch09.htm">Chapter
9</A>, you will explore some of the more advanced features and lesser known aspects
of control development, such as methods with optional parameters, asynchronous properties,
Clipboard support, and optimized drawing, to name a few.
<H2><A NAME="Heading2"></A>Creating the Basic Control Project</H2>
<P>To create an ATL ActiveX control, you want to take advantage of the AppWizard
provided by Visual C++. Run the Visual C++ development environment, and from the
<U>F</U>ile menu, select <U>N</U>ew. When the New dialog displays, select the Projects
tab (see fig 8.1). The Projects tab allows you the opportunity to define several
aspects of how the application will be created, for example, the type of application
to create, the name of the application, and the location where you want the project
created. For the type, select ATL COM AppWizard; enter the Project <U>N</U>ame ATLControl,
and the Lo<U>c</U>ation will be C:\que\ActiveX\ATLControl. Click the OK button to
start the ATL COM AppWizard so you can further define the properties of your control.
<B><BR>
<BR>
</B><A HREF="art/08/gfigs01.jpg"><B>FIG. 8.1</B></A> <I><BR>
Define the new ATL control project with the New dialog.</I></P>
<P>The next step in the AppWizard is defining the basic architecture of your ATL
project (see fig. 8.2). Since you are creating an ActiveX Control, you choose the
<U>D</U>ynamic Link Library (DLL) radio button. <B><BR>
<BR>
</B><A HREF="art/08/gfigs02.jpg"><B>FIG. 8.2</B></A> <I><BR>
Define the basic architecture of the ATL COM Object with the ATL COM AppWizard.An
OCX is in reality nothing more than a DLL. The extension OCX was carried over from
the early days of control development. You have the option of changing the extension
from DLL to OCX.</I></P>
<P>Since the sample implementation will be a control, it is not necessary to support
merging of the proxy/stub marshaling code, nor will the implementation require the
use of MFC. Click the <U>F</U>inish button to continue.</P>
<P>The New Project Information dialog is used to confirm the settings that were selected
for the project prior to the creation of the actual source files (see fig. 8.3).
This step is the last one in the ATL COM AppWizard. <B><BR>
<BR>
</B><A HREF="art/08/gfigs03.jpg"><B>FIG. 8.3</B></A> <BR>
<I>Confirm the new project settings with the New Project Information dialog.</I></P>
<P>&quot;But wait,&quot; you say, &quot;I haven't defined any of my control properties.&quot;
The ATL COM AppWizard takes a slightly different approach from that of MFC. Only
the basic source files are created with the AppWizard. The remainder of the project
is defined by the Object Wizard, which allows much better control of the project
implementation versus MFC since the developer can add any number of ActiveX Controls,
Servers, or plain COM Objects after the basic project is created. After you confirm
your project settings, click the OK button to close the ATL COM AppWizard and create
the <TT>ATLControl</TT> project.</P>
<P>The next step is to add your control implementations to the project. From the
<U>I</U>nsert menu, select the New <U>A</U>TL Object menu item. Within the ATL Object
Wizard, select the Controls item in the left panel to display the types of control
components that can be added (see fig. 8.4). Your implementation will be a Full Control,
so select the Full Control icon. The other types of components that can be created
are a Microsoft Internet Explorer control that supports all of the necessary interfaces
to be hosted by the Internet Explorer Web browser and a Property Page component,
which you need if your control requires property page support. The Internet Explorer
control simply supports fewer interfaces than the Full Control. The Full Control
will also work within a Web browser. For more information, see the ATL documentation.
Click the <U>N</U>ext button to continue. <B><BR>
<BR>
</B><A HREF="art/08/gfigs04.jpg"><B>FIG. 8.4</B></A> <BR>
<I>Select the type of ATL object to add to your project.</I></P>
<P>The next dialog is the ATL Object Wizard Properties dialog, which is used to define
the specific properties of the new object that will be added to your project. Select
the Names tab, and in the <U>S</U>hort Name edit field, type ATLControlWin (see fig.
8.5). The remainder of the edit fields will automatically update, reflecting the
short name that you added. The other fields can be changed, but in this case, you
use the default values. <B><BR>
<BR>
</B><A HREF="art/08/gfigs05.jpg"><B>FIG. 8.5</B></A><BR>
<I>Define the name of the new control object.</I></P>
<P>Select the Attributes tab so that you can define the attributes of the control
project (see fig. 8.6). Check the Support ISupportErrorInfo and Support Connection
Points check boxes to add OLE rich error support and events to the control. See <A
HREF="ch04.htm">Chapter 4</A> and the ATL documentation for more information regarding
the options available to you. Leave the remainder of the settings at their default
values. <B><BR>
<BR>
</B><A HREF="art/08/gfigs06.jpg"><B>FIG. 8.6</B></A> <I><BR>
Define the attributes of the new control object.</I></P>
<P>You use the Miscellaneous tab to define how the control will draw and act while
contained and whether your control implementation subclasses a built-in Windows control
(see fig. 8.7). For your implementation, you want the control to always create a
window whether or not the container is capable of supporting windowless controls,
so check the <U>W</U>indowed Only check box. Leave the remainder of the controls
at their default settings. <B><BR>
<BR>
</B><A HREF="art/08/gfigs07.jpg"><B>FIG. 8.7</B></A> <BR>
<I>The Miscellaneous tab is used to define some of the basic control behaviors.</I></P>
<P>The Stock Properties tab is used to define any number of the basic stock properties
that the control project will support (see fig. 8.8). For now, leave the Stock Properties
tab as is, and click the OK button to create the new control object. <B><BR>
<BR>
</B><A HREF="art/08/gfigs08.jpg"><B>FIG. 8.8</B></A> <I><BR>
The Stock Properties tab is used to define the stock properties that the control
object will be created with.</I></P>
<P>As with the MFC and later the BaseCtl implementation, you need to define two more
controls to complete the sample implementation. From the <U>I</U>nsert menu, select
the New <U>A</U>TL Object menu item. Within the ATL Object Wizard, select the Controls
item in the left panel, and select the Full Control icon (refer to fig. 8.4). Click
the <U>N</U>ext button to continue.</P>
<P>On the Names tab within the ATL Object Wizard Properties dialog, add the <U>S</U>hort
Name ATLControlNoWin, and on the Attributes tab, check the Support <U>I</U>SupportErrorInfo
and Support Connection <U>P</U>oints check boxes to add OLE rich error support and
events to the control.</P>
<P>On the Miscellaneous tab, do not check the <U>W</U>indowed Only check box--so
that the control will create a window for itself only if the container cannot. Leave
the Stock Properties tab at its default settings. Click OK to add the control object
to the project.</P>
<P>For the last control implementation, you create a control that subclasses another
window's control. Again, from the <U>I</U>nsert menu, select the New <U>A</U>TL Object
menu item. Within the ATL Object Wizard (refer again to fig. 8.4), select the Controls
item in the left panel, and select the Full Control icon. Click the <U>N</U>ext button
to continue.</P>
<P>On the Names tab, within the ATL Object Wizard Properties dialog, add the <U>S</U>hort
Name ATLControlSubWin, and on the Attributes tab, check the Support <U>I</U>SupportErrorInfo
and Support Connection <U>P</U>oints check boxes to add OLE rich error support and
events to the control.</P>
<P>On the Miscellaneous tab, select the Button control from the <U>A</U>dd control
based on list box, and check the <U>W</U>indowed Only check box to ensure that a
window is always created for the control whether the container supports windowless
controls or not. Leave the Stock Properties tabs at its default settings. Click OK
to add the control object to the project.</P>
<P>At this point in the MFC sample (see <A HREF="ch06.htm">Chapter 6</A>), you are
also able to add other ActiveX features as part of the AppWizard implementation.
The ATL AppWizard and Object Wizard do not allow for defining any other ActiveX features
at this point, but they are defined in <A HREF="ch09.htm">Chapter 9</A>.</P>
<P>All of the basic source files and control objects are now added to the control
project. The next step in any control project is to ensure that the project contains
registration support. Without registration, the control cannot be used by any application.
<H2><A NAME="Heading3"></A>Control Registration</H2>
<P>Control registration and unregistration support is provided for you by ATL. You
are not required to make any code changes or additions to support it. Unlike MFC,
which uses a set of constants, ATL relies on resource information in the form of
a registry script file to define the information that is added to the registry database.
The registry script file is added automatically to the project when the control object
is added; one script file is added for each control object.</P>
<P>The registry script file or files are compiled into the control project as resources
and can be viewed in binary form in the resource editor. The files, which have the
extension .rgs, are normal text files that can be edited within the IDE. For more
information about the use of registry script files and their particular syntax, see
the VC++ books online subject &quot;Registry Scripting Examples--Active Template
Library, Articles.&quot; Listing 8.1 shows the registry script file for the <TT>CATLControlWin</TT>
control object that you added.
<H3><A NAME="Heading4"></A>Listing 8.1 ATLCONTROLWIN.RGS--Sample Registry Script
File for the CATLControlWin Control Class</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
HKCR <BR>
{ <BR>
ATLControlWin.ATLControlWin.1 = s `ATLControlWin Class' <BR>
{ <BR>
CLSID = s `{A19F6964-7884-11D0-BEF3-00400538977D}' <BR>
} <BR>
ATLControlWin.ATLControlWin = s `ATLControlWin Class' <BR>
{ <BR>
CurVer = s `ATLControlWin.ATLControlWin.1' <BR>
} <BR>
NoRemove CLSID <BR>
{ <BR>
ForceRemove {A19F6964-7884-11D0-BEF3-00400538977D} = s `ATLControlWin Class' <BR>
{ <BR>
ProgID = s `ATLControlWin.ATLControlWin.1' <BR>
VersionIndependentProgID = s `ATLControlWin.ATLControlWin' <BR>
ForceRemove `Programmable' <BR>
InprocServer32 = s `%MODULE%' <BR>
{ <BR>
val ThreadingModel = s `Apartment' <BR>
} <BR>
ForceRemove `Control' <BR>
ForceRemove `Programmable' <BR>
ForceRemove `Insertable' <BR>
ForceRemove `ToolboxBitmap32' = s `%MODULE%, 1' <BR>
`MiscStatus' = s `0' <BR>
{ <BR>
`1' = s `131473' <BR>
} <BR>
`TypeLib' = s `{A19F6957-7884-11D0-BEF3-00400538977D}' <BR>
`Version' = s `1.0' <BR>
} <BR>
} <BR>
} </TT></FONT></P>
<P>You can now compile and register the control you've created, but it won't be of
much use because it doesn't contain any methods, properties, or events.
<H2><A NAME="Heading5"></A>Creating Methods</H2>
<H2>Creating Methods</H2>
<P>Now that you have successfully created your basic ActiveX control project, you
can add a <I>method</I>, which is one of the basic aspects of component development.</P>
<P>For the purposes of the sample control, you are going to add a method called <TT>CaptionMethod</TT>.
The method will accept two parameters, the second being optional. The first parameter
is a string that the control will display within its client area, and the second,
optional parameter is the alignment of the caption within the client area, either
left, right, or center. Adding methods to an ATL control differs from MFC in that
MFC relies on the familiar ClassWizard, and ATL does not. From the ClassView tab
in the Project Workspace window, select the <TT>IATLControlWin</TT> interface, click
the right mouse button, and select the Add <U>M</U>ethod menu item (see fig. 8.9).</P>
<P>In the Add Method to Interface dialog, add the Method <U>N</U>ame, <TT>CaptionMethod,</TT>
and the <TT>P</TT>arameters, <TT>[in] BSTR bstrCaption, [in, optional] VARIANT varAlignment,
[out, retval] long * lRetVal</TT> (see fig. 8.10). The <U>A</U>ttributes button displays
a dialog for adding Interface Definition Language (IDL) attributes for the entire
function declaration. <B><BR>
<BR>
</B><A HREF="art/08/gfigs09.jpg"><B>FIG. 8.9</B></A> <I><BR>
Add a new method to the control project.</I></P>
<P><A HREF="art/08/gfigs10.jpg"><B>FIG. 8.10</B></A> <I><BR>
Define the <TT>CaptionMethod</TT> method.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> All optional parameters must be of type <TT>VARIANT</TT>, and they
	must fall at the end of the parameter list. Optional parameters are not managed in
	any way by OLE. It is the Server application's responsibility to determine whether
	the <TT>VARIANT</TT> parameter passed to the method contains data and whether to

	<UL>
	<LI>either use the data passed to the method or convert the data to a useful type,
	if possible, or <BR>
	<BR>
	
	<LI>ignore the parameter if invalid data was passed and use the default value if
	appropri- ate, or <BR>
	<BR>
	
	<LI>inform the user of an error condition if one of the above conditions was not
	met.
	</UL>


</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
You've also added the direction that the parameters flow in the form of <TT>[in]</TT>
and <TT>[out]</TT> parameter attributes. See Table 8.1 for a complete description
of the possible attributes that can be used.</P>
<P>Parameter attributes are used to aid development tools in determining how parameters
are used within a function call. A tool like Visual Basic will hide the details of
how parameters are handled--such as creating and destroying memory--based on these
and other attributes in the type library. This is why the type library is so important
to ActiveX component development.</P>
<P>Note that the IDL parameter attributes are added directly to the parameter list.
Click OK to add the method to the control. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 8.1</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Parameter Flow Attributes</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Direction</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>in</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>out</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is returned from callee to caller.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>in, out</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee, and the callee returns a parameter.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>out, retval</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is the return value of the method and is returned from the callee to the
			caller.</TD>
	</TR>
</TABLE>
<BR>
<BR>
To aid your <TT>CaptionMethod</TT> implementation, you need to add an enumeration
for all the valid alignment settings and two member variables to your class definition
(see Listing 8.2). The enumeration is included in the header file Alignmentenums.h
(see Listing 8.3). The two member variables, <TT>m_lptstrCaption</TT> and <TT>m_lAlignment</TT>,
are used to store the caption string and the alignment setting while the control
is being used.</P>
<P>Note the data type used for the <TT>m_lAlignment</TT> member variable. The variable
is declared as type <TT>long</TT> and not as the enumeration type because of the
data type restrictions imposed upon you by ActiveX Automation. Remember that only
data types that can be passed in a <TT>VARIANT</TT> can be used in methods and properties.
By declaring the <TT>m_lAlignment</TT> member as <TT>long</TT>, you do not have to
explicitly convert the value by casting to the enumerated type when it is retrieved
from the <TT>VARIANT</TT> parameter in the <TT>caption</TT> method. On the other
hand, casting the value to the enumerated type is a trivial issue, and its implementation
is based completely on your preference.
<H3><A NAME="Heading6"></A>Listing 8.2 ATLCONTROLWIN.H--Alignment Enumeration Include
File and Member Variables Added to Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
// ATLControlWin.h : Declaration of the CATLControlWin <BR>
#ifndef __ATLCONTROLWIN_H_ <BR>
#define __ATLCONTROLWIN_H_ <BR>
#include &quot;resource.h&quot; // main symbols <BR>
#include &quot;alignmentenums.h&quot; <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// CATLControlWin <BR>
class ATL_NO_VTABLE CATLControlWin : <BR>
. . . <BR>
protected: <BR>
// storage variable for the caption <BR>
LPTSTR m_lptstrCaption; <BR>
// storage variable for the alignment <BR>
long m_lAlignment; <BR>
}; </TT></FONT></P>
<P>The enumeration is added as an include file. By adding the enumeration to an include
file, you are able to use the enumeration in other files simply by including the
file reference, which will be necessary as you proceed through the chapter (see Listing
8.3).
<H3><A NAME="Heading7"></A>Listing 8.3 ALIGNMENTENUMS.H--Alignment Enumeration Include
File</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
#if !defined _ALIGNMENTENUMS_H <BR>
#define _ALIGNMENTENUMS_H <BR>
// caption alignment enumeration <BR>
typedef enum tagAlignmentEnum <BR>
{ <BR>
EALIGN_LEFT = 0, <BR>
EALIGN_CENTER = 1, <BR>
EALIGN_RIGHT = 2, <BR>
}EALIGNMENT; <BR>
#define EALIGN_LEFT_TEXT &quot;Left&quot; <BR>
#define EALIGN_CENTER_TEXT &quot;Center&quot; <BR>
#define EALIGN_RIGHT_TEXT &quot;Right&quot; <BR>
#endif // #if !defined _ALIGNMENTENUMS_H </TT></FONT></P>
<P>You initialize your member variables in the constructor of your control (see Listing
8.4).
<H3><A NAME="Heading8"></A>Listing 8.4 ATLCONTROLWIN.H--Member Variable Initialization</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
. . . <BR>
public IConnectionPointContainerImpl&lt;CATLControlWin&gt;, <BR>
public ISpecifyPropertyPagesImpl&lt;CATLControlWin&gt; <BR>
{ <BR>
public: <BR>
CATLControlWin() <BR>
{ <BR>
// NULL terminate the string reference <BR>
m_lptstrCaption = new TCHAR[1]; <BR>
m_lptstrCaption[0] = `\0'; <BR>
// set the alignment to the default of left <BR>
m_lAlignment = EALIGN_LEFT; <BR>
} <BR>
DECLARE_REGISTRY_RESOURCEID(IDR_ATLCONTROLWIN) <BR>
. . . </TT></FONT></P>
<P>The <TT>CaptionMethod</TT> contains all of the code for setting the caption and
the alignment style, and like the MFC implementation, deals with the optional parameter
correctly (see Listing 8.5). See <A HREF="ch06.htm">Chapter 6</A> for more information
about optional parameters and their use.</P>
<P>Since the <TT>CaptionMethod</TT> is used for the <TT>IDispatch</TT> implementation
and the custom interface, the method is implemented in a slightly different way than
its MFC counterpart. First the function is declared as <TT>STDMETHODIMP</TT>, which
expands to an <TT>HRESULT</TT> return type. The return value is used by OLE to determine
whether the method call succeeded. The string parameter is passed in differently
also. All strings are passed as <TT>UNICODE</TT> in OLE. This is true even for MFC.
The only difference is that MFC hides the implementation details of how the strings
are managed; the developer simply uses the appropriate string data type based on
the target application and platform, that is, Win32 ANSI versus Win32 UNICODE. Note
the use of the USES_CONVERSION and W2A macros to convert the string from UNICODE
to ANSI. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>Useful Helper Functions and Conversion Macros</B><BR>
	The files ATLCONV.H and ATLCONV.CPP, which can be found in the directory ...\DevStudio\VC\ATL\include,
	contain a number of helper functions and macros for converting data such as UNICODE
	strings to ANSI. Since ATL does not require the use of MFC, you are wise to examine
	these files before writing functions to convert data.

</BLOCKQUOTE>

<P>
<HR>
<BR>
<BR>
Next, if the <TT>VARIANT</TT> is of a valid data type other than <TT>VT_I4</TT>,
the method tries to convert it to a <TT>VT_I4</TT> type. You try to convert the data
for the cases where a user passes valid data in the form of a different data type,
for example, a short or a string.</P>
<P>One very important thing to note is the use of the function <TT>VariantInit:</TT>.
All <TT>VARIANT</TT> variables must be initialized prior to their use. This practice
guarantees that the <TT>VARIANT</TT> does not contain invalid data type information
or invalid values. This practice follows the basic C++ tenet of initializing all
member variables to ensure that they do not contain invalid information.</P>
<P>If the requirements of your control demand that you deal with only specific data
types, you can also choose to add code (error messages, exceptions, and so on) to
deal with the fact that the method did not receive a valid data type. If the function
<TT>VariantChangeType</TT> is unable to convert the data, the method exits and returns
a value of <TT>FALSE</TT>. A return of <TT>FALSE</TT> indicates to the caller of
the method that the method didn't succeed. Again, you can also choose to add additional
error handling code to the method to give the user more information about the error
that occurred. See <A HREF="ch03.htm">Chapters 3</A> through <A HREF="ch05.htm">5</A>
on generating OLE exceptions for more information.</P>
<P>Before proceeding, the method ensures that the <TT>m_lAlignment</TT> member variable
contains valid data.</P>
<P>If the method received valid data or converted the data to a valid value, as indicated
by the variable <TT>lResult</TT> equaling <TT>TRUE</TT>, the method stores the caption
and the alignment values in the class member variables, invalidates the control so
it will redraw its User Interface (UI) based on the new information, and exits the
function.</P>
<P>Listing 8.5 contains another important difference from that of its MFC counterpart:
use of the function <TT>FireViewChange</TT> in place of the MFC <TT>InvalidateControl</TT>
function to force the control to repaint itself. Wherever appropriate, we will point
out the differences between MFC and ATL.
<H3><A NAME="Heading9"></A>Listing 8.5 ATLCONTROLWIN.CPP--CaptionMethod Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
STDMETHODIMP CATLControlWin::CaptionMethod(BSTR bstrCaption, VARIANT <BR>
varAlignment, long * lRetVal) <BR>
{ <BR>
// needed for the W2A macro <BR>
USES_CONVERSION; <BR>
HRESULT hResult = S_OK; <BR>
// return value initialized to failure result <BR>
*lRetVal = FALSE; <BR>
// convert the string to ANSI <BR>
LPTSTR lptstrTempCaption = W2A(bstrCaption); <BR>
// if the variant is a long just use the value <BR>
if(VT_I4 == varAlignment.vt) <BR>
{ <BR>
// assign the value to our member variable <BR>
m_lAlignment = varAlignment.lVal; <BR>
// set the return value <BR>
*lRetVal = TRUE; <BR>
} <BR>
// if the user didn't supply an alignment parameter we will assign the default <BR>
else if(VT_ERROR == varAlignment.vt || VT_EMPTY == varAlignment.vt) <BR>
{ <BR>
// assign the value to our member variable <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// set the return value <BR>
*lRetVal = TRUE; <BR>
} <BR>
else <BR>
{ <BR>
// get a variant that we can use for conversion purposes <BR>
VARIANT varConvertedValue; <BR>
// initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); <BR>
// see if we can convert the data type to something useful <BR>
// VariantChangeTypeEx() could also be used <BR>
if(S_OK == ::VariantChangeType(&amp;varConvertedValue, <BR>
(VARIANT *) &amp;varAlignment, 0, VT_I4)) <BR>
{ <BR>
// assign the value to our member variable <BR>
switch(varConvertedValue.lVal) <BR>
{ <BR>
case EALIGN_CENTER: <BR>
m_lAlignment = EALIGN_CENTER; <BR>
break; <BR>
case EALIGN_RIGHT: <BR>
m_lAlignment = EALIGN_RIGHT; <BR>
break; <BR>
default: <BR>
m_lAlignment = EALIGN_LEFT; <BR>
break; <BR>
} <BR>
// set the return value <BR>
*lRetVal = TRUE; <BR>
} <BR>
else <BR>
{ <BR>
// at this point we could either throw an error indicating <BR>
// there was a problem converting <BR>
// the data or change the return type of the method and <BR>
// return the HRESULT value from the <BR>
// the &quot;VariantChangeType&quot; call. <BR>
} <BR>
} <BR>
// if everything was OK <BR>
if(TRUE == *lRetVal) <BR>
{ <BR>
// if we have a string <BR>
if(lptstrTempCaption != NULL) <BR>
{ <BR>
// if we have a string <BR>
if(m_lptstrCaption) <BR>
{ <BR>
// delete the existing string <BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe <BR>
m_lptstrCaption = NULL; <BR>
} <BR>
// allocate a new string <BR>
m_lptstrCaption = new TCHAR[lstrlen(lptstrTempCaption) + 1]; <BR>
// assign the string to our member variable <BR>
lstrcpy(m_lptstrCaption, lptstrTempCaption); <BR>
} <BR>
// did they pass us bad data? <BR>
if(m_lAlignment &lt; EALIGN_LEFT || m_lAlignment &gt; EALIGN_RIGHT) <BR>
// sure did, lets fix their little red wagon <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
} <BR>
// return the result of the function call <BR>
return hResult; <BR>
} </TT></FONT></P>
<H2><A NAME="Heading10"></A>Properties</H2>
<P><I>Properties</I> can be categorized as user defined, stock, or ambient.</P>
<P><I>User defined properties</I> are properties that are implementation-specific
and have meaning only to the component that contains them. User defined properties
can be further broken into those properties that are defined only as their specific
data type (<I>normal</I> properties) and those with additional parameters (<I>parameterized</I>
properties).</P>
<P><I>Stock properties</I> are a set of properties that are already defined by OLE
in terms of the basic meaning. Stock properties are not implemented in the control
of the container by default. They still require implementation by the control developer.
They are predefined only to imply a certain level of uniformity between various control
implementations.</P>
<P><I>Ambient properties,</I> on the other hand, are properties that are supported
by the container to provide a default value to the control that uses them.</P>
<P>In the remainder of this section, you will create normal, parameterized, and stock
properties. You will also learn how to use ambient properties.
<H3><A NAME="Heading11"></A>Creating Normal User Defined Properties</H3>
<P>A <I>normal property</I> is a property that is declared as a single type, for
example, <TT>long</TT> or <TT>BSTR</TT>, and has no parameters. You will expose your
control's Alignment member variable through a property.</P>
<P>Properties are added in much the same way as methods. From the ClassView tab in
the Project Workspace window, select the <TT>IATLControlWin</TT> interface, click
the right mouse button, and select the Add <U>P</U>roperty menu item (see fig. 8.11).
<B><BR>
<BR>
</B><A HREF="art/08/gfigs11.jpg"><B>FIG. 8.11</B></A> <I><BR>
Add a new property to the control with the ATL ClassWizard.</I></P>
<P>In the Add Property to Interface dialog, set the Property <U>T</U>ype to <TT>long</TT>,
the Property <U>N</U>ame to <TT>Alignment</TT>, and leave the remainder of the settings
at their default values (see fig. 8.12). Click OK to confirm the entry and close
the dialog. <B><BR>
<BR>
</B><A HREF="art/08/gfigs12.jpg"><B>FIG. 8.12</B></A><B> </B><I><BR>
Define the <TT>Alignment</TT> property attributes.</I></P>
<P>After adding the property, you need to update the IDL file with a dispid constant
name that can be used from within the control implementation source files. Listing
8.6 shows the <TT>typedef</TT> that is added to the IDL file. The dispids are added
as an enumeration so that the MIDL compiler will generate an enumeration in the ATLControl.h
header file, which defines the interfaces and classes available in the control IDL
file. The reason for adding the dispids as a set of constants is the same reason
for having any constant. If the value of the dispid were to change, you wouldn't
have to search your source code trying to find where you used the value. Listing
8.6 also shows the change that is made to the <TT>Alignment</TT> property declaration
functions to reflect the dispid constant.
<H3><A NAME="Heading12"></A>Listing 8.6 ATLCONTROL.IDL--Dispid Enumeration Added
to the IDL File to Aid in the Support of Properties in the Control</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
typedef enum propdispids <BR>
{ <BR>
dispidAlignment = 2, <BR>
}PROPDISPIDS; <BR>
. . . <BR>
interface IATLControlWin : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method CaptionMethod&quot;)] <BR>
HRESULT CaptionMethod([in] BSTR bstrCaption, <BR>
[in, optional] VARIANT varAlignment, [out, retval] long * lRetVal); <BR>
[propget, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([out, retval] long *pVal); <BR>
[propput, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([in] long newVal); <BR>
}; <BR>
. . . </TT></FONT></P>
<P>Open the file ATLControlWin.cpp so that you can modify the <TT>get_Alignment/put_Alignment</TT>
functions. You could also select the functions from the Class View tab of the Project
Workspace window.</P>
<P>As you can see, Listing 8.7 takes advantage of the member variable <TT>m_Alignment</TT>,
which you added earlier, and uses the member to get and set the property value.</P>
<P>The <TT>GetAlignment</TT> function is simple in that it returns only the value
stored in the <TT>m_lAlignment</TT> member variable.</P>
<P>The <TT>SetAlignment</TT> function does a little more. This function checks to
see if the value is within the valid ranges of values and, if so, stores the value
in the <TT>m_lAlignment</TT> member variable. The function then calls the <TT>SetDirty</TT>
and the <TT>FireOnChanged</TT> functions--note the MFC equivalent functions still
in the code--to notify the control and the container, respectively, that the value
of the property has changed. <TT>FireOnChanged</TT> has the effect of forcing the
container to refresh its property browser to reflect the new value. This step is
very important because the value of the property could change without the container's
knowledge, either through the control's property sheet or, in some cases, in response
to another function call.</P>
<P>You might be asking &quot;Why didn't I add <TT>FireOnChanged</TT> to the <TT>CaptionMethod</TT>?&quot;
Well, you could have, but it wouldn't do much because the <TT>CaptionMethod</TT>
can never be executed while the control is in design mode, which is the purpose of
<TT>FireOnChanged</TT>. The <TT>FireOnChanged</TT> function is where you make use
of the dispid constants that were defined earlier.</P>
<P>The last thing the <TT>SetAlignment</TT> method does is to invalidate the control's
UI so it will repaint using the new information.
<H3><A NAME="Heading13"></A>Listing 8.7 ATLCONTROLWIN.CPP--Alignment Property Get/Put
Method Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::get_Alignment(long * pVal)
<BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
// return our current setting <BR>
*pVal = m_lAlignment; <BR>
return hResult; <BR>
} <BR>
STDMETHODIMP CATLControlWin::put_Alignment(long newVal) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
// if we are in the valid range for the property <BR>
if(newVal &gt;= EALIGN_LEFT &amp;&amp; newVal &lt;= EALIGN_RIGHT) <BR>
{ <BR>
// set the new property value <BR>
m_lAlignment = newVal; <BR>
// let the control know that the property has changed <BR>
this-&gt;SetDirty(TRUE); <BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
// refresh the property browser <BR>
this-&gt;FireOnChanged(dispidAlignment); <BR>
// this-&gt;BoundPropertyChanged(dispidAlignment); &lt;== MFC Version <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
} <BR>
return hResult; <BR>
} </TT></FONT></P>
<H3><A NAME="Heading14"></A>Creating Parameterized User Defined Properties</H3>
<P>A <I>parameterized property</I> is a property that, in addition to being of a
specific type (for example, <TT>BSTR</TT> or <TT>long</TT>), accepts one or more
additional parameters to further define the data of the property. Parameterized properties
can be useful for properties that represent collections of data where the additional
parameter is the index into the collection.</P>
<P>You are going to expose the control's <TT>m_lptstrCaption</TT> member variable
as a parameterized property in addition to your <TT>CaptionMethod</TT> function.</P>
<P>Parameterized properties are added in the same manner as normal properties. From
the ClassView tab in the Project Workspace window, select the <TT>IATLControlWin</TT>
interface, click the right mouse button, and select the Add <U>P</U>roperty menu
item.</P>
<P>In the Add Property to Interface dialog, set the Property <U>T</U>ype to <TT>BSTR</TT>
and the Property <U>N</U>ame to <TT>CaptionProp</TT>, add the Para<U>m</U>eters string
<TT>[in, optional] VARIANT varAlignment</TT>, and leave the remainder of the settings
at their default values (see fig. 8.13). Click OK to confirm the entry and close
the dialog. <B><BR>
<BR>
</B><A HREF="art/08/gfigs13.jpg"><B>FIG. 8.13</B></A><B> </B><I><BR>
Define the <TT>Caption</TT> property <TT>propget</TT> function attributes.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Even though the <TT>VARIANT</TT> <TT>varAlignment</TT> is defined
	as <TT>[optional]</TT> for both the <TT>get_CaptionProp</TT> and <TT>put_CaptionProp</TT>
	functions, only the <TT>get_CaptionProp</TT> implementation is truly optional. The
	parameter was added in this fashion because it is impossible to use the ATL ClassWizard
	to generate two separate functions each having the same name and ID. The <TT>[optional]</TT>
	attribute can be removed from the <TT>put_CaptionProp</TT> function if you want without
	adverse effect on the implementation.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>
<P>As with the normal user defined parameter, you add a constant, <TT>dispidCaptionProp</TT>,
to the IDL file (see Listing 8.8) that represents the dispid of the property. You
also need to replace the <TT>id</TT> of the property with the newly added constant
<TT>dispidCaptionProp</TT>.
<H3><A NAME="Heading15"></A>Listing 8.8 ATLCONTROL.IDL--Update the IDL File to Support
the Parameterized Property</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
typedef enum propdispids <BR>
{ <BR>
dispidAlignment = 2, <BR>
dispidCaptionProp = 3, <BR>
}PROPDISPIDS; <BR>
[ <BR>
object, <BR>
uuid(A19F6963-7884-11D0-BEF3-00400538977D), <BR>
dual, <BR>
helpstring(&quot;IATLControlWin Interface&quot;), <BR>
pointer_default(unique) <BR>
] <BR>
interface IATLControlWin : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method CaptionMethod&quot;)] <BR>
HRESULT CaptionMethod([in] BSTR bstrCaption, <BR>
[in, optional] VARIANT varAlignment, [out, retval] long * lRetVal); <BR>
[propget, id(dispidCaptionProp), helpstring(&quot;property CaptionProp&quot;)] <BR>
HRESULT CaptionProp([in, optional] VARIANT varAlignment, <BR>
[out, retval] BSTR *pVal); <BR>
[propput, id(dispidCaptionProp), helpstring(&quot;property CaptionProp&quot;)] <BR>
HRESULT CaptionProp([in] VARIANT varAlignment, [in] BSTR newVal); <BR>
[propget, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([out, retval] long *pVal); <BR>
[propput, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([in] long newVal); <BR>
}; <BR>
. . . </TT></FONT></P>
<P>The method <TT>get_CaptionProp</TT> is called to return data from the property.
In your implementation, you are going to ignore the alignment parameter because it
is of no use to you in this context; you simply return the caption (see Listing 8.9).
You need to make sure that the string variable, <TT>BSTR * pVal</TT>, that is passed
to the <TT>get_CaptionProp</TT> function does not already point to another string;
if it does, you need to destroy it. Next <TT>get_CaptionProp</TT> uses the function
<TT>SysAllocString</TT> to create a <TT>BSTR </TT>that is returned from the function
call. Note that it is first necessary to convert the <TT>ANSI</TT> string to an <TT>OLECHAR</TT>
string and then allocate a <TT>BSTR</TT> from that. The macros <TT>USES_CONVERSION</TT>
and <TT>T2OLE</TT> accomplish this for you.
<H3><A NAME="Heading16"></A>Listing 8.9 ATLCONTROLWIN.CPP--get_CaptionProp Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::get_CaptionProp(VARIANT
varAlignment, BSTR * pVal) <BR>
{ <BR>
// needed for the T2OLE macro <BR>
USES_CONVERSION; <BR>
// if there is a string <BR>
if(*pVal) <BR>
{ <BR>
// free the string because we are going to replace it <BR>
::SysFreeString(*pVal); <BR>
// clear the reference just to be safe <BR>
*pVal = NULL; <BR>
} <BR>
// convert the ANSI string to an OLECHAR and then allocate a BSTR <BR>
*pVal = ::SysAllocString(T2OLE(m_lptstrCaption)); <BR>
return S_OK; <BR>
} </TT></FONT></P>
<P><TT>put_CaptionProp</TT> simply defers to the <TT>CaptionMethod</TT> implementation
because the <TT>CaptionMethod</TT> already does everything that you need (see Listing
8.10).
<H3><A NAME="Heading17"></A>Listing 8.10 ATLCONTROLWIN.CPP--SetCaptionProp Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::put_CaptionProp(VARIANT
varAlignment, BSTR newVal) <BR>
{ <BR>
long lRetVal; <BR>
// defer to the CaptionMethod implementation <BR>
HRESULT hResult = this-&gt;CaptionMethod(newVal, varAlignment, &amp;lRetVal); <BR>
// if the function returned success <BR>
if(TRUE == lRetVal) <BR>
// let the control know that the property has changed <BR>
this-&gt;SetDirty(TRUE); <BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
// return the result <BR>
return hResult; <BR>
} </TT></FONT></P>
<H3><A NAME="Heading18"></A>Creating Stock Properties</H3>
<P>A <I>stock property</I> is a property that is understood by a control and its
container and that has a predefined meaning to both. Stock properties are intended
to provide basic uniform functionality to all the controls and containers that implement
them. Stock properties do not require you to implement a lot of code; you just hook
into the existing property.</P>
<P>Stock properties can be added to a control in two ways. The first way is during
the actual creation of the control using the ATL Object Wizard. You may recall that
earlier in the chapter one of the options in the ATL Object Wizard Properties dialog
was the Stock Properties tab (refer to fig. 8.8). If you add the stock properties
at this point, the ATL Object Wizard will add the class <TT>CStockPropImpl&lt;...&gt;</TT>
to your class declaration and will add the necessary IDL <TT>get_/put_</TT> function
declarations for each one of the properties.</P>
<P>The Object Wizard will also add a member variable to your class for each one of
the properties. The <TT>CStockPropImpl&lt;...&gt;</TT> template class contains declarations
for all of the available stock properties in the form of <TT>IMPLEMENT_STOCKPROP</TT>
and <TT>IMPLEMENT_BSTR_STOCKPROP</TT> macros. The macros define all of the appropriate
<TT>get_/put_</TT> function implementations for you; you need to use only the member
variable when you want to use the stock property. If you want to, you can also add
the <TT>CStockPropImpl&lt;...&gt;</TT> class after your control object has been created
and follow the same steps that were outlined in the preceding paragraph when creating
stock properties. Note that the <TT>CStockPropImpl&lt;...&gt;</TT> class replaces
the <TT>IDispatchImpl&lt;...&gt;</TT> class.</P>
<P>The second method of adding a stock property is the same method as for any other
user defined property. From the ClassView tab in the Project Workspace window, select
the <TT>IATLControlWin</TT> class, click the right mouse button, and select the Add
<U>P</U>roperty menu item. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The documentation about the use of the <TT>IMPLEMENT_STOCKPROP</TT>
	and <TT>IMPLEMENT_BSTR_STOCKPROP</TT> macros within your class is somewhat misleading.
	The macros depend on the <TT>CStockPropImpl&lt;...&gt;</TT> class, and they cannot
	simply be added to your control implementation, as is implied by the documentation
	on ATL support of stock properties.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
In the Add Property to Interface dialog, set the Property <U>T</U>ype to <TT>OLE_COLOR</TT>,
the Property <U>N</U>ame to <TT>BackColor</TT>, and leave the remainder of the settings
at their default values (see fig. 8.14). Click OK to confirm the entry and close
the dialog. <B><BR>
<BR>
</B><A HREF="art/08/gfigs14.jpg"><B>FIG. 8.14</B></A> <BR>
<I>Add the <TT>BackColor</TT> stock property to the control with the ATL ClassWizard.</I></P>
<P>The next step is to modify the IDL file to reflect the correct dispid for the
<TT>BackColor</TT> property. In this case, you need to replace the <TT>id</TT> with
<TT>DISPID_BACKCOLOR</TT>.
<H3><A NAME="Heading19"></A>Listing 8.11 ATLCONTROL.IDL--Add the Constant DISPID_BACKCOLOR
to the IDL to Support the BackColor Stock Property</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
interface IATLControlWin : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method CaptionMethod&quot;)] <BR>
HRESULT CaptionMethod([in] BSTR bstrCaption, <BR>
[in, optional] VARIANT varAlignment, [out, retval] long * lRetVal); <BR>
[propget, id(DISPID_BACKCOLOR), helpstring(&quot;property BackColor&quot;)] <BR>
HRESULT BackColor([out, retval] OLE_COLOR *pVal); <BR>
[propput, id(DISPID_BACKCOLOR), helpstring(&quot;property BackColor&quot;)] <BR>
HRESULT BackColor([in] OLE_COLOR newVal); <BR>
[propget, id(dispidCaptionProp), helpstring(&quot;property CaptionProp&quot;)] <BR>
HRESULT CaptionProp([in, optional] VARIANT varAlignment, <BR>
[out, retval] BSTR *pVal); <BR>
[propput, id(dispidCaptionProp), helpstring(&quot;property CaptionProp&quot;)] <BR>
HRESULT CaptionProp([in, optional] VARIANT varAlignment, <BR>
[in] BSTR newVal); <BR>
[propget, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([out, retval] long *pVal); <BR>
[propput, id(dispidAlignment), helpstring(&quot;property Alignment&quot;)] <BR>
HRESULT Alignment([in] long newVal); <BR>
}; <BR>
. . . </TT></FONT></P>
<P>Next you add a member variable to your class declaration that will store the <TT>BackColor</TT>
property (see Listing 8.12).
<H3><A NAME="Heading20"></A>Listing 8.12 ATLCONTROLWIN.H--m_BackColor Member Variable
Added to the Class Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
protected: <BR>
// storage variable for the caption <BR>
LPTSTR m_lptstrCaption; <BR>
// storage variable for the alignment <BR>
long m_lAlignment; <BR>
// storage variable for the BackColor stock property <BR>
OLE_COLOR m_BackColor; <BR>
}; <BR>
#endif //__ATLCONTROLWIN_H_ </TT></FONT></P>
<P>Finally you must update the <TT>get_BackColor/put_BackColor</TT> functions to
return and store the <TT>BackColor</TT> property (see Listing 8.13).
<H3><A NAME="Heading21"></A>Listing 8.13 ATLCONTROLWIN.CPP--BackColor Property Source
File Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CATLControlWin::get_BackColor(OLE_COLOR
* pVal) <BR>
{ <BR>
// return the color <BR>
*pVal = m_BackColor; <BR>
return S_OK; <BR>
} <BR>
STDMETHODIMP CATLControlWin::put_BackColor(OLE_COLOR newVal) <BR>
{ <BR>
// if the value is the same <BR>
if(newVal == m_BackColor) <BR>
return S_OK; <BR>
// store the value <BR>
m_BackColor = newVal; <BR>
// let the container know that the value has changed <BR>
this-&gt;FireOnChanged(DISPID_BACKCOLOR); <BR>
// this-&gt;AmbientPropertyChanged(DISPID_BACKCOLOR); &lt;== MFC Version <BR>
// redraw the control <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
// set the dirty flag <BR>
this-&gt;SetDirty(TRUE); <BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC Version <BR>
// exit <BR>
return S_OK; <BR>
} </TT></FONT></P>
<P>The last thing is to initialize the <TT>m_BackColor</TT> member within the constructor
of the class (see Listing 8.14).
<H3><A NAME="Heading22"></A>Listing 8.14 ATLCONTROLWIN.H--Initialize the BackColor
Property to an Initial Value</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
CATLControlWin() <BR>
{ <BR>
// NULL terminate the string reference <BR>
m_lptstrCaption = new TCHAR[1]; <BR>
m_lptstrCaption[0] = `\0'; <BR>
// set the alignment to the default of left <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// set the backcolor to the system default <BR>
m_BackColor = 0x80000000 | COLOR_WINDOW; <BR>
} <BR>
. . . </TT></FONT></P>
<P>Regardless of the implementation style that you use, you can now access the <TT>BackColor</TT>
stock property through the member variable in your class, just as you do any other
property. This implementation differs from the MFC implementation of stock properties,
which hides all of the details regarding their implementation from you.
<H3><A NAME="Heading23"></A>Using Ambient Properties</H3>
<P><I>Ambient properties</I> are properties implemented in the container in which
the control resides, as opposed to <I>stock properties, </I>which are implemented
in the control and not the container. Ambient properties share the same set of predefined
meanings and dispids as those of stock properties. To use an ambient property, the
control must request only the property value from the container and apply it in whatever
manner is appropriate for the property type. The use of ambient properties allows
the control to conform to the same settings as those of the container in which it
resides. This procedure provides much better integration between the control and
its container.</P>
<P>Take the previous example of adding the <TT>BackColor</TT> stock property to the
sample control implementation. Defined as a stock property, the user of the control
can change the background color of the control or leave it as is. If the color is
different from that of the container or if the container's background color changes
for some reason, the colors won't match and will give the appearance of a poorly
integrated and written application. However, if the control simply used the ambient
background color of its container, the control's background will always match that
of the container. The specific requirements of your control implementation will decide
which route you choose when implementing the properties your control supports.</P>
<P>To access an ambient property, you can call one of the many ambient property functions
defined in the <TT>CComControlBase</TT> class, for example, Get<TT>AmbientBackColor()</TT>
in the case of the <TT>BackColor</TT> property.
<H3><A NAME="Heading24"></A>Creating Property Sheets</H3>
<P>Property sheets are a way for a control to display its properties for review and
editing using a tabbed-dialog format. The original intent of property sheets were
for the cases when the control container did not support property browsing facilities.
While property sheets have their purpose, they are probably not necessary for all
implementations. Your specific requirements will determine whether your control should
contain a property sheet. The official OLE line is that all controls should have
property sheets. This is true for commercially developed and distributed controls
but is probably not the case for in-house implementations. The majority of development
environments already have excellent property browsing facilities. Implement property
sheets only if you feel that you absolutely have to.</P>
<P>Removing the property sheets and their corresponding implementation infrastructure
will definitely reduce the size of your control and should not take away from its
implementation in any way.</P>
<P>Before you can work on the implementation of the property sheet, you must add
a property sheet object to your control. This is done through the ATL Object Wizard.
From the <U>I</U>nsert menu, select the New <U>A</U>TL Object menu item. Within the
ATL Object Wizard, select the Controls item in the left panel to display the types
of control components that can be added (see fig. 8.15). Your implementation will
be a Property Page, so select the Property Page icon. Click the <U>N</U>ext button
to continue. <B><BR>
<BR>
</B><A HREF="art/08/gfigs15.jpg"><B>FIG. 8.15</B></A> <I><BR>
Add a property page object to your class with the ATL Object Wizard.</I></P>
<P>Select the Names tab in the ATL Object Wizard Properties dialog, and in the <U>S</U>hort
Name edit field, type ATLControlWinPPG; the remainder of the edit fields will automatically
update, reflecting the short name that you added (see fig. 8.16). The other fields
can be changed, but in this case, you use the default values. <B><BR>
<BR>
</B><A HREF="art/08/gfigs16.jpg"><B>FIG. 8.16</B></A> <I><BR>
Enter the name of the property page object.</I></P>
<P>Select the Strings tab, and enter the string <TT>General</TT> to the <U>T</U>itle
edit field and <TT>ATLControlWin</TT> Property Page to the <U>D</U>oc String edit
fields. The <U>H</U>elpfile edit field is where you add the name of the help file
associated with the property page; for now, leave the value at its default setting.
Click OK to add the property page object to your control.</P>
<P>The ATL Object Wizard adds all of the necessary code to your control implementation
to include the new property page object, including the <TT>OBJECT_MAP</TT>, the IDL
file, and all of the registry and resource information.</P>
<P>Because property sheets are tabbed dialogs, most of your work is done with the
dialog editor. Select the Resource View in the Project Workspace window. From the
list of dialogs, select <TT>IDD_ATLCONTROLWINPPG</TT>, and double-click the entry
to open the resource editor.</P>
<P>Using the resource editor, remove the static text control with the caption Insert
your controls here, and place a static text control and a combo box on the dialog.</P>
<P>Using the mouse, select the label control on the form, and click the right mouse
button. In the menu that appears, select the <U>P</U>roperties menu item. On the
General tab, set the <U>I</U>D of the control to <TT>IDC_ALIGNMENTLABEL</TT>, and
set the <U>C</U>aption to <TT>Alignment</TT>; you see the control in Figure 8.17.
Select the Styles tab, and set the Align Te<U>x</U>t property to <TT>Right</TT>.
Close the dialog to save the information. <B><BR>
<BR>
</B><A HREF="art/08/gfigs17.jpg"><B>FIG. 8.17</B></A> <BR>
<I>Add the controls to the Property Sheet dialog to display your property data.</I></P>
<P>Again, using the mouse, select the combo box, use the right mouse to click the
control, and in the menu that appears, select the <U>P</U>roperties menu item. On
the General tab, set the <U>I</U>D of the control to <TT>IDC_ALIGNMENTCOMBO</TT>.
On the Styles tab, set the T<U>y</U>pe to Dropdown, and uncheck the S<U>o</U>rt check
box. Close the dialog to save the information.</P>
<P>You have placed your two controls onto the property sheets and successfully modified
their properties. Now you need to add some code to complete the implementation. Close
the resource editor, and open the file ATLControlWinPPG.h. Your implementation of
the property page requires several resource definitions and the <TT>Alignment</TT>
enumeration that you created earlier. The values are added to the property page header
file in the form of <TT>include</TT> statements (see Listing 8.15).
<H3><A NAME="Heading25"></A>Listing 8.15 ATLCONTROLWINPPG.H--Add the Necessary Include
Files to the Property Page Header File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;resource.h&quot; // main symbols <BR>
#include &quot;alignmentenums.h&quot; <BR>
#include &quot;ATLControl.h&quot; <BR>
EXTERN_C const CLSID CLSID_ATLControlWinPPG; <BR>
. . . </TT></FONT></P>
<P>Since the property page is based on a dialog, you add a message handler for the
<TT>WM_INITDIALOG</TT> message so that you can load the <TT>Alignment</TT> combo
box with the value from the control's property when the property page is first created
(see Listing 8.16). ATL message maps are very similar to MFC; however, ATL lacks
the ClassWizard support that makes MFC so attractive. The message handler consists
of a single line added to the <TT>BEGIN_MSG_MAP</TT> macro. This line identifies
the message and receiving function that you want to implement, in this case <TT>WM_INITDIALOG</TT>
and <TT>OnInitDialog</TT>. The <TT>OnInitDialog</TT> function retrieves the window
handle to the <TT>Alignment</TT> combo box and resets its content. Next you add the
three string representations of the different <TT>Alignment</TT> styles possible
to the combo box. Then you retrieve a pointer to the control and get the current
property value of the <TT>Alignment</TT> property, and using the value, set the current
selection in the <TT>Alignment</TT> combo box. Note the use of the standard Win32
<TT>SendMessage</TT> function to update the data and settings of the combo box, which
is different from MFC, which has classes that wrap most of the core Win32 functions.
<H3><A NAME="Heading26"></A>Listing 8.16 ATLCONTROLWINPPG.H--Add the OnInitDialog
Message Handler so the Property Page Can Be Initialized</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_MSG_MAP(CATLControlWinPPG) <BR>
MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog) <BR>
COMMAND_HANDLER(IDC_ALIGNMENTCOMBO, CBN_SELCHANGE, <BR>
OnAlignmentComboSelChange) <BR>
CHAIN_MSG_MAP(IPropertyPageImpl&lt;CATLControlWinPPG&gt;) <BR>
END_MSG_MAP() <BR>
LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &amp; bHandled)
<BR>
{ <BR>
// get the window handle of the combobox control <BR>
HWND hTempWnd = ::GetDlgItem(m_hWnd, IDC_ALIGNMENTCOMBO); <BR>
// make sure that the control is empty <BR>
::SendMessage(hTempWnd, CB_RESETCONTENT, 0, 0); <BR>
// set the selection strings in the control - it is important that the control <BR>
// be unsorted since the entries index will relate to the property setting <BR>
::SendMessage(hTempWnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR) EALIGN_LEFT_TEXT); <BR>
::SendMessage(hTempWnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR) <BR>
EALIGN_CENTER_TEXT); <BR>
::SendMessage(hTempWnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR) EALIGN_RIGHT_TEXT); <BR>
// see if the object supports the interface we need <BR>
CComQIPtr&lt;IATLControlWin, &amp;IID_IATLControlWin&gt;pControl(m_ppUnk[0]); <BR>
long lAlignment; <BR>
// set the control with the new value and if it failed <BR>
pControl-&gt;get_Alignment(&amp;lAlignment); <BR>
// get the current selection in the listbox <BR>
::SendMessage(::GetDlgItem(m_hWnd, IDC_ALIGNMENTCOMBO), <BR>
CB_SETCURSEL, lAlignment, 0); <BR>
return TRUE; <BR>
} <BR>
LRESULT OnAlignmentComboSelChange(WORD wNotify, WORD wID, HWND hWnd, <BR>
BOOL&amp; bHandled) <BR>
{ <BR>
SetDirty(TRUE); <BR>
return FALSE; <BR>
} <BR>
. . . </TT></FONT></P>
<P>The property page contains a combo box that the user can use to change the value
of the <TT>Alignment</TT> property. When the user changes the value, the property
page has to be notified of the change so that the property page will update the control
with the new property value. As for the <TT>WM_INITDIALOG</TT> message, you are required
to add a <TT>WM_COMMAND</TT> message handler for the <TT>CBN_SELCHANGE</TT> message
that the combo box will fire when its value changes. Adding the message handler is
done through a slightly different type of message map called a <TT>COMMAND_HANDLER</TT>,
which assumes that the primary message is <TT>WM_COMMAND</TT> (see Listing 8.16)
and breaks the submessage into its appropriate values for you. The function<TT> OnAlignmenComboSelChange</TT>
simply sets the dirty flag for the property page and exits.</P>
<P>The last step is the actual updating of the control's properties when the property
page exits. By setting the dirty flag of the property page, you instruct the <TT>Apply</TT>
function to execute, which allows you the opportunity to update all the property
values that the property page is responsible for. The <TT>Apply</TT> function is
already supplied to you as part of the property page implementation (see Listing
8.17). You need only add your support for your specific properties.</P>
<P>Since more than one object may have a reference to the property page, you are
required to notify all of the objects that the properties have changed. The <TT>Apply</TT>
function cycles through all of the references checking to see whether each contains
the interface that you are looking for. If you find an interface that you can use,
you then need only call the appropriate member functions for each of the properties
that you support. If, for some reason, the setting of the property causes an error,
the property page notifies the user with an error message. You then reset the <TT>m_bDirty</TT>
flag to <TT>FALSE</TT> and exit the function. At this point, the property dialog
closes, and control returns to the development environment hosting the control.
<H3><A NAME="Heading27"></A>Listing 8.17 ATLCONTROLWINPPG.H--Modify the Apply Function
to Update All of the Properties in the Control When the Property Page Exits</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
STDMETHOD(Apply)(void) <BR>
{ <BR>
USES_CONVERSION; <BR>
ATLTRACE(_T(&quot;CATLControlWinPPG::Apply\n&quot;)); <BR>
for (UINT i = 0; i &lt; m_nObjects; i++) <BR>
{ <BR>
// see if the object supports the interface we need <BR>
CComQIPtr&lt;IATLControlWin, &amp;IID_IATLControlWin&gt; pControl(m_ppUnk[i]); <BR>
// get the current selection in the listbox <BR>
long lAlignment = (long) ::SendMessage( <BR>
::GetDlgItem(m_hWnd, IDC_ALIGNMENTCOMBO), CB_GETCURSEL, 0, 0); <BR>
// set the control with the new value and if it failed <BR>
if FAILED(pControl-&gt;put_Alignment(lAlignment)) <BR>
{ <BR>
// generate an error message <BR>
CComPtr&lt;IErrorInfo&gt; pError; <BR>
CComBSTR strError; <BR>
GetErrorInfo(0, &amp;pError); <BR>
pError-&gt;GetDescription(&amp;strError); <BR>
MessageBox(OLE2T(strError), _T(&quot;Error&quot;), MB_ICONEXCLAMATION); <BR>
return E_FAIL; <BR>
} <BR>
} <BR>
m_bDirty = FALSE; <BR>
return S_OK; <BR>
} <BR>
. . . </TT></FONT></P>
<P>The property page implementation is complete; however, the control is still not
aware of the property page's existence and that the control and the property page
are related. To connect the property page to the control, you must add an entry to
the <TT>BEGIN_PROPERTY_MAP</TT> macro in the class definition of the control (see
Listing 8.18). The macro <TT>PROP_ENTRY</TT> is used in place of the <TT>PROP_PAGE</TT>
macro so that the property will be persisted automatically when the control is saved.
<H3><A NAME="Heading28"></A>Listing 8.18 ATLCONTROLWIN.H--Add the Property Page Reference
to the Control Class Declaration to Complete the Property Page Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_PROPERTY_MAP(CATLControlWin) <BR>
// PROP_ENTRY(&quot;Description&quot;, dispid, clsid) <BR>
PROP_ENTRY(&quot;Alignment&quot;, dispidAlignment, CLSID_ATLControlWinPPG) <BR>
PROP_PAGE(CLSID_CColorPropPage) <BR>
END_PROPERTY_MAP() <BR>
. . . </TT></FONT></P>
<H2><A NAME="Heading30"></A>Adding Events</H2>
<P>Properties and methods are a way for a programmer to communicate with a control
from within the container application. <I>Events</I> are a way for the control to
communicate with the container. For ActiveX controls, events are nothing more than
<TT>IDispatch</TT> interfaces that are implemented on the container side of the container/control
relationship. The mechanism that events are based on is known as a <I>connection
point.</I> A connection point is simply a description of the type of interface that
is required in order to communicate with the container. Connection points are not
restricted to only <TT>IDispatch</TT> interfaces; rather, they can be of any COM
interface that is understood by both components. For that matter, connection points/events
are not restricted only to controls; they can be used in any COM implementation.
Controls were simply the first to take advantage of them. For more information regarding
connection points, refer to the documentation in the OLE online help or to Kraig
Brockschmidt's <I>Inside OLE, Second Edition</I>, published by Microsoft Press.</P>
<P>Because no ClassWizards are available to aid you, adding events in ATL requires
a bit more work than is required in MFC and BaseCtl. The first step is to add the
event interface to your IDL file (see Listing 8.19). Remember to create a new <TT>UUID</TT>
with the GUIDGEN.EXE program; do not reuse the <TT>UUID</TT>s in the sample. In addition
to the event interface, you need an event method. You also need to add the method
called <TT>Change</TT> to the event interface. The <TT>Change</TT> method has two
parameters. The first parameter is a string called b<TT>strCaption</TT>, passed by
reference (<TT>BSTR *</TT>). The second is a <TT>long</TT> called <TT>lAlignment</TT>,
also passed by reference (<TT>long *</TT>). You are passing the parameters by reference
to allow the container application the opportunity to change the values if necessary.
You must also add the event interface to the <TT>CoClass</TT> interface for the control
as the <TT>default</TT>, <TT>source</TT> interface.
<H3><A NAME="Heading31"></A>Listing 8.19 ATLCONTROL.IDL--Add the Event Interface
and the Change Method to the ATLControl.IDL File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
[ <BR>
uuid(C31D4C71-7AD7-11d0-BEF6-00400538977D), <BR>
helpstring(&quot;ATLControlWin Event Interface&quot;) <BR>
] <BR>
dispinterface _DATLControlWin <BR>
{ <BR>
properties: <BR>
methods: <BR>
[id(1)] void Change([in, out]BSTR * bstrCaption, <BR>
[in, out] long * lAlignment); <BR>
}; <BR>
[ <BR>
uuid(A19F6964-7884-11D0-BEF3-00400538977D), <BR>
helpstring(&quot;ATLControlWin Class&quot;) <BR>
] <BR>
coclass ATLControlWin <BR>
{ <BR>
[default] interface IATLControlWin; <BR>
[default, source] dispinterface _DATLControlWin; <BR>
}; <BR>
. . . </TT></FONT></P>
<P>Event interfaces are based on connection point interfaces, which you will add
to your control implementation. Connection points are implemented with the <TT>IConnectinPoint</TT>
and the <TT>IConnectionPointContainer</TT> interfaces. To aid in the creation of
the interfaces, ATL provides a proxy generator. To generate the proxy code follow
these steps:

<OL>
	<LI>From the <U>P</U>roject menu, select the <U>A</U>dd to Project menu item, and
	then select the Com_ponents and Controls submenu item.
	<P>
	<LI>In the Components and Controls Gallery dialog, double-click the Developer Studio
	Components folder.
	<P>
	<LI>After the Components and Controls Gallery dialog is refreshed with data, double-click
	the ATL Proxy Generator icon (see fig. 8.18).
	<P><A HREF="art/08/gfigs18.jpg"><B>FIG. 8.18</B></A> <I><BR>
	Select the ATL Proxy Generator from the Developer Studio Components.</I></P>
	<LI>Click OK to close the Insert the ProxyGen Component dialog.
	<P>
	<LI>Click the ... button, in the ATL Proxy Generator dialog to display the Open dialog.
	Select the ATLControl.tlb file, and click Open.
	<P>
	<LI>Select the <TT>_DATLControlWin</TT> entry in the <U>N</U>ot Selected list box,
	and click the &gt; button to move the entry to the <U>S</U>elected list box (see
	fig. 8.19). Ensure that the Proxy <U>T</U>ype is set to Connection Point, and click
	<U>I</U>nsert.
	<P><A HREF="art/08/gfigs19.jpg"><B>FIG. 8.19</B></A><B> </B><I><BR>
	Select the <TT>_DATLControlWin</TT> class in the ATL Proxy Generator dialog.</I></P>
	<LI>A Save dialog appears with the file CPATLControl.h in the File <U>n</U>ame edit
	box. Click <U>S</U>ave to continue. Click OK in the confirmation dialog that indicates
	that the operation was successful.
	<P>
	<LI>Click Close in the ATL Proxy Generator and Components and Controls Gallery dialogs.
</OL>

<P>The file CPATLControl.h contains that class <TT>CProxy_DATLControlWin</TT>, which
implements your event interface, and the <TT>Change</TT> event method in the form
<TT>Fire_Change</TT>, which you added earlier to the IDL file.</P>
<P>The next step is to add the <TT>CProxy_DATLControlWin</TT> interface to your control
implementation. Add the <TT>CPATLControl.h</TT> file as an include file to your ATLControlWin.h
file:</P>
<P><FONT COLOR="#0066FF"><TT>#include &quot;CPATLControl.h</TT></FONT></P>
<P>You must also update the inheritance structure of the <TT>CATLControlWin</TT>
class with the <TT>CProxy_DATLControlWin</TT> class</P>
<P><FONT COLOR="#0066FF"><TT>public CProxy_DATLControlWin&lt;CATLControlWin&gt;</TT></FONT></P>
<P>and add <TT>IID</TT> of the event interface to the <TT>IProvideClassInfo2Impl</TT>
interface</P>
<P><FONT COLOR="#0066FF"><TT>public IProvideClassInfo2Impl&lt;&amp;CLSID_ATLControlWin,
&amp;DIID__DATLControlWin, &amp;LIBID_ATLCONTROLLib&gt;</TT></FONT></P>
<P>See the ATL and ActiveX documentation for information regarding the implementation
of the <TT>IProvideClassInfo2</TT> interface.</P>
<P>Last you add the event interface to the <TT>BEGIN_CONNECTION_POINT_MAP</TT> macro
in the control's class declaration:</P>
<P><FONT COLOR="#0066FF"><TT>BEGIN_CONNECTION_POINT_MAP(CATLControlWin)<BR>
CONNECTION_POINT_ENTRY(DIID__DATLControlWin)<BR>
END_CONNECTION_POINT_MAP()</TT></FONT></P>
<P>Your event interface is now completely implemented. The last step is only a matter
of adding the <TT>Fire_Change</TT> method calls wherever appropriate in your control
implementation. Since your implementation of the <TT>Fire_Change</TT> method allows
the user of the control to change the data that is passed to the event, using a universal
helper function is easier to maintain the code by implementing a simple helper function,
<TT>FireChange</TT> (with no parameters), that encapsulates the data management associated
with the method and its parameters (see Listing 8.20). Remember to add the <TT>FireChange</TT>
function prototype to your class definition in the ATLCONTROLWIN.H header file.
<H3><A NAME="Heading32"></A>Listing 8.20 ATLCONTROLWIN.CPP--FireChange Helper Function
Added to the Control</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
void CATLControlWin::FireChange(void) <BR>
{ <BR>
// needed for the W2A macro <BR>
USES_CONVERSION; <BR>
// get a BSTR that can be passed via the event <BR>
BSTR bstrCaption = ::SysAllocString(T2OLE(m_lptstrCaption)); <BR>
// fire the change event <BR>
this-&gt;Fire_Change(&amp;bstrCaption, &amp;m_lAlignment); <BR>
// convert the string to ANSI <BR>
LPTSTR lptstrTempCaption = W2A(bstrCaption); <BR>
// free the data that was passed back <BR>
::SysFreeString(bstrCaption); <BR>
// if we have a string <BR>
if(m_lptstrCaption) <BR>
{ <BR>
// delete the existing string <BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe <BR>
m_lptstrCaption = NULL; <BR>
} <BR>
// allocate a new string <BR>
m_lptstrCaption = new TCHAR[lstrlen(lptstrTempCaption) + 1]; <BR>
// assign the string to our member variable <BR>
lstrcpy(m_lptstrCaption, lptstrTempCaption); <BR>
} </TT></FONT></P>
<P>Finally your event code is completely implemented. The common <TT>FireChange</TT>
function allows you to hide the details surrounding the change event from the rest
of the program. If you decide to change the <TT>FireChange</TT> implementation in
the future, it will impact only one function rather than a number of them.</P>
<P>The <TT>CaptionMethod</TT> will require that you fire a <TT>Change</TT> event
if the data changes, so you add your new event to the <TT>CaptionMethod</TT> (see
Listing 8.21). You also want to add the <TT>FireChange</TT> event to the <TT>put_Alignment</TT>
function, but do not add <TT>FireChange</TT> to the <TT>put_CaptionProp</TT> function
because it defers to the <TT>CaptionMethod</TT> for its implementation. Also, do
not forget to add the <TT>FireChange</TT> call to any new functions that are added
to the control as its implementation progresses.
<H3><A NAME="Heading33"></A>Listing 8.21 ATLCONTROLWIN.CPP--FireChange Event Added
to the CaptionMethod Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
<BR>
STDMETHODIMP CATLControlWin::CaptionMethod(BSTR bstrCaption, VARIANT <BR>
<BR>
varAlignment, <BR>
long * lRetVal) <BR>
{ <BR>
. . . <BR>
// if everything was OK <BR>
if(TRUE == *lRetVal) <BR>
{ <BR>
// if we have a string <BR>
if(lptstrTempCaption != NULL) <BR>
{ <BR>
// if we have a string <BR>
if(m_lptstrCaption) <BR>
{ <BR>
// delete the existing string <BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe <BR>
m_lptstrCaption = NULL; <BR>
} <BR>
// allocate a new string <BR>
m_lptstrCaption = new TCHAR[lstrlen(lptstrTempCaption) + 1]; <BR>
// assign the string to our member variable <BR>
lstrcpy(m_lptstrCaption, lptstrTempCaption); <BR>
} <BR>
// did they pass us bad data? <BR>
if(m_lAlignment &lt; EALIGN_LEFT || m_lAlignment &gt; EALIGN_RIGHT) <BR>
// sure did, lets fix their little red wagon <BR>
m_lAlignment = EALIGN_LEFT; <BR>
// fire the global change event <BR>
this-&gt;FireChange(); <BR>
// force the control to repaint itself <BR>
this-&gt;FireViewChange(); <BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
} <BR>
// return the result of the function call <BR>
return hResult; <BR>
} </TT></FONT></P>
<H2><A NAME="Heading34"></A>Persistence</H2>
<P><I>Persistence</I> refers to the capability of a component to retain its state
across execution lifetimes. In other words, regardless of the number of times that
the control is started and stopped, it remembers that you changed its background
color from white to mauve (even if it finds the color mauve revolting).</P>
<P>Property persistence in ATL is by far the simplest of all of the frameworks currently
available. Just add the property to the <TT>BEGIN_PROPERTY_MAP</TT> macro (see Listing
8.22), and you are finished; the rest is up to ATL.
<H3><A NAME="Heading35"></A>Listing 8.22 ATLCONTROLWIN.H--BackColor Property Added
to the Property Map for Persistence</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_PROPERTY_MAP(CATLControlWin) <BR>
// PROP_ENTRY(&quot;Description&quot;, dispid, clsid) <BR>
PROP_ENTRY(&quot;Alignment&quot;, dispidAlignment, CLSID_ATLControlWinPPG) <BR>
PROP_ENTRY(&quot;BackColor&quot;, DISPID_BACKCOLOR, CLSID_ATLControlWinPPG) <BR>
PROP_PAGE(CLSID_CColorPropPage) <BR>
END_PROPERTY_MAP() <BR>
. . . </TT></FONT></P>
<H2><A NAME="Heading36"></A>Drawing the Control</H2>
<P>Most controls will have some form of User Interface (UI). However, since the release
of the OC 96 specification and ActiveX, UI is no longer a requirement.</P>
<P>Drawing the UI of a control has long been regarded as one of the most critical
aspects of a control, in terms of both appearance and performance. A control that
flashes or flickers a lot appears poorly developed, regardless of its internal implementation.
The same is true for how fast the control draws. With the advent of the Internet
and ActiveX, it is even more crucial that a control draw fast and well.</P>
<P><I>Drawing</I> can be broken into two major categories: standard and optimized.
In this chapter, you focus only on standard drawing. <A HREF="ch09.htm">Chapter 9</A>
introduces optimized drawing.
<H3><A NAME="Heading37"></A>Standard Drawing</H3>
<P><I>Standard drawing </I>is just that: standard. You have complete freedom to draw
the control any way you see fit, using any method that is appropriate. You can use
pens and brushes, rectangles and circles. Remember that drawing <I>smart</I> is the
goal of any application with UI. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> Probably the greatest sources of flicker and flash are overlapped
	painting and unnecessary drawing -- drawing areas of the control that do not need
	to be drawn. Try to draw only to the areas of the control that have been invalidated.
	Doing so will save time and prevent annoying flash. For example, if your control
	has a white background and a black border, draw only the white portion where it is
	going to be seen. Don't draw over the border as this causes the control to flash
	every time it gets a paint message.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Before implementing the <TT>OnDraw</TT> method, you need to add a number of member
variables and functions to aid in your drawing implementation (see Listing 8.23).
<H3><A NAME="Heading38"></A>Listing 8.23 ATLCONTROLWIN.H--Drawing Implementation
Member Variables and Functions</H3>
<P><FONT COLOR="#0066FF"><TT>IFont * m_pFont; <BR>
void LoadFont(void); <BR>
HBRUSH hBrush, hOldBrush; <BR>
COLORREF TranslateColor(OLE_COLOR clrColor, HPALETTE hpal = NULL) <BR>
{COLORREF cr = RGB(0x00,0x00,0x00);OleTranslateColor(clrColor, hpal, &amp;cr); <BR>
return cr;} <BR>
void FillSolidRect(HDC hDC, LPCRECT lpRect, COLORREF clr) <BR>
{::SetBkColor(hDC, clr); <BR>
::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);} <BR>
void GetTextExtent(HDC hDC, LPCTSTR lpctstrString, int &amp; cx, int &amp; cy); <BR>
BOOL bRetrievedDimensions; <BR>
int iCharWidthArray[256]; <BR>
int iCharacterSpacing, iCharacterHeight; <BR>
}; <BR>
#endif //__ATLCONTROLWIN_H_ </TT></FONT></P>
<P>Initialize the member variables in the constructor of the class (see Listing 8.24)
to useful starting values. It is very important to initialize the members because
the implementation is dependent on the members being either <TT>NULL</TT>, indicating
that they are empty, or not <TT>NULL</TT>, indicating that they contain a valid value.
<H3><A NAME="Heading39"></A>Listing 8.24 ATLCONTROLWIN.H--Initialize the New Member
Variables in the Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>CATLControlWin() <BR>
{ <BR>
. . . <BR>
// clear the font <BR>
m_pFont = NULL; <BR>
// clear the brush <BR>
hOldBrush = hBrush = NULL; <BR>
// clear the flag <BR>
bRetrievedDimensions = FALSE; <BR>
} </TT></FONT></P>
<P>Next add the implementation for the helper functions <TT>GetTextExtent</TT> and
<TT>LoadFont</TT>. You also need a default font descriptor in the case when you cannot
retrieve the font from the container (see Listing 8.25).</P>
<P><TT>GetTextExtent</TT> is a function that is supported in MFC but not in Win32,
so we created our own implementation. The function will determine the width and height
of the font of the current DC and will then calculate the size in points of the string
that was supplied to the function. This function is used for displaying your text
with the correct alignment; left, right, or center. We optimized the method so as
to retrieve the information only once. If the control supported fonts for properties,
it would be a simple matter to clear the flag <TT>bRetrievedDimensions</TT> to refresh
the width and height of the new font when the control redrew itself.</P>
<P>The function <TT>LoadFont</TT> tries to load the ambient font from the container
and, if unable, creates a new font from the default settings.
<H3><A NAME="Heading40"></A>Listing 8.25 ATLCONTROLWIN.CPP--Drawing Helper Functions</H3>
<P><FONT COLOR="#0066FF"><TT>static FONTDESC _fdDefault = <BR>
{ <BR>
sizeof(FONTDESC), <BR>
L&quot;MS Sans Serif&quot;, <BR>
FONTSIZE(8), <BR>
FW_NORMAL, <BR>
DEFAULT_CHARSET, <BR>
FALSE, <BR>
FALSE, <BR>
FALSE <BR>
}; <BR>
void CATLControlWin::LoadFont(void) <BR>
{ <BR>
// if there isn't a font object <BR>
if(!m_pFont) <BR>
// get the font from the container <BR>
this-&gt;GetAmbientFont(&amp;m_pFont); <BR>
// if there still isn't a font object <BR>
if(!m_pFont) <BR>
// create a default font object <BR>
::OleCreateFontIndirect(&amp;_fdDefault, IID_IFont, (void **) &amp;m_pFont); <BR>
} <BR>
void CATLControlWin::GetTextExtent(HDC hDC, LPCTSTR lpctstrString, int &amp; cx,
int &amp; cy) <BR>
{ <BR>
// if we haven't gotten the dimensions yet <BR>
if(!bRetrievedDimensions) <BR>
{ <BR>
// get all of the widths for all of the chars <BR>
::GetCharWidth(hDC, 0, 255, &amp;iCharWidthArray[0]); <BR>
// get the spacing between the chars <BR>
iCharacterSpacing = ::GetTextCharacterExtra(hDC); <BR>
// make sure that this only executes once <BR>
bRetrievedDimensions = TRUE; <BR>
// get the metrics of this DC <BR>
TEXTMETRIC tmMetrics; <BR>
::GetTextMetrics(hDC, &amp;tmMetrics); <BR>
// get the height <BR>
iCharacterHeight = tmMetrics.tmHeight; <BR>
} <BR>
// return the height <BR>
cy = iCharacterHeight; <BR>
// set the initial value to 0 <BR>
int iTextWidth = 0; <BR>
// get the number of characters in our string <BR>
long lTextLength = lstrlen(lpctstrString); <BR>
// if we have a character <BR>
if(lTextLength) <BR>
{ <BR>
long lEndCharPos = lTextLength - 1; <BR>
// add up the widths of the characters and the spacing <BR>
for(long lCount = 0; lCount &lt;= lEndCharPos; lCount++) <BR>
iTextWidth += (iCharWidthArray[(BYTE)(lpctstrString[lCount])] <BR>
+ iCharacterSpacing); <BR>
} <BR>
// return the width <BR>
cx = iTextWidth; <BR>
} </TT></FONT></P>
<P>Listing 8.26 contains the code for drawing the control. The <TT>OnDraw</TT> implementation
is fairly straightforward. Select the font into the DC, get all of the colors that
you are going to use, and draw the background, text, and border. Last reset everything
back to the way it was when you started.
<H3><A NAME="Heading41"></A>Listing 8.26 ATLCONTROLWIN.CPP--Standard Drawing Added
to the OnDraw Function</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CATLControlWin::OnDraw(ATL_DRAWINFO &amp; di)
<BR>
{ <BR>
// ****** Get the text font ****** <BR>
// ** <BR>
HFONT hFont = NULL, hOldFont = NULL; <BR>
// if there isn't a font object <BR>
if(!m_pFont) <BR>
// try to load one <BR>
this-&gt;LoadFont(); <BR>
if(m_pFont) <BR>
{ <BR>
// get a font handle <BR>
m_pFont-&gt;get_hFont(&amp;hFont); <BR>
// increment the ref count so the font doesn't drop <BR>
// out from under us <BR>
m_pFont-&gt;AddRefHfont(hFont); <BR>
::SelectObject(di.hdcDraw, hFont); <BR>
} <BR>
// ** <BR>
// ****** Get the text font ****** <BR>
// ****** Get the colors ****** <BR>
// ** <BR>
// use the window color as the background color <BR>
OLE_COLOR tColor; <BR>
this-&gt;get_BackColor(&amp;tColor); <BR>
COLORREF clrTextBackgroundColor = this-&gt;TranslateColor(tColor); <BR>
// then use the normal windows color for the text <BR>
COLORREF clrTextForegroundColor = <BR>
this-&gt;TranslateColor(::GetSysColor(COLOR_WINDOWTEXT)); <BR>
// set to the system color <BR>
COLORREF clrEdgeBackgroundColor = ::GetSysColor(COLOR_3DFACE); <BR>
COLORREF clrEdgeForegroundColor = ::GetSysColor(COLOR_3DFACE); <BR>
// ** <BR>
// ****** Get the colors ****** <BR>
// ****** Draw the background ****** <BR>
// ** <BR>
// set the text color <BR>
COLORREF clrOldBackgroundColor = ::SetBkColor(di.hdcDraw, clrTextBackgroundColor);
<BR>
COLORREF clrOldForegroundColor = ::SetTextColor(di.hdcDraw, <BR>
clrTextForegroundColor); <BR>
// if we don't have a brush <BR>
if(hBrush == NULL) <BR>
// create a solid brush <BR>
hBrush = ::CreateSolidBrush(clrTextBackgroundColor); <BR>
// select the brush and save the old one <BR>
hOldBrush = (HBRUSH)::SelectObject(di.hdcDraw, hBrush); <BR>
// draw the background <BR>
::Rectangle(di.hdcDraw, di.prcBounds-&gt;left, di.prcBounds-&gt;top, <BR>
di.prcBounds-&gt;right, di.prcBounds-&gt;bottom); <BR>
// ** <BR>
// ****** Draw the background ****** <BR>
// ****** Draw the text ****** <BR>
// ** <BR>
int iHor, iVer; <BR>
// get the size of the text for this DC <BR>
int cx = 0, cy = 0; <BR>
this-&gt;GetTextExtent(di.hdcDraw, m_lptstrCaption, cx, cy); <BR>
switch(m_lAlignment) <BR>
{ <BR>
case EALIGN_CENTER: <BR>
iHor = (di.prcBounds-&gt;right - cx) / 2; <BR>
iVer = di.prcBounds-&gt;top + 3; <BR>
break; <BR>
case EALIGN_RIGHT: <BR>
iHor = di.prcBounds-&gt;right - cx - 3; <BR>
iVer = di.prcBounds-&gt;top + 3; <BR>
break; <BR>
// case EALIGN_LEFT: <BR>
default: <BR>
iHor = di.prcBounds-&gt;left + 3; <BR>
iVer = di.prcBounds-&gt;top + 3; <BR>
break; <BR>
} <BR>
// output our text <BR>
::ExtTextOut(di.hdcDraw, iHor, iVer, ETO_CLIPPED | ETO_OPAQUE, <BR>
(LPCRECT) di.prcBounds, m_lptstrCaption, lstrlen(m_lptstrCaption), NULL); <BR>
// ** <BR>
// ****** Draw the text ****** <BR>
// ****** Draw the border ****** <BR>
// ** <BR>
// set the edge style and flags <BR>
UINT uiBorderStyle = EDGE_SUNKEN; <BR>
UINT uiBorderFlags = BF_RECT; <BR>
// set the edge color <BR>
::SetBkColor(di.hdcDraw, clrEdgeBackgroundColor); <BR>
::SetTextColor(di.hdcDraw, clrEdgeForegroundColor); <BR>
// draw the 3D edge <BR>
::DrawEdge(di.hdcDraw, (LPRECT)(LPCRECT) di.prcBounds, <BR>
uiBorderStyle, uiBorderFlags); <BR>
// ** <BR>
// ****** Draw the border ****** <BR>
// ****** Reset the colors ****** <BR>
// ** <BR>
// restore the original colors <BR>
::SetBkColor(di.hdcDraw, clrOldBackgroundColor); <BR>
::SetTextColor(di.hdcDraw, clrOldForegroundColor); <BR>
// ** <BR>
// ****** Reset the colors ****** <BR>
// ****** release the text font ****** <BR>
// ** <BR>
if(hOldFont) <BR>
// select the old object <BR>
::SelectObject(di.hdcDraw, hOldFont); <BR>
// increment the ref count so the font doesn't drop <BR>
// out from under us <BR>
if(m_pFont &amp;&amp; hFont) <BR>
m_pFont-&gt;ReleaseHfont(hFont); <BR>
// ** <BR>
// ****** Get the text font ****** <BR>
// select the old brush back <BR>
::SelectObject(di.hdcDraw, hOldBrush); <BR>
// destroy the brush we created <BR>
::DeleteObject(hBrush); <BR>
// clear the brush handles <BR>
hBrush = hOldBrush = NULL; <BR>
return S_OK; <BR>
} </TT></FONT></P>
<H2><A NAME="Heading42"></A>From Here...</H2>
<P>This chapter focused on creating a basic control implementation. You added methods,
properties, and events, which are the backbone of every control implementation. This
chapter also addressed the issues of persistence and drawing without which a control
implementation is definitely incomplete.</P>
<P>Version 2.1 has brought ATL into the realm of complete ActiveX development frameworks
alongside MFC. The integration of ATL into the VC++ IDE was long overdue and sorely
needed. Finally there is a competitor for MFC in terms of rapid ActiveX/COM development,
with the added benefit of the ATL framework being lean and to the point. With ATL
being so close to the COM interface level, you also have the added benefit of seeing
how truly simple and easy it is to implement COM interfaces and components.</P>
<P>The only drawbacks to ATL might be its support of events and some of its tools
for creating components. We are certain, however, that ATL will continue to mature
and be the premier ActiveX development framework available.</P>

<P><A HREF="ch09.htm">Chapter 9</A> expands upon the knowledge you gained in this
chapter and adds new features and function to your control implementation to make
your control truly unique and interesting.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
