<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 11:19 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 10</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 10<BR>
Using BaseCtl to Create a Basic ActiveX Control</H1>

<UL>
	<LI><A HREF="#Heading1">Using BaseCtl to Create a Basic ActiveX Control</A>
	<UL>
		<LI><A HREF="#Heading3">Creating a Basic Control Project</A>
		<UL>
			<LI><A HREF="#Heading4">Listing 10.1 BCFCONTROL.CPP--Include New Control Header Files
			and Control Declarations</A>
			<LI><A HREF="#Heading5">Listing 10.2 GUIDS.H--Combined Guids.h</A>
			<LI><A HREF="#Heading6">Listing 10.3 BCFCONTROL.ODL--Combined Control ODL Files</A>
			<LI><A HREF="#Heading7">Listing 10.4 RESOURCE.H--Combined Resource.h Files</A>
			<LI><A HREF="#Heading8">Listing 10.5 LOCALOBJ.H--Combined LocalObj.h File</A>
			<LI><A HREF="#Heading9">Listing 10.6 BCFCONTROLCTL.H--Update the Bitmap Source</A>
		</UL>
		<LI><A HREF="#Heading10">Control Registration</A>
		<UL>
			<LI><A HREF="#Heading11">Listing 10.7 BCFCONTROLCTL.H--DEFINE_CONTROLOBJECT Structure</A>
		</UL>
		<LI><A HREF="#Heading12">Creating Methods</A>
		<UL>
			<LI><A HREF="#Heading13">Listing 10.8 DISPIDS.H--Dispid for CaptionMethod</A>
			<LI><A HREF="#Heading14">Listing 10.9 BCFCONTROLINTERFACES.H--Interface File Created
			from the ODL File</A>
			<LI><A HREF="#Heading15">Listing 10.10 BCFCONTROLCTL.H--Updated Control Class Header
			File</A>
			<LI><A HREF="#Heading16">Listing 10.11 ALIGNMENTENUMS.H--Alignment Styles Enumeration</A>
			<LI><A HREF="#Heading17">Listing 10.12 BCFCONTROLCTL.CPP--Member Variable Initialization</A>
			<LI><A HREF="#Heading18">Listing 10.13 BCFCONTROLCTL.CPP--CaptionMethod Implementation</A>
		</UL>
		<LI><A HREF="#Heading19">Creating Properties</A>
		<UL>
			<LI><A HREF="#Heading20">Creating Normal User Defined Properties</A>
			<LI><A HREF="#Heading21">Listing 10.14 BCFCONTROL.ODL--Normal User Defined Property
			ODL Declaration</A>
			<LI><A HREF="#Heading22">Listing 10.15 BCFCONTROLCTL.H--Property Function Prototypes</A>
			<LI><A HREF="#Heading23">Listing 10.16 BCFCONTROLCTL.CPP--Property Function Implementation</A>
			<LI><A HREF="#Heading24">Creating Parameterized User Defined Properties</A>
			<LI><A HREF="#Heading25">Listing 10.17 DISPIDS.H--Dispid for CaptionProp Property</A>
			<LI><A HREF="#Heading26">Listing 10.18 BCFCONTROL.ODL--ODL Entry for Caption Property</A>
			<LI><A HREF="#Heading27">Listing 10.19 BCFCONTROLCTL.H--CaptionProp Function Prototypes</A>
			<LI><A HREF="#Heading28">Listing 10.20 BCFCONTROLCTL.CPP--CaptionProp Property Implementation</A>
			<LI><A HREF="#Heading29">Creating Stock Properties</A>
			<LI><A HREF="#Heading30">Listing 10.21 BCFCONTROL.ODL--BackColor Stock Property Support</A>
			<LI><A HREF="#Heading31">Listing 10.22 BCFCONTROLCTL.H--BackColor Function Prototype</A>
			<LI><A HREF="#Heading32">Listing 10.23 BCFCONTROLCTL.H--BackColor Member Variable</A>
			<LI><A HREF="#Heading33">Listing 10.24 BCFCONTROLCTL.CPP--Member Initialization</A>
			<LI><A HREF="#Heading34">Listing 10.25 BCFCONTROLCTL.CPP--BackColor Property Implementation</A>
			<LI><A HREF="#Heading35">Using Ambient Properties</A>
			<LI><A HREF="#Heading36">Creating Property Sheets</A>
			<LI><A HREF="#Heading37">Listing 10.26 BCFCONTROLPPG.CPP--Property Page Implementation</A>
		</UL>
		<LI><A HREF="#Heading38">Adding Events</A>
		<UL>
			<LI><A HREF="#Heading39">Listing 10.27 DISPIDS.H--Change Event Dispid</A>
			<LI><A HREF="#Heading40">Listing 10.28 BCFCONTROL.ODL--Event ODL Entry</A>
			<LI><A HREF="#Heading41">Listing 10.29 BCFCONTROLCTL.H--Event Handling Structures--Header</A><A
			HREF="#Heading42">File</A>
			<LI><A HREF="#Heading43">Listing 10.30 BCFCONTROLCTL.CPP--Event Structures Implementation--Source
			File</A>
			<LI><A HREF="#Heading44">Listing 10.31 BCFCONTROLCTL.H--FireChange Event--Header
			File</A>
			<LI><A HREF="#Heading45">Listing 10.32 BCFCONTROLCTL.CPP--FireChange Event Implementation</A>
		</UL>
		<LI><A HREF="#Heading46">Persistence</A>
		<UL>
			<LI><A HREF="#Heading47">Text Persistence</A>
			<LI><A HREF="#Heading48">Listing 10.33 BCFCONTROLCTL.CPP--LoadTextState Implementation</A>
			<LI><A HREF="#Heading49">Listing 10.34 BCFCONTROLCTL.CPP--SaveTextState Implementation</A>
			<LI><A HREF="#Heading50">Binary Persistence</A>
			<LI><A HREF="#Heading51">Listing 10.35 BCFCONTROLCTL.CPP--SaveBinaryState Implementation</A>
			<LI><A HREF="#Heading52">Listing 10.36 BCFCONTROLCTL.CPP--LoadBinaryState Implementation</A>
		</UL>
		<LI><A HREF="#Heading53">Drawing the Control</A>
		<UL>
			<LI><A HREF="#Heading54">Standard Drawing</A>
			<LI><A HREF="#Heading55">Listing 10.37 BCFCONTROLCTL.H--Drawing Implementation Member
			Variables and Functions</A>
			<LI><A HREF="#Heading56">Listing 10.38 BCFCONTROLCTL.CPP--Member Initialization</A>
			<LI><A HREF="#Heading57">Listing 10.39 BCFCONTROLCTL.CPP--Drawing Helper Functions</A>
			<LI><A HREF="#Heading58">Listing 10.40 BCFCONTROLCTL.CPP--OnDraw Implementation</A>
		</UL>
		<LI><A HREF="#Heading59">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Using BaseCtl to Create a Basic ActiveX Control</H1>

<UL>
	<LI><B>Registration</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The BaseCtl framework supports control registration and unregistra-tion through
	a set of constants and structures that define the basic control framework.
	<P>
	<LI><B>Adding methods and properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Like ATL, BaseCtl methods are first implemented in the type library and then in
	the actual control. Like methods, properties are a way of exposing information about
	a control implementation to the control's user.
	<P>
	<LI><B>Adding events</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Implementing events in BaseCtl is far easier than in ATL and just as easy to maintain
	as MFC.
	<P>
	<LI><B>Persistence</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Persistence of data in BaseCtl is at its most basic and differs significantly from
	that of both MFC and ATL.
	<P>
	<LI><B>Drawing the control</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Drawing the User Interface can make or break a control implementation. Your implementation
	relies on the same basic drawing routines as the MFC and ATL implementations and
	requires almost no modification.
</UL>

<P>The BaseCtl framework was originally created by Marc Wandschneider, a member of
the Visual Basic (VB) team, to address the need for small, fast OCXs that could be
used within VB without adversely affecting VB's performance. The original implementation
was referred to lovingly as the MarcWan framework in honor of its primary author.</P>
<P>Along with the desire for a compact control framework that could be used to create
ActiveX controls came the mandate to remove the framework's dependence on MFC, which
in our mind is both the BaseCtl's strength and weakness. Removing the BaseCtl's dependence
on MFC solved several key problems: code overhead and control load time performance.
Since the BaseCtl framework is lean, the controls tend to execute faster, and because
the MFC DLLs are not required, the amount of time it takes to load the control into
memory is effectively reduced. However, writing a control from scratch using the
BaseCtl takes significantly more time since you do not have AppWizards and ClassWizards
at your disposal to speed up your implementation. The lack of general class support,
for example drawing classes and storage classes, can also increase your development
effort. With the coming of ActiveX, the need for small, fast OCXs suddenly became
an industry concern. Microsoft's answer to that demand was to publish the BaseCtl
as an alternative method (as opposed to MFC) for developing controls. Several versions
of the BaseCtl framework are floating around. The basic version, which ships with
the ActiveX SDK, consists of a number of source files and several samples. A more
thorough version consisting of more samples and even an AppWizard written in VB has
been available to the members of the Visual Basic 5 (VB 5) beta testing group.</P>
<P>The BaseCtl Framework is intended merely as a sample application and does not
have the same support and backing of Microsoft as do its other development products.
It was an immediate solution to an immediate problem. The BaseCtl framework has one
very distinct disadvantage in that Microsoft considers it a sample application only
and does not support it directly as a product. A growing number of developers on
the Internet are using BaseCtl, so you should be able to find support easily if you
run into a problem.</P>
<P>This chapter focuses on creating ActiveX controls using the BaseCtl sample that
ships with the ActiveX SDK. Be warned, though, that this kind of control development
is not for the timid. Be prepared to roll your sleeves up and get dirty.
<H2><A NAME="Heading3"></A>Creating a Basic Control Project</H2>
<P>The version of the BaseCtl sample that ships with the ActiveX SDK does not have
an AppWizard for creating a basic control like its MFC counterpart. Also, the documentation
is minimal and not much help. To speed up your development, we've included a sample
project called BCFBasicControl that is based on the original BaseCtl sample files.
Using this sample control, you can create a new project by copying the files and
changing the names of the files and classes.</P>
<P>First in Table 10.1 examine the files that are needed for creating a basic control
with the BaseCtl framework. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 10.1</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> BaseCtl Basic Project Files</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>File name</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.dsw</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ build file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.dsp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ build file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.opt</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ build file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Main control application file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Application definition file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.odl</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Object Definition Language file for describing the and interfaces contained in the
			control.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControl.rc</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Application resource file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControlCtl.bmp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Basic control bitmap that appears in the tool browser.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControlCtl.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Primary control source file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControlCtl.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Primary control header file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControlPPG.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Property page source file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BCFBasicControlPPG.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Property page header file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Dispids.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Header file that contains all of the method, property, event dispids. Add all dispids
			to this file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Dwinvers.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Version information header file. Change this file to the version information specific
			to the control.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Guids.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Source file for the GUIDs defined in the application.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Guids.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Header file for the GUID defined in the application.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">LocalObj.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Header file for the OBJECT_TYPE constants that are used in the g_ObjectInfo table
			to identify the controls and property pages contained in the application.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Resource.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Header file that contains all of the resource ID constants.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">project_nameInterfaces.H</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This file is not created until the project is compiled. The mktylib (or midl) compiler
			automatically generates this file from the ODL file. This file contains the C++style
			declarations for the interfaces of the ActiveX component. Do not modify this file
			directly; it will be recreated every time the ODL file is compiled.</TD>
	</TR>
</TABLE>
<BR>
<BR>
In this chapter, you will create three controls: a standard control, a windowless
control, and a subclassed control. All three will be combined into a single control
module to give you a feel for how it is done. None of the sample controls is meant
to be a fully functional control. They are used only to give you an understanding
of how to implement specific features and functionality with a minimum of effort.
Again, since you do not have an application wizard at your disposal, you must create
your project by hand. To create a new BaseCtl project, you need to perform the following
steps:

<UL>
	<LI>Create a directory for the new project. In this case, call the new project directory
	BCFControl.
	<P>
	<LI>Copy all of the files from the BCFBasicControl sample directory to the new directory.
	Change the names of the files from BCFBasicControl to your project name. In this
	case, change the names to BCFControl.
	<P>
	<LI>Using an application, such as Visual C++, that is capable of doing text replacement,
	change all of the BCFBasicControl entries to the name of your control. In this case,
	change the name BCFBasicControl to BCFControl and BCFBASICCONTROL to BCFCONTROL,
	respectively. Remember to change every file that was copied from the basic project
	and perform the replacement on a case-sensitive basis.
	<P>
	<LI>Generate new <TT>UUID</TT>s with GUIDGEN.EXE. See <A HREF="ch02.htm">Chapter
	2</A> for more information about GUIDGEN.EXE and how it is used. Replace the four
	<TT>UUI</TT>s in the ODL file and the one property page <TT>UUID</TT> in the Guids.h
	file.
	<P>
	<LI>Modify the Dwinvers.h file to reflect the version and company information that
	is appropriate for your project.
</UL>

<P>After you modify all of the files, you are ready to use your new project. Open
the Visual C++ development environment, and from the <U>F</U>ile menu, select the
Open Workspace menu item. In the Open Workspace dialog, change to the directory of
your newly created project (\Que\ActiveX\BCFControl), and open the BCFControl.dsw
file (see fig. 10.1). <BR>
<BR>
<A HREF="art/10/hfig01.jpg"><B>FIG. 10.1</B></A> <I><BR>
Open the new project with the Open Workspace dialog.</I></P>
<P>Unlike with the MFC and ATL projects, to support more than one control within
the application, you must add all of the code and files by hand since you do not
have an AppWizard. The simplest way to create additional controls is to repeat the
steps described earlier and copy the appropriate code and files into your base project.
You will create two additional controls named <TT>BCFControlNoWinControl</TT>, which
is a windowless control, and <TT>BCFControlSubWinControl</TT>, which will subclass
a BUTTON window.</P>
<P>After creating the two new projects, as described in the preceding paragraph,
copy the following files to the BCFControl directory.

<UL>
	<LI>BCFControlNoWinCtl.bmp
	<LI>BCFControlNoWinCtl.cpp
	<LI>BCFControlNoWinCtl.h
	<LI>BCFControlNoWinPPG.cpp
	<LI>BCFControlNoWinPPG.h
	<LI>BCFControlSubWinCtl.bmp
	<LI>BCFControlSubWinCtl.cpp
	<LI>BCFControlSubWinCtl.h
	<LI>BCFControlSubWinPPG.cpp
	<LI>BCFControlSubWinPPG.h
</UL>

<P>Ensure that the BCFControl project is open within the VC++ IDE, and from the <U>P</U>roject
menu, select the <U>A</U>dd to Project menu item and the <U>F</U>iles submenu. In
the Insert Files into Project dialog, select the files BCFControlNoWinCtl.Cpp, BCFControlNoWinPPG.Cpp,
BCFControlSubWinCtl.Cpp, and BCFControlSubWinPPG.Cpp, and click the OK button (see
fig. 10.2). <B><BR>
<BR>
</B><A HREF="art/10/hfig02.jpg"><B>FIG. 10.2</B></A> <I><BR>
Use the Insert Files into Project dialog to add the files of the <TT>BCFControlNoWin</TT>
and <TT>BCFControlSubWin</TT> control to the base project.</I></P>
<P>After you add all of the files that you need to your project, you still have to
do some cut and paste operations from the remaining files to complete the integration
of the three controls.</P>
<P>You need to include the header files from your new control projects to the main
application file (see Listing 10.1).</P>
<P>The BaseCtl framework supports a globally declared array for describing all of
the OLE components included within the application. The <TT>OBJECTINFO</TT> array,
as it is called, should contain an entry for each control, property page, and automation
server you want to declare within your module. You need to add your additional control
and property page declarations to the <TT>OBJECTINFO</TT> array.
<H3><A NAME="Heading4"></A>Listing 10.1 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.CPP--Include
New Control Header Files and Control Declarations</H3>
<P><FONT COLOR="#0066FF"><TT>//=--------------------------------------------------------------------------=<BR>
<BR>
// BCFControl.Cpp //=--------------------------------------------------------------------------=
<BR>
... <BR>
#include &quot;BCFControlCtl.H&quot;<BR>
#include &quot;BCFControlPPG.H&quot;<BR>
#include &quot;BCFControlNoWinCtl.H&quot;<BR>
<BR>
#include &quot;BCFControlNoWinPPG.H&quot;<BR>
#include &quot;BCFControlSubWinCtl.H&quot;<BR>
#include &quot;BCFControlSubWinPPG.H&quot; <BR>
... <BR>
//=--------------------------------------------------------------------------=<BR>
// This Table describes all the automatible objects in your automation server.<BR>
// See AutomationObject.H for a description of what goes in this structure<BR>
// and what it's used for.<BR>
//<BR>
OBJECTINFO g_ObjectInfo[] = {<BR>
CONTROLOBJECT(BCFControl),<BR>
PROPERTYPAGE(BCFControlGeneral),<BR>
CONTROLOBJECT(BCFControlNoWin),<BR>
PROPERTYPAGE(BCFControlNoWinGeneral),<BR>
CONTROLOBJECT(BCFControlSubWin),<BR>
PROPERTYPAGE(BCFControlSubWinGeneral), EMPTYOBJECT<BR>
};</TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT>...</TT></FONT></P>
<P>The ODL compiler will generate a C++ header file for accessing the interfaces
declared in the application. Since you are combining all three controls into a single
project, you will have a single interface file to deal with. The two additional control
implementations must be changed to reflect the new file. In the BCFControlNoWinCtl.h
header file, you need to change the include file<FONT COLOR="#0066FF"><TT><BR>
<BR>
#include &quot;BCFControlNoWinInterfaces.H&quot;</TT></FONT></P>

<P>to<FONT COLOR="#0066FF"><TT><BR>
<BR>
#include &quot;BCFControlInterfaces.H&quot;</TT></FONT></P>

<P>The same must be done for the BCFControlSubWinCtl.h header file.</P>
<P>Each of the individual projects contains a Guids.h file. You combine all three
into a single file (see Listing 10.2).
<H3><A NAME="Heading5"></A>Listing 10.2 <SPACER TYPE="HORIZONTAL" SIZE="10">GUIDS.H--Combined
Guids.h</H3>
<P><FONT COLOR="#0066FF"><TT>#ifndef _GUIDS_H_ <BR>
// for each property page this server will have, put the guid definition for it<BR>
// here so that it gets defined ...<BR>
//<BR>
DEFINE_GUID(CLSID_BCFControlGeneralPage, 0x317512F4, 0x3E75, 0x11d0,<BR>
0xBE, 0xBE, 0x00, 0x40, 0x05, 0x38, 0x97, 0x7D); <BR>
DEFINE_GUID(CLSID_BCFControlNoWinGeneralPage, 0xcf395064, 0x3fb6, 0x11d0,<BR>
0xbe, 0xc1, 0x00, 0x40, 0x05, 0x38, 0x97, 0x7d); <BR>
DEFINE_GUID(CLSID_BCFControlSubWinGeneralPage, 0x02456be4, 0x3fb7, 0x11d0,<BR>
0xbe, 0xc1, 0x00, 0x40, 0x05, 0x38, 0x97, 0x7d); <BR>
#define _GUIDS_H_ <BR>
#endif // _GUIDS_H_</TT></FONT></P>
<P>Next you need to combine all of the ODL files into a single file. While it is
possible for an application to contain more than one type library resource, for simplicity,
you will have one. Copy only the interface entries from each of the ODL files, and
insert them into the BCFControl.odl file (see Listing 10.3).
<H3><A NAME="Heading6"></A>Listing 10.3 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.ODL--Combined
Control ODL Files</H3>
<P><FONT COLOR="#0066FF"><TT>//=--------------------------------------------------------------------------=<BR>
// BCFControl.ODL<BR>
//=--------------------------------------------------------------------------=<BR>
// Copyright 1995 Microsoft Corporation. All Rights Reserved.<BR>
//<BR>
// THIS CODE AND INFORMATION IS PROVIDED &quot;AS IS&quot; WITHOUT WARRANTY OF <BR>
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <BR>
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <BR>
// PARTICULAR PURPOSE.<BR>
//=--------------------------------------------------------------------------=<BR>
//<BR>
// ODL file for the control(s) and automation object(s) in this inproc server<BR>
//<BR>
#include &lt;olectl.h&gt;<BR>
#include &quot;dispids.h&quot; <BR>
// can't include oaidl.h, so this will have to do<BR>
//<BR>
#define DISPID_NEWENUM -4 //=--------------------------------------------------------------------------=<BR>
// the libid for this type libray<BR>
//<BR>
[<BR>
uuid(317512F0-3E75-11d0-BEBE-00400538977D),<BR>
helpstring(&quot;BCFControl Control Library&quot;),<BR>
lcid(0x0000),<BR>
version(1.0)<BR>
]<BR>
library BCFControlObjects { <BR>
// standard imports<BR>
//<BR>
importlib(&quot;STDOLE32.TLB&quot;);<BR>
importlib(STDTYPE_TLB); <BR>
// primary dispatch interface for CBCFControl control<BR>
//<BR>
[<BR>
uuid(317512F1-3E75-11d0-BEBE-00400538977D),<BR>
helpstring(&quot;BCFControl Control&quot;),<BR>
hidden,<BR>
dual,<BR>
odl<BR>
]<BR>
interface IBCFControl : IDispatch { <BR>
// properties<BR>
// <BR>
// methods<BR>
//<BR>
[id(DISPID_ABOUTBOX)]<BR>
void AboutBox(void);<BR>
}; <BR>
// event interface for CBCFControl controls ...<BR>
//<BR>
[<BR>
uuid(317512F2-3E75-11d0-BEBE-00400538977D),<BR>
helpstring(&quot;Event interface for BCFControl control&quot;),<BR>
hidden<BR>
]<BR>
dispinterface DBCFControlEvents {<BR>
properties:<BR>
methods:<BR>
}; <BR>
// coclass for CBCFControl controls<BR>
//<BR>
[<BR>
uuid(317512F3-3E75-11d0-BEBE-00400538977D),<BR>
helpstring(&quot;BCFControl control&quot;)<BR>
]<BR>
coclass BCFControl {<BR>
[default] interface IBCFControl;<BR>
[default, source] dispinterface DBCFControlEvents;<BR>
}; <BR>
// primary dispatch interface for CBCFControlNoWin control<BR>
//<BR>
[<BR>
uuid(cf395061-3fb6-11d0-bec1-00400538977d),<BR>
helpstring(&quot;BCFControlNoWin Control&quot;),<BR>
hidden,<BR>
dual,<BR>
odl<BR>
]<BR>
interface IBCFControlNoWin : IDispatch { <BR>
// properties<BR>
// <BR>
// methods<BR>
//<BR>
[id(DISPID_ABOUTBOX)]<BR>
void AboutBox(void);<BR>
}; <BR>
// event interface for CBCFControlNoWin controls ...<BR>
//<BR>
[<BR>
uuid(cf395062-3fb6-11d0-bec1-00400538977d),<BR>
helpstring(&quot;Event interface for BCFControlNoWin control&quot;),<BR>
hidden<BR>
]<BR>
dispinterface DBCFControlNoWinEvents {<BR>
properties:<BR>
methods:<BR>
}; <BR>
// coclass for CBCFControlNoWin controls<BR>
//<BR>
[<BR>
uuid(cf395063-3fb6-11d0-bec1-00400538977d),<BR>
helpstring(&quot;BCFControlNoWin control&quot;)<BR>
]<BR>
coclass BCFControlNoWin {<BR>
[default] interface IBCFControlNoWin;<BR>
[default, source] dispinterface DBCFControlNoWinEvents;<BR>
}; <BR>
// primary dispatch interface for CBCFControlSubWin control<BR>
//<BR>
[<BR>
uuid(02456be1-3fb7-11d0-bec1-00400538977d),<BR>
helpstring(&quot;BCFControlSubWin Control&quot;),<BR>
hidden,<BR>
dual,<BR>
odl<BR>
]<BR>
interface IBCFControlSubWin : IDispatch { <BR>
// properties<BR>
// <BR>
// methods<BR>
//<BR>
[id(DISPID_ABOUTBOX)]<BR>
void AboutBox(void);<BR>
}; <BR>
// event interface for CBCFControlSubWin controls ...<BR>
//<BR>
[<BR>
uuid(02456be2-3fb7-11d0-bec1-00400538977d),<BR>
helpstring(&quot;Event interface for BCFControlSubWin control&quot;),<BR>
hidden<BR>
]<BR>
dispinterface DBCFControlSubWinEvents {<BR>
properties:<BR>
methods:<BR>
}; <BR>
// coclass for CBCFControlSubWin controls<BR>
//<BR>
[<BR>
uuid(02456be3-3fb7-11d0-bec1-00400538977d),<BR>
helpstring(&quot;BCFControlSubWin control&quot;)<BR>
]<BR>
coclass BCFControlSubWin {<BR>
[default] interface IBCFControlSubWin;<BR>
[default, source] dispinterface DBCFControlSubWinEvents;<BR>
}; <BR>
};</TT></FONT></P>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>CAUTION:</B><BR>
	When combining several OCXs, you <I>must</I> delete any .tlb files that may have
	already been created to update the dependencies of the project. Occasionally, Visual
	C++ will compile more that one type library into different directories and use the
	incorrect version when compiling the resources for the control. In the case where
	you have new information that is added to the ODL file, the result will be that the
	type library has not appeared to have changed, which can be a major problem for applications,
	such as VB, that depend on the type library for information about the component being
	used.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Open the BCFControlNoWin.rc and BCFControlSubWin.rc resource files. Copy the property
page dialogs and the string and bitmap resources to the BCFControl resource file.
Rename the bitmaps to <TT>RESID_TOOLBOX_BITMAP1</TT>, <TT>RESID_TOOLBOX_BITMAP2</TT>,
and <TT>RESID_TOOLBOX_BITMAP3</TT>, respectively. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> If you experience problems opening the resource files because of
	dependencies on the type library, you can either compile the ODL files into the type
	library or open the resource files in text mode and edit the files manually.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
After combining the resources, you need to combine your Resource.h files as well
(see Listing 10.4). Make sure that the constant values match their corresponding
resources.
<H3><A NAME="Heading7"></A>Listing 10.4 <SPACER TYPE="HORIZONTAL" SIZE="10">RESOURCE.H--Combined
Resource.h Files</H3>
<P><FONT COLOR="#0066FF"><TT>//=--------------------------------------------------------------------------=<BR>
<BR>
// Resource.H<BR>
//=--------------------------------------------------------------------------=<BR>
// Copyright 1995 Microsoft Corporation. All Rights Reserved.<BR>
//<BR>
// THIS CODE AND INFORMATION IS PROVIDED &quot;AS IS&quot; WITHOUT WARRANTY OF <BR>
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <BR>
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <BR>
// PARTICULAR PURPOSE.<BR>
//=--------------------------------------------------------------------------=<BR>
//<BR>
// resource IDs.<BR>
//<BR>
#ifndef _RESOURCE_H_ <BR>
#define RESID_TOOLBOX_BITMAP1 1<BR>
#define RESID_TOOLBOX_BITMAP2 2<BR>
#define RESID_TOOLBOX_BITMAP3 3 <BR>
//=--------------------------------------------------------------------------=<BR>
// Strings<BR>
// <BR>
// this must be defined for any server that has propety pages. it must be one<BR>
// thousand.<BR>
//<BR>
#define IDS_PROPERTIES 1000 <BR>
// this is defined for all inproc servers that use satellite localization. it<BR>
// must be 1001<BR>
//<BR>
#define IDS_SERVERBASENAME 1001 <BR>
#define IDS_BCFCONTROL_GENERALPAGETITLE 2003<BR>
#define IDS_BCFCONTROL_GENERALDOCSTRING 2004<BR>
#define IDS_BCFCONTROLNOWIN_GENERALPAGETITLE 2005<BR>
#define IDS_BCFCONTROLNOWIN_GENERALDOCSTRING 2006<BR>
#define IDS_BCFCONTROLSUBWIN_GENERALPAGETITLE 2007<BR>
#define IDS_BCFCONTROLSUBWIN_GENERALDOCSTRING 2008<BR>
#define IDS_BCFCONTROL_ABOUTBOXVERB 2009<BR>
#define IDS_BCFCONTROLNOWIN_ABOUTBOXVERB 2010<BR>
#define IDS_BCFCONTROLSUBWIN_ABOUTBOXVERB 2011 <BR>
//=--------------------------------------------------------------------------=<BR>
// Dialog Stuff<BR>
//<BR>
#define IDD_PROPPAGE_BCFCONTROLGENERAL 2000<BR>
#define IDD_PROPPAGE_BCFCONTROLNOWINGENERAL 2001<BR>
#define IDD_PROPPAGE_BCFCONTROLSUBWINGENERAL 2002 <BR>
#define _RESOURCE_H_ <BR>
#endif // _RESOURCE_H_</TT></FONT></P>
<P>Combine all of the LocalObj.h files (see Listing 10.5). Be sure to renumber the
constants so that they are not the same since they are used to identify each control
and property page in your application.
<H3><A NAME="Heading8"></A>Listing 10.5 <SPACER TYPE="HORIZONTAL" SIZE="10">LOCALOBJ.H--Combined
LocalObj.h File</H3>
<P><FONT COLOR="#0066FF"><TT>//=--------------------------------------------------------------------------=<BR>
// LocalObjects.H<BR>
//=--------------------------------------------------------------------------= <BR>
... <BR>
// **** ADD ALL NEW OBJECTS TO THIS LIST ****<BR>
// <BR>
#define OBJECT_TYPE_CTLBCFCONTROL 0<BR>
#define OBJECT_TYPE_PPGBCFCONTROLGENERAL 1<BR>
#define OBJECT_TYPE_CTLBCFCONTROLNOWIN 2<BR>
#define OBJECT_TYPE_PPGBCFCONTROLNOWINGENERAL 3<BR>
#define OBJECT_TYPE_CTLBCFCONTROLSUBWIN 4<BR>
#define OBJECT_TYPE_PPGBCFCONTROLSUBWINGENERAL 5 <BR>
#define _LOCALOBJECTS_H_ <BR>
#endif // _LOCALOBJECTS_H_</TT></FONT></P>
<P>Last you update the bitmap resource constant for each of your control header files.
Listing 10.6 shows the change that needs to be made to each of the control header
files.
<H3><A NAME="Heading9"></A>Listing 10.6<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--Update
the Bitmap Source</H3>
<P><FONT COLOR="#0066FF"><TT>extern const GUID *rgBCFControlPropPages [];<BR>
DEFINE_CONTROLOBJECT(BCFControl,<BR>
&amp;CLSID_BCFControl,<BR>
&quot;BCFControlCtl&quot;,<BR>
CBCFControlControl::Create,<BR>
1,<BR>
&amp;IID_IBCFControl,<BR>
&quot;BCFControl.HLP&quot;,<BR>
&amp;DIID_DBCFControlEvents,<BR>
OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | <BR>
OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT,<BR>
0, // no IPointerInactive policy by default<BR>
RESID_TOOLBOX_BITMAP1,<BR>
&quot;BCFControlWndClass&quot;,<BR>
1,<BR>
rgBCFControlPropPages,<BR>
0, <BR>
NULL);</TT></FONT></P>
<P>Be sure to make the same change to the BCFControlNoWinCtl.h and BCFControlSubWinCtl.h
header files using the ID's RESID_TOOLBOX_BITMAP2 and RESID_TOOLBOX_BITMAP3, respectively.</P>
<P>All of the basic source files are now added to the control project. The next step
in any control project is to ensure that the project contains registration support.
Without registration, the control cannot be used by any application.
<H2><A NAME="Heading10"></A>Control Registration</H2>
<P>Control registration support is handled completely by the BaseCtl framework and
is hidden from the developer. Some of the registration information is part of the
<TT>DEFINE_CONTROLOBJECT</TT> structure (see Listing 10.7), which you looked at earlier
in this chapter. See the BaseCtl documentation about the specific information that
can be changed.
<H3><A NAME="Heading11"></A>Listing 10.7<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--DEFINE_CONTROLOBJECT
Structure</H3>
<PRE><FONT COLOR="#0066FF">// TODO: if you have an array of verbs, then add an extern here with the name</FONT></PRE>
<P><FONT COLOR="#0066FF"><TT><BR>
// of it, so that you can include it in the DEFINE_CONTROLOBJECT.<BR>
// ie. extern VERBINFO m_BCFControlCustomVerbs [];<BR>
//<BR>
extern const GUID *rgBCFControlPropPages [];<BR>
DEFINE_CONTROLOBJECT(BCFControl,<BR>
&amp;CLSID_BCFControl,<BR>
&quot;BCFControlCtl&quot;,<BR>
CBCFControlControl::Create,<BR>
1,<BR>
&amp;IID_IBCFControl,<BR>
&quot;BCFControl.HLP&quot;,<BR>
&amp;DIID_DBCFControlEvents,<BR>
OLEMISC_SETCLIENTSITEFIRST | <BR>
OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | <BR>
OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT,<BR>
0, // no IPointerInactive policy by default<BR>
RESID_TOOLBOX_BITMAP1,<BR>
&quot;BCFControlWndClass&quot;,<BR>
1,<BR>
rgBCFControlPropPages,<BR>
0, <BR>
NULL);</TT></FONT></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The BaseCtl basic project does not by default contain support for
	registering the control automatically when the project is compiled. You must ensure
	that the control is properly registered before using it, especially if you recently
	switched between debug and release versions.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
You can now compile and register the control you've created, but it won't be of much
use because it doesn't contain any methods, properties, or events, which are the
basis of every ActiveX control.
<H2><A NAME="Heading12"></A>Creating Methods</H2>
<P>Now that you've successfully created your ActiveX control project, you can add
a <I>method, </I>which is one of the basic aspects of component development.</P>
<P>For the purposes of the sample control, you add a method called <TT>CaptionMethod</TT>.
The method accepts two parameters, the second being optional. The first parameter
is a string that the control displays within its client area, and the second, optional
parameter is the alignment of the caption within the client area, either left, right,
or center.</P>
<P>When creating methods, properties, and events for your control, you always start
with the ODL file. When the ODL file is compiled, a C++ header file is created that
defines all of the interfaces and methods of the control. From the header file, you
cut and paste the method, property, and event prototypes into your control implementation.
The one thing about your BaseCtl (and ATL) implementation that is different from
your MFC implementation is that your control supports dual-interfaces by default.
All methods, properties, and events must be written using dual-interface syntax rules,
which you get into a little later in this chapter.</P>
<P>First you need to add an entry to the Dispids.h file. Dispids are the constant
values used by the <TT>IDispatch</TT> routines to locate the correct method or property
being invoked through the <TT>IDispatch</TT> interface. Dispids can be any unique
number including negative numbers. Be careful when using negative values, however,
since the system-defined dispids are all negative. You are better off staying with
only positive values. Listing 10.8 shows the dispid entry that you added for your
<TT>CaptionMethod</TT>.
<H3><A NAME="Heading13"></A>Listing 10.8<SPACER TYPE="HORIZONTAL" SIZE="10"> DISPIDS.H--Dispid
for CaptionMethod</H3>
<P><FONT COLOR="#0066FF"><TT>#define dispidCaptionMethod 2</TT></FONT></P>
<P>Next you need to add the new method to your ODL file. From the Project Workspace
window, select the File View, and open the BCFControl.odl file. Listing 10.9 shows
the method that you added to the <TT>BCFControl</TT>'s primary dispatch interface.</P>
<P>The <TT>dispidCaptionMethod</TT> constant is used for the <TT>id</TT> of the method,
the return type is <TT>HRESULT</TT>--because it's dual-interface, and the name is
<TT>CaptionMethod</TT>. The parameters are de-fined as a <TT>BSTR</TT>, named <TT>lpctstrCaption</TT>,
and a <TT>VARIANT</TT>, named <TT>varAlignment</TT>. Your last parameter is actually
your return value and is defined as a <TT>long</TT> pointer, named <TT>RetVal</TT>.
You also added the direction that the parameters flow in the form of <TT>[in]</TT>
and <TT>[out]</TT> parameter attributes. (See Table 10.2 for a complete description
of the possible attributes that can be used.)</P>
<P>Parameter attributes are used to aid development tools, such as VB, in determining
how parameters are used within a function call. A tool like VB will hide the details
of how parameters are handled--for example, creating and destroying memory--based
on the parameter direction attributes and other attributes in the type library. The
type library is the description of your component to the tools that will use it and
is why it is so important to ActiveX component development. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 10.2</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>Parameter Flow Attributes</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Direction</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">in</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">out</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is returned from callee to caller.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">in, out</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee, and the callee returns a parameter.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">out, retval</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is the return value of the method and is returned from callee to the caller.</TD>
	</TR>
</TABLE>
<BR>
Next compile the type library to create a new C++ header file defining your control
and its interfaces. After compiling, open the BCFControlInterfaces.h file, and copy
the <TT>CaptionMethod</TT> line.
<H3><A NAME="Heading14"></A>Listing 10.9 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLINTERFACES.H--Interface
File Created from the ODL File</H3>
<P><FONT COLOR="#0066FF"><TT>interface DECLSPEC_UUID(&quot;317512F1-3E75-11d0-BEBE-00400538977D&quot;)<BR>
IBCFControl : public IDispatch<BR>
{<BR>
public:<BR>
virtual /* [id] */ HRESULT STDMETHODCALLTYPE CaptionMethod( <BR>
/* [in] */ BSTR bstrCaption,<BR>
/* [optional][in] */ VARIANT varAlignment,<BR>
/* [retval][out] */ long __RPC_FAR *lRetVal) = 0; <BR>
<BR>
};</TT></FONT></P>
<P>Open the BCFControlCtl.h file, and paste the line into your class header file,
making sure that you remove the <TT>= 0</TT> from the prototype. To aid your implementation,
you also need to add an enumeration and two member variables to your class definition
(see Listing 10.10).
<H3><A NAME="Heading15"></A>Listing 10.10 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--Updated
Control Class Header File</H3>
<P><FONT COLOR="#0066FF"><TT>... <BR>
#include &quot;BCFControlInterfaces.H&quot;<BR>
#include &quot;Dispids.H&quot; <BR>
#include &quot;alignmentenums.h&quot; <BR>
typedef struct tagBCFCONTROLCTLSTATE <BR>
{<BR>
long lCaptionLength;<BR>
long lAlignment;<BR>
} BCFCONTROLCTLSTATE; <BR>
//=--------------------------------------------------------------------------=<BR>
// CBCFControlControl<BR>
//=--------------------------------------------------------------------------=<BR>
// our control.<BR>
//<BR>
class CBCFControlControl : public COleControl, public IBCFControl, <BR>
public ISupportErrorInfo <BR>
{<BR>
public:<BR>
// IUnknown methods<BR>
//<BR>
DECLARE_STANDARD_UNKNOWN(); <BR>
// IDispatch methods<BR>
//<BR>
DECLARE_STANDARD_DISPATCH(); <BR>
// ISupportErrorInfo methods<BR>
//<BR>
DECLARE_STANDARD_SUPPORTERRORINFO(); <BR>
// IBCFControl methods<BR>
//<BR>
// TODO: copy over the method declarations from BCFControlInterfaces.H<BR>
// don't forget to remove the PURE from them.<BR>
//<BR>
STDMETHOD(CaptionMethod)(THIS_ BSTR bstrCaption, VARIANT varAlignment,<BR>
long FAR* lRetVal);<BR>
STDMETHOD_(void, AboutBox)(THIS); <BR>
// OLE Control stuff follows:<BR>
//<BR>
CBCFControlControl(IUnknown *pUnkOuter);<BR>
virtual ~CBCFControlControl(); <BR>
// static creation function. all controls must have one of these!<BR>
//<BR>
static IUnknown *Create(IUnknown *); <BR>
private:<BR>
// overridables that the control must implement.<BR>
//<BR>
STDMETHOD(LoadBinaryState)(IStream *pStream);<BR>
STDMETHOD(SaveBinaryState)(IStream *pStream);<BR>
STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);<BR>
STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault);<BR>
STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds,<BR>
LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize);<BR>
virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);<BR>
virtual BOOL RegisterClassData(void); <BR>
virtual HRESULT InternalQueryInterface(REFIID, void **);<BR>
virtual BOOL BeforeCreateWindow(DWORD *pdwWindowStyle, <BR>
DWORD *pdwExWindowStyle, LPSTR pszWindowTitle); <BR>
// private state information.<BR>
//<BR>
BCFCONTROLCTLSTATE m_state;<BR>
BCFCONTROLCTLSTATE m_DefaultState; <BR>
protected:<BR>
// storage variable for the caption<BR>
LPTSTR m_lptstrCaption;<BR>
}; <BR>
...</TT></FONT></P>
<P>The enumeration, which is in the include file Alignmentenums.h, is your list of
supported alignment styles (see Listing 10.11).
<H3><A NAME="Heading16"></A>Listing 10.11 <SPACER TYPE="HORIZONTAL" SIZE="10">ALIGNMENTENUMS.H--Alignment
Styles Enumeration</H3>
<P><FONT COLOR="#0066FF"><TT>typedef enum tagAlignmentEnum<BR>
{<BR>
EALIGN_LEFT = 0,<BR>
EALIGN_CENTER = 1,<BR>
EALIGN_RIGHT = 2,<BR>
}EALIGNMENT; <BR>
#define EALIGN_LEFT_TEXT &quot;Left&quot;<BR>
#define EALIGN_CENTER_TEXT &quot;Center&quot; <BR>
#define EALIGN_RIGHT_TEXT &quot;Right&quot;</TT></FONT></P>
<P>You added the <TT>lAlignment</TT> member variable into the <TT>BCFCONTROLCTLSTATE</TT>
structure, which is a member variable declared as <TT>m_state</TT>, in your control
class. Define the <TT>m_lptstrCaption</TT> variable as a member of the control class
rather than a member of the state structure--for persistence reasons; for now, suffice
it to say that you will make your life a lot easier by declaring your member variables
this way. You will address persistence and the use of the state structures in more
detail a little later in this chapter in the section &quot;Persistence.&quot; Also,
declare the member variable, <TT>lCaptionLength</TT>, which is related to the <TT>m_lptstrCaption</TT>
variable, which is needed for persistence reasons; for now, however, it will serve
no purpose.</P>
<P>In addition to the <TT>m_state</TT> variable, you need to add another member of
the same type called <TT>m_DefaultState</TT>. This structure is initialized in the
constructor to all of the default values that your control supports (see Listing
10.12). These values will be used later in your persistence implementation to determine
whether the properties have changed from their default values, and if not, the properties
will not be persisted. See the section entitled &quot;Persistence&quot; for more
information.
<H3><A NAME="Heading17"></A>Listing 10.12 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Member
Variable Initialization</H3>
<P><FONT COLOR="#0066FF"><TT>//=--------------------------------------------------------------------------=<BR>
// CBCFControlControl::CBCFControlControl<BR>
//=--------------------------------------------------------------------------=<BR>
// &quot;Being born is like being kidnapped. And then sold into slavery.&quot;<BR>
// - andy warhol (1928 - 87)<BR>
//<BR>
// Parameters:<BR>
// IUnknown * - [in]<BR>
//<BR>
// Notes:<BR>
//<BR>
#pragma warning(disable:4355) // using `this' in constructor<BR>
CBCFControlControl::CBCFControlControl<BR>
(<BR>
IUnknown *pUnkOuter<BR>
)<BR>
: COleControl(pUnkOuter, OBJECT_TYPE_CTLBCFCONTROL, (IDispatch *)this)<BR>
{<BR>
// initialize anything here ...<BR>
//<BR>
memset(&amp;m_state, 0, sizeof(BCFCONTROLCTLSTATE));<BR>
memset(&amp;m_DefaultState, 0, sizeof(BCFCONTROLCTLSTATE)); <BR>
// NULL terminate the string reference<BR>
m_lptstrCaption = new TCHAR[1];<BR>
m_lptstrCaption[0] = `\0'; <BR>
// set the alignment to the default of left<BR>
m_DefaultState.lAlignment = m_state.lAlignment = EALIGN_LEFT;<BR>
} <BR>
#pragma warning(default:4355) // using `this' in constructor</TT></FONT></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> If you like interesting quotations, you will find that the BaseCtl
	code is sprinkled with them in appropriate places, as can be seen in Listing 10.12.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The <TT>CaptionMethod</TT> contains all of the code for getting the caption and the
alignment style and, like your MFC and ATL implementations, deals correctly with
the optional parameter.</P>
<P>Listing 10.13 shows the implementation of the <TT>CaptionMethod</TT>. Since the
method is used both for your <TT>IDispatch</TT> implementation and your custom interface,
it is implemented slightly different from its MFC counterpart. First you declare
an <TT>HRESULT</TT> return type. This return value is used by OLE to determine whether
the method call succeeded. The string parameter is passed in differently also. All
strings are passed as <TT>UNICODE</TT> in OLE. This is true even for MFC; the only
difference is that MFC hides from the developer the implementation details of how
the strings are managed; the developer simply uses the appropriate string data type
based on the target application and platform, that is, Win32 <TT>ANSI</TT> versus
Win32 <TT>UNICODE</TT>.
<H3><A NAME="Heading18"></A>Listing 10.13<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--CaptionMethod
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::CaptionMethod(BSTR
bstrCaption,<BR>
VARIANT varAlignment, long FAR * lRetVal)<BR>
{<BR>
HRESULT hResult = S_OK; <BR>
// return value initialized to failure result<BR>
*lRetVal = FALSE; <BR>
MAKE_ANSIPTR_FROMWIDE(lpctstrCaption, bstrCaption); <BR>
// if the variant is a long just use the value<BR>
if(VT_I4 == varAlignment.vt)<BR>
{<BR>
// assign the value to our member variable<BR>
m_state.lAlignment = varAlignment.lVal; <BR>
// set the return value<BR>
*lRetVal = TRUE;<BR>
}<BR>
// if the user didn't supply an alignment parameter we will assign the default<BR>
else if(VT_ERROR == varAlignment.vt || VT_EMPTY == varAlignment.vt)<BR>
{<BR>
// assign the value to our member variable<BR>
m_state.lAlignment = EALIGN_LEFT; <BR>
// set the return value<BR>
*lRetVal = TRUE;<BR>
}<BR>
else<BR>
{<BR>
// get a variant that we can use for conversion purposes<BR>
VARIANT varConvertedValue; <BR>
// initialize the variant<BR>
::VariantInit(&amp;varConvertedValue); <BR>
// see if we can convert the data type to something useful<BR>
// VariantChangeTypeEx() could also be used<BR>
if(S_OK == ::VariantChangeType(&amp;varConvertedValue,<BR>
(VARIANT *) &amp;varAlignment, 0, VT_I4))<BR>
{<BR>
// assign the value to our member variable <BR>
switch(varConvertedValue.lVal)<BR>
{<BR>
case EALIGN_CENTER: <BR>
m_state.lAlignment = EALIGN_CENTER;<BR>
break;<BR>
case EALIGN_RIGHT:<BR>
m_state.lAlignment = EALIGN_RIGHT;<BR>
break;<BR>
default:<BR>
m_state.lAlignment = EALIGN_LEFT;<BR>
break;<BR>
} <BR>
// set the return value<BR>
*lRetVal = TRUE;<BR>
}<BR>
else<BR>
{<BR>
// at this point we could either throw an error <BR>
// indicating there was a problem converting <BR>
// the data or change the return type of the method<BR>
// and return the HRESULT value from the <BR>
// the &quot;VariantChangeType&quot; call.<BR>
}<BR>
} <BR>
// if everything was OK<BR>
if(TRUE == *lRetVal)<BR>
{<BR>
// if we have a string<BR>
if(lpctstrCaption != NULL)<BR>
{<BR>
// if we have a string<BR>
if(m_lptstrCaption)<BR>
{<BR>
// delete the existing string<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
m_lptstrCaption = NULL;<BR>
} <BR>
// allocate a new string<BR>
m_lptstrCaption = new TCHAR[lstrlen(lpctstrCaption) + 1]; <BR>
// assign the string to our member variable<BR>
lstrcpy(m_lptstrCaption, lpctstrCaption);<BR>
}<BR>
<BR>
// did they pass us bad data?<BR>
if(m_state.lAlignment &lt; EALIGN_LEFT || m_state.lAlignment &gt; EALIGN_RIGHT)<BR>
// sure did, lets fix their little red wagon<BR>
m_state.lAlignment = EALIGN_LEFT; <BR>
// force the control to repaint itself<BR>
this-&gt;InvalidateControl(NULL);<BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version<BR>
} <BR>
// return the result of the function call<BR>
return hResult; <BR>
}</TT></FONT></P>
<P>Use the BaseCtl utility macro <TT>MAKE_ANSIPTR_FROMWIDE</TT> to convert the <TT>BSTR</TT>
to an <TT>ANSI</TT> string. The file UTIL.H contains a number of helper functions
and macros to aid in your control development. This file, along with the BaseCtl
header files for the control and automation object implementations, deserves to be
reviewed just to note the differences between the standard MFC implementation and
the BaseCtl implementation for ActiveX controls. In addition, since documentation
is nonexistent, reviewing the header files will give you a feel for the types of
functions and functionality that are available to you for doing BaseCtl development.
<BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> A number of <I>wrapper </I>functions are defined in the COleControl
	header file for performing other common functions, such as invalidating a rectangle.
	The wrapper functions allow the control to be created as either windowed or windowless,
	without requiring separate code implementations to deal with each unique state. When
	writing your control, do <I>not</I> use the control's window handle directly. Cases
	like these are why the BaseCtl code should be reviewed carefully prior to making
	large implementation investments. And due to the lack of documentation, the little
	differences are also why a BaseCtl implementation can be a little more difficult.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Aside from the string conversion, the <TT>CaptionMethod</TT> varies little from its
MFC and ATL counterpart.</P>
<P>One thing to note though is the use of the method <TT>InvalidateControl</TT> to
force the control's UI to redraw. This is a very good example of the kind of differences
between BaseCtl and MFC in terms of certain basic functionality. In this case, the
function <TT>InvalidateControl</TT> requires that a parameter be passed, thus differing
from the MFC implementation, which has a default parameter of <TT>NULL</TT>. All
differences of this kind are pointed out in the source code.
<H2><A NAME="Heading19"></A>Creating Properties</H2>
<P><I>Properties</I> can be categorized as user defined, stock, or ambient.</P>
<P><I>User defined properties</I> are properties that are implementation- specific
and have meaning only to the component that contains them. User defined properties
can be further broken into those properties that are defined only as their specific
data type (<I>normal</I> properties) and those with additional parameters (<I>parameterized</I>
properties).</P>
<P><I>Stock properties</I> are a set of properties that are already defined by OLE
in terms of the basic meaning. Stock properties are not implemented in the control
of the container by default. They still require implementation by the control developer.
They are predefined only to imply a certain level of uniformity between various control
implementations.</P>
<P><I>Ambient properties,</I> on the other hand, are properties that are supported
by the container to provide a default value to the control that uses them.</P>
<P>In the remainder of this chapter, you will create all three types of properties:
normal, parameterized, and stock. You will also learn how to use ambient properties.
<H3><A NAME="Heading20"></A>Creating Normal User Defined Properties</H3>
<P>A <I>normal property</I> is a property that is declared as a single type, for
example, <TT>long</TT> or <TT>BSTR</TT>, and has no parameters. You will expose your
control's Alignment member variable through a property.</P>
<P>Properties are added in much the same way as methods. First add the dispid for
the property to the Dispids.h file.</P>
<P><FONT COLOR="#0066FF"><TT>#define dispidAlignment 1</TT></FONT></P>
<P>Next add the property declaration to the ODL file (see Listing 10.14). The property
declaration is really a pair of methods sharing the same dispid. The <TT>propget</TT>
and <TT>propput</TT> attributes denote the direction with which data is moved to
and from the property. The <TT>propget</TT> method contains a single parameter defined
as the return value of the method, using the <TT>[out, retval]</TT> attributes. The
<TT>propput</TT> method correspondingly accepts a single parameter of the same type.
<H3><A NAME="Heading21"></A>Listing 10.14 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.ODL--Normal
User Defined Property ODL Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>// primary dispatch interface for CBCFControl control<BR>
//<BR>
[uuid(317512F1-3E75-11d0-BEBE-00400538977D), helpstring(&quot;BCFControl Control&quot;),<BR>
hidden, dual, odl]<BR>
interface IBCFControl : IDispatch <BR>
{<BR>
// properties<BR>
[id(dispidAlignment), propget] HRESULT Alignment([out, retval] long * Value);<BR>
[id(dispidAlignment), propput] HRESULT Alignment([in] long Value); <BR>
// methods<BR>
[id(dispidCaptionMethod)] HRESULT CaptionMethod([in] BSTR bstrCaption,<BR>
[in, optional] VARIANT varAlignment, [out, retval] long *lRetVal);<BR>
[id(DISPID_ABOUTBOX)] void AboutBox(void); <BR>
};</TT></FONT></P>
<P>As with your method implementation, you need to compile the ODL file in order
to create the C++ interface prototypes that you add to your class definition. After
the ODL is compiled, copy the two new function prototypes from the ODL-generated
header file to the BCFControl.h header file (see Listing 10.15).
<H3><A NAME="Heading22"></A>Listing 10.15 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--Property
Function Prototypes</H3>
<P><FONT COLOR="#0066FF"><TT>// IBCFControl methods<BR>
//<BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* Value);<BR>
STDMETHOD(put_Alignment)(THIS_ long Value);<BR>
STDMETHOD(CaptionMethod)(THIS_ BSTR bstrCaption, VARIANT varAlignment,<BR>
long FAR* lRetVal); <BR>
STDMETHOD_(void, AboutBox)(THIS);</TT></FONT></P>
<P>Don't forget to remove the <TT>= 0</TT> from the function prototypes when you
copy them over.</P>
<P>As you can see, Listing 10.16 takes advantage of the member variable <TT>m_state.lAlignment</TT>,
which you added earlier, and uses it to get and set the property value.</P>
<P>The <TT>get_Alignment</TT> function returns only the value stored in the <TT>m_state.lAlignment</TT>
member variable.</P>
<P>The <TT>put_Alignment</TT> function does a little more. This function checks to
see if the value is within the valid ranges of values and, if so, stores the value
in the <TT>m_state.lAlignment</TT> member variable. The function then sets the <TT>m_fDirty</TT>
flag and calls <TT>PropertyChanged</TT> functions (note the MFC equivalent functions
still in the code) to notify the control and the container, respectively, that the
value of the property has changed. <TT>PropertyChanged</TT> has the effect of forcing
the container to refresh its property browser to reflect the new value. This effect
is very important because the value of the property could change without the container's
knowledge, either through the control's property sheet or, in some cases, in response
to another function call.</P>
<P>You might be asking, &quot;Why didn't I add <TT>PropertyChanged</TT> to the <TT>CaptionMethod</TT>?&quot;
Well, you could have, but it wouldn't do much because the <TT>CaptionMethod</TT>
can never be executed while the control is in design mode, which is the purpose of
<TT>PropertyChanged</TT>. The <TT>PropertyChanged</TT> function is where you make
use of the dispid constants that were defined earlier. The last thing the <TT>put_Alignment</TT>
method does is invalidate the control's UI so it will repaint using the new information.
<H3><A NAME="Heading23"></A>Listing 10.16 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Property
Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::get_Alignment(long
FAR* Value)<BR>
{<BR>
HRESULT hResult = S_OK; <BR>
// return our current setting<BR>
*Value = m_state.lAlignment; <BR>
return hResult;<BR>
} <BR>
STDMETHODIMP CBCFControlControl::put_Alignment(long Value)<BR>
{<BR>
HRESULT hResult = S_OK; <BR>
// if we are in the valid range for the property<BR>
if(Value &gt;= EALIGN_LEFT &amp;&amp; Value &lt;= EALIGN_RIGHT)<BR>
{<BR>
// set the new property value<BR>
m_state.lAlignment = Value; <BR>
// let the control know that the property has changed<BR>
m_fDirty = TRUE;<BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
// refresh the property browser<BR>
this-&gt;PropertyChanged(dispidAlignment);<BR>
// this-&gt;BoundPropertyChanged(dispidAlignment); &lt;== MFC Version<BR>
} <BR>
return hResult; <BR>
}</TT></FONT></P>
<P>The implementation simply sets or returns the value in your member variable <TT>m_state.lAlignment</TT>.
Again, note the differences between your BaseCtl and your MFC implementation.
<H3><A NAME="Heading24"></A>Creating Parameterized User Defined Properties</H3>
<P>A <I>parameterized property</I> is a property that, besides being of a specific
type (for example, <TT>BSTR</TT> or <TT>long</TT>), accepts one or more additional
parameters to further define the data of the property. Parameterized properties can
be useful for properties that represent collections of data where the additional
parameter is the index into the collection.</P>
<P>You expose your <TT>m_lptstrCaption</TT> member variable as a parameterized property
in addition to your <TT>CaptionMethod</TT> function.</P>
<P>First add the new dispid for the <TT>dispidCaptionProp</TT> (see Listing 10.17).
<H3><A NAME="Heading25"></A>Listing 10.17<SPACER TYPE="HORIZONTAL" SIZE="10"> DISPIDS.H--Dispid
for CaptionProp Property</H3>
<P><FONT COLOR="#0066FF"><TT>// properties &amp; methods<BR>
// <BR>
#define dispidAlignment 1<BR>
#define dispidCaptionMethod 2<BR>
#define dispidCaptionProp 3 <BR>
// events</TT></FONT></P>
<P>Next you add your ODL definition (see Listing 10.18) and compile the type library
to create the header file.
<H3><A NAME="Heading26"></A>Listing 10.18 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.ODL--ODL
Entry for Caption Property</H3>
<P><FONT COLOR="#0066FF"><TT>// properties<BR>
[id(dispidAlignment), propget] HRESULT Alignment([out, retval] long * Value);<BR>
[id(dispidAlignment), propput] HRESULT Alignment([in] long Value); <BR>
// methods<BR>
[id(dispidCaptionMethod)] HRESULT CaptionMethod([in] BSTR bstrCaption,<BR>
[in, optional] VARIANT varAlignment, [out, retval] long * lRetVal);<BR>
[id(dispidCaptionProp), propget] HRESULT CaptionProp(<BR>
[in, optional] VARIANT varAlignment, [out, retval] BSTR * bstrRetVal);<BR>
[id(dispidCaptionProp), propput] HRESULT CaptionProp(<BR>
[in] VARIANT varAlignment, [in] BSTR lpszNewValue); <BR>
[id(DISPID_ABOUTBOX)] void AboutBox(void);</TT></FONT></P>
<P>Copy the new function prototypes from the header file, BCFControlInterfaces.h,
and paste them into the control header file (see Listing 10.19).
<H3><A NAME="Heading27"></A>Listing 10.19 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--CaptionProp
Function Prototypes</H3>
<P><FONT COLOR="#0066FF"><TT>// IBCFControl methods<BR>
//<BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* Value);<BR>
STDMETHOD(put_Alignment)(THIS_ long Value);<BR>
STDMETHOD(CaptionMethod)(THIS_ BSTR bstrCaption, VARIANT varAlignment,<BR>
long FAR* lRetVal);<BR>
STDMETHOD(get_CaptionProp)(THIS_ VARIANT varAlignment, BSTR FAR* bstrRetVal);<BR>
STDMETHOD(put_CaptionProp)(THIS_ VARIANT varAlignment, BSTR lpszNewValue); <BR>
STDMETHOD_(void, AboutBox)(THIS);</TT></FONT></P>
<P>Finally you add the implementation of the <TT>CaptionProp</TT> function pair (see
Listing 10.20). The method <TT>get_CaptionProp</TT> is called to return data from
the property. In your implementation, you ignore the alignment parameter because
it is of no use to you in this context; you simply return the caption. You need to
make sure that the string variable, <TT>BSTR FAR * bstrRetVal</TT>, which is passed
to the <TT>get_CaptionProp</TT> function does not already point to another string.
If it does, you need to destroy it. Next <TT>get_CaptionProp</TT> uses the function
<TT>SysAllocString</TT> to create a <TT>BSTR</TT> that is returned from the function
call. Note that it is first necessary to convert the <TT>ANSI</TT> string to an <TT>OLECHAR</TT>
string, with the <TT>OLESTRFROMANSI</TT> macro, and then allocate a <TT>BSTR</TT>
from that.</P>
<P><TT>put_CaptionProp</TT> defers to the <TT>CaptionMethod</TT> implementation because
the <TT>CaptionMethod</TT> already does everything that you need.
<H3><A NAME="Heading28"></A>Listing 10.20 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--CaptionProp
Property Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::get_CaptionProp(VARIANT
varAlignment,<BR>
BSTR FAR* bstrRetVal)<BR>
{<BR>
// if there is a string<BR>
if(*bstrRetVal);<BR>
{<BR>
// free the string because we are going to replace it<BR>
::SysFreeString(*bstrRetVal); <BR>
// clear the reference just to be safe<BR>
*bstrRetVal = NULL;<BR>
} <BR>
// return the caption as a BSTR<BR>
*bstrRetVal = ::SysAllocString(OLESTRFROMANSI(m_lptstrCaption)); <BR>
return S_OK;<BR>
} <BR>
STDMETHODIMP CBCFControlControl::put_CaptionProp(VARIANT varAlignment, <BR>
BSTR lpszNewValue)<BR>
{<BR>
long lRetVal;<BR>
HRESULT hResult = this-&gt;CaptionMethod(lpszNewValue, varAlignment, &amp;lRetVal);
<BR>
// use the &quot;CaptionMethod&quot; implementation<BR>
if(hResult == S_OK &amp;&amp; lRetVal)<BR>
// let the container know that the property has changed<BR>
m_fDirty = TRUE;<BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC version <BR>
return hResult; <BR>
}</TT></FONT></P>
<H3><A NAME="Heading29"></A>Creating Stock Properties</H3>
<P>A <I>stock property</I> is a property that is understood by both a control and
its container and that has a predefined meaning to both. Stock properties are intended
to provide basic uniform functionality to all the controls and containers that implement
them. Stock properties do not require you to implement a lot of code; you just hook
into the existing property.</P>
<P>You are going to support the stock property <TT>BackColor</TT>. For stock properties,
you do not need to add dispids; rather, you take advantage of the constants defined
by OLE. A complete list of system-defined dispids can be found in OLECTL.H, which
is one of the files included with VC++. Listing 10.21 shows your ODL implementation
of the <TT>BackColor</TT> property.
<H3><A NAME="Heading30"></A>Listing 10.21 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.ODL--BackColor
Stock Property Support</H3>
<P><FONT COLOR="#0066FF"><TT>// properties<BR>
[id(dispidAlignment), propget] HRESULT Alignment(<BR>
[out, retval] long * Value);<BR>
[id(dispidAlignment), propput] HRESULT Alignment([in] long Value);<BR>
[id(DISPID_BACKCOLOR), propget] HRESULT BackColor(<BR>
[out, retval] OLE_COLOR * Value);<BR>
[id(DISPID_BACKCOLOR), propput] HRESULT BackColor([in] OLE_COLOR Value);<BR>
// methods</TT></FONT></P>
<P>Listing 10.22 shows the function prototype that was generated from the type library
and added to your control header file.
<H3><A NAME="Heading31"></A>Listing 10.22<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.H--BackColor
Function Prototype</H3>
<P><FONT COLOR="#0066FF"><TT>// IBCFControl methods<BR>
//<BR>
STDMETHOD(get_Alignment)(THIS_ long FAR* Value);<BR>
STDMETHOD(put_Alignment)(THIS_ long Value);<BR>
STDMETHOD(get_BackColor)(THIS_ OLE_COLOR FAR* Value);<BR>
STDMETHOD(put_BackColor)(THIS_ OLE_COLOR Value);<BR>
STDMETHOD(CaptionMethod)(THIS_ BSTR bstrCaption, VARIANT varAlignment,<BR>
long FAR* lRetVal);<BR>
STDMETHOD(get_CaptionProp)(THIS_ VARIANT varAlignment, BSTR FAR* bstrRetVal);<BR>
STDMETHOD(put_CaptionProp)(THIS_ VARIANT varAlignment, BSTR lpszNewValue); <BR>
STDMETHOD_(void, AboutBox)(THIS);</TT></FONT></P>
<P>You also need to add a member variable to your control to store the value of the
<TT>BackColor</TT>. You add the member to the <TT>BCFCONTROLCTLSTATE</TT> structure,
as in Listing 10.23.
<H3><A NAME="Heading32"></A>Listing 10.23 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--BackColor
Member Variable</H3>
<P><FONT COLOR="#0066FF"><TT>typedef struct tagBCFCONTROLCTLSTATE <BR>
{<BR>
long lCaptionLength;<BR>
long lAlignment;<BR>
OLE_COLOR ocBackColor; <BR>
} BCFCONTROLCTLSTATE;</TT></FONT></P>
<P>Also, do not forget to add the member variable initialization to your constructor
(see Listing 10.24).
<H3><A NAME="Heading33"></A>Listing 10.24 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Member
Initialization</H3>
<P><FONT COLOR="#0066FF"><TT>#pragma warning(disable:4355) // using `this' in constructor<BR>
CBCFControlControl::CBCFControlControl<BR>
(<BR>
IUnknown *pUnkOuter<BR>
)<BR>
: CInternetControl(pUnkOuter, OBJECT_TYPE_CTLBCFCONTROL, (IDispatch *)this)<BR>
{<BR>
// initialize anything here ...<BR>
//<BR>
memset(&amp;m_state, 0, sizeof(BCFCONTROLCTLSTATE));<BR>
memset(&amp;m_DefaultState, 0, sizeof(BCFCONTROLCTLSTATE)); <BR>
// NULL terminate the string reference<BR>
m_lptstrCaption = new TCHAR[1];<BR>
m_lptstrCaption[0] = `\0'; <BR>
// set the alignment to the default of left<BR>
m_DefaultState.lAlignment = m_state.lAlignment = EALIGN_LEFT; <BR>
// set the backcolor to the system default<BR>
m_DefaultState.ocBackColor = m_state.ocBackColor = 0x80000000 | COLOR_WINDOW; <BR>
. . .</TT></FONT></P>
<P>Finally you must update the <TT>get_BackColor/put_BackColor</TT> functions to
return and store the <TT>BackColor</TT> property (see Listing 10.25).
<H3><A NAME="Heading34"></A>Listing 10.25 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--BackColor
Property Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::get_BackColor(OLE_COLOR
* Value)<BR>
{<BR>
// make sure that we have a good pointer<BR>
' CHECK_POINTER(Value); <BR>
// set the return value<BR>
*Value = m_state.ocBackColor; <BR>
// return the result<BR>
return S_OK;<BR>
} <BR>
STDMETHODIMP CBCFControlControl::put_BackColor(OLE_COLOR Value)<BR>
{<BR>
// if the value is the same<BR>
if (m_state.ocBackColor == Value)<BR>
// exit <BR>
return S_OK; <BR>
// save the value<BR>
m_state.ocBackColor = Value; <BR>
// let the container know that the value has changed<BR>
this-&gt;PropertyChanged(DISPID_BACKCOLOR);<BR>
// this-&gt;AmbientPropertyChanged(DISPID_BACKCOLOR); &lt;== MFC Version <BR>
// redraw the control<BR>
this-&gt;InvalidateControl(NULL);<BR>
// this-&gt;InvalidateControl(); &lt;== MFC Version <BR>
// set the dirty flag<BR>
m_fDirty = TRUE;<BR>
// this-&gt;SetModifiedFlag(); &lt;== MFC Version <BR>
// exit<BR>
return S_OK; <BR>
}</TT></FONT></P>
<P>The last type of property that you are going to look at is Ambient.
<H3><A NAME="Heading35"></A>Using Ambient Properties</H3>
<P><I>Ambient properties</I> are properties implemented in the container in which
the control resides, as opposed to <I>stock properties, </I>which are implemented
in the control and not the container. Ambient properties share the same set of predefined
meanings and dispids as those of stock properties. To use an ambient property, the
control need request only the property value from the container and apply it in whatever
manner is appropriate for the property type. The use of ambient properties allows
the control to conform to the same settings as those of the container in which it
resides. Using ambient properties provides much better integration between the control
and its container.</P>
<P>The BaseCtl framework defines these two methods for retrieving Ambient properties:</P>
<P><FONT COLOR="#0066FF"><TT>BOOL GetAmbientProperty(DISPID, VARTYPE, void *);<BR>
BOOL GetAmbientFont(IFont **ppFontOut);</TT></FONT></P>
<P><TT>GetAmbientProperty</TT> is a general method for retrieving properties based
on the dispid supplied. The function will not perform any type of dispid validation
when the call is made, so theoretically any dispid can be passed. When supporting
nonstock properties, use this routine to check the return value to guarantee that
it executed successfully. Also, remember that not all containers support the same
set of properties, so as a general rule, the return value should be checked.</P>
<P><TT>GetAmbientFont</TT> is a specialized form of the same routine that retrieves
the interface pointer to an <TT>IFont</TT> object. The font object can then be selected
into the control and used for the control's drawing operations.</P>
<P>Once the property value is retrieved, it can be used any way the developer sees
fit.
<H3><A NAME="Heading36"></A>Creating Property Sheets</H3>
<P><I>Property sheets</I> are a way for a control to display its properties for review
and editing using a tabbed dialog format. The original intent of property sheets
was for cases when the control container did not support property browsing facilities.
While property sheets have their purpose, they probably are not necessary for all
implementations. Your specific requirements will determine whether your control should
contain a property sheet. The official OLE line is that all controls should have
property sheets, which though correct for commercially developed and distributed
controls, is probably not the case for in-house implementations. The majority of
development environments already have excellent property browsing facilities. Implement
property sheets only if you feel that you absolutely have to.</P>
<P>Removing the property sheets and their corresponding implementation infrastructure
definitely reduces the size of your control and should not take away from its implementation
in any way.</P>
<P>Since property sheets are tabbed dialogs, some of your work will be done with
the dialog editor. Select the Resource View in the Project Workspace window. From
the list of dialogs, select <TT>IDD_PROPPAGE_BCFCONTROLGENERAL</TT>, and double-click
the entry to open the resource editor.</P>
<P>Using the resource editor, place a static text control and a combo box on the
dialog. Select the label control on the form, and click the right mouse button. In
the menu that appears, select the Properties menu item. On the General tab, set the
<U>I</U>D of the control to <TT>IDC_ALIGNMENTLABEL</TT>, and set the <U>C</U>aption
to <TT>Alignment</TT>; you see the control in Figure 10.3. Select the Styles tab,
and set the Align Te<U>x</U>t property to <TT>Right</TT>. Close the dialog to save
the information.</P>
<P>Again, using the mouse, select the combo box, use the right mouse to click the
control, and in the menu that appears, select the Properties menu item. On the General
tab, set the <U>I</U>D of the control to <TT>IDC_ALIGNMENTCOMBO</TT>. On the Styles
tab, set the T_ype to Drop down, and uncheck the S<U>o</U>rt check box. Close the
dialog to save the information.</P>
<P>You have placed your two controls on the property sheets and successfully modified
their properties. Now you need to add some code to complete the implementation. Close
the resource editor, and open the file BCFControlPPG.cpp. Listing 10.26 shows your
property page implementation. For developers who have done Windows programming since
the &quot;old days,&quot; before class libraries and C++, this code will look familiar.
We're hopeful that the nightmares won't last too long.</P>
<P>What you have is a standard Windows callback implementation. The first message
you look for is <TT>WM_INITDIALOG</TT>, which is where you set up the Combo Box control
with the appropriate data. The next several messages are defined by the BaseCtl framework.</P>
<P><TT>PPM_NEWOBJECTS</TT> is the message that is sent when the property page is
first connected to the control. This message is where you get all of the property
data from the control and set it into the controls on the property page.</P>
<P><TT>PPM_APPLY</TT> is the message that is sent when the data in the property page
needs to be transferred back to the control. Note the loop that notifies all of the
objects that the data has been changed.</P>
<P>The last messages you look for are standard windows control notification messages
that let the property page know the data in the control has changed. When you receive
the correct messages, you set the dirty flag for the property page. If the dirty
flag is set when the Apply button is pressed or if the property dialog is closed,
the <TT>PPM_APPLY</TT> message will be sent to the dialog, thus causing your code
that will update the control with the new property values to execute.
<H3><A NAME="Heading37"></A>Listing 10.26<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLPPG.CPP--Property
Page Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>//=--------------------------------------------------------------------------=<BR>
// CBCFControlGeneralPage::DialogProc<BR>
//=--------------------------------------------------------------------------=<BR>
// our dialog proc.<BR>
//<BR>
// Parameters:<BR>
// - see win32sdk docs on DialogProc<BR>
//<BR>
// Notes:<BR>
//<BR>
BOOL CBCFControlGeneralPage::DialogProc<BR>
(<BR>
HWND hwnd,<BR>
UINT msg,<BR>
WPARAM wParam,<BR>
LPARAM lParam<BR>
)<BR>
{<BR>
switch (msg)<BR>
{<BR>
case WM_INITDIALOG:<BR>
{<BR>
// get the window handle of the combobox control<BR>
HWND hTempWnd = ::GetDlgItem(hwnd, IDC_ALIGNMENTCOMBO);<BR>
// make sure that the control is empty<BR>
::SendMessage(hTempWnd, CB_RESETCONTENT, 0, 0); <BR>
// set the selection strings in the control - it is important that the control<BR>
// be unsorted since the entries index will relate to the property setting<BR>
::SendMessage(hTempWnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR) EALIGN_LEFT_TEXT);<BR>
::SendMessage(hTempWnd, CB_ADDSTRING, 0, <BR>
(LPARAM)(LPCTSTR) EALIGN_CENTER_TEXT);<BR>
::SendMessage(hTempWnd, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR) EALIGN_RIGHT_TEXT);<BR>
}<BR>
return TRUE;<BR>
// we've been given some new objects, so go and re-set up the dialog page.<BR>
case PPM_NEWOBJECTS:<BR>
{<BR>
HRESULT hr;<BR>
IBCFControl *pBCFControl;<BR>
IUnknown *pUnk;<BR>
DWORD dwDummy;<BR>
LONG lAlignment; <BR>
// get the IUnknown of the control<BR>
pUnk = FirstControl(&amp;dwDummy); <BR>
// if we didn't get a pointer then exit<BR>
if (!pUnk) return FALSE; <BR>
// get the controls custom interface<BR>
hr = pUnk-&gt;QueryInterface(IID_IBCFControl, (void **)&amp;pBCFControl); <BR>
// if it failed then exit<BR>
if (FAILED(hr)) return FALSE; <BR>
// get the alignment from the control<BR>
pBCFControl-&gt;get_Alignment(&amp;lAlignment); <BR>
// set the alignment selection in the control<BR>
::SendMessage(::GetDlgItem(hwnd, IDC_ALIGNMENTCOMBO), <BR>
CB_SETCURSEL, lAlignment, 0); <BR>
// release the interface<BR>
pBCFControl-&gt;Release();<BR>
}<BR>
return TRUE;<BR>
case PPM_APPLY:<BR>
{<BR>
IBCFControl *pBCFControl;<BR>
IUnknown *pUnk;<BR>
HRESULT hr;<BR>
DWORD dwCookie; <BR>
// get all the controls we have to update.<BR>
//<BR>
for(pUnk = FirstControl(&amp;dwCookie); pUnk; pUnk = NextControl(&amp;dwCookie))<BR>
{<BR>
// QI for the controls custom interface<BR>
hr = pUnk-&gt;QueryInterface(IID_IBCFControl, (void **)&amp;pBCFControl); <BR>
// if it failed then continue to the next &quot;for&quot; iteration<BR>
if (FAILED(hr)) continue;<BR>
<BR>
// get the alignment selection in the dialog control<BR>
long lAlignment = ::SendMessage(<BR>
::GetDlgItem(hwnd, IDC_ALIGNMENTCOMBO), CB_GETCURSEL, 0,0); <BR>
// set the alignment in the control<BR>
pBCFControl-&gt;put_Alignment(lAlignment); <BR>
// release the interface pointer<BR>
pBCFControl-&gt;Release();<BR>
}<BR>
}<BR>
return TRUE;<BR>
case WM_COMMAND:<BR>
switch (LOWORD(wParam))<BR>
{<BR>
case IDC_ALIGNMENTCOMBO:<BR>
if(HIWORD(wParam) == CBN_SELCHANGE)<BR>
this-&gt;MakeDirty();<BR>
}<BR>
break;<BR>
}<BR>
<BR>
return FALSE; <BR>
}</TT></FONT></P>
<H2><A NAME="Heading38"></A>Adding Events</H2>
<P>Properties and methods are a way for a programmer to communicate with a control
from within the container application. <I>Events</I> are a way for the control to
communicate with the container. For ActiveX controls, events are nothing more than
<TT>IDispatch</TT> interfaces that are implemented on the container side of the container/control
relationship.</P>
<P>The mechanism that events are based on is known as a connection point. A <I>connection
point </I>is simply a description of the type of interface that is required in order
to communicate with the container. Connection points are not restricted to only <TT>IDispatch</TT>
interfaces; rather, they can be of any COM interface that is understood by both components.
For that matter, connection points/events are not restricted to only controls, they
can be used in any COM implementation. Controls were simply the first to take advantage
of them. For more information regarding connection points, refer to the documentation
in the OLE online help or to Kraig Brockschmidt's <I>Inside OLE,</I> <I>Second Edition</I>,
from Microsoft Press.</P>
<P>For the BaseCtl Framework, events are fairly easy to implement.</P>
<P>You add an event for notifying the user that the data in your control has changed.
Your event will contain two parameters: a string and a long. The parameters are your
caption and alignment property values and are passed by reference so that the programmer
of the control can allow or disallow the change that may be taking place. This type
of event may not be practical but is used to demonstrate the fact that events are
nothing more than methods and have the same level of functionality and flexibility.</P>
<P>The first step is to add the dispid that you use to identify the event (see Listing
10.27).
<H3><A NAME="Heading39"></A>Listing 10.27<SPACER TYPE="HORIZONTAL" SIZE="10"> DISPIDS.H--Change
Event Dispid</H3>
<P><FONT COLOR="#0066FF"><TT>... <BR>
#define dispidCaptionProp 3 <BR>
// events<BR>
//<BR>
#define eventidChange 5 <BR>
#define _DISPIDS_H_ <BR>
#endif // _DISPIDS_H_</TT></FONT></P>
<P>As with every other aspect of your control implementation, you must add an entry
to the ODL file. Events are added in the same fashion as methods; however, they are
added to the event dispatch interface in the ODL file (see Listing 10.28).</P>
<P>Note that the event interface differs slightly from your primary dispatch interface.
The most obvious difference being that the interface is of type <TT>dispinterface</TT>
and does not support dual-interface. For these reasons, your event methods are declared
in C/C++ fashion and do not require the parameter attributes that your primary dispatch
interface did. <BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Event (or rather Source) interfaces cannot be dual-interface.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading40"></A>Listing 10.28 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROL.ODL--Event
ODL Entry</H3>
<P><FONT COLOR="#0066FF"><TT>// event interface for CBCFControl controls ...<BR>
//<BR>
[<BR>
uuid(317512F2-3E75-11d0-BEBE-00400538977D),<BR>
helpstring(&quot;Event interface for BCFControl control&quot;),<BR>
hidden<BR>
]<BR>
dispinterface DBCFControlEvents {<BR>
properties:<BR>
methods:<BR>
[id(eventidChange)] void Change(BSTR* cstrCaption, long* lAlignment); <BR>
};</TT></FONT></P>
<P>When you implemented your methods and properties, you had to copy the function
prototype from the C++ header file that was generated from the ODL file to your class
definition. For events, the implementation works a little differently. The function
for the event is actually located in the container, so instead of implementing the
function, you need to create some utility structures for calling the event (see Listing
10.29).</P>
<P>You added an enumeration to identify the event that you want to fire. You also
declared two arrays: one of <TT>VARTYPE</TT> and the other <TT>EVENTINFO</TT>.</P>
<P>The <TT>VARTYPE</TT> array is an array of variant data type constants that are
passed to the <TT>FireEvent</TT> function. The array is used to identify and give
the order of the parameters (if any) that need to be passed to the event method when
it is called.</P>
<P>The <TT>EVENTINFO</TT> array is an array of structures. The <TT>EVENTINFO</TT>
is defined by the BaseCtl framework and is used for declaring the event, the number
of parameters it has, and the <TT>VARTYPE</TT> array of parameter types that it uses.
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> When assigning the values to the enumeration, it is important that
	they correspond to the position in the <TT>EVENTINFO</TT> structure array of the
	actual event being referenced. The first event is at position 0 in the array, the
	second is at position 1 in the array, and so forth. The enumeration value is used
	in the event firing method to retrieve information about the event and how it is
	called.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading41"></A>Listing 10.29 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--Event
Handling Structures--Header File</H3>
<P><FONT COLOR="#0066FF"><TT>... <BR>
#include &quot;alignmentenums.h&quot; <BR>
typedef enum <BR>
{<BR>
BCFControlEvent_Change = 0,<BR>
} BCFCONTROLEVENTS; <BR>
VARTYPE rgPI4PBSTR [];<BR>
EVENTINFO m_rgBCFControlEvents[]; <BR>
typedef struct tagBCFCONTROLCTLSTATE <BR>
{ <BR>
...</TT></FONT></P>
<P>You've added your header declarations; now you need to add your source file implementation
(see Listing 10.30). Here you initialize the two arrays that you declare in your
header file. The <TT>VARTYPE</TT> array is initialized with two elements: a <TT>BSTR</TT>
pointer type and a <TT>long</TT> pointer type. These are the data types of the two
parameters that are passed to the event method.</P>
<P>The <TT>EVENTINFO</TT> structure is initialized to a single element identifying
the event ID, the number of parameters, and the parameter array descriptor.
<H3><A NAME="Heading43"></A>Listing 10.30 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Event
Structures Implementation--Source File</H3>
<P><FONT COLOR="#0066FF"><TT>... <BR>
//=--------------------------------------------------------------------------=<BR>
// all the events in this control<BR>
//<BR>
// TODO: add events here ...<BR>
// <BR>
VARTYPE rgPI4PBSTR [] = { VT_BSTR | VT_BYREF, VT_I4 | VT_BYREF }; <BR>
EVENTINFO m_rgBCFControlEvents [] = <BR>
{<BR>
{ eventidChange, 2, rgPI4PBSTR }<BR>
}; <BR>
...</TT></FONT></P>
<P>Your event interface is now completely implemented. The final step is only a matter
of adding the <TT>FireEvent</TT> method calls wherever appropriate in your control
implementation. Before adding the <TT>FireEvent</TT> calls to your code, though,
you add a simple helper function to aid your implementation. Since your implementation
of the <TT>FireEvent</TT> method allows the user of the control to change the data
that is passed to the event, you will find it easier to maintain the code by implementing
the simple helper function, <TT>FireChange</TT> (with no parameters), that encapsulates
the data management associated with the method and its parameters (see Listing 10.31).
<H3><A NAME="Heading44"></A>Listing 10.31<SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--FireChange
Event--Header File</H3>
<P><FONT COLOR="#0066FF"><TT>... <BR>
// private state information.<BR>
//<BR>
BCFCONTROLCTLSTATE m_state; <BR>
protected:<BR>
void FireChange(void); <BR>
LPTSTR m_lptstrCaption;<BR>
}; <BR>
...</TT></FONT></P>
<P>Now add your implementation (see Listing 10.32). The BaseCtl framework defines
the <TT>FireEvent</TT> function for calling event functions. The first parameter
of the function is the <TT>EVENTINFO</TT> structure that you defined, and the remaining
parameters are based on the parameters you declared for the event.
<H3><A NAME="Heading45"></A>Listing 10.32 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--FireChange
Event Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CBCFControlControl::FireChange(void)<BR>
{<BR>
// get a BSTR that can be passed via the event<BR>
BSTR bstrCaption = ::SysAllocString(OLESTRFROMANSI(m_lptstrCaption)); <BR>
// fire the change event<BR>
this-&gt;FireEvent(&amp;(m_rgBCFControlEvents[BCFControlEvent_Change]),<BR>
&amp;bstrCaption, &amp;m_state.lAlignment); <BR>
// create an ANSI string<BR>
MAKE_ANSIPTR_FROMWIDE(lpctstrCaption, bstrCaption); <BR>
// free the data that was passed back<BR>
::SysFreeString(bstrCaption); <BR>
// if we have a string<BR>
if(m_lptstrCaption)<BR>
{<BR>
// delete the existing string<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
m_lptstrCaption = NULL;<BR>
} <BR>
// allocate a new string<BR>
m_lptstrCaption = new TCHAR[lstrlen(lpctstrCaption) + 1]; <BR>
// assign the string to our member variable<BR>
lstrcpy(m_lptstrCaption, lpctstrCaption); <BR>
}</TT></FONT></P>
<P>Now you add the event firing to your control, which is just a matter of adding
the</P>
<P><FONT COLOR="#0066FF"><TT>this-&gt;FireChange();</TT></FONT></P>
<P>function call wherever appropriate. In your case, you added it to your <TT>put_Alignment</TT>
and <TT>CaptionMethod</TT> functions. Last you compile the control and test your
implementation. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> If any of the methods, properties, or events don't appear in your
	container after you have added them, remember to do the following:

</BLOCKQUOTE>


<UL>
	<UL>
		<LI>Delete the .tlb file for the control, and look for extra copies in other directories.
		<LI>Update the dependencies of your project.
		<LI>Rebuild your control.
		<LI>Register the control.
	</UL>
</UL>



<BLOCKQUOTE>
	<P>Occasionally, the project will point to an incorrect version of the type library
	or the registry may point to the incorrect version of the control, which can be a
	little confusing when you're testing your control and it doesn't behave the way you
	expect.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H2><A NAME="Heading46"></A>Persistence</H2>
<P><I>Persistence</I> refers to the capability of a component to retain its state
across execution lifetimes. In other words, regardless of the number of times that
the control is started and stopped, it remembers that you changed its background
color from white to mauve.</P>
<P>Persistence in a BaseCtl implementation is broken into two major parts consisting
of a total of four aspects.</P>
<P>The first part is described as <I>text persistence,</I> that is the persistence
of the properties to some form of permanent storage such as a file. The second part,
known as <I>binary persistence,</I> is when the control is being used in some form
of development environment and the state of the container is switching between a
design-time mode and a runtime mode for testing purposes. In this case, the persistence
is performed using a temporary storage device such as the computer's memory.</P>
<P>Text persistence of the control's properties are broken into two parts, also.
The first is the function <TT>LoadTextState</TT>, which is called the first time
the control is instantiated. Note that this function will not be called when switching
from a design-time mode to a runtime mode, even though the control is re-created
when switching between modes. The last function to be called is <TT>SaveTextState</TT>,
which is called when the control instance is being terminated. For an application
that is switching between design-time and runtime mode, this function will not be
called, even though the control is destroyed and re-created.</P>
<P>Binary persistence also consists of two parts: <TT>LoadBinaryState</TT> and <TT>SaveBinaryState</TT>.
<TT>SaveBinaryState</TT> is called when a control, in design-mode, is destroyed with
the intent of switching to runtime mode. <TT>LoadBinaryState</TT> is called when
the control is being loaded in design-time mode after being in runtime mode, and
vice versa. The hierarchy of events looks like this:</P>
<P>Runtime mode only:</P>
<P><FONT COLOR="#0066FF"><TT>LoadText Data<BR>
... (some action)<BR>
SaveTextState</TT></FONT></P>
<P>Design-time mode <I>and</I> runtime mode:</P>
<P><FONT COLOR="#0066FF"><TT>LoadTextState - Design Mode<BR>
...<BR>
SaveBinaryState (Container is changed to Run-Time mode)<BR>
LoadBinaryState (Container is changed to Run-Time mode)<BR>
...<BR>
LoadBinaryState (Container is changed to Design mode)<BR>
...<BR>
SaveTextState - Design Mode</TT></FONT></P>
<P>First you implement your text persistence, and then you implement your binary
persistence.
<H3><A NAME="Heading47"></A>Text Persistence</H3>
<P>Text persistence is the actual storage of your data to some form of data store,
such as a file. For your implementation, you persist the caption, alignment, text
data path, and background color. <B><I><BR>
<BR>
LoadTextState</I> </B><SPACER TYPE="HORIZONTAL" SIZE="10">Listing 10.33 shows the
implementation for your loading of the properties. The control simply reads the property
from the stream and, if successful, loads the property into the control. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Do not exit this function if the control was unable to retrieve a
	property. It may be that the property was not persisted in the first place and does
	not really represent an error.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading48"></A>Listing 10.33<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--LoadTextState
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::LoadTextState<BR>
(<BR>
IPropertyBag *pPropertyBag,<BR>
IErrorLog *pErrorLog<BR>
)<BR>
{<BR>
HRESULT hr;<BR>
VARIANT v; <BR>
::VariantInit(&amp;v);<BR>
v.vt = VT_BSTR;<BR>
hr = pPropertyBag-&gt;Read(OLESTRFROMANSI(&quot;Caption&quot;), &amp;v, pErrorLog);<BR>
if(SUCCEEDED(hr)) <BR>
{<BR>
// get a ANSI string from the BSTR<BR>
MAKE_ANSIPTR_FROMWIDE(lpctstrCaption, v.bstrVal); <BR>
// free the BSTR that was passed in<BR>
::SysFreeString(v.bstrVal); <BR>
// if we have a string<BR>
if(lpctstrCaption != NULL)<BR>
{<BR>
// if we have a string<BR>
if(m_lptstrCaption)<BR>
{<BR>
// delete the existing string<BR>
delete [] m_lptstrCaption; <BR>
// clear the reference just to be safe<BR>
m_lptstrCaption = NULL;<BR>
} <BR>
// allocate a new string<BR>
m_lptstrCaption = new TCHAR[lstrlen(lpctstrCaption) + 1]; <BR>
// assign the string to our member variable<BR>
lstrcpy(m_lptstrCaption, lpctstrCaption);<BR>
}<BR>
} <BR>
::VariantInit(&amp;v);<BR>
v.vt = VT_I4;<BR>
hr = pPropertyBag-&gt;Read(OLESTRFROMANSI(&quot;Alignment&quot;), &amp;v, pErrorLog);<BR>
if(SUCCEEDED(hr)) <BR>
m_state.lAlignment = v.lVal;<BR>
<BR>
::VariantInit(&amp;v);<BR>
v.vt = VT_I4;<BR>
hr = pPropertyBag-&gt;Read(OLESTRFROMANSI(&quot;BackColor&quot;), &amp;v, pErrorLog);<BR>
if(SUCCEEDED(hr)) <BR>
m_state.ocBackColor = v.lVal; <BR>
this-&gt;InvalidateControl(NULL);<BR>
this-&gt;m_fDirty = TRUE; <BR>
// always return S_OK<BR>
return S_OK; <BR>
}</TT></FONT></P>
<P><B><I>SaveTextState</I></B><SPACER TYPE="HORIZONTAL" SIZE="10"> Listing 10.34
shows your persistence to permanent storage implementation. Note that the values
are persisted only if they have not changed from their default value or are required
to by the container. The use of the default state structure definitely improves your
overall control load and save times, which is critical to having a control that is
useful.
<H3><A NAME="Heading49"></A>Listing 10.34 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--SaveTextState
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::SaveTextState<BR>
(<BR>
IPropertyBag *pPropertyBag,<BR>
BOOL fWriteDefaults<BR>
)<BR>
{<BR>
HRESULT hr = S_OK;<BR>
VARIANT v; <BR>
if(lstrlen(m_lptstrCaption) || fWriteDefaults)<BR>
{<BR>
::VariantInit(&amp;v);<BR>
v.vt = VT_BSTR;<BR>
v.bstrVal = ::SysAllocString(OLESTRFROMANSI(m_lptstrCaption));<BR>
if (!v.bstrVal) return E_OUTOFMEMORY;<BR>
hr = pPropertyBag-&gt;Write(OLESTRFROMANSI(&quot;Caption&quot;), &amp;v);<BR>
::SysFreeString(v.bstrVal);<BR>
RETURN_ON_FAILURE(hr); <BR>
} <BR>
if(m_DefaultState.lAlignment != m_state.lAlignment || fWriteDefaults)<BR>
{<BR>
::VariantInit(&amp;v);<BR>
v.vt = VT_I4;<BR>
v.lVal = m_state.lAlignment;<BR>
hr = pPropertyBag-&gt;Write(OLESTRFROMANSI(&quot;Alignment&quot;), &amp;v);<BR>
RETURN_ON_FAILURE(hr); <BR>
} <BR>
if(m_DefaultState.ocBackColor != m_state.ocBackColor || fWriteDefaults)<BR>
{<BR>
::VariantInit(&amp;v);<BR>
v.vt = VT_I4;<BR>
v.lVal = m_state.ocBackColor;<BR>
hr = pPropertyBag-&gt;Write(OLESTRFROMANSI(&quot;BackColor&quot;), &amp;v);<BR>
RETURN_ON_FAILURE(hr);<BR>
} <BR>
return hr; <BR>
}</TT></FONT></P>
<P>You've implemented the persistence of the control's data for the start and end
of its lifetime. Now you need to implement the persistence of the control when it
transitions from a design-time mode to a runtime mode and back again.
<H3><A NAME="Heading50"></A>Binary Persistence</H3>
<P><I>Binary persistence</I> is the streaming of the control's data to a temporary
storage device, which is done for performance and storage reasons. Loading the data
of the control in and out of the binary persistence is much faster than writing to
and from the primary storage. In addition, until the container of the control is
completely closed, the persistent data of the control should be considered transitive
and volatile and should not be persisted to permanent storage. You probably don't
want to save the properties of the control to a file every time you start or stop
your application while in design mode.</P>
<P>Throughout the implementation of various other aspects of your control, you have
been adding your data members to a structure called <TT>m_state</TT>. Now that structure
becomes of real use. <B><I><BR>
<BR>
SaveBinaryState</I></B><SPACER TYPE="HORIZONTAL" SIZE="10">Listing 10.35, shows your
implementation of the <TT>SaveBinaryState</TT> method. First you determine the length
of the string <TT>m_lptstrCaption</TT> and store it in your state structure <TT>m_state</TT>.
Next you persist the state structure in its entirety. Finally you persist the two
strings. You do this in separate operations because the strings can be of variable
length, and you do not want to restrict the user in any way by truncating the strings
or enforcing a size limit.
<H3><A NAME="Heading51"></A>Listing 10.35<SPACER TYPE="HORIZONTAL" SIZE="10"> BCFCONTROLCTL.CPP--SaveBinaryState
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::SaveBinaryState<BR>
<BR>
(<BR>
IStream *pStream<BR>
)<BR>
{<BR>
HRESULT hr = S_OK; <BR>
// store the length of the string and the NULL<BR>
m_state.lCaptionLength = lstrlen(m_lptstrCaption) + 1; <BR>
// write the state of the data to the stream<BR>
hr = pStream-&gt;Write(&amp;m_state, sizeof(m_state), NULL);<BR>
RETURN_ON_FAILURE(hr); <BR>
// write the string and the NULL<BR>
hr = pStream-&gt;Write(m_lptstrCaption, m_state. lCaptionLength, NULL);<BR>
RETURN_ON_FAILURE(hr); <BR>
return S_OK; <BR>
}</TT></FONT></P>
<P>After you persist the data, all that remains is to read the data back in when
the time is right. <B><I><BR>
LoadBinaryState</I></B> <SPACER TYPE="HORIZONTAL" SIZE="10">When the container changes
its state from runtime mode to design-time mode (and vice versa), the control is
destroyed and re-created. However, in the interests of performance, the control will
read its persistence from a local stream set up by the container, rather than from
the normal storage used by the container when persisting the properties across execution
boundaries. <TT>LoadBinaryState</TT> receives an <TT>IStream</TT> pointer as its
only parameter, from which you can read your persisted data. Listing 10.36 shows
your implementation of the <TT>LoadBinaryState</TT> function.</P>
<P>First you read in your <TT>m_state</TT> structure, which allows you to determine
the length of the two strings that were persisted with the <TT>SaveBinaryState</TT>
function. After you read in your strings, you force the control to redraw itself
to reflect the new information.
<H3><A NAME="Heading52"></A>Listing 10.36 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--LoadBinaryState
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>STDMETHODIMP CBCFControlControl::LoadBinaryState<BR>
(<BR>
IStream *pStream<BR>
)<BR>
{<BR>
HRESULT hr = S_OK; <BR>
// read the state of the control<BR>
hr = pStream-&gt;Read(&amp;m_state, sizeof(m_state), NULL); <BR>
// create a string of the appropriate size this includes the NULL<BR>
m_lptstrCaption = new TCHAR[m_state.lCaptionLength]; <BR>
// read the string and NULL<BR>
hr = pStream-&gt;Read(m_lptstrCaption, m_state.lCaptionLength, NULL); <BR>
// redraw the control<BR>
this-&gt;InvalidateControl(NULL);<BR>
this-&gt;m_fDirty = TRUE; <BR>
return S_OK; <BR>
}</TT></FONT></P>
<P>Although persistence support requires a little more work when using the BaseCtl
framework, it is not too difficult. It is more tedious and time consuming than anything.
The BaseCtl sample code contains examples of persisting other type of properties,
including fonts, which differ slightly from other built-in data types, such as <TT>long</TT>
or <TT>BSTR</TT>.
<H2><A NAME="Heading53"></A>Drawing the Control</H2>
<P>You draw the control's UI similarly to the way you draw it in your MFC and ATL
implementations. For developers accustomed to MFC, the most difficult aspect of drawing
the UI is the lack of utility class support. All those nice classes and functions
that create brushes and convert colors, for example, are not available with the BaseCtl
framework. Most MFC classes and functions have Win32 equivalents, so you shouldn't
find it too difficult to convert between the two.</P>
<P>As we point out in <A HREF="ch06.htm">Chapters 6</A> and <A HREF="ch08.htm">8</A>,
there are two types of drawing: standard and optimized. Your drawing implementation
will support both methods. This chapter will describe standard drawing, and <A HREF="ch11.htm">Chapter
11</A> will focus on optimized drawing.
<H3><A NAME="Heading54"></A>Standard Drawing</H3>
<P><I>Standard drawing </I>is just that: standard. You have complete freedom to draw
the control any way you see fit, using any method that is appropriate. You can use
pens and brushes, rectangles and circles. Remember that drawing <I>smart</I> is the
goal of any application with UI.</P>
<P>First you need to add a number of member variables and functions to aid in your
drawing implementation (see Listing 10.37).
<H3><A NAME="Heading55"></A>Listing 10.37 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.H--Drawing
Implementation Member Variables and Functions</H3>
<P><FONT COLOR="#0066FF"><TT>...<BR>
virtual HRESULT InternalQueryInterface(REFIID, void **);<BR>
virtual BOOL BeforeCreateWindow(DWORD *pdwWindowStyle,<BR>
DWORD *pdwExWindowStyle, LPSTR pszWindowTitle); <BR>
// OnData is called asynchronously as data for an object<BR>
// or property arrives...<BR>
virtual HRESULT OnData(DISPID propId, DWORD bscfFlag, IStream * strm, <BR>
DWORD dwSize); <BR>
// private state information.<BR>
//<BR>
BCFCONTROLCTLSTATE m_state;<BR>
BCFCONTROLCTLSTATE m_DefaultState; <BR>
protected:<BR>
void FireChange(void); <BR>
LPTSTR m_lptstrCaption; <BR>
IFont * m_pFont;<BR>
void LoadFont(void);<BR>
HBRUSH hBrush, hOldBrush;<BR>
COLORREF TranslateColor(OLE_COLOR clrColor, HPALETTE hpal = NULL){<BR>
COLORREF cr = RGB(0x00,0x00,0x00);OleTranslateColor(clrColor, hpal, &amp;cr);return
cr;}<BR>
void FillSolidRect(HDC hDC, LPCRECT lpRect, COLORREF clr){<BR>
::SetBkColor(hDC, clr);::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, lpRect, <BR>
NULL, 0, NULL);}<BR>
void GetTextExtent(HDC hDC, LPCTSTR lpctstrString, int &amp; cx, int &amp; cy);<BR>
BOOL bRetrievedDimensions;<BR>
int iCharWidthArray[256];<BR>
int iCharacterSpacing, iCharacterHeight;<BR>
}; <BR>
...</TT></FONT></P>
<P>You need to initialize the member variables to a valid state, which you do in
your constructor (see Listing 10.38).
<H3><A NAME="Heading56"></A>Listing 10.38 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Member
Initialization</H3>
<P><FONT COLOR="#0066FF"><TT>#pragma warning(disable:4355) // using `this' in constructor<BR>
CBCFControlControl::CBCFControlControl<BR>
(<BR>
IUnknown *pUnkOuter<BR>
)<BR>
: CInternetControl(pUnkOuter, OBJECT_TYPE_CTLBCFCONTROL, (IDispatch *)this)<BR>
{<BR>
// initialize anything here ...<BR>
// <BR>
. . . <BR>
// clear the font<BR>
m_pFont = NULL; <BR>
// clear the brush<BR>
hOldBrush = hBrush = NULL; <BR>
// clear the flag<BR>
bRetrievedDimensions = FALSE;<BR>
} <BR>
#pragma warning(default:4355) // using `this' in constructor</TT></FONT></P>
<P>Next you add the helper functions, <TT>GetTextExtent</TT> and <TT>LoadFont</TT>,
to your implementation (see Listing 10.39). You also add a default <TT>FONTDESC</TT>
structure in the event that you can't retrieve the ambient font from the container.</P>
<P><TT>GetTextExtent</TT> is a function that is supported in MFC but not in Win32,
so we've created our own implementation. The function determines the width and height
of the font of the current Device Context (DC) and then calculates the size in points
of the string that was supplied to the function. This function is used for displaying
the text with the correct alignment: left, right, or center. We've optimized the
method so as to retrieve the information only once. If your control supports fonts
for properties, it is a simple matter to clear the flag <TT>bRetrievedDimensions</TT>
to refresh the width and height of the new font when the control redraws itself.</P>
<P>The function <TT>LoadFont</TT> tries to load the ambient font from the container
and, if unable, creates a new font from your default settings.
<H3><A NAME="Heading57"></A>Listing 10.39 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--Drawing
Helper Functions</H3>
<P><FONT COLOR="#0066FF"><TT>static FONTDESC _fdDefault = <BR>
{<BR>
sizeof(FONTDESC),<BR>
L&quot;MS Sans Serif&quot;,<BR>
FONTSIZE(8),<BR>
FW_NORMAL,<BR>
DEFAULT_CHARSET,<BR>
FALSE,<BR>
FALSE,<BR>
FALSE<BR>
}; <BR>
void CBCFControlControl::LoadFont(void)<BR>
{<BR>
// if there isn't a font object<BR>
if(!m_pFont)<BR>
// get the font from the container<BR>
this-&gt;GetAmbientFont(&amp;m_pFont); <BR>
// if there still isn't a font object<BR>
if(!m_pFont)<BR>
// create a default font object<BR>
::OleCreateFontIndirect(&amp;_fdDefault, IID_IFont, (void **) &amp;m_pFont);<BR>
} <BR>
void CBCFControlControl::GetTextExtent(HDC hDC, LPCTSTR lpctstrString,<BR>
int &amp; cx, int &amp; cy)<BR>
{<BR>
// if we haven't gotten the dimensions yet<BR>
if(!bRetrievedDimensions)<BR>
{<BR>
// get all of the widths for all of the chars<BR>
::GetCharWidth(hDC, 0, 255, &amp;iCharWidthArray[0]); <BR>
// get the spacing between the chars<BR>
iCharacterSpacing = ::GetTextCharacterExtra(hDC); <BR>
// make sure that this only executes once<BR>
bRetrievedDimensions = TRUE; <BR>
// get the metrics of this DC<BR>
TEXTMETRIC tmMetrics;<BR>
::GetTextMetrics(hDC, &amp;tmMetrics); <BR>
// get the height<BR>
iCharacterHeight = tmMetrics.tmHeight;<BR>
} <BR>
// return the height<BR>
cy = iCharacterHeight; <BR>
// set the initial value to 0<BR>
int iTextWidth = 0; <BR>
// get the number of characters in our string<BR>
long lTextLength = lstrlen(lpctstrString); <BR>
// if we have a character<BR>
if(lTextLength)<BR>
{<BR>
long lEndCharPos = lTextLength - 1; <BR>
// add up the widths of the characters and the spacing<BR>
for(long lCount = 0; lCount &lt;= lEndCharPos; lCount++)<BR>
iTextWidth += (iCharWidthArray[(BYTE)<BR>
(lpctstrString[lCount])] + iCharacterSpacing);<BR>
} <BR>
// return the width<BR>
cx = iTextWidth; <BR>
}</TT></FONT></P>
<P>Next you add your <TT>OnDraw</TT> implementation (see Listing 10.40). First you
try to load and select the font into the DC. Then you get the colors you draw with.
For the background color, you rely on the stock property that you implemented in
the section entitled &quot;Creating Stock Properties.&quot; For the rest of the colors,
you rely on the system definitions.</P>
<P>Next you draw the background of the control. The sample takes the brute force
method here by drawing the entire background every time. A better implementation
would be to draw in only the area between the border and the text to prevent unnecessary
flicker when the control repaints itself.</P>
<P>After the background is drawn, you draw the text and place it within the control's
UI, relative to the alignment property setting. And, finally, you draw a nice 3-D
sunken border around the text.</P>
<P>Now comes the cleanup. You reset the colors and the font, and you select the original
brush back into the DC and destroy the brush that you created.
<H3><A NAME="Heading58"></A>Listing 10.40 <SPACER TYPE="HORIZONTAL" SIZE="10">BCFCONTROLCTL.CPP--OnDraw
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>HRESULT CBCFControlControl::OnDraw<BR>
(<BR>
DWORD dvAspect,<BR>
HDC hdcDraw,<BR>
LPCRECTL prcBounds,<BR>
LPCRECTL prcWBounds,<BR>
HDC hicTargetDevice,<BR>
BOOL fOptimize<BR>
)<BR>
{<BR>
// ****** Get the text font ******<BR>
// **<BR>
HFONT hFont = NULL, hOldFont = NULL; <BR>
// if there isn't a font object<BR>
if(!m_pFont)<BR>
// try to load one<BR>
this-&gt;LoadFont(); <BR>
if(m_pFont)<BR>
{<BR>
// get a font handle<BR>
m_pFont-&gt;get_hFont(&amp;hFont); <BR>
// increment the ref count so the font doesn't drop<BR>
// out from under us<BR>
m_pFont-&gt;AddRefHfont(hFont); <BR>
::SelectObject(hdcDraw, hFont);<BR>
}<BR>
// **<BR>
// ****** Get the text font ****** <BR>
// ****** Get the colors ******<BR>
// **<BR>
// use the window color as the background color<BR>
OLE_COLOR tColor;<BR>
this-&gt;get_BackColor(&amp;tColor);<BR>
COLORREF clrTextBackgroundColor = this-&gt;TranslateColor(tColor); <BR>
// then use the normal windows color for the text<BR>
COLORREF clrTextForegroundColor = <BR>
this-&gt;TranslateColor(::GetSysColor(COLOR_WINDOWTEXT)); <BR>
// set to the system color<BR>
COLORREF clrEdgeBackgroundColor = ::GetSysColor(COLOR_3DFACE);<BR>
COLORREF clrEdgeForegroundColor = ::GetSysColor(COLOR_3DFACE);<BR>
// **<BR>
// ****** Get the colors ****** <BR>
// ****** Draw the background ******<BR>
// **<BR>
// set the text color<BR>
COLORREF clrOldBackgroundColor = ::SetBkColor(hdcDraw,clrTextBackgroundColor); <BR>
COLORREF clrOldForegroundColor = ::SetTextColor(hdcDraw, clrTextForegroundColor);
<BR>
// if we don't have a brush<BR>
if(hBrush == NULL)<BR>
// create a solid brush<BR>
hBrush = ::CreateSolidBrush(clrTextBackgroundColor); <BR>
// select the brush and save the old one<BR>
hOldBrush = ::SelectObject(hdcDraw, hBrush); <BR>
// draw the background<BR>
::Rectangle(hdcDraw, prcBounds-&gt;left, prcBounds-&gt;top, <BR>
prcBounds-&gt;right, prcBounds-&gt;bottom);<BR>
// **<BR>
// ****** Draw the background ****** <BR>
// ****** Draw the text ******<BR>
// **<BR>
int iHor, iVer; <BR>
// get the size of the text for this DC<BR>
int cx = 0, cy = 0;<BR>
this-&gt;GetTextExtent(hdcDraw, m_lptstrCaption, cx, cy); <BR>
switch(m_state.lAlignment)<BR>
{<BR>
case EALIGN_CENTER:<BR>
iHor = (prcBounds-&gt;right - cx) / 2;<BR>
iVer = prcBounds-&gt;top + 3;<BR>
break;<BR>
case EALIGN_RIGHT:<BR>
iHor = prcBounds-&gt;right - cx - 3;<BR>
iVer = prcBounds-&gt;top + 3;<BR>
break;<BR>
// case EALIGN_LEFT:<BR>
default:<BR>
iHor = prcBounds-&gt;left + 3;<BR>
iVer = prcBounds-&gt;top + 3;<BR>
break;<BR>
} <BR>
// output our text<BR>
::ExtTextOut(hdcDraw, iHor, iVer, ETO_CLIPPED | ETO_OPAQUE, <BR>
(LPCRECT) prcBounds, m_lptstrCaption, lstrlen(m_lptstrCaption), NULL);<BR>
// **<BR>
// ****** Draw the text ****** <BR>
// ****** Draw the border ******<BR>
// **<BR>
// set the edge style and flags<BR>
UINT uiBorderStyle = EDGE_SUNKEN;<BR>
UINT uiBorderFlags = BF_RECT; <BR>
// set the edge color<BR>
::SetBkColor(hdcDraw, clrEdgeBackgroundColor);<BR>
::SetTextColor(hdcDraw, clrEdgeForegroundColor); <BR>
// draw the 3D edge<BR>
::DrawEdge(hdcDraw, (LPRECT)(LPCRECT) prcBounds, uiBorderStyle, uiBorderFlags);<BR>
// **<BR>
// ****** Draw the border ****** <BR>
// ****** Reset the colors ******<BR>
// **<BR>
// restore the original colors<BR>
::SetBkColor(hdcDraw, clrOldBackgroundColor);<BR>
::SetTextColor(hdcDraw, clrOldForegroundColor);<BR>
// **<BR>
// ****** Reset the colors ****** <BR>
// ****** release the text font ******<BR>
// **<BR>
if(hOldFont)<BR>
// select the old object<BR>
::SelectObject(hdcDraw, hOldFont); <BR>
// increment the ref count so the font doesn't drop<BR>
// out from under us<BR>
if(m_pFont &amp;&amp; hFont)<BR>
m_pFont-&gt;ReleaseHfont(hFont);<BR>
// **<BR>
// ****** Get the text font ****** <BR>
// select the old brush back<BR>
::SelectObject(hdcDraw, hOldBrush); <BR>
// destroy the brush we created<BR>
::DeleteObject(hBrush); <BR>
// clear the brush handles<BR>
hBrush = hOldBrush = NULL; <BR>
return S_OK; <BR>
}</TT></FONT></P>
<H2><A NAME="Heading59"></A>From Here...</H2>
<P>This chapter focused on creating a basic control implementation. You added methods,
properties, and events, which are the backbone of every control implementation. Adding
these basic features to a BaseCtl ActiveX control implementation is fairly straightforward.
The one major drawback, though, is the lack of IDE support such as you have with
MFC and ATL.</P>
<P>This chapter also addressed the issues of persistence and drawing without which
a control implementation is definitely incomplete. <A HREF="ch11.htm">Chapter 11</A>
expands upon what you have learned and adds new features and functions to your control
implementation to make your control truly unique and interesting.</P>

<P>The BaseCtl framework is fairly complete and robust, and as you progress through
<A HREF="ch11.htm">Chapter 11</A>, you will find that a lot of the new features you
add will be implemented in a fashion similar to the features you implemented in this
chapter. The one thing that BaseCtl has going for it is that it is all based on COM,
which is the foundation of any ActiveX component.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
