<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 9:17 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 3</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 3</H1>

<UL>
	<LI><A HREF="#Heading1">Creating ActiveX Automation Servers Using MFC</A>
	<UL>
		<LI><A HREF="#Heading2">Creating the Basic Project</A>
		<LI><A HREF="#Heading3">Adding an Automation Interface to the Application</A>
		<UL>
			<LI><A HREF="#Heading4">Listing 3.1 MFCSERVER.ODL--Dispinterface and CoClass ODL
			Entries</A>
			<LI><A HREF="#Heading5">Listing 3.2 TRACKER.H--Add the Class Factory Support with
			the Macro DECLARE_OLECREATE</A>
			<LI><A HREF="#Heading6">Listing 3.3 TRACKER.CPP--Add the Class Factory Implementationwith
			the IMPLEMENT_OLECREATE Macro</A>
		</UL>
		<LI><A HREF="#Heading7">Registry</A>
		<UL>
			<LI><A HREF="#Heading8">Server Registration</A>
			<LI><A HREF="#Heading9">Server Unregistration</A>
		</UL>
		<LI><A HREF="#Heading10">Sample Server Support Code</A>
		<UL>
			<LI><A HREF="#Heading11">Listing 3.4 TRACKER.H-- Sample Server Support Code Added
			to the Header File</A>
			<LI><A HREF="#Heading12">Listing 3.5 TRACKER.CPP--Updated Source File</A>
		</UL>
		<LI><A HREF="#Heading13">Adding Methods</A>
		<UL>
			<LI><A HREF="#Heading14">Listing 3.6 MFCSERVER.ODL--Updated ODL Entry for OutputLines
			Method</A>
			<LI><A HREF="#Heading15">Listing 3.7 TRACKER.H--New Member Variable Added to the
			Tracker Class</A>
			<LI><A HREF="#Heading16">Listing 3.8 TRACKER.CPP--Member Initialization in the Constructor</A>
			<LI><A HREF="#Heading17">Listing 3.9 TRACKER.CPP--OutputLines Method Implementation</A>
		</UL>
		<LI><A HREF="#Heading18">Adding Properties</A>
		<UL>
			<LI><A HREF="#Heading19">Listing 3.10 TRACKER.CPP--Indent Property Implementation</A>
		</UL>
		<LI><A HREF="#Heading20">Generating OLE Exceptions</A>
		<UL>
			<LI><A HREF="#Heading21">Listing 3.11 MFCSERVER.ODL--Error Enumeration</A>
			<LI><A HREF="#Heading22">Listing 3.12 TRACKERERROR.H--Tracker Error Constants</A>
			<LI><A HREF="#Heading23">Listing 3.13 TRACKER.CPP--Exception Handling Code Added
			to the Source Files</A>
		</UL>
		<LI><A HREF="#Heading24">Dual-Interface</A>
		<UL>
			<LI><A HREF="#Heading25">Listing 3.14 MFCSERVER.ODL--ODL Changes to Support Dual-Interface</A>
			<LI><A HREF="#Heading26">Listing 3.15 TRACKER.CPP--ODL-Generated Header File Is Added
			to the Tracker Source File</A>
			<LI><A HREF="#Heading27">Listing 3.16 TRACKER.H--Interface Macro Update of the Tracker
			Class Definition</A>
			<LI><A HREF="#Heading28">Listing 3.17 TRACKER.CPP--Interface Implementation of the
			ITracker Interface</A>
			<LI><A HREF="#Heading29">Listing 3.18 TRACKER.CPP--IDispatch Function Implementation
			for a Dual-Interface Server</A>
			<LI><A HREF="#Heading30">Listing 3.19 TRACKER.CPP--ITracker Function Implementation</A>
		</UL>
		<LI><A HREF="#Heading31">Generating Dual-Interface OLE Exceptions</A>
		<UL>
			<LI><A HREF="#Heading32">Listing 3.20 ERRORINFOMACROS.H--ISupportErrorInfo Helper
			Macros</A>
			<LI><A HREF="#Heading33">Listing 3.21 TRACKER.CPP--ISupportErrorInfo Include File</A>
			<LI><A HREF="#Heading34">Listing 3.22 TRACKER.H--ISupportErrorInfo Class Declaration</A>
			<LI><A HREF="#Heading35">Listing 3.23 TRACKER.CPP--ISupportErrorInfo Interface Implementation</A>
			<LI><A HREF="#Heading36">Listing 3.24 TRACKER.CPP--Custom Interface Exception Handling
			Code</A>
		</UL>
		<LI><A HREF="#Heading37">Server Instantiation Using C++</A>
		<LI><A HREF="#Heading38">Shared Servers</A>
		<UL>
			<LI><A HREF="#Heading39">Listing 3.25 TRACKER.H--Shared Object Member Variable Added
			to the CTracker Class</A>
			<LI><A HREF="#Heading40">Listing 3.26 TRACKER.CPP--CLSID Declaration</A>
			<LI><A HREF="#Heading41">Listing 3.27 TRACKER.CPP--RegisterActiveObject Added to
			the CTracker Constructor</A>
			<LI><A HREF="#Heading42">Listing 3.28 TRACKER.CPP--RevokeActiveObject Added to the
			Server</A>
		</UL>
		<LI><A HREF="#Heading43">Single Instance Servers</A>
		<UL>
			<LI><A HREF="#Heading44">Listing 3.29 SHAREDOBJECT.H--Shared Server Class Factory
			Header File</A>
			<LI><A HREF="#Heading45">Listing 3.30 SHAREDOBJECT.CPP--Shared Server Implementation
			File</A>
			<LI><A HREF="#Heading46">Listing 3.31 TRACKER.H--Shared Server Class Factory Support
			Added to the Class Definition</A>
			<LI><A HREF="#Heading47">Listing 3.32 TRACKER.CPP--Shared Server Update to Class
			Implementation</A>
			<LI><A HREF="#Heading48">Listing 3.33 TRACKER.CPP--Shared Server Release Implementation</A>
		</UL>
		<LI><A HREF="#Heading49">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Creating ActiveX Automation Servers Using MFC</H1>

<UL>
	<LI><B>Methods and properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 MFC Class Wizard will greatly reduce the time required to implement your server.
	<P>
	<LI><B>OLE exceptions</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 MFC uses the class COleDispatchException for generating errors.
	<P>
	<LI><B>Dual-interface</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The user of the Automatic Server users can choose between an IDispatch or COM interface
	when accessing the server. Dual-interface is not supported directly by MFC.
	<P>
	<LI><B>Dual-interface OLE exceptions</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 In dual-interface support, OLE exceptions are generated differently from standard
	MFC COleDispatchExceptions.
	<P>
	<LI><B>Creating servers using C++</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 C++ can be used to launch servers from the application they are defined in.
	<P>
	<LI><B>Shared and single instance servers</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Accessing an already running server may be required. With a single instance server,
	the server implement is responsible for the reuse of an already running server.
</UL>

<P>MFC and Visual C++ (VC++) provide a very simple and easy to use framework for
creating ActiveX Automation Servers. In fact, the VC++ development environment's
AppWizard and ClassWizard are implemented with this in mind. Creating and manipulating
automation interfaces is one of VC++'s primary functions.</P>
<P>In this chapter, you will create a simple in-process Automation Server using MFC
for logging string data to a file. Throughout this chapter, you can use an application
such as Visual Basic (VB) to test your implementation. VB is perfect for accessing
Automation Servers since it takes so little time and code to do so.</P>
<P>As you proceed through the chapter, you will expand on your implementation, highlighting
some of the more advanced concepts of Automation Server creation.
<H2><A NAME="Heading2"></A>Creating the Basic Project</H2>
<P>When creating an Automation Server, the first step is to create a <I>basic project
</I>upon which you will build your application's features and functionality. MFC
provides an AppWizard that greatly simplifies this process. The AppWizard consists
of a set of structured dialogs and choices that, in the end, will result in a set
of files representing the basic application's project.</P>
<P>To create the basic project, you need to open the VC++ Integrated Development
Environment (IDE) and from the <U>F</U>ile menu, select the <U>N</U>ew menu item.
Select the Projects tab in the New dialog, and select MFC AppWizard (dll) as the
type. Enter the Project <U>n</U>ame MFCServer, and set the Lo<U>c</U>ation to the
\Que\ActiveX\MFCServer directory (see fig. 3.1). Click OK to continue. <B><BR>
<BR>
</B><A HREF="art/03/cfig1r.jpg"><B>FIG. 3.1</B></A> <BR>
<I>Select the application type, name, and location of your new project.</I></P>
<P>In the MFC AppWizard -- Step 1 of 1 dialog, you define the specifics about how
your application is going to be created (see fig. 3.2). For the type of DLL to create,
select <U>R</U>egular DLL with MFC statically linked, which results in a slightly
larger application but one that should load faster because you won't have to load
the MFC DLLs whenever the server is launched. Also, check the A<U>u</U>tomation check
box--since that is the reason you are creating the application in the first place.
Click the <U>F</U>inish button to continue. <B><BR>
<BR>
</B><A HREF="art/03/cfig2r.jpg"><B>FIG. 3.2</B></A> <BR>
<I>Define the specific application features in the MFC AppWizard -- Step 1 of 1 dialog.</I></P>
<P>The New Project Information dialog allows you to review your choices before creating
the actual project (see fig. 3.3). Click OK to complete the creation of your project.
<B><BR>
<BR>
</B><A HREF="art/03/cfig3r.jpg"><B>FIG. 3.3</B></A> <I><BR>
Confirm the project settings in the New Project Information dialog.</I></P>
<P>The MFC AppWizard will create all the basic files that are needed to create a
DLL-based Automation Server. Table 3.1 lists all of the files that are created for
you and a brief explanation of what they are used for. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 3.1 </B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>Basic Source Files Created
		by the MFC AppWizard</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Filename</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.clw</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Main application source file and entry point for the DLL.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard application DEF file. This file contains the function export declarations
			needed for all in-process servers.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.dsp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.dsw</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Main application header file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.ncb</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.odl</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard Object Definition Language (ODL) file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">MFCServer.rc</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard resource file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ReadMe.txt</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Text file that describes the project.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Resource.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Resource header file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">StdAfx.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard precompiled header source file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">StdAfx.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard precompiled header file. All the MFC-specific include files are added here.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">Res\MFCServer.rc2</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard resource 2 file. This file contains all of the resource information that
			cannot be edited directly by VC++.</TD>
	</TR>
</TABLE>
At this point, you can compile your project, but you can do very little with it since
it does not contain interfaces, methods, or properties.
<H2><A NAME="Heading3"></A>Adding an Automation Interface to the Application</H2>
<P>To be an <I>Automation Server, </I>an application must contain at least one or
more <TT>IDispatch</TT>-based interfaces. In MFC, the <TT>CCmdTarget</TT> class is
used to implement this interface. You will use the <TT>MFCClassWizard</TT> to add
your automation interfaces to your application. From the <U>V</U>iew menu, select
the Class<U>W</U>izard menu item. Click the Add C<U>l</U>ass button, and select the
New menu item to open the New Class dialog (see fig. 3.4). <B><BR>
<BR>
</B><A HREF="art/03/cfig4r.jpg"><B>FIG. 3.4</B></A> <I><BR>
Add a new Automation Server class using the Add C</I><CITE>l</CITE><I>ass feature
of the MFC ClassWizard.</I></P>
<P>Enter the <U>N</U>ame CTracker, and select <TT>CCmdTarget</TT> as its base class
in the <U>B</U>ase class combo box. Select the <U>A</U>utomation radio button in
the Automation radio button group. The C<U>r</U>eateable by type ID radio button
and edit field are used to define the <TT>ProgID</TT> that will be used to create
and launch the Automation Server. The human readable <TT>ProgID</TT> is used in place
of the <TT>CLSID</TT> since it is much easier to write and remember. Be careful when
defining a <TT>ProgID</TT> not to create duplicates. For your application, leave
the <TT>ProgID</TT> set to its default value. Click OK to create your new class and
add it to your application. Click OK in the MFC ClassWizard dialog to close the ClassWizard.</P>
<P>When creating a new <TT>CCmdTarget</TT> class, MFC not only creates a header and
source file with all of the appropriate information, Tracker.h and Tracker.cpp in
your case, but since you selected automation support, it also updates the ODL file
with the new <TT>Dispinterface</TT> and <TT>CoClass</TT> entries (see Listing 3.1)
of your Automation Server.</P>
<P>The <TT>Dispinterface</TT> is your primary <TT>IDispatch</TT>-based interface
and is where the ClassWizard will add your new methods and properties. The <TT>CoClass</TT>
interface identifies your class factory interface. The class factory is the part
of the application that performs the actual creation of your Automation Server when
it is necessary to do so. See the OLE and MFC documentation for more information
on class factories and their role in OLE.
<H3><A NAME="Heading4"></A>Listing 3.1 MFCSERVER.ODL--Dispinterface and CoClass ODL
Entries</H3>
<P><FONT COLOR="#0066FF"><TT>// MFCServer.odl : type library source for MFCServer.dll<BR>
// This file will be processed by the Make Type Library (mktyplib) tool to<BR>
// produce the type library (MFCServer.tlb).<BR>
[ uuid(11C82943-4EDD-11D0-BED8-00400538977D), version(1.0) ]<BR>
library MFCServer<BR>
{<BR>
importlib(&quot;stdole32.tlb&quot;);<BR>
// Primary dispatch interface for CTracker<BR>
[ uuid(11C82946-4EDD-11D0-BED8-00400538977D) ]<BR>
dispinterface ITracker<BR>
{<BR>
properties:<BR>
// NOTE - ClassWizard will maintain property information here.<BR>
// Use extreme caution when editing this section.<BR>
//{{AFX_ODL_PROP(CTracker)<BR>
//}}AFX_ODL_PROP<BR>
methods:<BR>
// NOTE - ClassWizard will maintain method information here.<BR>
// Use extreme caution when editing this section.<BR>
//{{AFX_ODL_METHOD(CTracker)<BR>
//}}AFX_ODL_METHOD<BR>
};<BR>
// Class information for CTracker<BR>
[ uuid(11C82947-4EDD-11D0-BED8-00400538977D) ]<BR>
coclass TRACKER<BR>
{<BR>
[default] dispinterface ITracker;<BR>
};<BR>
//{{AFX_APPEND_ODL}}<BR>
};</TT></FONT></P>
<P>Even though the MFC ClassWizard added the new interface to the server, it did
not expose the interface to the outside world. Basically, what you have right now
is an Automation Server that cannot be created by any application. Not very useful.</P>
<P>All ActiveX components are created through an object known as a class factory.
MFC defines the class <TT>COleObjectFactory</TT> for its class factory support. You
do not add the <TT>COleObjectFactory</TT> class directly to your server implementation;
instead, you need to use two macros defined by MFC: <TT>DECLARE_OLECREATE</TT> and
<TT>IMPLEMENT_OLECREATE</TT>.</P>
<P>In the Project Workspace, select the ClassView tab. Expand the class list, and
double-click the <TT>CTracker</TT> class to open the Tracker.h file. Add the macro
<TT>DECLARE_OLECREATE</TT> to your class definition as in Listing 3.2. The macro
takes a single parameter, <TT>CTracker</TT>, which is your class name.
<H3><A NAME="Heading5"></A>Listing 3.2 TRACKER.H--Add the Class Factory Support with
the Macro DECLARE_OLECREATE</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
// NOTE - the ClassWizard will add and remove member functions here.<BR>
//}}AFX_DISPATCH<BR>
DECLARE_DISPATCH_MAP()<BR>
DECLARE_INTERFACE_MAP()<BR>
DECLARE_OLECREATE(CTracker)<BR>
};</TT></FONT></P>
<P>Next in the Project Workspace window, select the FileView tab, expand the Source
Files list, and double-click the Tracker.cpp entry to open the file. Add the macro
<TT>IMPLEMENT_OLECREATE</TT> to your source file (see Listing 3.3). The <TT>IMPLEMENT_OLECREATE</TT>
macro takes three parameters: the class name, the <TT>ProgID</TT> that is used to
create the server, and the <TT>CLSID</TT> of the <TT>CoClass</TT> interface, as defined
in your ODL file. When the ODL file was created by the AppWizard, a <TT>CLSID</TT>
was generated for the type library. When the ClassWizard added the <TT>CTracker</TT>
class, it too created new <TT>CLSID</TT>s; one for the <TT>Dispinterface</TT> and
the other for the <TT>CoClass</TT>.
<H3><A NAME="Heading6"></A>Listing 3.3 TRACKER.CPP--Add the Class Factory Implementationwith
the IMPLEMENT_OLECREATE Macro</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
// {11C82946-4EDD-11D0-BED8-00400538977D}<BR>
static const IID IID_ITracker =<BR>
{ 0x11c82946, 0x4edd, 0x11d0, { 0xbe, 0xd8, 0x0, 0x40, 0x5, 0x38, 0x97, 0x7d } };
<BR>
BEGIN_INTERFACE_MAP(CTracker, CCmdTarget)<BR>
INTERFACE_PART(CTracker, IID_ITracker, Dispatch)<BR>
END_INTERFACE_MAP()<BR>
IMPLEMENT_OLECREATE(CTracker, _T(&quot;MFCServer.Tracker&quot;), 0x11C82947, 0x4edd,
0x11d0, 0xbe, 0xd8, 0x0, 0x40, 0x5, 0x38, 0x97, 0x7d)<BR>
. . .</TT></FONT></P>
<P>Your server implementation is now class factory enabled, which allows it to be
created by other applications. Before another application can create the server,
however, OLE has to know where to find the server, which is done through the system
registry. All ActiveX components that are publicly available to other applications
must support registration and must create valid registry entries.
<H2><A NAME="Heading7"></A>Registry</H2>
<P>ActiveX components have one or more registry entries that are used to describe
various aspects of the application and how it can be used. The registry is critical
to the successful launching and using of ActiveX components.
<H3><A NAME="Heading8"></A>Server Registration</H3>
<P>Local servers rely on command-line options for registration support. It is the
responsibility of the local server developer to check for the correct command-line
option and take the appropriate action. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 3.2 </B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>Local Server Command-Line
		Options for Registration Support</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Command-Line Option</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>R</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Register all components.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>U</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Unregister all components.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>S</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Perform registration in silent mode and do not display confirmation dialogs, indicating
			success. Error messages should still be displayed. This option can be combined with
			<TT>R</TT> or <TT>U</TT>.</TD>
	</TR>
</TABLE>
<BR>
<BR>
All inproc ActiveX components expose registration support via two exported functions:
<TT>DllRegisterServer</TT> and <TT>DllUnregisterServer</TT>.</P>
<P>The MFC AppWizard will automatically add the <TT>DllRegisterServer</TT> function
to the main application file of a project when it is created. The registration of
all of the components contained in the application should be performed in this function,
with each ActiveX component being responsible for its own registration support.</P>
<P>Registration support is handled automatically by the <TT>COleObjectFactory</TT>
class. Even though you may not be aware of it, the <TT>COleObjectFactory</TT> class
contains a singly linked list that is used to keep track of all of the <TT>COleObjectFactory</TT>
classes implemented in a single application. The linked list is a static member,
which means that all instances of the class share the same class factory list. <TT>COleObjectFactory</TT>
also contains a static function, <TT>UpdateRegistryAll</TT>, that will cycle through
the list of <TT>COleObjectFactory</TT> classes, instructing each to register themselves.
<H3><A NAME="Heading9"></A>Server Unregistration</H3>
<P>The MFC AppWizard does not add the exported function, <TT>DllUnregisterServer</TT>,
to a project when it is created. This is probably due to an inherent limitation in
MFC. The MFC group apparently did not feel it was necessary to add unregistration
support to the basic MFC <TT>COleObjectFactory</TT> class. This is very interesting
since all of the Microsoft logo requirements indicate that all applications that
are installed and registered must also uninstall and unregister themselves in order
to qualify for the logo.</P>
<P>To support server unregistration, you would have to add the exported function,
<TT>DllUnregisterServer</TT> and call the static function <TT>COleObjectFactory::UpdateRegistryAll</TT>
passing <TT>FALSE</TT> as the parameter.</P>
<P>The actual unregistration code requires more work. We didn't include the unregistration
code as a part of the sample code, but the implementation is straightforward and
is outlined here. The first step is to create a new class that inherits from <TT>COleObjectFactory</TT>,
and override the virtual function, <TT>UpdateRegistry</TT>. Check the parameter that
is passed to the function, and based on its value, call the appropriate registration
and unregistration code. MFC provides a basic registration helper function, <TT>AfxOleRegisterServerClass</TT>,
but does not define a companion helper function for unregistration. Searching the
source files in MFC reveals a complete set of helper functions for the registry,
but unfortunately they are not accessible from anything but an MFC-implemented ActiveX
control. Since nothing is available from MFC, you are required to implement the registry
updating code yourself. Remember to remove all of the registry entries that the server
created: the <TT>ProgID</TT>, the <TT>CLSID</TT>, and the type library.
<H2><A NAME="Heading10"></A>Sample Server Support Code</H2>
<P>Since your <I>sample server </I>is used to output data to a file, you first need
to add some support code to your application before adding its methods and properties.</P>
<P>Listing 3.4 shows the changes and additions that have been made to the class header
file. A set of member variables was added for storing the file handle and timer information
that will be used throughout the server implementation.
<H3><A NAME="Heading11"></A>Listing 3.4 TRACKER.H-- Sample Server Support Code Added
to the Header File</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
DECLARE_OLECREATE(CTracker)<BR>
protected:<BR>
FILE * m_fileLog;<BR>
long m_lTimeBegin;<BR>
long m_lHiResTime;<BR>
long m_lLastHiResTime;<BR>
};</TT></FONT></P>
<P>The next step is to update the source file for the class. Add the include file
mmsystem.h to the Tracker.cpp file (see Listing 3.5). This is for the timer functions
that you are taking advantage of in the sample server implementation.</P>
<P>The constructor and destructor of the server have also been updated. When using
OLE in MFC applications, you must always lock the application in memory by calling
the method <TT>AfxOleLockApp()</TT>,<TT> </TT>which ensures that the application
will not be unloaded from memory until the reference count reaches zero. This step
is critical and must be in all MFC-based servers.</P>
<P>Next you create a high resolution timer and store its current value in your member
variables. The timer is useful for determining the number of milliseconds that have
passed since the last method call was made. The timer output is great for tracking
the performance of a particular action or set of actions.</P>
<P>You then get the current date and create a filename with the format YYYYMMDD.tracklog.
After successfully opening the file, you output some start-up data to the file and
exit the constructor.</P>
<P>The destructor does the exact opposite of the constructor. If there is a valid
file handle, you write some closing information to the file and close it. Next you
terminate the timer. Remember to call the function <TT>AfxOleUnlockApp()</TT> to
allow the application to be removed from memory.
<H3><A NAME="Heading12"></A>Listing 3.5 TRACKER.CPP--Updated Source File</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
#include &quot;Tracker.h&quot;<BR>
// needed for the high resolution timer services<BR>
#include &lt;mmsystem.h&gt;<BR>
#ifdef _DEBUG<BR>
#define new DEBUG_NEW<BR>
#undef THIS_FILE<BR>
static char THIS_FILE[] = __FILE__;<BR>
#endif<BR>
/////////////////////////////////////////////////////////////////////////////<BR>
// CTracker<BR>
IMPLEMENT_DYNCREATE(CTracker, CCmdTarget)<BR>
CTracker::CTracker()<BR>
{<BR>
EnableAutomation();<BR>
// make sure that the application won't unload until the reference count is <BR>
::AfxOleLockApp();<BR>
// setup our timer resolution<BR>
m_lTimeBegin = timeBeginPeriod(1);<BR>
m_lHiResTime = m_lLastHiResTime = timeGetTime();<BR>
// get the current date and time<BR>
CTime oTimeStamp = CTime::GetCurrentTime();<BR>
CString cstrFileName;<BR>
// create a file name based on the date<BR>
cstrFileName.Format(_T(&quot;%s.tracklog&quot;), (LPCTSTR) <BR>
oTimeStamp.Format(&quot;%Y%m%d&quot;));<BR>
// open a file<BR>
m_fileLog = fopen(cstrFileName, _T(&quot;a&quot;));<BR>
// if we have a file handle<BR>
if(m_fileLog)<BR>
{<BR>
// output some starting information<BR>
fprintf(m_fileLog, _T(&quot;************************\n&quot;));<BR>
fprintf(m_fileLog, _T(&quot;Start %s\n&quot;), (LPCTSTR) oTimeStamp.Format (&quot;%B
%#d, %Y, %I:%M %p&quot;));<BR>
fprintf(m_fileLog, _T(&quot;\n&quot;));<BR>
}<BR>
}<BR>
CTracker::~CTracker()<BR>
{<BR>
// if we have a file handle<BR>
if(m_fileLog)<BR>
{<BR>
// output some closing information<BR>
CTime oTimeStamp = CTime::GetCurrentTime();<BR>
fprintf(m_fileLog, _T(&quot;\n&quot;));<BR>
fprintf(m_fileLog, _T(&quot;End %s\n&quot;), oTimeStamp.Format <BR>
(&quot;%B %#d, %Y, %I:%M %p&quot;));<BR>
fprintf(m_fileLog, _T(&quot;************************\n&quot;));<BR>
// close the file<BR>
fclose(m_fileLog);<BR>
}<BR>
<BR>
// if we have valid timer services<BR>
if(m_lTimeBegin == TIMERR_NOERROR)<BR>
// reset the timer to its original state<BR>
timeEndPeriod(1);<BR>
// make sure that the application can unloaded<BR>
::AfxOleUnlockApp();<BR>
}<BR>
. . .</TT></FONT></P>
<P>Finally you update the build settings for the project. Since the sample implementation
is using some timer functions defined in mmsystem.h, you also need to be linked with
the appropriate library file that contains their implementation. Under the <U>P</U>roject
menu, select the <U>S</U>ettings menu item. In the Project Settings dialog, from
the <U>S</U>ettings For drop-down list box, select the All Configurations entry.
Select the Link tab, and add the file winmm.lib to the Object/<U>l</U>ibrary modules
edit field. Click OK to close the dialog.</P>
<P>The basic support code needed for the sample implementation is now added. The
server will open a file in its constructor and leave the file open during its entire
lifetime. When the server is destroyed, the destructor will be called, and the file
will be closed.</P>
<P>The next step is to make the sample more meaningful by adding methods and properties,
which are used to output data to the open file.
<H2><A NAME="Heading13"></A>Adding Methods</H2>
<P>An <I>automation method</I> consists of zero to <I>n </I>parameters and may or
may not have a return value. The term <I>method</I> is synonymous with function or
subroutine, depending on the particular language you are familiar with. Since your
server is <TT>IDispatch</TT>-based, you are limited to a specific set of data types.
Only those data types that are valid <TT>VARIANT</TT> data types can be passed or
returned via a method.</P>
<P>The rules for declaring parameters and how they are used is very much like C++
and VB. Methods can pass parameters by value or by reference and may also declare
them as optional, meaning that the parameter does not have to be supplied.</P>
<P>When passing a parameter by value, a copy of the data is sent to the method, and
when passing by reference, the address of the parameter is passed, allowing the method
to change the data.</P>
<P>Optional parameters are handled a little differently than C++, however, since
you can't specify a default value in the traditional C++ sense. Optional parameters
must be passed as <TT>VARIANT</TT> data types and not the actual data type they represent.</P>
<P>For developers using VB to access a method with optional parameters, VB will supply
the parameter for you if one has not been provided. With C++, you are still required
to supply a <TT>VARIANT</TT> parameter even though it may not contain any data.</P>
<P>As we stated at the beginning of the chapter, the sample Automation Server will
be used to log strings of data to a file. The server will define the method <TT>OutputLines</TT>,
which is used by the user of the server to supply the string data that is written
to the file. The method will accept an array of strings and an optional indentation
parameter and will output the strings to the file. The indentation parameter is used
to offset the strings by <I>n </I>number of tab characters to provide simple, yet
effective, formatting to the data as it is output to the file.</P>
<P>From the <U>V</U>iew menu, select the Class<U>W</U>izard menu item. Select the
Automation tab, and click the <U>A</U>dd Method button. In the Add Method dialog
enter an <U>E</U>xternal name of <TT>OutputLines</TT> and a Return <U>t</U>ype of
<TT>BOOL</TT> (see fig. 3.5). <B><BR>
<BR>
</B><A HREF="art/03/cfig5r.jpg"><B>FIG. 3.5</B></A> <I><BR>
Add the <TT>OutputLines</TT> method with the ClassWizard.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>Boolean Data Type Differences Between VC++ and VB</B><BR>
	It is important to note a fundamental difference between VC++ and VB when using Boolean
	data types. The Boolean data type is defined by C++ as being of type integer that
	is a 32-bit value. For VB, however, an integer is 16-bit. For simple MFC-based Automation
	Servers, the difference in sizes between a VB integer and VC++ integer is not a problem
	since MFC hides the details involving the conversion of the 32-bit value to a 16-bit
	value, and vice versa. For dual-interface applications, though, the size difference
	poses a significant problem. When accessing the custom interface of a dual-interface
	server, the functions are called in the same fashion as any other function in an
	application. Basically, the parameters of the function are pushed on to a stack,
	and the function is called. When the function executes, the parameters are then popped
	off the stack. If VB calls a function in VC++, the stack will become corrupt because
	of the different sizes that each language uses for the Boolean data type. To be safe,
	VC++ applications should define all Boolean data types as type <TT>VARIANT_BOOL</TT>,
	which is defined by OLE as a 16-bit value and which is guaranteed to be the same
	size regardless of the language or tool being used. The actual Boolean data value
	is different between VB and VC++ also. VB developers are used to Boolean values of
	0 indicating <TT>FALSE</TT> and -1 indicating <TT>TRUE</TT>. For those of you who
	may be wondering why, the binary values for each is 00000000 and 11111111, respectively.
	For C++ programmers, Boolean data values are usually defined as 0 for <TT>FALSE</TT>
	and 1 or non-zero for <TT>TRUE</TT>.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">

<DL>
	<DT>The differences in Boolean data values can cause considerable problems when integrating
	VB and VC++ applications. In addition, VB 4 has some behavioral differences in its
	language, depending on the value being tested. Some VB functions do not test for
	0 or non-zero and will test for the absolute value of 0 or -1, and vice versa, depending
	on the data type and function. When using Boolean data types, it is wise to also
	use the <TT>VARIANT_FALSE</TT> and <TT>VARIANT_TRUE</TT> constants to define the
	value of the variable.</DT>
</DL>

<P><TT>OutputLines</TT> is defined as having two parameters: <TT>varOutputArray</TT>
as a <TT>VARIANT</TT> passed by reference, which will contain a string array of data
to output to the file, and <TT>varIndent</TT> as a <TT>VARIANT</TT> passed by value,
which is also an optional parameter indicating the amount of indentation when writing
the string data to the file. To add the method parameters, double-click the line
in the <U>P</U>arameter list that is directly below the Name column, and type varOutputArray.
Click directly under the Type column to activate the Type drop-down list box. Select
<TT>VARIANT *</TT> from the list. Repeat the same process for <TT>varIndent</TT>,
but set the data type to <TT>VARIANT</TT>.</P>
<P>Due to data type restrictions imposed by Automation, you cannot pass arrays as
parameters of methods. You can, however, pass <TT>VARIANT</TT> data types that can
contain arrays, thus the reason for defining <TT>varOutputArray</TT> as a <TT>VARIANT</TT>.
You are also required to pass <TT>varOutputArray</TT> by reference because the array
stored in the <TT>VARIANT</TT> does not get copied over when it is passed by value.</P>
<P>Optional parameters must fall at the end of the parameter list and must be of
type <TT>VARIANT</TT> (see Listing 3.6). <TT>varIndent</TT> is an optional parameter
that indents the text output as an added formatting feature.</P>
<P>Click OK to add the method.</P>
<P>Click OK in the MFC ClassWizard dialog to close the ClassWizard. Remember that
the ClassWizard also added an entry to the ODL file as well as the header and source
files.</P>
<P>It is a function of the ODL file to declare a parameter of a method as being optional.
To be optional, a parameter must be declared with the optional parameter attribute
(see Listing 3.6), which you are required to add by hand since the ClassWizard will
not add it for you.
<H3><A NAME="Heading14"></A>Listing 3.6 MFCSERVER.ODL--Updated ODL Entry for OutputLines
Method</H3>
<P><FONT COLOR="#0066FF"><TT>// NOTE - ClassWizard will maintain method information
here. <BR>
// Use extreme caution when editing this section. <BR>
//{{AFX_ODL_METHOD(CTracker) <BR>
[id(1)] boolean OutputLines(VARIANT* varOutputArray, <BR>
[optional] VARIANT varIndent); <BR>
<BR>
//}}AFX_ODL_METHOD </TT></FONT></P>
<P>Before you add the implementation of the <TT>OutputLines</TT> method, you need
to add a member variable to the class definition (see Listing 3.7). The new member,
<TT>m_lIndent</TT>, is used to store the current indentation level between calls
to the method <TT>OutputLines</TT>.
<H3><A NAME="Heading15"></A>Listing 3.7 TRACKER.H--New Member Variable Added to the
Tracker Class</H3>
<P><FONT COLOR="#0066FF"><TT>protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; <BR>
long m_lIndent; <BR>
<BR>
}; </TT></FONT></P>
<P>You also need to update the constructor to initialize the member to a valid starting
value (see Listing 3.8).
<H3><A NAME="Heading16"></A>Listing 3.8 TRACKER.CPP--Member Initialization in the
Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>CTracker::CTracker() <BR>
{<BR>
. . .<BR>
m_lIndent = 0;<BR>
}</TT></FONT></P>
<P>Listing 3.9 shows the implementation of the <TT>OutputLines</TT> method. First
you check to see if you have a valid file handle and array of string data. The next
step is to lock down the array so that you can perform operations on it. This step
is required for all functions that manipulate safe arrays. The next function determines
the starting point of the array, which can be either 0 or 1. This procedure is very
important to implement since programming languages such as C++ define a base of 0
for arrays, and languages such as VB can define a base of 0 or 1. Next you retrieve
the number of dimensions in the array. Note that this value represents the number
of dimensions and not the last dimension relative to the lower bound value.</P>
<P>After establishing the boundaries of the array, you check to see if you have received
an indentation value also. You want to receive a long, <TT>VT_I4</TT>, but if you
don't receive it, you try to convert the data that was given to you to a usable value.
If you can't convert the data, you simply use the value that the variable already
contains. To indent the text, concatenate from 1 to <I>n </I>tab characters into
a string.</P>
<P>For each of the elements in the array of strings, get the current time and the
data associated with each element, and output them along with the indentation string
to the open file--and don't forget to free the string element when you finish with
it.</P>
<P>The last step is to unlock the array and exit the method with the proper return
value.
<H3><A NAME="Heading17"></A>Listing 3.9 TRACKER.CPP--OutputLines Method Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// CTracker message handlers <BR>
BOOL CTracker::OutputLines(VARIANT FAR* varOutputArray, const VARIANT FAR&amp; varIndent)
<BR>
{ <BR>
BOOL bResult = VARIANT_TRUE; <BR>
// if we have a file a if the variant contains a string array <BR>
if(m_fileLog &amp;&amp; varOutputArray-&gt;vt == (VT_ARRAY | VT_BSTR)) <BR>
{ <BR>
// lock the array so we can use it <BR>
if(::SafeArrayLock(varOutputArray-&gt;parray) == S_OK) <BR>
{ <BR>
LONG lLBound; <BR>
// get the lower bound of the array <BR>
if(::SafeArrayGetLBound(varOutputArray-&gt;parray, 1, &amp;lLBound) == S_OK) <BR>
{ <BR>
LONG lUBound; <BR>
// get the number of elements in the array <BR>
if(::SafeArrayGetUBound(varOutputArray-&gt;parray, 1, &amp;lUBound) == S_OK) <BR>
{ <BR>
CString cstrIndent; <BR>
CTime oTimeStamp; <BR>
BSTR bstrTemp; <BR>
// if we have an indent parameter <BR>
if(varIndent.vt != VT_I4) <BR>
{ <BR>
// get a variant that we can use for conversion purposes <BR>
VARIANT varConvertedValue; <BR>
// initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); <BR>
// see if we can convert the data type to something useful - VariantChangeTypeEx()
could also be used <BR>
if(S_OK == ::VariantChangeType(&amp;varConvertedValue, (VARIANT *) &amp;varIndent,
0, VT_I4)) <BR>
// assign the value to our member variable <BR>
m_lIndent = varConvertedValue.lVal; <BR>
} <BR>
else <BR>
// assign the value to our member variable <BR>
m_lIndent = varIndent.lVal; <BR>
// if we have to indent the text <BR>
for(long lIndentCount = 0; lIndentCount &lt; m_lIndent; lIndentCount++) <BR>
// add a tab to the string <BR>
cstrIndent += _T(&quot;\t&quot;); <BR>
// for each of the elements in the array <BR>
for(long lArrayCount = lLBound; lArrayCount &lt; (lUBound + lLBound); lArrayCount++)
<BR>
{ <BR>
// update the time <BR>
oTimeStamp = CTime::GetCurrentTime(); <BR>
m_lHiResTime = timeGetTime(); <BR>
// get the data from the array <BR>
if(::SafeArrayGetElement(varOutputArray-&gt;parray, &amp;lArrayCount, &amp;bstrTemp)
== S_OK) <BR>
{ <BR>
// output the data <BR>
fprintf(m_fileLog, _T(&quot;%s(%10ld)-%s%ls\n&quot;), (LPCTSTR) oTimeStamp.Format(&quot;%H:%M:%S&quot;),
m_lHiResTime - m_lLastHiResTime, (LPCTSTR) cstrIndent, bstrTemp); <BR>
// store the last timer value <BR>
m_lLastHiResTime = m_lHiResTime; <BR>
// free the bstr <BR>
::SysFreeString(bstrTemp); <BR>
} <BR>
} <BR>
} <BR>
else <BR>
bResult = VARIANT_FALSE; <BR>
} <BR>
else <BR>
bResult = VARIANT_FALSE; <BR>
// unlock the array we don't need it anymore <BR>
::SafeArrayUnlock(varOutputArray-&gt;parray); <BR>
} <BR>
else <BR>
bResult = VARIANT_FALSE; <BR>
} <BR>
else <BR>
bResult = VARIANT_FALSE; <BR>
// return the result <BR>
return bResult; <BR>
<BR>
} </TT></FONT></P>
<P>It is worthwhile to review the documentation in the VC++ books online on ODL,
Automation, and <TT>VARIANT</TT> data types to see what kind of flexibility you have
when defining methods and parameters. See <A HREF="ch06.htm">Chapters 6</A> through
11 on developing ActiveX controls for descriptions of more options and features when
creating methods.</P>
<P>Now that you have added a method, you are ready to implement its counterpart,
the property.
<H2><A NAME="Heading18"></A>Adding Properties</H2>
<P>A <I>property</I> can be thought of as an exposed variable that is defined in
the Automation Server. Properties are useful for setting and retrieving information
about the state of the server.</P>
<P>Properties are implemented as a pair of methods: one to get the value, and the
other to set the value. The <TT>m_lIndent</TT> member variable that you added to
the class definition is a perfect candidate to be exposed as a property.</P>
<P>As with methods, properties are also added via the ClassWizard in MFC. From the
<U>V</U>iew menu, select the Class<U>W</U>izard menu item. In the MFC ClassWizard
dialog, select the Automation tab, and click the Add P<U>r</U>operty button. In the
Add Property dialog, enter the <U>E</U>xternal name of the property as Indent and
select the type as <TT>long</TT> (see fig. 3.6). Set the Implementation to Get/Set
<U>m</U>ethods, and click OK to add the property to the server. Click the <U>E</U>dit
Code button to close the MFC ClassWizard dialog and open the source file for editing.
<B><BR>
<BR>
</B><A HREF="art/03/cfig6r.jpg"><B>FIG. 3.6</B></A> <I><BR>
Add the <TT>Indent</TT> property with the ClassWizard.</I></P>
<P>The actual implementation of the <TT>Indent</TT> property is very easy (see Listing
3.10). <TT>GetIndent</TT> returns the value currently stored in the member variable,
and <TT>SetIndent</TT> stores the new value, after a little bit of error checking,
in the member variable.
<H3><A NAME="Heading19"></A>Listing 3.10 TRACKER.CPP--Indent Property Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>long CTracker::GetIndent() <BR>
{ <BR>
// return the member variable <BR>
return m_lIndent; <BR>
} <BR>
void CTracker::SetIndent(long nNewValue) <BR>
{ <BR>
// if the new value is a least 0 <BR>
if(nNewValue &gt;= 0) <BR>
// assign the value to our member variable <BR>
m_lIndent = nNewValue; <BR>
<BR>
} </TT></FONT></P>
<P>Properties, like methods, also have a wide variety of implementation options,
including parameterized and enumerated values. See <A HREF="ch06.htm">Chapters 6</A>
through 11 on developing ActiveX controls for descriptions of more options and features
when creating properties.</P>
<P>You've added methods and properties to the server but haven't really dealt with
the issue of error handling in their implementation. In some cases, simply returning
success or failure is not enough information for the developer to understand that
an error occurred and what caused it. You will communicate more error information
through the use of OLE exceptions.
<H2><A NAME="Heading20"></A>Generating OLE Exceptions</H2>
<P>While executing a method call or some other action, at times it is necessary to
terminate the process due to some critical error that has occurred or is about to
occur. For example, a method is called to write data to a file, but the method cannot
open the file because there is not enough room on the hard disk to do so. It is necessary
to halt further processing until the error can be resolved. An error of this kind
is known as an <I>exception. </I>Any type of error can be treated as an exception;
it depends on the requirements of your application and how you choose to deal with
the errors that may result.</P>
<P>You must become familiar with two forms of exceptions when creating ActiveX components.
The first is a C++ exception. A <I>C++ exception </I>is a language mechanism used
to create critical errors of the type described earlier and is confined to the application
in which they are defined. The second is an OLE exception. <I>OLE exceptions </I>are
used to communicate the same kinds of errors externally to applications that are
using a component. The difference between the two is that C++ exceptions are used
internal to an application's implementation, and OLE exceptions are used externally
to communicate errors to other applications.</P>
<P>The <TT>IDispatch</TT> interface contains specific parameters in its functions
for dealing with exceptions and passing them to the controller application. The MFC
implementation of the <TT>CCmdTarget</TT> class handles the details of generating
OLE exceptions by trapping any C++ exceptions that it receives and translates them
to the proper <TT>IDispatch</TT> error information. You need only create a C++ exception
of type <TT>COleDispatchException</TT> and throw it. MFC does all of the work for
you. When creating dual-interface servers, exceptions are handled in a different
way, which you will see later in this chapter.</P>
<P>The first step is to add an enumeration of the types of errors that the server
can generate to the ODL file (see Listing 3.11). Adding the enumeration to the ODL
has the effect of publishing the error constants to the applications developer that
is using the server. You add the constants in the form of an include file so that
you can use the same error constants file in the C++ source code implementation.
You also add a <TT>UUID</TT> to the <TT>typedef</TT> so that it can be identified
in the type library that is generated with the GUIDGEN.EXE program.
<H3><A NAME="Heading21"></A>Listing 3.11 MFCSERVER.ODL--Error Enumeration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
[ uuid(11C82947-4EDD-11D0-BED8-00400538977D) ] <BR>
coclass TRACKER <BR>
{ <BR>
[default] dispinterface ITracker; <BR>
}; <BR>
typedef [uuid(11C82948-4EDD-11D0-BED8-00400538977D), helpstring(&quot;Tracker Error
Constants&quot;)] <BR>
#include &quot;trackererror.h&quot; <BR>
//{{AFX_APPEND_ODL}} <BR>
<BR>
}; </TT></FONT></P>
<P>TrackerError.h contains a standard C/C++ enumeration of the errors that the application
supports (see Listing 3.12). The starting value of the errors falls into the range
of valid user-defined errors. Be careful when assigning error numbers since most
tools will first look up the system-defined error message before using the message
defined in the exception.
<H3><A NAME="Heading22"></A>Listing 3.12 TRACKERERROR.H--Tracker Error Constants</H3>
<P><FONT COLOR="#0066FF"><TT>// Error enumeration <BR>
enum tagTrackerError <BR>
{ <BR>
MFCSERVER_E_NO_UBOUND = 46080, <BR>
MFCSERVER_E_NO_LBOUND = 46081, <BR>
MFCSERVER_E_NO_ARRAYLOCK = 46082,<BR>
MFCSERVER_E_NO_FILE = 46083,<BR>
MFCSERVER_E_BAD_ARRAY_PARAMETER = 46084,<BR>
MFCSERVER_E_INVALID_VALUE = 46085<BR>
}TRACKERERROR;</TT></FONT></P>
<P>The next step is to add the code that will generate the exceptions to all of the
appropriate locations in the server code (see Listing 3.13). As you can see, instead
of returning <TT>VARIANT_FALSE</TT> or ignoring an error condition, you now generate
meaningful errors and messages instructing the developer as to the source of the
problem. The exception-generating code is fairly straightforward. First you create
a <TT>COleDispacthException</TT> and set the appropriate members with the data that
is necessary for the error that was generated (for information about other types
of exceptions, see the VC++ documentation). For your implementation, you set the
error code, the name of the file that generated the error, and the error message.
You could also supply a help filename and a help ID to further describe the error.
Note the use of the <TT>MAKE_SCODE</TT> macro to generate a valid <TT>SCODE</TT>
error number for the exception.
<H3><A NAME="Heading23"></A>Listing 3.13 TRACKER.CPP--Exception Handling Code Added
to the Source Files</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CTracker message handlers <BR>
BOOL CTracker::OutputLines(VARIANT FAR* varOutputArray, const VARIANT FAR&amp; varIndent)
<BR>
{ <BR>
BOOL bResult = VARIANT_TRUE; <BR>
// if we have a file a if the variant contains a string array <BR>
if(m_fileLog &amp;&amp; varOutputArray-&gt;vt == (VT_ARRAY | VT_BSTR)) <BR>
{ <BR>
// lock the array so we can use it <BR>
if(::SafeArrayLock(varOutputArray-&gt;parray) == S_OK) <BR>
{ <BR>
LONG lLBound; <BR>
// get the lower bound of the array <BR>
if(::SafeArrayGetLBound(varOutputArray-&gt;parray, 1, &amp;lLBound) == S_OK) <BR>
{ <BR>
LONG lUBound; <BR>
// get the number of elements in the array <BR>
if(::SafeArrayGetUBound(varOutputArray-&gt;parray, 1, &amp;lUBound) == S_OK) <BR>
{ <BR>
CString cstrIndent; <BR>
CTime oTimeStamp; <BR>
BSTR bstrTemp; <BR>
// if we have an indent parameter <BR>
if(varIndent.vt != VT_I4) <BR>
{ <BR>
// get a variant that we can use for conversion purposes <BR>
VARIANT varConvertedValue; <BR>
// initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); <BR>
// see if we can convert the data type to something useful - VariantChangeTypeEx()
could also be used <BR>
if(S_OK == ::VariantChangeType(&amp;varConvertedValue, (VARIANT *) &amp;varIndent,
0, VT_I4)) <BR>
// assign the value to our member variable <BR>
m_lIndent = varConvertedValue.lVal; <BR>
} <BR>
else <BR>
// assign the value to our member variable <BR>
m_lIndent = varIndent.lVal; <BR>
// if we have to indent the text <BR>
for(long lIndentCount = 0; lIndentCount &lt; m_lIndent; lIndentCount++) <BR>
// add a tab to the string <BR>
cstrIndent += _T(&quot;\t&quot;); <BR>
// for each of the elements in the array <BR>
for(long lArrayCount = lLBound; lArrayCount &lt; (lUBound + lLBound); lArrayCount++)
<BR>
{ <BR>
// update the time <BR>
oTimeStamp = CTime::GetCurrentTime(); <BR>
m_lHiResTime = timeGetTime(); <BR>
// get the data from the array <BR>
if(::SafeArrayGetElement(varOutputArray-&gt;parray, &amp;lArrayCount, &amp;bstrTemp)
== S_OK) <BR>
{ <BR>
// output the data <BR>
fprintf(m_fileLog, _T(&quot;%s(%10ld)-%s%ls\n&quot;), (LPCTSTR) oTimeStamp.Format(&quot;%H:%M:%S&quot;),
m_lHiResTime - m_lLastHiResTime, (LPCTSTR) cstrIndent, bstrTemp); <BR>
// store the last timer value <BR>
m_lLastHiResTime = m_lHiResTime; <BR>
// free the bstr <BR>
::SysFreeString(bstrTemp); <BR>
} <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
bResult = VARIANT_FALSE; <BR>
// unable to get a record based on the sql statement - throw an exception <BR>
COleDispatchException * pOleDispExcep = new COleDispatchException(_T(&quot;&quot;),
NULL, 0); <BR>
// format the error code <BR>
pOleDispExcep-&gt;m_scError = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_UBOUND);
<BR>
// set the source file <BR>
pOleDispExcep-&gt;m_strSource = __FILE__; <BR>
// format the error description <BR>
pOleDispExcep-&gt;m_strDescription = _T(&quot;Unable to retrieve the upper bound
dimension of the array.&quot;); <BR>
// the function call failed cause an ole exception <BR>
throw(pOleDispExcep); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
bResult = VARIANT_FALSE; <BR>
// unable to get a record based on the sql statement - throw an exception <BR>
COleDispatchException * pOleDispExcep = new COleDispatchException(_T(&quot;&quot;),
NULL, 0); <BR>
// format the error code <BR>
pOleDispExcep-&gt;m_scError = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_LBOUND);
<BR>
// set the source file <BR>
pOleDispExcep-&gt;m_strSource = __FILE__; <BR>
// format the error description <BR>
pOleDispExcep-&gt;m_strDescription = _T(&quot;Unable to retrieve the lower bound
dimension of the array.&quot;); <BR>
// the function call failed cause an ole exception <BR>
throw(pOleDispExcep); <BR>
} <BR>
// unlock the array we don't need it anymore <BR>
::SafeArrayUnlock(varOutputArray-&gt;parray); <BR>
} <BR>
else <BR>
{ <BR>
bResult = VARIANT_FALSE; <BR>
// unable to get a record based on the sql statement - throw an exception <BR>
COleDispatchException * pOleDispExcep = new COleDispatchException(_T(&quot;&quot;),
NULL, 0); <BR>
// format the error code <BR>
pOleDispExcep-&gt;m_scError = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_ARRAYLOCK);
<BR>
// set the source file <BR>
pOleDispExcep-&gt;m_strSource = __FILE__; <BR>
// format the error description <BR>
pOleDispExcep-&gt;m_strDescription = _T(&quot;Unable to lock the array memory.&quot;);
<BR>
// the function call failed cause an ole exception <BR>
throw(pOleDispExcep); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
bResult = VARIANT_FALSE; <BR>
// unable to get a record based on the sql statement - throw an exception <BR>
COleDispatchException * pOleDispExcep = new COleDispatchException(_T(&quot;&quot;),
NULL, 0); <BR>
// if we didn't have a file handle <BR>
if(!m_fileLog) <BR>
// format the error code <BR>
pOleDispExcep-&gt;m_scError = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_FILE);
<BR>
else <BR>
// format the error code <BR>
pOleDispExcep-&gt;m_scError = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_BAD_ARRAY_PARAMETER);
<BR>
// set the source file <BR>
pOleDispExcep-&gt;m_strSource = __FILE__; <BR>
// if we didn't have a file handle <BR>
if(!m_fileLog) <BR>
// format the error description <BR>
pOleDispExcep-&gt;m_strDescription = _T(&quot;Invalid File Handle. File could not
be opened for output.&quot;); <BR>
else <BR>
// format the error description <BR>
pOleDispExcep-&gt;m_strDescription = _T(&quot;The first parameter must be a string
array passed by reference.&quot;); <BR>
// the function call failed cause an ole exception <BR>
throw(pOleDispExcep); <BR>
} <BR>
// return the result <BR>
return bResult; <BR>
} <BR>
long CTracker::GetIndent() <BR>
{ <BR>
// return the member variable <BR>
return m_lIndent; <BR>
} <BR>
void CTracker::SetIndent(long nNewValue) <BR>
{ <BR>
// if the new value is a least 0 <BR>
if(nNewValue &gt;= 0) <BR>
// assign the value to our member variable <BR>
m_lIndent = nNewValue; <BR>
else <BR>
{ <BR>
// unable to get a record based on the sql statement - throw an exception <BR>
COleDispatchException * pOleDispExcep = new <BR>
<BR>
<BR>
<BR>
COleDispatchException(_T(&quot;&quot;), NULL, 0); <BR>
// format the error code <BR>
pOleDispExcep-&gt;m_scError = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_INVALID_VALUE);
<BR>
// set the source file <BR>
pOleDispExcep-&gt;m_strSource = __FILE__; <BR>
// format the error description <BR>
pOleDispExcep-&gt;m_strDescription = _T(&quot;Invalid value. Value must be 0 or greater.&quot;);
<BR>
// the function call failed cause an ole exception <BR>
throw(pOleDispExcep); <BR>
} <BR>
<BR>
} </TT></FONT></P>
<P>Exceptions are useful for communicating error conditions and problems back to
the application and developer who are using an ActiveX component. Make use of them
whenever you can to further enhance your implementation.
<H2><A NAME="Heading24"></A>Dual-Interface</H2>
<P>Dual-interface is exactly what it sounds like: The server implementation supports
two interfaces with which to talk to the server. One interface, an IDispatch<I> interface,</I>
is what you have been working with so far. The other, a <I>custom interface, </I>is
a type of interface that you have not looked at yet. The dual portion refers to the
fact that no matter which interface you choose, you are always talking to the same
server, and you will always get the same response.</P>
<P>An <TT>IDispatch</TT>-based interface uses a generic mechanism for calling methods
and properties in a server. When a method in a server is called, you pass the ID
of the method to invoke and a structure describing its parameters and return type.
This data is packaged and sent to the server, which unpackages the data and calls
the appropriate method based on the ID supplied.</P>
<P>A custom interface, on the other hand, is very different. When using a custom
interface, you are talking directly to the server's functions and are not depending
on a generic mechanism for invoking the methods or properties. The packaging of the
parameters and return value are left to the compiler that created the applications.</P>
<P>Since the interfaces are written to access the same set of functions, the custom
interface portion of a dual-interface server must conform to the same data type restrictions
imposed by Automation. This way, you are not required to create your own code to
transfer data between the two applications: the controller and the server. OLE does
that for you with standard marshaling.</P>
<P>The major advantage to dual-interface is performance. The number of steps to call
a method using the custom interface is far less than the number needed to call a
method when using the <TT>IDispatch</TT> interface.</P>
<P>The main disadvantage to dual-interface support in MFC servers is that they are
not supported by the ClassWizard and will require manual changes to implement. The
code involved is not too difficult to maintain; the hardest part is probably remembering
to do it. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The advantage of using the custom interface of a dual-interface server
	loses its luster when executing across process boundaries. The custom interface is
	still faster, but not by much. The real performance benefit, a 25 to 50 percent improvement,
	is when the server is in-process to the calling application. The amount of improvement
	depends on the number and types of parameters that are being passed between the applications.
	If you are interested in seeing actual numbers regarding the amount of performance
	improvement, you can refer to recent Microsoft Systems Journal articles, which have
	focused on performance differences between <TT>IDispatch</TT> and custom interfaces.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The first step when converting an MFC-based ActiveX server to dual-interface is to
change the ODL file. Listing 3.14 shows the changes that have been made to the server
to support dual-interface. It is not necessary to generate new <TT>UUID</TT>s because
the functionality of the server has not changed. You must add the <TT>oleautomation</TT>
and <TT>dual</TT> attributes to the interface class, though. You also add the <TT>hidden</TT>
attribute, so this interface will not be visible within VB. This is fine since VB
will display the <TT>CoClass</TT> interface and will also show all of the methods
and properties for the server. As a general rule, you should always hide your interfaces
and leave visible the <TT>CoClasses</TT> used to create them. This is because applications
like VB will display both interfaces, and the reality is that only the <TT>CoClass</TT>
name is valid in VB; if you try to reference an object by its interface name, you
will get an error.</P>
<P>Since the server supports dual-interface, you must change your interface declaration
to inherit from the <TT>IDispatch</TT> interface rather than declare the interface
as type <TT>dispinterface</TT>, as in the original implementation. Dual-interface
method and property declarations are different from <TT>dispinterface</TT> declarations,
which are more like standard C++. Note that keywords such as <TT>method</TT> and
<TT>properties</TT> are no longer within the interface declaration. Those terms are
keywords related to the <TT>dispinterface</TT> keyword. As we stated earlier, properties
are accessed using a pair of methods sharing the same dispid. The distinguishing
factors are the method attributes <TT>propget</TT> and <TT>propput,</TT> which denote
the direction of data flow. You must also change the <TT>CoClass</TT> to refer to
interface and not <TT>dispinterface</TT>.</P>
<P>All dual-interface methods must return an <TT>HRESULT</TT> data type. If a method
requires a return value, it must be specified as the last parameter of the method
and must have the parameter attributes of <TT>out</TT> and <TT>retval</TT>. All parameters
must have an attribute describing the direction of data flow. See Table 3.3 for a
complete description of the possible attributes and combinations. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 3.3</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Parameter Flow Attributes</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Direction</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>in</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>out</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is returned from callee to caller.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>in</TT>, <TT>out</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee, and the callee returns a parameter.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>out</TT>, <TT>retval</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is the return value of the method and is returned from the callee to the
			caller.</TD>
	</TR>
</TABLE>

<H3><A NAME="Heading25"></A>Listing 3.14 MFCSERVER.ODL--ODL Changes to Support Dual-Interface</H3>
<P><FONT COLOR="#0066FF"><TT>[ uuid(11C82943-4EDD-11D0-BED8-00400538977D), version(1.0)
] <BR>
library MFCServer <BR>
{ <BR>
importlib(&quot;stdole32.tlb&quot;); <BR>
<BR>
[ uuid(11C82946-4EDD-11D0-BED8-00400538977D), oleautomation, dual, hidden ] <BR>
interface ITracker: IDispatch <BR>
{ <BR>
[id(1), propget] HRESULT Indent([out, retval] long * Value); <BR>
[id(1), propput] HRESULT Indent([in] long Value); <BR>
[id(2)] HRESULT OutputLines([in] VARIANT * varOutputArray, [in, optional] VARIANT
varIndent, [out, retval] boolean * RetVal); <BR>
}; <BR>
// CoClass for CTracker <BR>
[ uuid(11C82947-4EDD-11D0-BED8-00400538977D) ] <BR>
coclass TRACKER <BR>
{ <BR>
[default] interface ITracker; <BR>
}; <BR>
typedef [uuid(11C82948-4EDD-11D0-BED8-00400538977D), helpstring(&quot;Tracker Error
Constants&quot;)] <BR>
#include &quot;trackererror.h&quot; <BR>
//{{AFX_APPEND_ODL}} <BR>
<BR>
}; </TT></FONT></P>
<P>The remainder of the ODL file entries do not have to be changed to support dual-interface.
<BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The changes that have been made to the ODL file will prevent the
	ClassWizard from updating the ODL file automatically when new methods and properties
	are added. You are now responsible for maintaining the entries manually.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The ODL compiler has the capability of generating a C++ header file that describes
all of the interfaces and enumerations that are contained in the type library that
you've created for your server. The ODL-generated header file is useful for creating
function prototypes that are required in the implementation of the server. You add
the entry to the ODL file and compile it into a type library. Next copy the new method
from the header file into your class definition and make some minor changes--and
everything is finished. In addition, you now have an interface file that can be used
by other applications to access the custom interface of your server as well as the
enumerations that are used when accessing specific methods and properties.</P>
<P>To generate the header file, you must update the build settings of your project.
From the <U>P</U>roject menu, select the <U>S</U>ettings menu item. In the <U>S</U>ettings
For drop-down list box found in the Project Settings dialog, select All Configurations
(see fig. 3.7). Expand the MFCServer project node and the Source Files node, and
select the MFCServer.odl file. Select the OLE Types tab, and in the Output h<U>e</U>ader
file name edit field, enter the name <B>TrackerInterface.h</B>. Whenever the type
library is compiled, the TrackerInterface.h will be regenerated to reflect the new
implementation. <B><BR>
<BR>
</B><A HREF="art/03/cfig7r.jpg"><B>FIG. 3.7</B></A> <I><BR>
Update the project settings to create the C++ header file from the ODL file.</I></P>
<P>Listing 3.15 shows the inclusion of the new header file to the Tracker.cpp source
file. Note that you also remove the TrackerError.h file because the error enumeration
that you declared earlier in the chapter is also defined in the header file generated
by the ODL compiler. The TrackerInterface.h must be included <I>before </I>or<I>
in</I> the Tracker.h file; the <TT>CTracker</TT> class is dependent on the information
in the TrackerInterface.h file.
<H3><A NAME="Heading26"></A>Listing 3.15 TRACKER.CPP--ODL-Generated Header File Is
Added to the Tracker Source File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;MFCServer.h&quot; <BR>
// ODL generated interface file <BR>
#include &quot;trackerinterface.h&quot; <BR>
#include &quot;Tracker.h&quot; <BR>
// needed for the high resolution timer services <BR>
#include &lt;mmsystem.h&gt; <BR>
#ifdef _DEBUG <BR>
#define new DEBUG_NEW <BR>
<BR>
. . . </TT></FONT></P>
<P>MFC defines a set of macros for describing interfaces within the context of an
MFC component implementation. The interface macro defines the interface, its name,
and the methods that it contains. Listing 3.16 shows the MFC interface declaration
that is added to your class definition to describe the custom interface portion of
your server. The interface declaration can be added anywhere after the <TT>DECLARE_INTERFACE_MAP</TT>
macro.</P>
<P>The first parameter of the <TT>BEGIN_INTERFACE_PART</TT> macro, <TT>SubDispatch</TT>,
is the name that is used to create a nested class within the class definition of
the server. The second parameter is the name of the interface from which the nested
class is inherited. The <TT>ITracker</TT> interface is declared in the TrackerInterface.h
header file that was created from the ODL file. The <TT>ITracker</TT> declaration
in the header file contains a set of pure virtual functions that need to be copied
into your interface declaration. When copying the functions, remember to remove the
<TT>= 0</TT> from the end of the function, since this is where you will implement
them.
<H3><A NAME="Heading27"></A>Listing 3.16 TRACKER.H--Interface Macro Update of the
Tracker Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
// needed for dual interface support <BR>
BEGIN_INTERFACE_PART(SubDispatch, ITracker) <BR>
STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo); <BR>
STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, <BR>
ITypeInfo FAR* FAR* pptinfo); <BR>
STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, <BR>
OLECHAR FAR* FAR* rgszNames, UINT cNames, LCID lcid, <BR>
DISPID FAR* rgdispid); <BR>
STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, <BR>
LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams, <BR>
VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, <BR>
UINT FAR* puArgErr); <BR>
virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Indent( <BR>
/* [retval][out] */ long __RPC_FAR *Value); <BR>
<BR>
virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Indent( <BR>
/* [in] */ long Value); <BR>
<BR>
virtual /* [id] */ HRESULT STDMETHODCALLTYPE OutputLines( <BR>
/* [in] */ VARIANT __RPC_FAR *varOutputArray, <BR>
/* [optional][in] */ VARIANT varIndent, <BR>
/* [retval][out] */ VARIANT_BOOL __RPC_FAR *RetVal); <BR>
<BR>
<BR>
END_INTERFACE_PART(SubDispatch). . . </TT></FONT></P>
<P>The header file contains the interface declaration, and the source file contains
the interface implementation. The MFC AppWizard created a default interface implementation
for the server when it was created. The original definition deferred to the default
<TT>IDispatch</TT> interface defined in MFC. Since you have implemented an interface
that inherits from <TT>IDispatch</TT>, it is necessary to route all <TT>IDispatch</TT>
calls to the new interface. The interface map located in the server source file must
be changed to reflect the new interface that you've declared. Change the interface
from <TT>IDispatch</TT> to the name of the interface declared in the header file,
in your case <TT>SubDispatch</TT>, as in Listing 3.17. Changing the name of the interface
will have the effect of routing all calls to the <TT>IDispatch</TT> interface to
your implementation of the interface first, which you can then implement yourself
or pass on to the default implementation.</P>
<P>Unfortunately, MFC does not allow for true C++ inheritance of the COM interfaces
it contains, so it is necessary to route messages for a particular COM interface
to the correct handler function in the server. Routing the messages is done through
the <TT>BEGIN_INTERFACE_MAP</TT> macro. Since your implementation supports both an
<TT>IDispatch</TT> interface and a custom interface, you are required to add to entries
to the macro. In your case, you defer all <TT>IDispatch</TT> messages to the custom
interface functions. The same is true of the custom interface messages.
<H3><A NAME="Heading28"></A>Listing 3.17 TRACKER.CPP--Interface Implementation of
the ITracker Interface</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
BEGIN_INTERFACE_MAP(CTracker, CCmdTarget) <BR>
INTERFACE_PART(CTracker, IID_IDispatch, SubDispatch) <BR>
INTERFACE_PART(CTracker, IID_ITracker, SubDispatch) <BR>
END_INTERFACE_MAP() <BR>
<BR>
. . . </TT></FONT></P>
<P>The last step in adding dual-interface support to your server is to add the actual
implementation of the functions declared in the interface. The first set of functions
to implement is the base <TT>IDispatch</TT> functions that your server inherited
from the <TT>IDispatch</TT> class. Listing 3.18 shows the implementation of the functions.
In all cases, you defer to the base class implementation of the method. You have
the option to implement these functions yourself or rely on MFC to handle the methods
for you. An important thing to note is the method used to call the basic <TT>IDispatch</TT>
functions. Since the server captures all <TT>IDispatch</TT> messages and routes them
to the custom interface implementation, you cannot call <TT>GetIDispatch()</TT> to
retrieve the pointer to the <TT>IDispatch</TT> interface of the server. The reason
for this is that it will result in a recursive call since the <TT>IDispatch</TT>
functions are routed to your server implementation; instead, the implementation calls
the <TT>IDispatch</TT> functions <TT>((IDispatch*)&amp;pThis-&gt;m_xDispatch)-&gt;</TT>
directly, bypassing the message routing functions, thus avoiding the recursion problem.
You also note that the nested class <TT>SubDispatch</TT> is declared as <TT>XSubDispatch</TT>
in the implementation. The X<I> </I>comes from the <TT>BEGIN_INTERFACE_PART</TT>
macros and has no particular significance. The same is true for the member variable
<TT>m_xDispatch</TT>.</P>
<P>Note the use of the macro <TT>METHOD_PROLOGUE</TT>, which is required in MFC-based
applications to ensure that MFC is in a valid state while the function is executing.
<H3><A NAME="Heading29"></A>Listing 3.18 TRACKER.CPP--IDispatch Function Implementation
for a Dual-Interface Server</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CTracker Standard IDispatch Dual Interface Handlers <BR>
ULONG FAR EXPORT CTracker::XSubDispatch::AddRef() <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return pThis-&gt;ExternalAddRef(); <BR>
} <BR>
ULONG FAR EXPORT CTracker::XSubDispatch::Release() <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return pThis-&gt;ExternalRelease(); <BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::QueryInterface(REFIID riid, LPVOID FAR*
ppvObj) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return (HRESULT) pThis-&gt;ExternalQueryInterface(&amp;riid, ppvObj); <BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::GetTypeInfoCount(UINT FAR* pctinfo) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return ((IDispatch*)&amp;pThis-&gt;m_xDispatch)-&gt;GetTypeInfoCount(pctinfo); <BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo
FAR* FAR* pptinfo) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return ((IDispatch*)&amp;pThis-&gt;m_xDispatch)-&gt;GetTypeInfo(itinfo, lcid, pptinfo);
<BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::GetIDsOfNames(REFIID riid, <BR>
OLECHAR FAR* FAR* rgszNames, UINT cNames, LCID lcid, DISPID FAR* rgdispid) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return ((IDispatch*)&amp;pThis-&gt;m_xDispatch)-&gt;GetIDsOfNames(riid, rgszNames,
cNames, lcid, rgdispid); <BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::Invoke(DISPID dispidMember, REFIID riid,
<BR>
LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, <BR>
EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
return ((IDispatch*)&amp;pThis-&gt;m_xDispatch)-&gt;Invoke(dispidMember, riid, lcid,
wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); <BR>
<BR>
} </TT></FONT></P>
<P>The last step is to implement the functions that are specific to your server.
As can be seen in Listing 3.19, you simplified the implementation by calling the
original MFC functions from the dual-interface implementations rather than reimplementing
the functions using the new style. Doing so solves several problems. First, you can
still rely on the MFC message mapping functions to invoke the methods when they are
called via the <TT>IDispatch</TT> interface, and it does not require you to implement
your own <TT>IDispatch</TT> code. Supporting the original MFC implementation also
prevents you from having to change internal code that may rely on the already existing
functions. As you will see a little later in this chapter, adding error handling
to the dual-interface code is much simpler using this style.
<H3><A NAME="Heading30"></A>Listing 3.19 TRACKER.CPP--ITracker Function Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CTracker interface handlers <BR>
HRESULT CTracker::XSubDispatch::get_Indent(LONG * Indent) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
HRESULT hResult = S_OK; <BR>
*Indent = pThis-&gt;GetIndent(); <BR>
return hResult; <BR>
} <BR>
HRESULT CTracker::XSubDispatch::put_Indent(LONG Indent) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
HRESULT hResult = S_OK; <BR>
pThis-&gt;SetIndent(Indent); <BR>
return hResult; <BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::OutputLines(VARIANT FAR* varOutputArray,
VARIANT varIndent, VARIANT_BOOL FAR* RetVal) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
HRESULT hResult = S_OK; <BR>
*RetVal = pThis-&gt;OutputLines(varOutputArray, varIndent); <BR>
return hResult; <BR>
<BR>
} </TT></FONT></P>
<P>After compiling the server and registering it, you are ready to test its new dual-interface
functionality. From C++, you will create the server as you did before, but now you
may access its custom interface by using the <TT>QueryInterface</TT> function supplying
the correct interface <TT>IID.</TT> From VB, you need only add the type library for
the server to your list of references and change the name of the variable to the
name that appears in the Object References dialog. You can also create the server
using <TT>New</TT> instead of the <TT>CreateObject</TT> method.</P>
<P>In VB, you call</P>
<P><FONT COLOR="#0066FF"><TT>Dim MyTracker as TRACKER<BR>
Set MyTracker = new TRACKER</TT></FONT></P>
<P>instead of</P>
<P><FONT COLOR="#0066FF"><TT>Dim MyTracker as Object<BR>
Set MyTracker = CreateObject(&quot;MFCServer.Tracker&quot;)<BR>
</TT></FONT><BR>
In C++, you call <TT>QueryInterface</TT> passing the <TT>IID ITracker</TT> interface
<TT>IID.</TT> The last step in your dual-interface conversion is to handle errors
correctly. As a general rule, a server cannot throw C++ exceptions from the custom
interface implementation of a dual-interface server. For that matter, it can't throw
them from any interface.</P>
<P>MFC just does the job of catching the C++ exceptions for you and converting them
to OLE exceptions that are understood by OLE. Since you are supporting a custom interface
in your server, you must do the same.
<H2><A NAME="Heading31"></A>Generating Dual-Interface OLE Exceptions</H2>
<P>Dual-interface rules for handling errors and exceptions is slightly different
for the custom interface portion of the interface. As you saw earlier, all of the
methods were changed to return an <TT>HRESULT</TT> in place of the function's normal
return value. An <TT>HRESULT</TT> is used to indicate that an error or exception
has occurred within the context of the method that was invoked. When an automation
controller invokes a method in the custom interface of a server, it should check
the return value of the function to see if it returned <TT>S_OK</TT>. If not, the
controller has the option of checking to see whether the server supports extended
error information via the <TT>ISupportErrorInfo</TT> interface. When a server that
supports the <TT>ISupportErrorInfo</TT> interface creates an error, it does so by
creating an <TT>IErrorInfo</TT> object containing the error information.</P>
<P>MFC does not support the <TT>ISupportErrorInfo</TT> interface by default, so you
must add it yourself. We've created a set of macros to aid in adding the <TT>ISupportErrorInfo</TT>
interface to your Automation Server (see Listing 3.20). We've used the macros defined
in the ACDUAL sample included with MFC to simplify the <TT>ISupportErrorInfo</TT>
implementation.
<H3><A NAME="Heading32"></A>Listing 3.20 ERRORINFOMACROS.H--ISupportErrorInfo Helper
Macros</H3>
<P><FONT COLOR="#0066FF"><TT>// this code is based on the ACDUAL MFC\OLE sample application
provided with Visual C++ <BR>
///////////////////////////////////////////////////////////////////// <BR>
// DECLARE_DUAL_ERRORINFO expands to declare the ISupportErrorInfo <BR>
// support class. It works together with DUAL_ERRORINFO_PART and <BR>
// IMPLEMENT_DUAL_ERRORINFO defined below. <BR>
#define DECLARE_DUAL_ERRORINFO() \ <BR>
BEGIN_INTERFACE_PART(SupportErrorInfo, ISupportErrorInfo) \ <BR>
STDMETHOD(InterfaceSupportsErrorInfo)(THIS_ REFIID riid); \ <BR>
END_INTERFACE_PART(SupportErrorInfo) \ <BR>
///////////////////////////////////////////////////////////////////// <BR>
// DUAL_ERRORINFO_PART adds the appropriate entry to the interface map <BR>
// for ISupportErrorInfo, if you used DECLARE_DUAL_ERRORINFO. <BR>
#define DUAL_ERRORINFO_PART(objectClass) \ <BR>
INTERFACE_PART(objectClass, IID_ISupportErrorInfo, SupportErrorInfo) \ <BR>
///////////////////////////////////////////////////////////////////// <BR>
// IMPLEMENT_DUAL_ERRORINFO expands to an implementation of <BR>
// ISupportErrorInfo which matches the declaration in <BR>
// DECLARE_DUAL_ERRORINFO. <BR>
#define IMPLEMENT_DUAL_ERRORINFO(objectClass, riidSource) \ <BR>
STDMETHODIMP_(ULONG) objectClass::XSupportErrorInfo::AddRef() \ <BR>
{ \ <BR>
METHOD_PROLOGUE(objectClass, SupportErrorInfo) \ <BR>
return pThis-&gt;ExternalAddRef(); \ <BR>
} \ <BR>
STDMETHODIMP_(ULONG) objectClass::XSupportErrorInfo::Release() \ <BR>
{ \ <BR>
METHOD_PROLOGUE(objectClass, SupportErrorInfo) \ <BR>
return pThis-&gt;ExternalRelease(); \ <BR>
} \ <BR>
STDMETHODIMP objectClass::XSupportErrorInfo::QueryInterface( \ <BR>
REFIID iid, LPVOID* ppvObj) \ <BR>
{ \ <BR>
METHOD_PROLOGUE(objectClass, SupportErrorInfo) \ <BR>
return pThis-&gt;ExternalQueryInterface(&amp;iid, ppvObj); \ <BR>
} \ <BR>
STDMETHODIMP objectClass::XSupportErrorInfo::InterfaceSupportsErrorInfo( \ <BR>
REFIID iid) \ <BR>
{ \ <BR>
METHOD_PROLOGUE(objectClass, SupportErrorInfo) \ <BR>
return (iid == riidSource) ? S_OK : S_FALSE; \ <BR>
<BR>
} </TT></FONT></P>
<P>Include the ErrorInfoMacros.h file in the server source file, as in Listing 3.21.
<H3><A NAME="Heading33"></A>Listing 3.21 TRACKER.CPP--ISupportErrorInfo Include File</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;stdafx.h&quot; <BR>
#include &quot;MFCServer.h&quot; <BR>
// error info support <BR>
#include &quot;ErrorInfoMacros.h&quot; <BR>
// ODL generated interface file <BR>
#include &quot;trackerinterface.h&quot; <BR>
<BR>
. . . </TT></FONT></P>
<P>You need to add a macro and a helper function to the class declaration of the
server (see Listing 3.22). The macro declares the <TT>ISupportErrorInfo</TT> interface,
and the helper function is used to translate the exception into an <TT>IErrorInfo</TT>
object.
<H3><A NAME="Heading34"></A>Listing 3.22 TRACKER.H--ISupportErrorInfo Class Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
DECLARE_OLECREATE(CTracker) <BR>
// add declaration of ISupportErrorInfo implementation <BR>
// to indicate we support the OLE Automation error object <BR>
DECLARE_DUAL_ERRORINFO() <BR>
HRESULT CreateErrorInfo(CException * pAnyException, REFIID riidSource); <BR>
// needed for dual interface support <BR>
BEGIN_INTERFACE_PART(SubDispatch, ITracker) <BR>
<BR>
. . . </TT></FONT></P>
<P>Now that you have your interface declaration, you need to add it to the interface
map. You also need to add the implementation macro for the interface and add the
implementation of the helper function (see Listing 3.23).</P>
<P>The <TT>CreateErrorInfo</TT> function translates any exception into an <TT>IErrorInfo</TT>
object. The function is based on code that is part of the ACDUAL MFC sample application
included with MFC. The primary responsibility of the function is to convert <TT>COleDispatchExceptions</TT>
into <TT>IErrorInfo</TT> objects. It can, however, deal with any exception that it
is passed, but the level of information about the error is far less. After the exception
has been translated, it is set as the error information object for the currently
executing thread.
<H3><A NAME="Heading35"></A>Listing 3.23 TRACKER.CPP--ISupportErrorInfo Interface
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BEGIN_INTERFACE_MAP(CTracker, CCmdTarget) <BR>
INTERFACE_PART(CTracker, IID_ITracker, SubDispatch) <BR>
DUAL_ERRORINFO_PART(CTracker) <BR>
END_INTERFACE_MAP() <BR>
IMPLEMENT_OLECREATE(CTracker, _T(&quot;MFCServer.Tracker&quot;), 0x11C82947, 0x4edd,
0x11d0, 0xbe, 0xd8, 0x0, 0x40, 0x5, 0x38, 0x97, 0x7d) <BR>
// Implement ISupportErrorInfo to indicate we support the <BR>
// OLE Automation error handler. <BR>
IMPLEMENT_DUAL_ERRORINFO(CTracker, IID_ITracker) <BR>
// this code is based on the ACDUAL MFC\OLE sample application provided with Visual
C++ <BR>
HRESULT CTracker::CreateErrorInfo(CException * pAnyException, REFIID riidSource)
<BR>
{ <BR>
ASSERT_VALID(pAnyException); <BR>
// create an error info object <BR>
ICreateErrorInfo * pcerrinfo; <BR>
HRESULT hr = ::CreateErrorInfo(&amp;pcerrinfo); <BR>
// if we succeeded <BR>
if(SUCCEEDED(hr)) <BR>
{ <BR>
// dispatch exception? <BR>
if(pAnyException-&gt;IsKindOf(RUNTIME_CLASS(COleDispatchException))) <BR>
{ <BR>
// specific IDispatch style exception <BR>
COleDispatchException * e = (COleDispatchException *) pAnyException; <BR>
// set the return value to the error <BR>
hr = e-&gt;m_scError; <BR>
// Set up ErrInfo object <BR>
pcerrinfo-&gt;SetGUID(riidSource); <BR>
pcerrinfo-&gt;SetDescription(e-&gt;m_strDescription.AllocSysString()); <BR>
pcerrinfo-&gt;SetHelpContext(e-&gt;m_dwHelpContext); <BR>
pcerrinfo-&gt;SetHelpFile(e-&gt;m_strHelpFile.AllocSysString()); <BR>
pcerrinfo-&gt;SetSource(e-&gt;m_strSource.AllocSysString()); <BR>
} <BR>
else if (pAnyException-&gt;IsKindOf(RUNTIME_CLASS(CMemoryException))) <BR>
{ <BR>
// failed memory allocation <BR>
hr = E_OUTOFMEMORY; <BR>
// Set up ErrInfo object <BR>
pcerrinfo-&gt;SetGUID(riidSource); <BR>
CString cstrFileName(AfxGetAppName()); <BR>
pcerrinfo-&gt;SetSource(cstrFileName.AllocSysString()); <BR>
} <BR>
else <BR>
{ <BR>
// other unknown/uncommon error <BR>
hr = E_UNEXPECTED; <BR>
// Set up ErrInfo object <BR>
pcerrinfo-&gt;SetGUID(riidSource); <BR>
CString cstrFileName(AfxGetAppName()); <BR>
pcerrinfo-&gt;SetSource(cstrFileName.AllocSysString()); <BR>
} <BR>
// QI for the IErrorInfo interface <BR>
IErrorInfo * perrinfo; <BR>
if(SUCCEEDED(pcerrinfo-&gt;QueryInterface(IID_IErrorInfo, (LPVOID *) &amp;perrinfo)))
<BR>
{ <BR>
// set the error info object <BR>
::SetErrorInfo(0, perrinfo); <BR>
// release the reference <BR>
perrinfo-&gt;Release(); <BR>
} <BR>
// release the reference <BR>
pcerrinfo-&gt;Release(); <BR>
} <BR>
// delete the exception <BR>
pAnyException-&gt;Delete(); <BR>
// return the error value <BR>
return hr; <BR>
<BR>
} </TT></FONT></P>
<P>The last step is to update the custom interface methods to defer all exceptions
to the helper function that you just added. The additional code needed is straightforward
and simple to implement (see Listing 3.24). For each of the methods, you wrap the
call to the basic implementation of the function with a <TT>try...catch</TT> block
that will translate any exception into an <TT>IErrorInfo</TT> object and return the
error code of the exception to the calling application.
<H3><A NAME="Heading36"></A>Listing 3.24 TRACKER.CPP--Custom Interface Exception
Handling Code</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CTracker interface handlers <BR>
HRESULT CTracker::XSubDispatch::get_Indent(LONG * Indent) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
HRESULT hResult = S_OK; <BR>
try <BR>
{ <BR>
*Indent = pThis-&gt;GetIndent(); <BR>
} <BR>
catch(CException * pException) <BR>
{ <BR>
hResult = pThis-&gt;CreateErrorInfo(pException, IID_ITracker); <BR>
} <BR>
return hResult; <BR>
} <BR>
HRESULT CTracker::XSubDispatch::put_Indent(LONG Indent) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
HRESULT hResult = S_OK; <BR>
try <BR>
{ <BR>
pThis-&gt;SetIndent(Indent); <BR>
} <BR>
catch(CException * pException) <BR>
{ <BR>
hResult = pThis-&gt;CreateErrorInfo(pException, IID_ITracker); <BR>
} <BR>
return hResult; <BR>
} <BR>
HRESULT FAR EXPORT CTracker::XSubDispatch::OutputLines(VARIANT FAR* varOutputArray,
VARIANT varIndent, VARIANT_BOOL FAR* RetVal) <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
HRESULT hResult = S_OK; <BR>
try <BR>
{ <BR>
*RetVal = pThis-&gt;OutputLines(varOutputArray, varIndent); <BR>
} <BR>
catch(CException * pException) <BR>
{ <BR>
hResult = pThis-&gt;CreateErrorInfo(pException, IID_ITracker); <BR>
} <BR>
return hResult; <BR>
<BR>
} </TT></FONT></P>
<P>You've covered all of the basics of ActiveX server creation and use by applications
other than your own. What if you need to create and use the server from within the
application in which it is defined? Or perhaps your application contains more than
one server implementation, with only one server being exposed as a creatable object
and with the remaining servers being created only in response to a valid method call
in the exposed server. These are referred to as <I>nested objects</I>.
<H2><A NAME="Heading37"></A>Server Instantiation Using C++</H2>
<P>OLE is not the only method for creating and using Automation Servers. This chapter
will show you how to instantiate Automation Servers using C++ syntax.</P>
<P>At times, instantiating and using Automation Servers is necessary from within
the application in which they are defined. Take, for example, a case where an application
contains three servers, only one of which is directly creatable by outside applications
using OLE. The remaining two servers can be created by the exposed server using C++
and returned via a method call to another application, which then uses the server
as though it was created via OLE.</P>
<P>As we stated earlier in this chapter, in order for an application to be created
by another application using OLE, the server must include the MFC macros <TT>DECLARE_OLECREATE</TT>
and <TT>IMPLEMENT_OLECREATE</TT>. By removing or not including these macros, an application
cannot be instantiated using standard OLE server creation mechanisms. That fact,
however, does not prevent the server from being created using C++ and MFC. Note,
though, that any OLE server can be created in this fashion, as opposed to just those
that are not creatable through standard OLE mechanisms.</P>
<P>MFC supports a facility for creating OLE servers using a helper class known as
<TT>CRuntimeClass</TT>.</P>
<P>The <TT>CRuntimeClass</TT> can be used to create servers that will be used internally
to the application in which they are defined and externally as a return or parameter
value supplied to another application. To support <TT>CRuntimeClass</TT> creation
of objects, a class must define either the <TT>IMPLEMENT_DYNAMIC</TT>, <TT>IMPLEMENT_DYNCREATE</TT>,
or the <TT>IMPLEMENT_SERIAL</TT> macros within their class implementation, which
is true for any MFC class inherited for <TT>Cobject</TT>, and not just those classes
that utilize OLE.</P>
<P>The following listing is not included in the sample applications because of its
simplicity. We have, however, used the <TT>CTracker</TT> server as our example server.
To create a server using the <TT>CRuntimeClass</TT>, perform the following steps:</P>
<P><FONT COLOR="#0066FF"><TT><BR>
// create a CTracker runtime object <BR>
CRuntimeClass * pRuntimeClass = RUNTIME_CLASS(CTracker); <BR>
// create an CTracker OLE object <BR>
CTracker * opTracker = (CTracker *) pRuntimeClass-&gt;CreateObject(); <BR>
. . . // use the object in anyway that is appropriate for the application <BR>
// finished with the object - destroy it <BR>
<BR>
delete opTracker; </TT></FONT></P>
<P>After an object is created, it can then also be passed to another application.
MFC supports two functions for retrieving OLE interfaces from a running server: <TT>GetIDispatch</TT>
and <TT>GetInterface</TT>. <TT>GetIDispatch</TT> is defined in the VC++ help file,
but the <TT>GetInterface</TT> function is not. <TT>GetInterface</TT> accepts a single
parameter of an <TT>IID</TT> of the interface that is being requested. <TT>GetInterface</TT>
will not increment the reference count of the pointer that is returned. The <TT>GetIDispatch</TT>
function gives you the option. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>Problems Associated with Instantiating OLE Servers Using C++</B><BR>
	Two problems arise when instantiating OLE components using C++: reference counting
	and in-process versus out-of-process execution. For reference counting, the problems
	can be that too many or too few reference counts exist on the server being used.
	Reference counting problems can arise regardless of how the server is instantiated,
	with either C++ or OLE. The problem is really relative to using servers in one to
	many relationships. All of the applications that use the same server must <TT>AddRef</TT>
	and <TT>Release</TT> the server properly to prevent problems. Reference counting
	problems manifest themselves as either the server terminating before it should or
	not terminating when it should. Be sure to check that all reference counts are being
	incremented and decremented correctly when creating and using objects in a one-to-many
	relationship or when a server is created and passed to another application. The next
	problem that can arise is far more subtle and easier to miss, although the effects
	can be dramatic and obvious and involve the server's execution model. A server is
	not guaranteed to execute in-process to the application that is using it--only with
	the application that created it.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">

<DL>
	<DT>Application A creates and uses an in-process server called Server 1. At some
	point, Application A creates an out-of-process server called Application B. Application
	A passes Server 1 to Application B. Server 1 will execute as an out-of-process server
	to Application B since the server was created in the process space of Application
	A. This is important to keep in mind when creating and using nested objects or shared
	objects since the performance differences between the two is so great.</DT>
</DL>

<P>So far you've only looked at how to create individual instances of objects. Next
you will look at how to share objects.
<H2><A NAME="Heading38"></A>Shared Servers</H2>
<P>OLE defines a facility for sharing objects called the <I>Running Object Table.
</I>Essentially, a shareable object will publish its <TT>CLSID</TT> and an <TT>IUnknown</TT>
reference to itself in the Running Object Table. Any application that so desires
can ask for the running instance of the object rather than create a new instance.
Using shared objects is useful for applications that may need to work with a single
running instance of an application rather than create multiple copies. The Tracker
object is a perfect candidate for this kind of functionality. Multiple applications
could use the same Tracker object to log information, thus saving on memory.</P>
<P>The first step in enabling shared object support is to add a member variable to
store the ID that will identify the object in the Running Object Table. This ID must
be retained since it is used later in revoking the object from the Running Object
Table when the object is destroyed. For the sample implementation, you add the variable
as a public member of the class (see Listing 3.25).
<H3><A NAME="Heading39"></A>Listing 3.25 TRACKER.H--Shared Object Member Variable
Added to the CTracker Class</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
END_INTERFACE_PART(SubDispatch) <BR>
public: <BR>
DWORD m_dwRegister; <BR>
protected: <BR>
FILE * m_fileLog; <BR>
<BR>
. . . </TT></FONT></P>
<P>When registering a server in the Running Object Table, you use the <TT>CLSID</TT>
of the <TT>CoClass</TT> object to identify the object in the table. Your implementation
requires that you declare the <TT>CLSID</TT> of the <TT>CoClass</TT> object in the
source file. The <TT>CLSID</TT> is copied from the TrackerInterface.h header file
and added to the source file. The line before the <TT>CLSID</TT> should be the include
file initguid.h; this file is needed to properly declare the <TT>CLSID</TT> and resolve
it to the compiler.
<H3><A NAME="Heading40"></A>Listing 3.26 TRACKER.CPP--CLSID Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
static const IID IID_ITracker = <BR>
{ 0x11c82946, 0x4edd, 0x11d0, { 0xbe, 0xd8, 0x0, 0x40, 0x5, 0x38, 0x97, 0x7d } <BR>
#include &lt;initguid.h&gt; <BR>
DEFINE_GUID(CLSID_TRACKER,0x11C82947L,0x4EDD,0x11D0,0xBE,0xD8,0x00,0x40,0x05, 0x38,0x97,0x7D);
<BR>
BEGIN_INTERFACE_MAP(CTracker, CCmdTarget) <BR>
<BR>
. . . </TT></FONT></P>
<P>Next you add the code to the server that registers the object as running in the
Running Object Table. Listing 3.27 shows the implementation of the <TT>CTracker</TT>
shared object support in the constructor of the <TT>CTracker</TT> class. The specifics
of your server will determine the exact location where you register it as running.
For your implementation, the constructor is fine. Other implementations may be dependent
on a particular state being reached in the server before registering the server.
The decision is completely up to you and your specific implementation.</P>
<P>In your implementation, the first step is to clear the member variable. The implementation
is dependent on this member to identify whether the object was successfully registered
as running or not. Next you retrieve the <TT>IUnknown</TT> reference for the object
and, if successful, pass it along with an address of the member variable to the <TT>RegisterActiveObject</TT>
function. You specify a strong registration that will result in an extra reference
count on the server to keep it in memory. If you didn't register the server, you
make sure to clear the member variable, just to be safe.
<H3><A NAME="Heading41"></A>Listing 3.27 TRACKER.CPP--RegisterActiveObject Added
to the CTracker Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
EnableAutomation(); <BR>
// make sure that the application won't unload until the reference count is <BR>
::AfxOleLockApp(); <BR>
// clear the member <BR>
m_dwRegister = NULL; <BR>
// QI for the IUnknown - remember no AddRef <BR>
LPUNKNOWN pIUnknown = this-&gt;GetInterface(&amp;IID_IUnknown); <BR>
<BR>
// if we have an IUnknown <BR>
if(pIUnknown) <BR>
{ <BR>
// register the clsid as an active object so other applications will get the same
object <BR>
if(::RegisterActiveObject(pIUnknown, CLSID_TRACKER, <BR>
<BR>
<BR>
<BR>
ACTIVEOBJECT_STRONG, &amp;m_dwRegister) != S_OK) <BR>
// make sure that the reference is clear <BR>
m_dwRegister = NULL; <BR>
} <BR>
// setup our timer resolution <BR>
m_lTimeBegin = timeBeginPeriod(1); <BR>
m_lHiResTime = m_lLastHiResTime = timeGetTime(); <BR>
<BR>
. . . </TT></FONT></P>
<P>The last step is to call <TT>RevokeActiveObject</TT> to remove the server from
the Running Object Table. This step is the most critical aspect of shared object
support. Do not add this code to the destructor of your server, as it will never
be called. The destructor is called in response to the destruction of the server,
which results from the server reference count reaching 0. But since the server has
an extra reference count from the <TT>RegisterActiveObject</TT> call, this state
is never reached. To ensure that you properly remove the server from the table, your
best course of action is to implement the revocation in the <TT>Release</TT> function
of the <TT>IUnknown</TT> implementation of your server so that the server's reference
count can be monitored. Listing 3.28 shows the implementation to revoke the object
from the Running Object Table. A call is made to decrement the reference count of
the server, and the return value is saved.</P>
<P>The next step is to see if the server has been registered as running, which is
implied through a non-zero value in the member variable. Then you check to see if
the reference count is 1. If the reference count is 1, the object is ready to be
destroyed since the only application now referencing the object is the Running Object
Table. Before calling <TT>RevokeActiveObject,</TT> it is important to increment the
reference count and clear the member variable. <TT>RevokeActiveObject</TT> will result
in a recursive call to <TT>Release</TT>, and you don't want to destroy the object
until you are finished with the first call to <TT>Release</TT>. After the <TT>RevokeActiveObject</TT>
call returns, call the <TT>Release</TT> function one last time to actually destroy
the object and remove it from memory.
<H3><A NAME="Heading42"></A>Listing 3.28 TRACKER.CPP--RevokeActiveObject Added to
the Server</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
ULONG FAR EXPORT CTracker::XSubDispatch::Release() <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
// call the function and check the refcount <BR>
long lRefCount = pThis-&gt;ExternalRelease(); <BR>
// if we are registered as running and there is the only refcount left <BR>
if(pThis-&gt;m_dwRegister &amp;&amp; lRefCount == 1) <BR>
{ <BR>
// bump our refcount up so we don't destroy ourselves until we are done <BR>
pThis-&gt;ExternalAddRef(); <BR>
// get the registration ID <BR>
DWORD tdwRegister = pThis-&gt;m_dwRegister; <BR>
// clear the member variable to prevent us from hitting this method again <BR>
pThis-&gt;m_dwRegister = 0; <BR>
// remove the interface from the running object table <BR>
::RevokeActiveObject(tdwRegister, NULL); <BR>
// the revoke should have decremented our refcount by one <BR>
// this call to Release should destroy our server <BR>
return pThis-&gt;ExternalRelease(); <BR>
} <BR>
// exit <BR>
return lRefCount; <BR>
} <BR>
<BR>
. . . </TT></FONT></P>
<P>During the lifetime of the server, you can get the same instance of the server
and use it from multiple applications. In VB, getting a running instance of a server
is done with the <TT>GetObject</TT> call, and in VC++, with the <TT>GetActiveObject</TT>
function. After the pointer to the server is retrieved, the server can be used as
though it was created through normal OLE mechanisms.</P>
<P>This method of sharing objects is fine but requires that the application using
the server take an active role in deciding to use the shared object versus an application
creating its own instance of the object. Another approach can be taken: You can supply
the instance of a running server to an application that calls <TT>CreateObject</TT>,
rather than relying on an application to call <TT>GetObject</TT>. This approach is
known as a single instance server.
<H2><A NAME="Heading43"></A>Single Instance Servers</H2>
<P>To support single instance servers, it is necessary to perform all of the steps
described earlier in this chapter, in the section &quot;Shared Servers,&quot; from
within the <TT>ClassFactory</TT> of the server and not from within the implementation
of the server itself. By implementing the object sharing code within the class factory,
you are able to control the number of instances of the server without having to rely
on the user of the server to program specifically for those cases.</P>
<P>Unfortunately, MFC does not provide simple access to the <TT>COleObjectFactory</TT>
class, which is responsible for creating OLE servers to allow for this kind of implementation.
C++ inheritance, however, allows you to create a new specialized version of the <TT>COleObjectFactory</TT>
class that can support server instance sharing.</P>
<P>We created the class <TT>COleObjectFactoryShared</TT> and several macros to speed
up your development. As can be seen in Listing 3.29, we created a new class derived
from the original MFC class <TT>COleObjectFactory</TT>. The class contains a constructor
and an interface map that routes messages from the <TT>IClassFactory</TT> and <TT>IClassFactory2</TT>
interfaces to the implementation. Last is a member variable that is used to store
the ID of the server after it has been loaded into the Running Object Table.</P>
<P>Two macros must be added to the server class declaration and implementation to
enable shared server support. <TT>DECLARE_OLECREATE_SHARED</TT> must replace the
<TT>DECLARE_OLECREATE</TT> macro in the class header file, and <TT>IMPLEMENT_OLECREATE_SHARED</TT>
must replace <TT>IMPLEMENT_OLECREATE</TT> in the server source file. The only difference
between the new macros and the originals is that a class factory of type <TT>COleObjectFactoryShared</TT>
will be added to the server implementation rather than a <TT>COleObjectFactory</TT>
class.
<H3><A NAME="Heading44"></A>Listing 3.29 SHAREDOBJECT.H--Shared Server Class Factory
Header File</H3>
<P><FONT COLOR="#0066FF"><TT>// <BR>
// Shared Server Class Factory <BR>
// <BR>
// Code based on COleObjectFactory (c) 1996,1997 Microsoft Corp <BR>
// <BR>
class COleObjectFactoryShared: public COleObjectFactory <BR>
{ <BR>
DECLARE_DYNAMIC(COleObjectFactoryShared) <BR>
// Construction <BR>
public: <BR>
COleObjectFactoryShared(REFCLSID clsid, CRuntimeClass* pRuntimeClass, <BR>
BOOL bMultiInstance, LPCTSTR lpszProgID); <BR>
// Interface Maps <BR>
public: <BR>
DECLARE_INTERFACE_MAP() <BR>
BEGIN_INTERFACE_PART(SubClassFactory, IClassFactory2) <BR>
STDMETHOD(CreateInstance)(LPUNKNOWN, REFIID, LPVOID*); <BR>
STDMETHOD(LockServer)(BOOL); <BR>
STDMETHOD(GetLicInfo)(LPLICINFO); <BR>
STDMETHOD(RequestLicKey)(DWORD, BSTR*); <BR>
STDMETHOD(CreateInstanceLic)(LPUNKNOWN, LPUNKNOWN, REFIID, BSTR, LPVOID*); <BR>
END_INTERFACE_PART(SubClassFactory) <BR>
public: <BR>
DWORD m_dwRegister; <BR>
}; <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// Macros for creating &quot;creatable and shareable&quot; automation classes. <BR>
#define DECLARE_OLECREATE_SHARED(class_name) \ <BR>
public: \ <BR>
static AFX_DATA COleObjectFactoryShared factory; \ <BR>
static AFX_DATA const GUID guid; <BR>
#define IMPLEMENT_OLECREATE_SHARED(class_name, external_name, l, w1, w2, b1, b2,
b3, b4, b5, b6, b7, b8) \ <BR>
AFX_DATADEF COleObjectFactoryShared class_name::factory(class_name::guid, \ <BR>
RUNTIME_CLASS(class_name), FALSE, _T(external_name)); \ <BR>
const AFX_DATADEF GUID class_name::guid = \ <BR>
<BR>
{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; </TT></FONT></P>
<P>Listing 3.30 shows the implementation of the <TT>COleObjectFactoryShared</TT>
class. The constructor defers to the base class and clears the <TT>m_dwRegister</TT>
member variable. As with the previous section, the <TT>m_dwRegsiter</TT> variable
is crucial to the success of the shared server support.</P>
<P>Next you route all messages from the <TT>IClassFactory</TT> and <TT>IClassFactory2</TT>
interfaces to the implementation of the functions. All but two of the functions defer
to the base class implementation without modification. <TT>CreateInstance</TT> and
<TT>CreateInstanceLic</TT> first check to see if an instance of the server is already
running. If not, the functions attempt to create the server using the base class
implementation of <TT>CreateInstanceLic;</TT> if so, the functions register the server
as running. If the server was already running, the function returns the <TT>IUnknown</TT>
of the existing object. Remember that when the server is registered as running, it
has an extra reference count. The code to manage the release of the server correctly
will remain almost unchanged from the implementation that you created earlier in
this chapter.
<H3><A NAME="Heading45"></A>Listing 3.30 SHAREDOBJECT.CPP--Shared Server Implementation
File</H3>
<P><FONT COLOR="#0066FF"><TT>// <BR>
// Shared Server Class Factory <BR>
// <BR>
// Code based on COleObjectFactory (c) 1996,1997 Microsoft Corp <BR>
// <BR>
#include &quot;stdafx.h&quot; <BR>
#include &quot;sharedobject.h&quot; <BR>
IMPLEMENT_DYNAMIC(COleObjectFactoryShared, COleObjectFactory) <BR>
COleObjectFactoryShared::COleObjectFactoryShared(REFCLSID clsid, <BR>
CRuntimeClass* pRuntimeClass, BOOL bMultiInstance, LPCTSTR lpszProgID) <BR>
:COleObjectFactory(clsid, pRuntimeClass, bMultiInstance, lpszProgID) <BR>
{ <BR>
// clear the registered server ID member <BR>
m_dwRegister = NULL; <BR>
} <BR>
BEGIN_INTERFACE_MAP(COleObjectFactoryShared, COleObjectFactory) <BR>
INTERFACE_PART(COleObjectFactoryShared, IID_IClassFactory, SubClassFactory) <BR>
INTERFACE_PART(COleObjectFactoryShared, IID_IClassFactory2, <BR>
END_INTERFACE_MAP() <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// Implementation of COleObjectFactoryShared::IClassFactory interface <BR>
STDMETHODIMP_(ULONG) COleObjectFactoryShared::XSubClassFactory::AddRef() <BR>
{ <BR>
METHOD_PROLOGUE_EX_(COleObjectFactoryShared, SubClassFactory) <BR>
return pThis-&gt;m_xClassFactory.AddRef(); <BR>
} <BR>
STDMETHODIMP_(ULONG) COleObjectFactoryShared::XSubClassFactory::Release() <BR>
{ <BR>
METHOD_PROLOGUE_EX_(COleObjectFactoryShared, SubClassFactory) <BR>
return pThis-&gt;m_xClassFactory.Release(); <BR>
} <BR>
STDMETHODIMP COleObjectFactoryShared::XSubClassFactory::QueryInterface( <BR>
REFIID iid, LPVOID* ppvObj) <BR>
{ <BR>
METHOD_PROLOGUE_EX_(COleObjectFactoryShared, SubClassFactory) <BR>
return pThis-&gt;m_xClassFactory.QueryInterface(iid, ppvObj); <BR>
} <BR>
STDMETHODIMP COleObjectFactoryShared::XSubClassFactory::CreateInstance( <BR>
IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObject) <BR>
{ <BR>
METHOD_PROLOGUE_EX_(COleObjectFactoryShared, SubClassFactory) <BR>
HRESULT hResult = S_OK; <BR>
// Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// see if the object is already running <BR>
::GetActiveObject(riid, NULL, &amp;pIUnknown); <BR>
// if we didn't get a reference to a running object <BR>
if(!pIUnknown) <BR>
{ <BR>
// create the server <BR>
hResult = pThis-&gt;m_xClassFactory.CreateInstanceLic(pUnkOuter, <BR>
NULL, riid, NULL, ppvObject); <BR>
// if successful <BR>
if(hResult == S_OK) <BR>
{ <BR>
// register the clsid as an active object so <BR>
// other applications will get the same object <BR>
if(::RegisterActiveObject((IUnknown*)*ppvObject, riid, <BR>
ACTIVEOBJECT_STRONG, &amp;pThis-&gt;m_dwRegister) != S_OK) <BR>
// clear the ID member <BR>
pThis-&gt;m_dwRegister = NULL; <BR>
} <BR>
else <BR>
// clear the ID member <BR>
pThis-&gt;m_dwRegister = NULL; <BR>
} <BR>
else <BR>
// use the running object <BR>
*ppvObject = pIUnknown; <BR>
return hResult; <BR>
} <BR>
STDMETHODIMP COleObjectFactoryShared::XSubClassFactory::LockServer(BOOL fLock) <BR>
{ <BR>
METHOD_PROLOGUE_EX(COleObjectFactoryShared, SubClassFactory) <BR>
return pThis-&gt;m_xClassFactory.LockServer(fLock); <BR>
} <BR>
STDMETHODIMP COleObjectFactoryShared::XSubClassFactory::GetLicInfo( <BR>
LPLICINFO pLicInfo) <BR>
{ <BR>
METHOD_PROLOGUE_EX(COleObjectFactoryShared, SubClassFactory) <BR>
return pThis-&gt;m_xClassFactory.GetLicInfo(pLicInfo); <BR>
} <BR>
STDMETHODIMP COleObjectFactoryShared::XSubClassFactory::RequestLicKey( <BR>
DWORD dwReserved, BSTR* pbstrKey) <BR>
{ <BR>
METHOD_PROLOGUE_EX(COleObjectFactoryShared, SubClassFactory) <BR>
return pThis-&gt;m_xClassFactory.RequestLicKey(dwReserved, pbstrKey); <BR>
} <BR>
STDMETHODIMP COleObjectFactoryShared::XSubClassFactory::CreateInstanceLic( <BR>
LPUNKNOWN pUnkOuter, LPUNKNOWN pUnkReserved, REFIID riid, <BR>
BSTR bstrKey, LPVOID* ppvObject) <BR>
{ <BR>
METHOD_PROLOGUE_EX(COleObjectFactoryShared, SubClassFactory) <BR>
HRESULT hResult = S_OK; <BR>
// clear the ID member <BR>
pThis-&gt;m_dwRegister = NULL; <BR>
// Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// see if the object is already running <BR>
::GetActiveObject(riid, NULL, &amp;pIUnknown); <BR>
// if we didn't get a reference to a running object <BR>
if(!pIUnknown) <BR>
{ <BR>
// create the server <BR>
hResult = pThis-&gt;m_xClassFactory.CreateInstanceLic(pUnkOuter, <BR>
pUnkReserved, riid, bstrKey, ppvObject); <BR>
// if successful <BR>
if(hResult == S_OK) <BR>
{ <BR>
// register the clsid as an active object <BR>
// so other applications will get the same object <BR>
if(::RegisterActiveObject((IUnknown*)*ppvObject, riid, <BR>
ACTIVEOBJECT_STRONG, &amp;pThis-&gt;m_dwRegister) != S_OK) <BR>
// clear the ID member <BR>
pThis-&gt;m_dwRegister = NULL; <BR>
} <BR>
} <BR>
else <BR>
// use the running object <BR>
*ppvObject = pIUnknown; <BR>
return hResult; <BR>
<BR>
} </TT></FONT></P>
<P>Now that the infrastructure is in place to support shared servers, you need to
add the new code to your application.</P>
<P>First the header file must be updated (see Listing 3.31). Replace the macro <TT>DECLARE_OLECREATE</TT>
with the new macro <TT>DECLARE_OLECREATE_SHARED</TT>. Since the sample application
was used for the section on how to implement shared servers, we have also commented
out the registered server ID member variable, <TT>m_dwRegister</TT>.
<H3><A NAME="Heading46"></A>Listing 3.31 TRACKER.H--Shared Server Class Factory Support
Added to the Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
afx_msg BOOL OutputLines(VARIANT FAR* varOutputArray, <BR>
const VARIANT FAR&amp; varIndent); <BR>
//}}AFX_DISPATCH <BR>
DECLARE_DISPATCH_MAP() <BR>
DECLARE_INTERFACE_MAP() <BR>
// DECLARE_OLECREATE(CTracker) <BR>
DECLARE_OLECREATE_SHARED(CTracker) <BR>
// add declaration of ISupportErrorInfo implementation <BR>
// to indicate we support the OLE Automation error object <BR>
DECLARE_DUAL_ERRORINFO() <BR>
HRESULT CreateErrorInfo(CException * pAnyException, REFIID riidSource); <BR>
// needed for dual interface support <BR>
BEGIN_INTERFACE_PART(SubDispatch, ITracker) <BR>
STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo); <BR>
STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, <BR>
ITypeInfo FAR* FAR* pptinfo); <BR>
STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, <BR>
UINT cNames, LCID lcid, DISPID FAR* rgdispid); <BR>
STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, <BR>
WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, <BR>
EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr); <BR>
STDMETHOD(get_Indent)(THIS_ long FAR* Value); <BR>
STDMETHOD(put_Indent)(THIS_ long Value); <BR>
STDMETHOD(OutputLines)(THIS_ VARIANT FAR* varOutputArray, <BR>
VARIANT varIndent, VARIANT_BOOL FAR* RetVal); <BR>
END_INTERFACE_PART(SubDispatch) <BR>
//public: <BR>
// DWORD m_dwRegister; <BR>
protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; <BR>
long m_lIndent; <BR>
<BR>
}; </TT></FONT></P>
<P>Next you must update the source file for your server (see Listing 3.32). Add the
include file SharedObject.h to resolve the macros and class name. In the sample,
we commented out the section of code within the constructor that registered the server
as running. You must also replace the macro <TT>IMPLEMENT_OLECREATE</TT> with <TT>IMPLEMENT_OLECREATE_SHARED</TT>.
<H3><A NAME="Heading47"></A>Listing 3.32 TRACKER.CPP--Shared Server Update to Class
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
#include &quot;stdafx.h&quot; <BR>
#include &quot;MFCServer.h&quot; <BR>
// shared object support <BR>
#include &quot;sharedobject.h&quot; <BR>
// error info support <BR>
#include &quot;ErrorInfoMacros.h&quot; <BR>
// ODL generated interface file <BR>
CTracker::CTracker() <BR>
{ <BR>
EnableAutomation(); <BR>
// make sure that the application won't unload until the reference count is <BR>
::AfxOleLockApp(); <BR>
// clear the member <BR>
/* m_dwRegister = NULL; <BR>
// QI for the IUnknown - remember no AddRef <BR>
LPUNKNOWN pIUnknown = this-&gt;GetInterface(&amp;IID_IUnknown); <BR>
<BR>
// if we have an IUnknown <BR>
if(pIUnknown) <BR>
{ <BR>
// register the clsid as an active object so other applications <BR>
// will get the same object <BR>
if(::RegisterActiveObject(pIUnknown, CLSID_TRACKER, ACTIVEOBJECT_STRONG, <BR>
&amp;m_dwRegister) != S_OK) <BR>
// make sure that the reference is clear <BR>
m_dwRegister = NULL; <BR>
} <BR>
*/ <BR>
// setup our timer resolution <BR>
m_lTimeBegin = timeBeginPeriod(1); <BR>
m_lHiResTime = m_lLastHiResTime = timeGetTime(); <BR>
// get the current date and time <BR>
CTime oTimeStamp = CTime::GetCurrentTime(); <BR>
CString cstrFileName; <BR>
// create a file name based on the date <BR>
cstrFileName.Format(_T(&quot;%s.tracklog&quot;), (LPCTSTR) oTimeStamp.Format(&quot;%Y%m%d&quot;));
<BR>
// open a file <BR>
m_fileLog = fopen(cstrFileName, _T(&quot;a&quot;)); <BR>
<BR>
// if we have a file handle <BR>
if(m_fileLog) <BR>
{ <BR>
// output some starting information <BR>
fprintf(m_fileLog, _T(&quot;************************\n&quot;)); <BR>
fprintf(m_fileLog, _T(&quot;Start %s\n&quot;), <BR>
(LPCTSTR) oTimeStamp.Format(&quot;%B %#d, %Y, %I:%M %p&quot;)); <BR>
fprintf(m_fileLog, _T(&quot;\n&quot;)); <BR>
} <BR>
m_lIndent = 0; <BR>
} <BR>
. . . <BR>
<BR>
IMPLEMENT_OLECREATE_SHARED(CTracker, _T(&quot;MFCServer.Tracker&quot;), 0x11C82947,
0x4edd, 0x11d0, 0xbe, 0xd8, 0x0, 0x40, 0x5, 0x38, 0x97, 0x7d) </TT></FONT></P>
<P>The last step is to add the code to revoke the server from the Running Object
Table (see Listing 3.33). As with the previous section, the management of the server's
lifetime is dependent on its reference count and is handled within the <TT>Release</TT>
function implementation. The only difference between this implementation and the
shared object implementation is the location of the <TT>m_dwRegister</TT> member
variable, which is now located in the <TT>COleObjectFactoryShared</TT> class.
<H3><A NAME="Heading48"></A>Listing 3.33 TRACKER.CPP--Shared Server Release Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>ULONG FAR EXPORT CTracker::XSubDispatch::Release() <BR>
{ <BR>
METHOD_PROLOGUE(CTracker, SubDispatch) <BR>
// call the function and check the refcount <BR>
long lRefCount = pThis-&gt;ExternalRelease(); <BR>
// if we are registered as running and there is the only refcount left <BR>
// if(pThis-&gt;m_dwRegister &amp;&amp; lRefCount == 1) <BR>
if(pThis-&gt;factory.m_dwRegister &amp;&amp; lRefCount == 1) <BR>
{ <BR>
// bump our refcount up so we don't destroy ourselves until we are done <BR>
pThis-&gt;ExternalAddRef(); <BR>
// get the registration ID <BR>
// DWORD tdwRegister = pThis-&gt;m_dwRegister; <BR>
DWORD tdwRegister = pThis-&gt;factory.m_dwRegister; <BR>
// clear the member variable to prevent us from hitting this method again <BR>
// pThis-&gt;m_dwRegister = 0; <BR>
pThis-&gt;factory.m_dwRegister = 0; <BR>
// remove the interface from the running object table <BR>
::RevokeActiveObject(tdwRegister, NULL); <BR>
// the revoke should have decremented our refcount by one <BR>
// this call to Release should destroy our server <BR>
return pThis-&gt;ExternalRelease(); <BR>
} <BR>
// exit <BR>
return lRefCount; <BR>
<BR>
} </TT></FONT></P>
<P>The implementation and use of shared and single instance server support is straightforward
and adds a level of functionality not normally found in standard server implementations.
<H2><A NAME="Heading49"></A>From Here...</H2>
<P>In this chapter, you learned how to create a basic implementation of an MFC Automation
Server. You also learned how to expand upon the basic framework provided by MFC to
create new and interesting features within your implementation.</P>
<P>Other areas where your server development has room to expand are in adding User
Interface, possibly in the form of dialogs and event interfaces. The use of the basic
MFC dialog classes can make implementation of UI a very easy and rewarding part of
your implementations. At the time of this writing, no container applications will
recognize either of these features within an Automation Server. If your implementation
has these requirements, you must decide how to implement them. The creation of services
and remote servers also makes the prospect of implementing Automation Servers very
enticing.</P>
<P>Every day more and more developers are enabling or integrating automation support
as a basic feature of their applications. Any situation that calls for the transfer
of data among applications can now be performed with OLE automation, whereas before
data transfer would have required the exchange of data using DDE or, even worse,
file import/export functions.</P>
<P>Automation Servers provide an easy and flexible way to create lightweight ActiveX
components for use by your applications. The support of both <TT>IDispatch</TT> interfaces
and custom interfaces (a Dual-Interface Server) also gives the user of the server
a lot of flexibility in terms of implementation styles and methods.</P>

<P><A HREF="ch04.htm">Chapter 4</A> looks at how to create an Automation Server using
the ActiveX Template Library (ATL).


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
