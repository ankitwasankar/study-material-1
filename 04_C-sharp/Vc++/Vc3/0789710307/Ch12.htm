<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 11:44 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 12</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 12<BR>
Creating ActiveX COM Objects and Custom Interfaces Using MFC</H1>

<UL>
	<LI><A HREF="#Heading1">Creating ActiveX COM Objects and Custom Interfaces Using
	MFC</A>
	<UL>
		<LI><A HREF="#Heading2">Anatomy of a COM Object</A>
		<LI><A HREF="#Heading3">Tools Needed for Building COM Objects</A>
		<UL>
			<LI><A HREF="#Heading4">MIDL Compiler</A>
			<LI><A HREF="#Heading5">GUIDGEN</A>
			<LI><A HREF="#Heading6">RegEdit</A>
			<LI><A HREF="#Heading7">Registration Server</A>
			<LI><A HREF="#Heading8">Adding the Tools to the Visual C++ Development Environment</A>
		</UL>
		<LI><A HREF="#Heading9">Defining COM Interfaces Using IDL</A>
		<UL>
			<LI><A HREF="#Heading10">Creating the IFISH Project</A>
			<LI><A HREF="#Heading11">Creating the Interface Definition</A>
			<LI><A HREF="#Heading12">Listing 12.1 IFISH.IDL--Interface Definition for IFish</A>
			<LI><A HREF="#Heading13">Listing 12.2 IBASS.IDL--Interface Definition for IBass</A>
			<LI><A HREF="#Heading14">Compiling the Interface Definition Files</A>
			<LI><A HREF="#Heading15">Creating a Definition File</A>
			<LI><A HREF="#Heading16">Listing 12.3 DLL LIBRARY--Definition File for IFISH.DLL</A>
			<LI><A HREF="#Heading17">Adding the RPC Libraries to the Interface Project</A>
			<LI><A HREF="#Heading18">Listing 12.4 RPCHELP.C--Compiler Pragmas Used for Referencing
			RPC Libraries</A>
			<LI><A HREF="#Heading19">Registering the Interfaces</A>
			<LI><A HREF="#Heading20">Listing 12.5 IFISH.REG--Contexts of IFISH.REG File Used
			to Register the Interfaces Supported by the IFISH.DLL</A>
		</UL>
		<LI><A HREF="#Heading21">Implementing the Interface</A>
		<UL>
			<LI><A HREF="#Heading22">Using the Visual C++ AppWizard to Create the COM Object</A>
			<LI><A HREF="#Heading23">Accessing In-Process COM Objects</A>
			<LI><A HREF="#Heading24">Listing 12.6 BASS.DEF--BASS Definition File with the COM
			Support Functions Explicitly Exported</A>
			<LI><A HREF="#Heading25">Listing 12.7 BASS.CPP--DLlGetClassObject Implementation
			Code Inserted by the MFC AppWizard</A>
			<LI><A HREF="#Heading26">Listing 12.8 DLLCanUnloadNow--Implementation Code Inserted
			by the MFC AppWizard</A>
			<LI><A HREF="#Heading27">Listing 12.9 DllRegisterServer--Implementation Code Inserted
			by the MFC AppWizard</A>
			<LI><A HREF="#Heading28">Creating a Class that Implements COM Interfaces</A>
			<LI><A HREF="#Heading29">Listing 12.10 COMMACROS.H--COM Macros Used for Accessing
			the IUnknown Implementation of CCmdTarget</A>
			<LI><A HREF="#Heading30">Listing 12.11 BASSID.H--Header File bassid.h that Contains
			the Implementation of CLSID for the CBass Class</A>
			<LI><A HREF="#Heading31">Listing 12.12 BASS.H--Header File for the CBass Class (bass.h)</A>
			<LI><A HREF="#Heading32">Listing 12.13 BASS.CPP--Complete Implementation File for
			CBass object (Bass.cpp)</A>
		</UL>
		<LI><A HREF="#Heading33">Using the Interface</A>
		<UL>
			<LI><A HREF="#Heading34">OLE Initialization and Shutdown Functions</A>
			<LI><A HREF="#Heading35">Listing 12.14 COMTEST.CPP--Initialization and Removal of
			OLE Libraries within an MFC Application</A>
			<LI><A HREF="#Heading36">COM Object Access Functions</A>
			<LI><A HREF="#Heading37">Listing 12.15 Comtestview.cpp--Test Function Used for Accessing
			the IFish and IBass Interfaces</A>
		</UL>
		<LI><A HREF="#Heading38">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Creating ActiveX COM Objects and Custom Interfaces Using
MFC</H1>

<UL>
	<LI><B>Supporting COM with MFC</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 While MFC does not utilize COM directly, the MFC architects did provide support
	mechanisms that make adding COM functionality an easy task.
	<P>
	<LI><B>Adding COM tools to the Visual C++ development environment</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The implementation of COM Objects requires new tools, such as the MIDL compiler,
	that are outside the scope of traditional application development.
	<P>
	<LI><B>Creating a basic Component Object using MFC</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Examine the implementation and details of the two types of component objects, in-process
	(DLL) and out-of-process (EXE).
	<P>
	<LI><B>Defining a COM interface using the Interface Definition Language (IDL)</B>
	
<SPACER TYPE="VERTICAL" SIZE="2">
 The Interface Definition Language is used for defining your COM Object interface.
	<P>
	<LI><B>Setting up and installing COM Objects</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Installing and using a COM Object is a straightforward process, but you need to
	be aware of a few trouble spots.
</UL>

<P>ActiveX is a strategic technology base for Internet programming and distributed
computing. While ActiveX is the successor for OLE (Object Linking and Embedding),
OLE still forms the foundation of ActiveX programming. The basis for ActiveX is to
provide an object-oriented solution for solving problems encountered in developing
operating systems and applications. ActiveX provides the specifications necessary
to create component software that ultimately benefits the computing industry.</P>
<P>At the core of ActiveX is an extremely powerful and extensible architecture called
the <I>Component Object Model (COM)</I>. COM provides a simple yet elegant solution
for solving complex software problems such as accessing objects and services outside
of application boundaries and version control. COM solves these problems through
the use of binary components that are running in the system rather than by developing
source code components within an application.</P>
<P>If you are using the Visual C++ compiler from Microsoft, chances are very high
that you are also using the Microsoft Foundation Classes (MFC) as the building blocks
for your applications and components. MFC is a powerful set of base classes that
provide a framework of abstractions into the Windows SDK for developing Win32 applications
and components.</P>
<P>Classes within the MFC framework are not directly derived from COM interfaces.
However, the architects of MFC have provided direct support for adding COM to any
MFC-based component or application. The roots for supporting COM within MFC lie in
wrappers called <I>Interface maps. </I>Interface maps are similar to message maps
(which are used for distributing Windows messages to MFC classes) in both concept
and execution.
<H2><A NAME="Heading2"></A>Anatomy of a COM Object</H2>
<P>COM Objects give software developers the ability to leverage object-oriented software
techniques for solving application and operating system development issues. The COM
specification is not geared toward a specific language, although C++ is a natural
choice when developing COM Objects. Four basic components compose a COM Object:

<UL>
	<LI>Classes--A <I>class</I> is a data structure with a set of interfaces used for
	accessing and manipulating the data structure. This definition is analogous to C++
	class. The difference is that COM allows a class created in any language to be registered
	with the operating system and to be used in a language-independent manner.
	<P>
	<LI>Objects--An <I>object</I> is an instance of a class created during program execution.
	In C++, an object is typically created via the <TT>new</TT> operator. When using
	COM, COM Objects are created through the function <TT>CoCreateInstance</TT>. Many
	instances of an object can be created.
	<P>
	<LI>Interfaces--An <I>interface </I>is a group of functions (often called methods)
	that are part of a class. The interface functions are used to directly manipulate
	the data in a class. ActiveX is based on a set of COM interfaces. Of the set of ActiveX
	interfaces, the two that must be supported by COM Objects are <TT>IUnknown</TT> and
	<TT>IClassFactory</TT>.
	<P>
	<LI>GUIDs--A GUID (Global Unique Identifier) is an 8-byte number that provides a
	unique identifier for each COM Object. <TT>GUID</TT>s are generated by a tool called
	<TT>GUIDGEN</TT>. Each COM class <I>must</I> have two <TT>GUID</TT>s, one for the
	Class ID and one for the Interface ID.
</UL>

<P>The <I>class ID </I>(<TT>CLSID</TT>) is an identifier for the COM class. This
key is registered in the Windows Registry and contains a pointer (path) to where
the DLL (Dynamic Link Library) or EXE containing the class can be located. The <TT>CLSID</TT>
can be found in the Windows Registry under the path HKEY_CLASSES_ROOT\CLSID.</P>
<P>The <I>Interface ID </I>(<TT>IID</TT>) is an identifier for the interface to the
class. The <TT>IID</TT> is used by applications to query and invoke the methods into
the class. The <TT>IID</TT> is also contained in the Windows Registry and can be
found in the path HKEY_CLASSES_ROOT\Interface. Figure 12.1 illustrates the relationship
among class, interfaces, and <TT>IID</TT>. <BR>
<BR>
<A HREF="art/12/ifig01.jpg"><B>FIG. 12.1</B></A> <BR>
<I>Relationship of COM Classes and Interfaces.</I></P>
<P>What COM provides to software developers is an object-oriented solution for building
and maintaining software solutions. Programmers using non-object-oriented languages
such as Visual Basic can develop and use COM components to build software solutions.</P>
<P>COM also provides a unique solution to the version control problems present in
many of today's software solutions. Since COM Objects are binary components, developers
do not have to worry about new or updated versions of a component being placed on
a computer where their application is running. The reason for this is that COM deals
with interfaces. If an interface is enhanced, new methods can be added to the interface,
or additional interfaces can be obtained without breaking an existing application.
COM's solution to version control provides a great method for upgrading applications
while preserving legacy systems.
<H2><A NAME="Heading3"></A>Tools Needed for Building COM Objects</H2>
<P>When creating your COM Objects, a few tools must be installed on your computer.
Most of these tools are automatically installed as part of the Visual C++ development
environment.
<H3><A NAME="Heading4"></A>MIDL Compiler</H3>
<P>The Microsoft MIDL compiler is now a standard component of the Microsoft Visual
C++ environment. The MIDL compiler compiles COM interface definitions into C code,
which is then compiled into the project by the Visual C++ compiler. Figure 12.2 illustrates
the purpose of the MIDL compiler. <B><BR>
<BR>
</B><A HREF="art/12/ifig02.jpg"><B>FIG. 12.2</B></A> <I><BR>
Inputs and outputs of the MIDL compiler.</I></P>
<P>The MIDL compiler also provides support for marshaling interfaces across process
boundaries. Starting with Visual C++ 4.0, the MIDL compiler was shipped as a standard
component of Visual C++. The MIDL compiler is also available with the Win32 SDK from
Microsoft.
<H3><A NAME="Heading5"></A>GUIDGEN</H3>
<P><TT>GUIDGEN</TT> is a tool used to generate Global Unique Identifiers (<TT>GUID</TT>),
which can be used for Interface IDs, Class IDs, or any other 128-bit <TT>UUID</TT>,
such as an <TT>RPC</TT> interface. <TT>GUIDGEN</TT> is installed when the OLE development
option is selected during the Visual C++ installation. When <TT>GUIDGEN</TT> is run,
you must select the proper format for the <TT>UUID</TT> and then press the New <TT>GUID</TT>
button to copy the <TT>UUID</TT> to the Windows Clipboard. After running the <TT>GUIDGEN</TT>
application, the resulting <TT>GUID</TT> is pasted from the Clipboard into the code
that needs a <TT>GUID</TT>. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The tool <TT>GUIDGEN</TT> is also installed by default if the option
	Typical is selected during the Visual C++ 5.0 installation.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading6"></A>RegEdit</H3>
<P><TT>RegEdit</TT> or the registration editor is a standard component of both the
Windows 95 and Windows NT operating systems. The registration editor is used for
browsing and altering operating system and application settings. The registration
editor can also be used for installing and registering your COM Objects. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>CAUTION:<BR>
	</B><TT>RegEdit</TT> is a powerful tool and must be used with extreme caution by
	experienced users. If used improperly, systems can be damaged, resulting in a loss
	of data or a malfunctioning computer.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
In Windows 95, this program is called regedit.exe. In Windows NT, this program is
called regedt32.exe.
<H3><A NAME="Heading7"></A>Registration Server</H3>
<P>The <I>registration server </I>is an application that can be used to register
the settings of a COM Object in the Windows registry without the need to create a
separate registration file. The application is called regsvr32.exe and is automatically
installed if the OLE development option is selected during Visual C++ installation
or if the ActiveX SDK is installed.
<H3><A NAME="Heading8"></A>Adding the Tools to the Visual C++ Development Environment</H3>
<P>In order to maximize development productivity, the tools needed for COM programming
should be integrated into the Visual C++ environment. Each of the tools needed can
be added to the IDEs (Integrated Development Environment) <U>T</U>ools menu. The
following sections illustrate how to incorporate the tools into the IDE. <B><BR>
<BR>
Adding the MIDL Compiler to the IDE </B><SPACER TYPE="HORIZONTAL" SIZE="10">Adding
the MIDL compiler to the IDE allows for easy compilation of an IDL (Interface Definition
Language) file. After adding this command, an IDL file can be compiled, and the MIDL
compiler will generate a C source file with all appropriate parameter marshaling
code. To add the MIDL compiler to the Visual C++ environment:

<OL>
	<LI>Select the <U>C</U>ustomize command from the <U>T</U>ools menu. Select the Tools
	tab from the Customize dialog.
	<P>
	<LI>In the <U>C</U>ommand edit box, type <B>MIDL.EXE</B>.
	<P>
	<LI>In the <U>M</U>enu contents edit box, type <B>Compile &amp;IDL File</B>.
	<P>
	<LI>In the Argume<U>n</U>ts edit box, type <B>/ms_ext /char unsigned /c_ext $FileName</B>.
	<P>
	<LI>In the <U>I</U>nitial directory edit box, type <B>$FileDir</B>.
	<P>
	<LI>Click the check box <U>U</U>se Output Window (the box should already be checked).
	<P>
	<LI>In the completed Customize dialog, click the Close button to add the entry to
	the <U>T</U>ools menu (see fig. 12.3).
</OL>

<P><A HREF="art/12/ifig03.jpg"><B>FIG. 12.3</B></A> <BR>
<I>Add your tools settings for the MIDL compiler in the Customize dialog.</I></P>
<P><B>Adding <I>GUIDGEN</I> </B><SPACER TYPE="HORIZONTAL" SIZE="10">Adding <TT>GUIDGEN</TT>
to the Visual C++ environment enables the generation of a <TT>UUID</TT> from a single
menu command. As stated earlier, the generated <TT>UUID</TT> is placed in the Windows
Clipboard and must be pasted into the project code. To add <TT>GUIDGEN</TT> to the
Visual C++ development environment:

<OL>
	<LI>Select the <U>C</U>ustomize command from the <U>T</U>ools menu. Select the Tools
	tab from the Customize dialog.
	<P>
	<LI>In the <U>C</U>ommand edit box, type <B>GUIDGEN.EXE</B>.
	<P>
	<LI>In the <U>M</U>enu contents edit box, type <B>&amp;Generate New UUID</B>.
	<P>
	<LI>Clear all text from the Argume<U>n</U>ts edit box.
	<P>
	<LI>Clear all text from the <U>I</U>nitial Directory edit box.
	<P>
	<LI>Click the Close button to add the entry to the <U>T</U>ools menu.
</OL>

<P><B>Adding the Registry Editor </B><SPACER TYPE="HORIZONTAL" SIZE="10">The Registry
Editor serves two purposes: to add registration information to the Windows registry
and to browse the registry to view information. To add the Registry Editor to the
Visual C++ environment, follow these steps:

<OL>
	<LI>Select the <U>C</U>ustomize command from the <U>T</U>ools menu. Select the Tools
	tab from the Customize dialog.
	<P>
	<LI>In the <U>C</U>ommand edit box, type <B>REGEDIT.EXE</B> if the development platform
	is Windows 95. Type <B>REGEDT32.EXE</B> if the development platform is Windows NT.
	<P>
	<LI>In the <U>M</U>enu contents edit box, type <B>&amp;Registry Editor</B>.
	<P>
	<LI>Clear all text from the Argume<U>n</U>ts edit box.
	<P>
	<LI>In the <U>I</U>nitial directory edit box, type <B>$FileDir</B>.
	<P>
	<LI>Click the Close button to add the entry to the <U>T</U>ools menu.
</OL>

<P><B>Adding the Registration Server</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>If
the ActiveX Control option was selected during the Visual C++ installation, the registration
server is already installed as the Regis<U>t</U>er Control command from the <U>T</U>ools
menu. If you have not installed the ActiveX Control option, installing it now adds
the appropriate files and menu items to the Visual C++ development environment.
<H2><A NAME="Heading9"></A>Defining COM Interfaces Using IDL</H2>
<P>A <I>COM interface </I>is a group of functions used to manipulate the data of
the class that is implementing the interface. Interfaces only <I>define</I> the functions
that belong to the group. An interface does not implement the function or contain
data. The function implementation and data belong to the class that implements the
interface.</P>
<P>ActiveX is based entirely on a set of COM interfaces. These COM interfaces are
a standard part of the operating system. In other words, Windows 95 and Windows NT
contain all of the code that implement the ActiveX COM interfaces.</P>
<P>When building new components based on COM, these components define <I>custom</I>
interfaces. A custom interface is an interface that is not already supported by the
operating system. A custom interface contains a set of functions that are specific
to the new component being built. For example, a spell-checker component may contain
a custom interface that contains a set of functions used by a program that uses the
spell-checker component. Once an interface is defined, multiple components may be
built that support and implement the interface.</P>
<P>Going back to the spell-checker component, a defined spell-checker interface may
be implemented by multiple companies. Having multiple companies provide a component
with the same interface gives application developers the flexibility to have all
of the components exist on a system, yet provide the user with the ability to load
and use a specific company's spelling checker.</P>
<P>When creating a custom interface, the interface definitions need to be shared
among multiple applications, such as the server that implements the interface and
the client that uses the interface. For this reason, it makes sense to define the
interfaces in a project separate from the server or client projects. Multiple interfaces
can be defined within a single project.</P>
<P>In this chapter, we develop three projects to implement and use COM Objects. Table
12.1 shows the project names and the purpose of each project. <BR>
<BR>

<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 12.1</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Chapter 12 Project Descriptions</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Project Name</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Purpose</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">IFISH (IFISH.DLL)</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Implements a COM interface definition.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">BASS (BASS.DLL)</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Contains an MFC class that implements the COM interfaces in IFISH.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">COMTEST (COMTEST.EXE)</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Sample Test application that uses the BASS COM Object.</TD>
	</TR>
</TABLE>
<BR>
<BR>
The project IFISH defines two COM interfaces, the <TT>IFish</TT> interface and the
<TT>IBass</TT> interface. The <TT>IFish</TT> interface is a <I>base </I>class for
all of the different species of fish. The <TT>IBass</TT> interface is an interface
specific to a particular type of fish. Both of these interface definitions will be
implemented within the IFISH project.
<H3><A NAME="Heading10"></A>Creating the IFISH Project</H3>
<P>The IFISH project contains two COM interface definitions, <TT>IFish</TT> and <TT>IBass</TT>.
The project IFISH is implemented as a DLL. The DLL does not contain any MFC code
or written C\C++ code. The code contained within IFISH is produced by the MIDL compiler.
The MIDL compiler takes the interface definition files (IDL) as input and produces
C code for the interface as output. The C code that is produced is needed to implement
<I>parameter marshaling. </I>Parameter marshaling is needed if the COM interface
is implemented in an executable (EXE). The marshaling allows the parameters to be
passed across process boundaries.</P>
<P>Even if the COM interface implementation is in a DLL (in-process server), the
MIDL compiler should still be used. There are no penalties for implementing parameter
marshaling. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The IFISH project is built as a DLL. This is not the DLL that is
	implementing the COM interface. IFISH contains only the interface definitions. Projects
	that <I>contain</I> the interface definitions should be implemented as DLLs.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Perform the following steps in order to create the IFISH project:

<OL>
	<LI>From within the Visual C++ development environment, select the command <U>N</U>ew
	from the <U>F</U>ile menu.
	<P>
	<LI>Select Projects tab from the New dialog.
	<P>
	<LI>Select Dynamic Link Library (see fig. 12.4). Enter the project name into the
	Project <U>n</U>ame edit box. The project is named IFISH. Select the OK button.
	<P><A HREF="art/12/ifig04.jpg"><B>FIG. 12.4</B></A> <I><BR>
	Select the project attributes for IFISH in the New dialog.</I></P>
	<LI>The project IFISH is now created.
</OL>

<H3><A NAME="Heading11"></A>Creating the Interface Definition</H3>
<P>When creating the interface definition, you must determine whether marshaling
code is needed to provide support for passing parameters between two processes. The
safest method is to always assume that marshaling is needed. Providing marshaling
support also allows the freedom to create either an in-process server (DLL) or an
out-of-process server (EXE) to implement the interface.</P>
<P>Use of the Microsoft RPC MIDL compiler provides parameter marshaling support.
Parameter marshaling is automatically provided by defining the COM interface with
the <I>Interface Definition Language</I> (IDL). Once the interface is defined using
IDL, the RPC MIDL compiler automatically generates the code necessary for marshaling
support.</P>
<P>Two interface definition files are used in the IFISH project, IFISH.IDL and IBASS.IDL
(see Listing 12.1).
<H3><A NAME="Heading12"></A>Listing 12.1 <SPACER TYPE="HORIZONTAL" SIZE="10">IFISH.IDL--Interface
Definition for IFish</H3>
<P><FONT COLOR="#0066FF"><TT>[ <BR>
object, <BR>
uuid(011BB310-5AB0-11d0-907E-00A0C91FDE82), <BR>
pointer_default(unique) <BR>
] <BR>
interface IFish : IUnknown <BR>
{ <BR>
import &quot;unknwn.idl&quot;; <BR>
HRESULT IsFreshwater([out] BOOL *pBool); <BR>
HRESULT GetFishName([out, string, size_is(255)] char *p); } </TT></FONT></P>
<P>All interface definition files have the extension IDL. The first portion of the
IDL file contains an object definition section. The most important part of this section
is the <TT>UUID</TT> of the object. The <TT>UUID</TT> is a unique 128-bit number
that is created through the tool <TT>GUIDGEN</TT>. The <TT>UUID</TT> in IFISH.IDL
distinctly identifies the <TT>IFish</TT> COM interface definition. This number is
used by applications that will use the <TT>IFish</TT> interface.</P>
<P>A unique <TT>UUID</TT> number can be generated by performing the following steps:

<OL>
	<LI>From the Visual C++ development environment, select the command <U>G</U>enerate
	New UUID, located under the <U>T</U>ools menu. (<I>Note: </I>This command was added
	earlier to the <U>T</U>ools menu, as shown in the section &quot;Adding GUIDGEN&quot;).
	The Create GUID dialog is displayed (see fig. 12.5).
	<P><A HREF="art/12/ifig05.jpg"><B>FIG. 12.5</B></A> <I><BR>
	Use the Create GUID dialog to generate unique identifiers for COM interfaces.</I></P>
	<LI>From the dialog, under <TT>GUID</TT> Format, select Registry Format [i.e., {XXXXXXX-XXXX...XXXX}].
	<P>
	<LI>Select the <U>C</U>opy button. This option copies the new <TT>UUID</TT> into
	the Windows Clipboard.
	<P>
	<LI>Select E<U>x</U>it to close the GUIDGEN dialog.
	<P>
	<LI>In the interface definition file, paste the contents of the Clipboard (that is,
	the new <TT>UUID</TT>) into the <TT>UUID</TT> section of the IDL file. This is the
	unique identifier used for your interface. If another <TT>GUID</TT> is needed, you
	can press the <U>N</U>ew GUID button and then copy the second <TT>GUID</TT> from
	the Clipboard.
</OL>

<P>Following the object definition section is the actual interface definition. As
shown in Listing 12.1, the object definition resembles a C++ class definition. The
keyword interface specifies the start of an interface definition. The name of the
interface and any inherited interfaces follows. In this case, the interface name
is <TT>IFish</TT>, and this interface inherits the <TT>IUnknown</TT> interface.</P>
<P>Since the <TT>IUnknown</TT> interface is a standard interface within the operating
system, you don't need to redefine the functions within the interface. You only need
to import the <TT>IUnknown</TT> interface definition. You do this through the statement
<TT>import &quot;unknwn.idl&quot;;</TT>.</P>
<P>The functions implemented by the interface need to be added in order to complete
the interface definition. When using IDL, all portions of a function must be defined:
the return value and all parameters, including direction (<TT>in</TT>, <TT>out</TT>,
or both) and size of the parameters. Specifying all portions of a function allows
the MIDL compiler to generate the correct marshaling code for the interface. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> All return values <I>must</I> be of type <TT>HRESULT</TT>, which
	is standard OLE return value. If the return value is <I>not</I> an <TT>HRESULT</TT>,
	the MIDL compiler will not provide marshaling information to marshal across process
	boundaries. The return value <TT>HRESULT</TT> is needed for network support. In case
	a network error occurs, a valid error code can be returned without having to generate
	an exception.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The interface for <TT>IBASS</TT> is shown in Listing 12.2. Note that <TT>IBass</TT>
is an aggregate interface, <I>not</I> an inherited interface. Aggregate interfaces
will be explained in the section &quot;Implementing the Interface.&quot;
<H3><A NAME="Heading13"></A>Listing 12.2<SPACER TYPE="HORIZONTAL" SIZE="10"> IBASS.IDL--Interface
Definition for IBass</H3>
<P><FONT COLOR="#0066FF"><TT>[ <BR>
object, <BR>
uuid(F60D7C40-5B4E-11d0-ABE6-D07900C10000), <BR>
pointer_default(unique) <BR>
] <BR>
interface IBass : IUnknown <BR>
{ <BR>
import &quot;unknwn.idl&quot;; <BR>
HRESULT GetLocation([out, string, size_is(255)] char *p); <BR>
HRESULT SetLocation([in, string] char *p); <BR>
HRESULT EatsOtherFish([out] BOOL *pBool); } </TT></FONT></P>
<H3><A NAME="Heading14"></A>Compiling the Interface Definition Files</H3>
<P>After the respective IDL files have been created, they must be compiled in order
for the interface code to be generated. Since the MIDL compiler was added to the
project in the section &quot;Adding the MIDL Compiler to the IDE,&quot; this task
is an easy one.</P>
<P>To compile the IDL files, perform the following steps:

<OL>
	<LI>Load the file IFish.IDL into the Visual C++ environment.
	<P>
	<LI>Select the command Compile <U>I</U>DL from the <U>T</U>ools menu in the Visual
	C++ development environment.
	<P>
	<LI>Load the file IBass.IDL into the Visual C++ environment.
	<P>
	<LI>Select the command Compile <U>I</U>DL from the <U>T</U>ools menu in the Visual
	C++ development environment.
	<P>
	<LI>The MIDL compiler has now compiled the interface definition files and generated
	the source code for supporting these interfaces.
</OL>

<P>You may be surprised to see the code that is generated by the MIDL compiler from
the simple interface definitions <TT>IFish</TT> and <TT>IBass</TT>. Unlike a C++
compiler, the output from MIDL is <I>not</I> binary code. Instead, MIDL generates
C code, which is then compiled by the C compiler as part of the interface project.</P>
<P>When the file IFISH.IDL was compiled, the files shown in Table 12.2 were generated.

<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 12.2</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Results Produced by Compiling
		IFISH.IDL</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>File</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Purpose</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">IFISH.H</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Support header file for the <TT>IFish</TT> interface.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">IFISH_I.C</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface definition file that is added to both the server and client projects.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">IFISH_P.C</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Proxy code that implements the marshaling code for the interface.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">DLLDATA.C</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Reference file used for loading the correct interface from the DLL. Shared by all
			IDL files compiled within this project.</TD>
	</TR>
</TABLE>
<BR>
<BR>
The files that were created by the MIDL compiler must now be added to the IFISH project.
<BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> When the IFISH project was created, no source files were included
	in the project. The entire project consisted of only a MAK file. Since this is an
	interface-only DLL, the entire contents of the project will consist of the files
	created via the MIDL compiler.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The following files must be added to the IFISH makefile in order for the <TT>IFish</TT>
and <TT>IBass</TT> interface definitions to be accessible and used in COM Object
implementations. 
<TABLE BORDER="0">
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT">ifish.h</TD>
		<TD ALIGN="LEFT">ibass_i.c</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT">ifish_i.c</TD>
		<TD ALIGN="LEFT">ibass_p.c</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT">ifish_p.c</TD>
		<TD ALIGN="LEFT">Dlldata.c</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT">ibass.h</TD>
		<TD ALIGN="LEFT">Rpchelp.c</TD>
	</TR>
</TABLE>
You can add these files to the project by performing the following steps:

<OL>
	<LI>From the Visual C++ development environment, select the <U>F</U>iles command
	from the <U>A</U>dd to Project menu item, which can be accessed from the <U>F</U>ile
	menu. The Insert Files into Project dialog is displayed (see fig. 12.6).
	<P><A HREF="art/12/ifig06.jpg"><B>FIG. 12.6</B></A> <I><BR>
	The Insert Files into Project dialog is used for adding MIDL files into a project.</I></P>
	<LI>Select the files shown in the preceding file list, and click OK. The files are
	now added to the interface project make file.
</OL>

<H3><A NAME="Heading15"></A>Creating a Definition File</H3>
<P>One of the tedious tasks that, unfortunately, is not performed by either the Application
Wizard or the MIDL compiler is the creation of a library definition file (DEF). This
library definition file, a standard part of DLLs, defines which functions are exported
or made accessible by the DLL. The filename is IFISH.DEF. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Since a standard Win32 DLL was created, there were no functions to
	be exported because there were no source files when the file was created. This is
	<I>not</I> the case when an MFC DLL is created. In that case, MFC source code is
	produced, and a DEF file for the project is also created with default functions exported
	through the DEF file.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The contents of the IFISH.DEF file were created manually and can be viewed in Listing
12.3.
<H3><A NAME="Heading16"></A>Listing 12.3<SPACER TYPE="HORIZONTAL" SIZE="10"> DLL
LIBRARY--Definition File for IFISH.DLL</H3>
<P><FONT COLOR="#0066FF"><TT>LIBRARY IFISH <BR>
DESCRIPTION `IFISH Interface Marshaling' <BR>
EXPORTS <BR>
DllGetClassObject <BR>
DllCanUnloadNow </TT></FONT></P>
<P>The DLL entry points <I>must</I> be defined because of the parameter-marshaling
code generated by the MIDL compiler. The MIDL compiler generates code that uses the
<TT>IMarshall</TT> interface. The <TT>IMarshall</TT> interface requires the DLL entry
point's <TT>DllGetClassObject</TT><B> </B>and <TT>DllCanUnloadNow</TT>. The <TT>IMarshall</TT>
interface is a COM interface that implements parameter marshaling for all COM Objects.</P>
<P>These two entry points are explained in greater detail in the section &quot;Accessing
In-Process COM Objects.&quot;
<H3><A NAME="Heading17"></A>Adding the RPC Libraries to the Interface Project</H3>
<P>Parameter marshaling is implemented through RPC (Remote Procedure Calls) libraries.
When creating interface libraries that use RPC for parameter marshaling, you must
link a number of RPC libraries into the interface project. You can select from two
methods for linking the RPC libraries into the interface project:

<UL>
	<LI>Add the library names to the list of input libraries used when linking the project.
	<LI>Create a file with compiler pragmas that reference the libraries.
</UL>

<P>Four RPC libraries must be included in the interface project, rpcndr.lib, rpcdce4.lib,
rpcns4.lib, and rpcrt4.lib. Creating a file with compiler pragmas is much easier
than trying to remember these library filenames and including them for each project
that defines a COM interface.</P>
<P>In the IFISH project is a file called RPCHELP.C (see Listing 12.4). This file
contains the necessary compiler pragmas for RPC support.
<H3><A NAME="Heading18"></A>Listing 12.4<SPACER TYPE="HORIZONTAL" SIZE="10">RPCHELP.C--Compiler
Pragmas Used for Referencing RPC Libraries</H3>
<P><FONT COLOR="#0066FF"><TT>#pragma comment(lib, &quot;rpcndr.lib&quot;) <BR>
#pragma comment(lib, &quot;rpcns4.lib&quot;) <BR>
#pragma comment(lib, &quot;rpcrt4.lib&quot;) </TT></FONT></P>
<P>The file RPCHELP.C must be added to the IFISH project in order for the project
to link properly. The file can be added to the project by performing the following
steps:

<OL>
	<LI>From the Visual C++ development environment, select the <U>F</U>iles command
	from the <U>A</U>dd to Project menu item, which can be accessed from the <U>F</U>ile
	menu.
	<P>
	<LI>Select the files shown in the file list provided earlier in this chapter, and
	click OK. The files are now added to the interface project make file.
</OL>

<P>The interface definitions for IFISH are now complete, and the project is ready
to be built. Building the project generates a DLL called IFISH.DLL.
<H3><A NAME="Heading19"></A>Registering the Interfaces</H3>
<P>Only one task remains before the <TT>IFish</TT> and <TT>IBass</TT> interfaces
can be used. The interfaces must be registered in the Windows registry. The Windows
registry is the holding ground for all class and interface IDs.</P>
<P>For the IFISH project, a registration file named IFISH.REG must be manually created.
The contents of IFISH.REG are shown in code Listing 12.5.
<H3><A NAME="Heading20"></A>Listing 12.5 <SPACER TYPE="HORIZONTAL" SIZE="10">IFISH.REG--Contexts
of IFISH.REG File Used to Register the Interfaces Supported by the IFISH.DLL</H3>
<P><FONT COLOR="#0066FF"><TT>HKEY_CLASSES_ROOT\Interface\{011BB310-5AB0-11d0-907E-00A0C91FDE82}
<BR>
HKEY_CLASSES_ROOT\Interface\{011BB310-5AB0-11d0-907E-00A0C91FDE82} \ProxyStubClsid32
<BR>
HKEY_CLASSES_ROOT\CLSID\{011BB310-5AB0-11d0-907E-00A0C91FDE82} = IFish_PSFactory
<BR>
HKEY_CLASSES_ROOT\CLSID\{011BB310-5AB0-11d0-907E-00A0C91FDE82}\InprocServer32 = d:\dev\ifish\debug\ifish.dll
<BR>
HKEY_CLASSES_ROOT\Interface\{F60D7C40-5B4E-11d0-ABE6-D07900C10000} <BR>
HKEY_CLASSES_ROOT\Interface\{F60D7C40-5B4E-11d0-ABE6-D07900C10000} \ProxyStubClsid32
<BR>
HKEY_CLASSES_ROOT\CLSID\{F60D7C40-5B4E-11d0-ABE6-D07900C10000} = IBass_PSFactory
<BR>
HKEY_CLASSES_ROOT\CLSID\{F60D7C40-5B4E-11d0-ABE6-D07900C10000}\InprocServer32 = d:\dev\ifish\debug\ifish.dll
</TT></FONT></P>
<P>To add the interface keys to the Windows registry, do the following:

<OL>
	<LI>Select the command <U>R</U>egistry Editor from the <U>T</U>ools menu of the Visual
	C++ development environment.
	<P>
	<LI>Select the command <U>I</U>mport Registry File from the Registry Editor <U>F</U>ile
	menu.
	<P>
	<LI>Select the file IFISH.REG, and then select OK.
</OL>

<H2><A NAME="Heading21"></A>Implementing the Interface</H2>
<P>Now that the <TT>IFish</TT> interface definitions are defined, the object that
implements the interfaces must be created. Remember that the <TT>IFISH</TT> interface
DLL contains <I>only</I> the interface definitions and RPC proxy code for parameter
marshaling. There is no code for implementing the interface within IFISH.DLL. The
COM Object developed in this section in the project BASS.DLL will contain an MFC
class called <TT>CBass</TT> that will implement both the <TT>IFish</TT> and <TT>IBass</TT>
interfaces.</P>
<P>COM Objects can be implemented as either a DLL or an EXE. COM Objects that reside
within a DLL are called in-process servers. COM Objects that reside in an EXE are
called out-of-process servers. The application that will use the COM Objects does
not see a difference between the two types of servers. However, internally, there
are a few differences between in-process servers and out-of-process servers.

<UL>
	<LI>An in-process server typically provides better load time performance. COM Object
	load time is faster with an in-process server due to the COM Object being contained
	in a DLL. DLLs typically load faster than executables.
	<P>
	<LI>COM Objects in an in-process server also execute faster because parameter marshaling
	does not need to occur when passing information from the calling application to the
	COM Object.
</UL>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>CAUTION:</B><BR>
	If DCOM is in your development plans, you have one detriment to in-process servers:
	DCOM or the Distributed Component Object Model allows components to reside on other
	computers in your network environment. This feature allows the components to utilize
	the processing power of other workstations. If you are planning for DCOM, you must
	implement your COM Objects as out-of-process servers because DLLs cannot be used
	across machine boundaries.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading22"></A>Using the Visual C++ AppWizard to Create the COM Object</H3>
<P>Nothing special is needed to create a basic <I>application </I>for containing
your COM Objects. The application is where the COM interface definitions are implemented.
With this in mind, you can create a basic COM Object application. In this section,
you will create a COM Object using an MFC DLL (in-process server) as the containing
application. During creation of the application, the differences between creating
an in-process and out-of-process server will be pointed out. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The differences between an in-process and out-of-process server are
	trivial at this point because the interface DLL already contains the proxy code used
	for parameter marshaling. The determination to have an in-process server versus an
	out-of-process server depends on the use and needs of the COM Object.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
To create the basic application, perform the following steps:

<OL>
	<LI>In the Visual C++ development environment, select the <U>N</U>ew command from
	the <U>F</U>ile menu.
	<P>
	<LI>From the Projects tab on the New dialog, select MFC AppWizard (dll). (See fig.
	12.7.) Enter the project name into the Project <U>n</U>ame edit box. This project
	is called BASS. Select the OK button.
	<P><A HREF="art/12/ifig07.jpg"><B>FIG. 12.7</B></A> <I><BR>
	Name the COM Object in the New Project Workspace dialog.<BR>
	<BR>
	<IMG SRC="bar.gif" WIDTH="430" HEIGHT="6" ALIGN="BOTTOM" BORDER="0" VSPACE="5"></I><B><BR>
	NOTE:</B> When creating an out-of-process server, select the MFC AppWizard (exe)
	item in the New Project tab.<IMG SRC="bar.gif" WIDTH="430" HEIGHT="6" ALIGN="BOTTOM"
	BORDER="0" VSPACE="5">
	<LI>From the MFC AppWizard dialog, select <U>R</U>egular DLL with MFC statically
	linked or select Regular <U>D</U>LL using shared MFC DLL (see fig. 12.8), depending
	on your needs. Also select the A<U>u</U>tomation option in the MFC AppWizard dialog.
	The A<U>u</U>tomation option will cause the AppWizard to insert start-up and exit
	code used for both OLE Automation Servers and COM Objects. Select the <U>F</U>inish
	button when completed. The New Project Information dialog will confirm your choices
	(see fig. 12.9).
</OL>

<P><A HREF="art/12/ifig08.jpg"><B>FIG. 12.8</B></A> <I><BR>
Choose your project build options.</I></P>
<P><A HREF="art/12/ifig09.jpg"><B>FIG. 12.9</B></A> <I><BR>
Recap the project selections in the New Project Information dialog.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> Your COM Objects will be easier to distribute if you use the static-linked
	version of MFC. If your COM Objects are part of a project that contains other MFC
	components and applications, you will get better performance by using the DLL version
	of MFC.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
At this point, you have a basic shell application that can be used for your COM Objects.
<H3><A NAME="Heading23"></A>Accessing In-Process COM Objects</H3>
<P>In-process servers contain two functions that serve as entry points for clients
accessing COM Objects. These functions are <TT>DllGetClassObject</TT> and <TT>DllCanUnloadNow</TT>.
These functions are not needed for EXE or out-of-process servers.</P>
<P>In order for the COM support functions to be accessed, the functions must be exported
from the DLL. An exported function can be called from any Windows application. The
COM support functions are defined in MFC but are implemented in the server DLL. These
support functions are also exported through the definition file (.DEF) of the DLL
that uses the functions--in this case, BASS DLL. The AppWizard has already created
a DEF file entitled BASS.DEF (see Listing 12.6).
<H3><A NAME="Heading24"></A>Listing 12.6<SPACER TYPE="HORIZONTAL" SIZE="10"> BASS.DEF--BASS
Definition File with the COM Support Functions Explicitly Exported</H3>
<P><FONT COLOR="#0066FF"><TT>; BASS.def : Declares the module parameters for the
DLL. <BR>
LIBRARY &quot;BASS&quot; <BR>
DESCRIPTION `FISH Windows Dynamic Link Library' <BR>
EXPORTS <BR>
; Explicit exports can go here <BR>
DllCanUnloadNow PRIVATE <BR>
DllGetClassObject PRIVATE <BR>
DllRegisterServer PRIVATE</TT></FONT></P>
<PRE><FONT COLOR="#0066FF"><TT></TT></FONT></PRE>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The BASS definition file and the three support functions needed for
	accessing COM Objects were automatically inserted by the MFC Application Wizard as
	a result of selecting the OLE Automation option for the project. Automation and COM
	Objects are accessed in in-process servers through the same support functions. If
	OLE Automation was <I>not</I> selected, these functions will have to be implemented
	manually.

</BLOCKQUOTE>

<P>
<HR>
Each of the COM support functions are explained in the following three sections.
<B><I><BR>
<BR>
HRESULT DllGetClassObject (REFCLSID rclsid</I>, <I>REFIID riid</I>, <I>LPVOID *ppv)</I>
</B><SPACER TYPE="HORIZONTAL" SIZE="10">When a user requests a given COM Object,
the Component Object Library looks into the Windows registry for the <TT>InProcServer</TT>
of the given <TT>CLSID</TT>. The DLL that implements the COM Object is then loaded
into memory, and the function <TT>DllGetClassObject</TT> is called. The <TT>CLSID</TT>
of the COM Object implementing the interface and <TT>IID</TT> of the interface the
user is requesting are passed into the function. The DLL containing the COM Object
then creates the appropriate class factory for the <TT>CLSID</TT> and returns the
corresponding interface pointer for the <TT>IID</TT>. Since a <TT>CLSID</TT> is passed
into <TT>DllGetClassObject</TT>, a DLL can contain many different COM Objects. The
interface pointer is returned to the caller through the parameter <TT>ppv</TT>.</P>
<P>The MFC AppWizard inserts all of the code needed for accessing COM Objects in
an MFC Application DLL. The code for <TT>DllGetClassObjects</TT> is shown in Listing
12.7.
<H3><A NAME="Heading25"></A>Listing 12.7<SPACER TYPE="HORIZONTAL" SIZE="10"> BASS.CPP--DLlGetClassObject
Implementation Code Inserted by the MFC AppWizard</H3>
<P><FONT COLOR="#0066FF"><TT>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid,
LPVOID* ppv) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()); <BR>
return AfxDllGetClassObject(rclsid, riid, ppv); <BR>
} </TT></FONT></P>
<P><B><I>STDAPI DllCanUnloadNow(void)</I></B> <SPACER TYPE="HORIZONTAL" SIZE="10">Since
the client application using the COM Object does not link directly with the server
creating the COM Object, an unload mechanism must be in place so that unneeded COM
Objects are removed from memory. With in-process servers, this mechanism is through
the function <TT>DllCanUnloadNow</TT>. The Component Object Library periodically
asks each COM Object server if it can be unloaded from memory. If the server returns
<TT>S_OK</TT>, the server DLL is removed from memory. A COM Object server returns
<TT>S_OK</TT> when clients have finished using the COM Objects. The function <TT>DllCanUnloadNow</TT>
is shown in Listing 12.8.</P>
<P>An EXE server does not need to implement the function <TT>DllCanUnloadNow</TT>
because an EXE can keep track of how many users it has. When the usage count reaches
0, the EXE can unload itself from memory.
<H3><A NAME="Heading26"></A>Listing 12.8 <SPACER TYPE="HORIZONTAL" SIZE="10">DLLCanUnloadNow--Implementation
Code Inserted by the MFC AppWizard</H3>
<P><FONT COLOR="#0066FF"><TT>STDAPI DllCanUnloadNow(void) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()); <BR>
return AfxDllCanUnloadNow(); <BR>
}</TT></FONT></P>
<PRE><FONT COLOR="#0066FF"><TT></TT></FONT></PRE>
<P><B><I>BOOL DllRegisterServer(void)</I></B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>
</B>The function <TT>DllRegisterServer</TT> is a useful method for having the COM
Object server correctly register with the Windows registry. When this function is
called, the COM Object server updates the Windows registry with the settings necessary
for client applications to use the server.</P>
<P>The ActiveX development kit has a tool called regsvr32.exe. This program can be
run with two parameters. The first parameter is the DLL to register. The second parameter
is <TT>TRUE</TT> (for registering a server) or <TT>FALSE</TT> for unregistering a
server. To register the BASS COM server, run <TT>regsvr32</TT><B> </B>with the following
parameters:</P>
<P><FONT COLOR="#0066FF"><TT>regsvr32 BASS.DLL TRUE</TT></FONT>
<H3><A NAME="Heading27"></A>Listing 12.9 <SPACER TYPE="HORIZONTAL" SIZE="10">DllRegisterServer--Implementation
Code Inserted by the MFC AppWizard</H3>
<P><FONT COLOR="#0066FF"><TT>// by exporting DllRegisterServer, you can use regsvr.exe
<BR>
STDAPI DllRegisterServer(void) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()); <BR>
COleObjectFactory::UpdateRegistryAll(); <BR>
return S_OK; <BR>
}</TT></FONT></P>
<PRE><FONT COLOR="#0066FF"><TT></TT></FONT></PRE>
<H3><A NAME="Heading28"></A>Creating a Class that Implements COM Interfaces</H3>
<P>Now that the application that will contain the COM Class has been created, the
COM Class needs to be added to the project. The Visual C++ ClassWizard will be used
to implement this class. The class name being created is <TT>CBass</TT>. To create
the <TT>CBass</TT> class, perform the following steps:

<OL>
	<LI>Select the Class<U>W</U>izard command from the <U>V</U>iew menu of the Visual
	C++ development environment. The ClassWizard dialog will appear as shown in Figure
	12.10.
	<P>
	<LI>Select the Add C<U>l</U>ass button, and then select the new option. The New Class
	dialog appears (see fig. 12.11).
</OL>

<P><A HREF="art/12/ifig11.jpg"><B>FIG. 12.11</B></A> <BR>
<I>Set the class options with the New Class dialog.</I></P>

<OL>
	<LI>Enter the class name <B>CBass</B> in the <U>N</U>ame edit box.
	<P>
	<LI>Select the base class <TT>CCmdTarget</TT> from the <U>B</U>ase class drop-down
	list.
	<P>
	<LI>Select the Create button. The Class <TT>CBass</TT> is now part of the BASS project.
</OL>

<P>The class <TT>CCmdTarget</TT> is chosen as the base class because MFC provides
a standard implementation of the <TT>IUnknown</TT> interface in this class. As you
have seen, the <TT>IUnknown</TT> interface provides the three basic methods that
<I>must </I>be supported by all COM Objects.</P>
<P>Deriving from the <TT>CCmdTarget</TT> base class also allows the object to be
created through the MFC class <TT>COleObjectFactory</TT>. The class <TT>COleObjectFactory</TT>
is called through the DLL entry point, <TT>DllGetClassObject</TT>. If the COM class
was not derived from a class with <TT>CCmdTarget</TT> as its base, special object
creation code must be written in the function <TT>DllGetClassObject</TT> to create
an instance of the object. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Even though <TT>CCmdTarget</TT> was selected as the base class for
	the <TT>CBass</TT> class, any of the other classes derived from <TT>CCmdTarget</TT>
	can be used. If a class <I>not </I>derived from <TT>CCmdTarget</TT> is used, you
	<I>must </I>manually provide support for the <TT>IUnknown</TT> interface.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Figure 12.12 illustrates the <TT>CBass</TT> class and the interfaces that will be
encapsulated within this class. <B><BR>
<BR>
</B><A HREF="art/12/ifig12.jpg"><B>FIG. 12.12</B></A> <I><BR>
Class hierarchy and supported interfaces of the CBass class.</I></P>
<P><B>Supporting the <I>IUnknown</I> Interface </B><SPACER TYPE="HORIZONTAL" SIZE="10">While
the MFC class <TT>CCmdTarget</TT> provides built-in support for the <TT>IUnknown</TT>
interface, the COM class derived from <TT>CCmdTarget</TT> must still provide methods
that enable the MFC Interface maps to call these routines. Since <TT>IUnknown</TT>
is a standard COM interface, the functions that must be called from the COM class
have been implemented through a series of support macros. The advantage of the set
of macros is that they can be used for the <TT>IUnknown</TT> implementation of any
MFC derived class. The file commacros.h implements a set of macros that are used
for calling the <TT>IUnknown</TT> implementation within the <TT>CCmdTarget</TT> class.
Listing 12.10 shows the COM support macros for MFC. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> The file commacros.h is not a part of MFC and must be added to the
	project manually.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading29"></A>Listing 12.10 <SPACER TYPE="HORIZONTAL" SIZE="10">COMMACROS.H--COM
Macros Used for Accessing the IUnknown Implementation of CCmdTarget</H3>
<P><FONT COLOR="#0066FF"><TT>#ifndef _COMMACROS_H <BR>
#define _COMMACROS_H <BR>
#ifndef IMPLEMENT_IUNKNOWN <BR>
#define IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass)\ <BR>
STDMETHODIMP_(ULONG)ObjectClass::X##InterfaceClass::AddRef(void)\ <BR>
{ \ <BR>
METHOD_PROLOGUE(ObjectClass, InterfaceClass); \ <BR>
return pThis-&gt;ExternalAddRef(); \ <BR>
} <BR>
#define IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass)\ <BR>
STDMETHODIMP_(ULONG)ObjectClass::X##InterfaceClass::Release(void)\ <BR>
{ \ <BR>
METHOD_PROLOGUE(ObjectClass, InterfaceClass); \ <BR>
return pThis-&gt;ExternalRelease(); \ <BR>
} <BR>
#define IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass)\ <BR>
STDMETHODIMP ObjectClass::X##InterfaceClass::QueryInterface(REFIID riid, LPVOID *pVoid)\
<BR>
{ \ <BR>
METHOD_PROLOGUE(ObjectClass, InterfaceClass); \ <BR>
return (HRESULT)pThis-&gt;ExternalQueryInterface(&amp;riid ,ppVoid); \ <BR>
} <BR>
#define IMPLEMENT_IUNKNOWN(ObjectClass, InterfaceClass)\ <BR>
IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass)\ <BR>
IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass)\ <BR>
IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass) <BR>
#endif #endif </TT></FONT></P>
<P><B>Adding a Class ID</B><SPACER TYPE="HORIZONTAL" SIZE="10">Now that the class
that will support the COM interfaces is defined, a unique class ID (<TT>CLSID</TT>)
must be created for the class. The <TT>CLSID</TT> allows the operating system to
distinguish which application to load when a client program wants to invoke an instance
of the object. To create a unique <TT>CLSID</TT>, the program GUIDGEN must once again
be run. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> To create a unique ID using <TT>GUIDGEN</TT>, refer to the steps
	outlined in the section &quot; Creating the Interface Definition.&quot;

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
After the <TT>CLSID</TT> is created, it must be placed in a header file that acts
as a define for the class implementation. For the <TT>CBass</TT> object, the file
bassid.h is created. The <TT>CLSID</TT> is then pasted into the file and added to
the macro <TT>DEFINE_GUID</TT> (see Listing 12.11).
<H3><A NAME="Heading30"></A>Listing 12.11 <SPACER TYPE="HORIZONTAL" SIZE="10">BASSID.H--Header
File bassid.h that Contains the Implementation of CLSID for the CBass Class</H3>
<P><FONT COLOR="#0066FF"><TT>#ifndef _CLSID_Bass <BR>
#define _CLSID_Bass <BR>
//{AFA853E0-5B50-11d0-ABE6-D07900C10000} <BR>
DEFINE_GUID(CLSID_Bass,0xAFA853E0,0x5B50,0x11d0, <BR>
0xAB,0xE6,0xD0,0x79,0x00,0xC1,0x00,0x00); #endif </TT></FONT></P>
<P>The macro <TT>DEFINE_GUID</TT> assigns the name <TT>CLSID_Bass</TT> to the class
ID that was created via GUIDGEN. This macro is placed in a header file that is used
by all clients that need to invoke an instance of <TT>CLSID_Bass</TT>. This file
is <I>not </I>used by the server that implements the COM Object. <B><BR>
<BR>
Using Interface Maps to Support COM Interfaces </B><SPACER TYPE="HORIZONTAL" SIZE="10">MFC
supports COM interfaces through a technique known as <I>interface maps. </I>This
technique is similar to the message maps used to route Windows messages to message
handlers (functions) within the target class. Interface maps are basically a set
of macros that provide support for the COM interfaces embedded within the MFC-derived
class. Interface maps determine which interface methods will be handled by the particular
MFC derived class. Only methods placed in the interface maps are supported by the
COM Object. Only interface functions declared within the interface map are supported
by the COM Object. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Even though the <TT>IUnknown</TT> interface functions are <I>not
	</I>included within the interface map for the class, they <I>must </I>be supported
	by the class. All derived methods of the interface <I>must</I> be supported, although
	not explicitly defined.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
Adding Interface maps to a class is an easy procedure. To add interface maps to a
class, perform the following steps:

<OL>
	<LI>Add the header files that define the interfaces to your class. In the BASS project,
	<TT>includes</TT> for the interface files Ifish.h and Ibass.h were added to the header
	file bass.h. The interface files ifish.h and ibass.h were generated by the MIDL compiler
	when the IFISH.DLL project was built. These files define the respective interface
	classes.
	<P>
	<LI>Add the macro <TT>DECLARE_OLECREATE()</TT><B> </B>to the class. This macro adds
	public data members to the class including <TT>COleObjectFactory</TT>, which is the
	primary interface needed for creating an object of the specified class.
	<P>
	<LI>The COM specification dictates that interfaces simply define the interface and
	that they do not implement the methods for the interface or contain data members.
	This concept means that the class implementing the interface must contain the methods
	for the interface and contain any data variables needed to keep track of information
	about the interface. For the class <TT>CBass</TT>, Table 12.3 illustrates the data
	members needed for the interface implementation and the interface method that retrieves
	or sets the data member.
	<P>
	<LI>Now that the data members are added to the class, some MFC macros must be added
	to the class in order for MFC to support the interfaces. The first macro is <TT>DECLARE_INTERFACE_MAP</TT>,
	which is added to a protected section of the class. This define is analogous to the
	<TT>DECLARE_MESSAGE_MAP</TT> macro that is needed for support of Windows message
	maps. <TT>DECLARE_INTERFACE_MAP</TT> is a macro that adds member variables needed
	for the support of COM interfaces.
	<P>
	<LI>For each of the supported primary interfaces, there must be an interface map.
	An interface map is added to a class through the macros <TT>BEGIN_INTERFACE_PART
	(Class Name, Interface Name)</TT> and <TT>END_INTERFACE_PART (Class Name)</TT>. Between
	these sections are the methods that implement the interface in the class. Again,
	the <TT>IUnknown</TT> interface methods do not need to be added.
</OL>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Upon inspection of the macro <TT>BEGIN_INTERFACE_PART</TT>, you can
	see that the methods for the <TT>IUnknown</TT> interface are automatically added
	to the class. This eliminates the need to manually add them to the class.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>

<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 12.3</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Data Members Needed in <I>CBass</I>
		Class to Implement Supported Interfaces</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Data Member</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Interface Method</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>BOOL m_bFreshwater</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IFish::IsFreshwater</TT></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>CString m_zFishName</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IFish::GetFishName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>CString m_zLocation</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IBass::GetLocation</TT> <TT>IBass::SetLocation</TT></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>BOOL m_bEatsOtherFish</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>IBass::EatsOtherFish</TT></TD>
	</TR>
</TABLE>
<BR>
<BR>
The header file for the <TT>CBass</TT> class (BASS.H) has been modified to include
all of the changes listed in Table 12.3. The resultant file is shown in Listing 12.12.
<H3><A NAME="Heading31"></A>Listing 12.12 <SPACER TYPE="HORIZONTAL" SIZE="10">BASS.H--Header
File for the CBass Class (bass.h)</H3>
<P><FONT COLOR="#0066FF"><TT>#ifndef __AFXWIN_H__ <BR>
#error include `stdafx.h' before including this file for PCH <BR>
#endif <BR>
#include &quot;resource.h&quot; // main symbols <BR>
#include &quot;..\ifish\ifish.h&quot; <BR>
#include &quot;..\ifish\ibass.h&quot; ////////////////////////////////////////////////////
/////////////////////////// CBass command target <BR>
class CBass : public CCmdTarget <BR>
{ <BR>
DECLARE_DYNCREATE(CBass) <BR>
CBass(); // protected constructor used by dynamic creation <BR>
// Attributes <BR>
public: <BR>
CString m_zFishName; <BR>
CString m_zLocation; <BR>
BOOL m_bEatsOtherFish; <BR>
BOOL m_bFreshwater; <BR>
// Operations <BR>
public: <BR>
// Overrides <BR>
// ClassWizard generated virtual function overrides <BR>
//{{AFX_VIRTUAL(CBass) <BR>
//}}AFX_VIRTUAL <BR>
// Implementation <BR>
protected: <BR>
virtual ~CBass(); <BR>
// Generated message map functions <BR>
//{{AFX_MSG(CBass) <BR>
// NOTE - the ClassWizard will add and remove member functions here. <BR>
//}}AFX_MSG <BR>
DECLARE_MESSAGE_MAP() <BR>
DECLARE_OLECREATE(CBass) <BR>
DECLARE_INTERFACE_MAP() <BR>
BEGIN_INTERFACE_PART(Fish, IFish) <BR>
STDMETHOD(GetFishName)(char *pStr); <BR>
STDMETHOD(IsFreshWater)(BOOL *pBool); <BR>
END_INTERFACE_PART(Fish) <BR>
BEGIN_INTERFACE_PART(Bass, IBass) <BR>
STDMETHOD(GetLocation)(char *pStr); <BR>
STDMETHOD(SetLocation)(char *pStr); <BR>
STDMETHOD(EatsOtherFish)(BOOL *pBool); <BR>
END_INTERFACE_PART(Bass) }; </TT></FONT></P>
<P><B>Implementing MFC Interface Maps</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>
</B>In the previous section, interface maps were added to the class header file.
The actual interface maps must now be implemented in order for the interfaces to
be supported. These changes are made to the source implementation file for the class.
For the <TT>CBass</TT> class, this file is bass.cpp.

<OL>
	<LI>Add the COM support macros to the implementation file. Add the line <TT>#include
	&quot;commacros.h&quot;</TT> to your class implementation file. Commacros.h is the
	common include file that implements the <TT>IUnknown</TT> interface for your MFC
	class.
	<P>
	<LI>Add the macro <TT>IMPLEMENT_OLECREATE()</TT> to the source file as shown here.
	This macro links the MFC class, in this case <TT>CBass</TT>, with the <I>friendly
	</I>or callable name for the class (<TT>Bass</TT>). The <TT>CLSID</TT> for this class
	is also passed into the macro. The <TT>IMPLEMENT_OLECREATE</TT> is needed for implementation
	of the <TT>COleClassFactory</TT> object that instantiates instances of the <TT>CBass</TT>
	object.
	<P><FONT COLOR="#0066FF"><TT>//{AFA853E0-5B50-11d0-ABE6-D07900C10000}<BR>
	IMPLEMENT_OLECREATE(CBass, &quot;Bass&quot;, <BR>
	0xAFA853E0,0x5B50,0x11d0,0xAB,0xE6,0xD0,0x79,0x00,0xC1,0x00,0x00)</TT></FONT>
	<LI>Implement the interface map for the class. This process is very similar to implementing
	the message map. You implement an interface map by using three macros: <TT>BEGIN_INTERFACE_MAP</TT>,
	<TT>INTERFACE</TT>_<TT>PART</TT>, and <TT>END_INTERFACE_MAP.</TT>
	<P><BR>
	The macro <TT>BEGIN_INTERFACE_MAP</TT> takes two parameters: the runtime class (<TT>Cbass</TT>)
	and the derived class (<TT>CCmdTarget</TT>). This macro provides a series of methods
	used for retrieving entries into the interface map structure.<BR>
	<BR>
	The macro <TT>INTERFACE_PART</TT> is needed for each COM interface that is to be
	supported by the class. This macro links the runtime class with the <TT>UUID</TT>
	for the interface and the friendly interface name.<BR>
	<BR>
	The macro <TT>END_INTERFACE_MAP</TT> ends the interface map implementation.<BR>
	<BR>
	<FONT COLOR="#0066FF"><TT>BEGIN_INTERFACE_MAP(CBass, CCmdTarget)<BR>
	INTERFACE_PART(CBass, IID_IFish, Fish)<BR>
	INTERFACE_PART(CBass, IID_IBass, Bass)<BR>
	END_INTERFACE_MAP();</TT></FONT>
	<LI>Now you implement the interfaces within the class. This step is where the methods
	for the interface are implemented. Adding methods to a class is a straightforward
	process, with one exception. The method definition is as follows:
	<P><FONT COLOR="#0066FF"><TT>runtime_class::interface_class::method. </TT><BR>
	<BR>
	</FONT>Listing 12.13 illustrates the implementation file, bass.cpp.<BR>
	The macro <TT>METHOD_PROLOGUE</TT> is used to establish a local variable named pThis<I>,
	</I>which is a pointer to the interface function table. The arguments to the <TT>METHOD_PROLOGUE</TT>
	are the runtime class and the interface name. This macro <I>must </I>precede every
	interface implementation.
	<LI>So far you have not implemented the <TT>IUnknown</TT> interfaces for the class.
	To implement the <TT>IUnknown</TT> interfaces, use the macro that was added in the
	commacros.h file. In bass.cpp, the following lines are added to implement the <TT>IUnknown</TT>
	interface for each interface.
	<P><FONT COLOR="#0066FF"><TT>// implement the Iunknown interface<BR>
	IMPLEMENT_IUNKNOWN(CBass, Fish)<BR>
	IMPLEMENT_IUNKNOWN(CBass, Bass)</TT></FONT>
</OL>

<PRE></PRE>
<H3><A NAME="Heading32"></A>Listing 12.13<SPACER TYPE="HORIZONTAL" SIZE="10"> BASS.CPP--Complete
Implementation File for CBass object (Bass.cpp)</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CBass <BR>
IMPLEMENT_DYNCREATE(CBass, CCmdTarget) <BR>
CBass::CBass() <BR>
{ <BR>
m_zFishName = &quot;Large Mouth Bass&quot;; <BR>
m_zLocation = &quot;Under Lily Pads&quot;; <BR>
m_bEatsOtherFish = TRUE; <BR>
m_bFreshwater = TRUE; <BR>
} <BR>
CBass::~CBass() <BR>
{ <BR>
} BEGIN_MESSAGE_MAP(CBass, CCmdTarget) <BR>
//{{AFX_MSG_MAP(CBass) <BR>
// NOTE - the ClassWizard will add and remove mapping macros here. <BR>
//}}AFX_MSG_MAP <BR>
END_MESSAGE_MAP() <BR>
//{AFA853E0-5B50-11d0-ABE6-D07900C10000} <BR>
IMPLEMENT_OLECREATE(CBass, &quot;Bass&quot;, <BR>
0xAFA853E0,0x5B50,0x11d0,0xAB,0xE6,0xD0,0x79,0x00,0xC1,0x00,0x00) <BR>
BEGIN_INTERFACE_MAP(CBass, CCmdTarget) <BR>
INTERFACE_PART(CBass, IID_IFish, Fish) <BR>
INTERFACE_PART(CBass, IID_IBass, Bass) <BR>
END_INTERFACE_MAP(); <BR>
///////////////////////////////////////////////////////////////////////////// <BR>
// CBass message handlers <BR>
// CBass:Fish implementation of IFish <BR>
// implement the Iunknown interface <BR>
IMPLEMENT_IUNKNOWN(CBass, Fish) <BR>
STDMETHODIMP CBass::XFish::GetFishName( char *pStr) <BR>
{ <BR>
METHOD_PROLOGUE(CBass, Fish); <BR>
TRACE(&quot;CBass::XFish::GetFishName\n&quot;); <BR>
if (pStr) <BR>
strcpy((char *)pStr, (LPCTSTR)pThis-&gt;m_zFishName); <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
STDMETHODIMP CBass::XFish::IsFreshwater( BOOL *pBool ) <BR>
{ <BR>
METHOD_PROLOGUE(CBass, Fish); <BR>
TRACE(&quot;CBass::XFish::IsFreswWater\n&quot;); <BR>
if (pBool) <BR>
{ <BR>
*pBool = pThis-&gt;m_bFreshwater; <BR>
return S_OK; <BR>
} <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
// CBass:Fish implementation of IFish <BR>
// implement the Iunknown interface <BR>
IMPLEMENT_IUNKNOWN(CBass, Bass) <BR>
STDMETHODIMP CBass::XBass::GetLocation( char *pStr) <BR>
{ <BR>
METHOD_PROLOGUE(CBass, Bass); <BR>
TRACE(&quot;CBass::XBass::GetLocation\n&quot;); <BR>
if (pStr) <BR>
strcpy((char *)pStr, (LPCTSTR)pThis-&gt;m_zLocation); <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
STDMETHODIMP CBass::XBass::SetLocation( char *pStr) <BR>
{ <BR>
METHOD_PROLOGUE(CBass, Bass); <BR>
TRACE(&quot;CBass::XBass::SetLocation\n&quot;); <BR>
if (pStr) <BR>
pThis-&gt;m_zLocation = pStr; <BR>
return (HRESULT)NOERROR; <BR>
} <BR>
STDMETHODIMP CBass::XBass::EatsOtherFish( BOOL *pBool ) <BR>
{ <BR>
METHOD_PROLOGUE(CBass, Bass); <BR>
TRACE(&quot;CBass::XBass::EatsOtherFish\n&quot;); <BR>
if (pBool) <BR>
{ <BR>
*pBool = pThis-&gt;m_bEatsOtherFish; <BR>
return S_OK; <BR>
} <BR>
// return E_BADPOINTER; <BR>
return (HRESULT)NOERROR; <BR>
} </TT></FONT></P>
<P><B>Building the COM Object </B><SPACER TYPE="HORIZONTAL" SIZE="10">The good news
is that all of the code has been written for the COM Object. However, here are a
couple of items that still need to be done before the COM Object can be built:

<UL>
	<LI>First you need to add the two MIDL-generated &quot;C&quot; files to the project.
	When the MIDL compiler generates the <TT>IID</TT> for the interface, only an external
	reference to the <TT>IID</TT> structure is created. In order to successfully build
	the project using the interfaces, the actual definition of the <TT>IID</TT> structure
	must be included. These definitions can be found in the files iXXX_i.c files. For
	the Bass project, these files are ifish_i.c and ibass_i.c. These MIDL-generated files
	<I>must </I>be added to the list of files compiled and built when creating the project.
	<P>
	<LI>The Visual C++ project default option of precompiling headers using stdafx.h
	must be changed. The correct option for compiling projects that use MIDL-generated
	files is to automatically use precompiled headers. Automatic use of precompiled headers
	can be enabled by the following steps:
	<P>
	<OL>
		<LI>Select the <U>S</U>ettings command from the <U>P</U>roject menu.
		<P>
		<LI>Select the C/C++ tab in the Project Settings dialog.
		<P>
		<LI>Select precompiled headers from the Category<SUB>_</SUB> drop-down list (see
		fig. 12.13).
		<P><A HREF="art/12/ifig13.jpg"><B>FIG. 12.13</B></A> <I><BR>
		Enabling automatic use of precompiled headers for building a COM Object.</I>
		<LI>Select Automatic use of precompiled headers.
		<P>
		<LI>Click the OK button.
	</OL>
</UL>

<H2><A NAME="Heading33"></A>Using the Interface</H2>
<P>Use of COM Objects within an application is an easy task. A test application called
ComTest has been developed to aid in the testing and use of the <TT>IFish</TT> and
<TT>IBass</TT> interfaces.</P>
<P>Only a handful of functions are necessary to access and utilize COM interfaces
within an application. These functions can be broken into two categories:

<UL>
	<LI>OLE Initialization and Shutdown functions
	<LI>COM Object access functions
</UL>

<H3><A NAME="Heading34"></A>OLE Initialization and Shutdown Functions</H3>
<P>When building MFC applications that will utilize COM interfaces, two functions
must be called to properly initialize the MFC framework. These functions are <TT>AfxOleInit()</TT><B>
</B>and <TT>CoFreeUnusedLibraries()</TT>. These functions must be called during the
application initialization and removal. Listing 12.14 shows how the OLE libraries
are initialized for use during application creation and removed during exit. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> If the COMTEST app was created with OLE support, the AppWizard would
	have automatically inserted the function <TT>AfxOleInit()</TT> within the <TT>InitInstance()</TT>
	method of <TT>CComTestApp</TT>. Likewise, OLE termination code would be automatically
	called on the program's exit.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading35"></A>Listing 12.14 <SPACER TYPE="HORIZONTAL" SIZE="10">COMTEST.CPP--Initialization
and Removal of OLE Libraries within an MFC Application</H3>
<P><FONT COLOR="#0066FF"><TT>CComTestApp::CComTestApp() <BR>
{ <BR>
// TODO: add construction code here, <BR>
// Place all significant initialization in InitInstance <BR>
AfxOleInit(); <BR>
} <BR>
int CComTestApp::ExitInstance() <BR>
{ <BR>
::CoFreeUnusedLibraries(); <BR>
<BR>
return CWinApp::ExitInstance(); <BR>
}</TT></FONT></P>
<PRE><FONT COLOR="#0066FF"><TT></TT></FONT></PRE>
<H3><A NAME="Heading36"></A>COM Object Access Functions</H3>
<P>Using COM interfaces within an application is similar to using any ordinary C++
class, the exception being that instances of a class are created through the function
<TT>CoCreateInstance()</TT><B> </B>rather than the <TT>new</TT> operator. After an
interface pointer is returned, it can be used as though it is a C++ class, to call
any of the functions in the interface. Listing 12.15 provides an example of how to
access COM interfaces and call their functions.
<H3><A NAME="Heading37"></A>Listing 12.15 <SPACER TYPE="HORIZONTAL" SIZE="10">Comtestview.cpp--Test
Function Used for Accessing the IFish and IBass Interfaces</H3>
<P><FONT COLOR="#0066FF"><TT>void CComTestView::OnEditCreatebassinterfaces() <BR>
{ <BR>
char lo_Location[255]; <BR>
char lo_FishName[255]; <BR>
IFish *pIfish; <BR>
IBass *pIBass; <BR>
::CoCreateInstance( CLSID_Bass, NULL, <BR>
CLSCTX_INPROC_SERVER, <BR>
IID_IFish, <BR>
(LPVOID *)&amp;pIfish); <BR>
if ( pIfish ) <BR>
{ <BR>
TRACE0(&quot;Success ... Got an interface to Ifish\n&quot;); <BR>
pIfish-&gt;GetFishName(lo_FishName); <BR>
TRACE1(&quot;The Fish Name is %s\n&quot;, lo_FishName); <BR>
if (pIfish-&gt;QueryInterface(IID_IBass, (LPVOID *)&amp;pIBass)== S_OK) <BR>
{ <BR>
pIBass-&gt;GetLocation(lo_Location); <BR>
TRACE1(&quot; The Fish is a bass and it is located %s\n&quot;, lo_Location); <BR>
pIBass-&gt;Release(); <BR>
} <BR>
pIfish-&gt;Release(); <BR>
} } </TT></FONT></P>
<H2><A NAME="Heading38"></A>From Here...</H2>
<P>This chapter discussed creating COM Objects based on the MFC application framework.
While MFC does not directly utilize COM, provisions have been made so that MFC supports
COM and reduces the amount of work necessary in creating COM Objects. Other techniques
can be used for creating COM Objects. <A HREF="ch13.htm">Chapter 13</A> examines
the creation of COM Objects through the ActiveX Template Library (ATL). ATL provides
a lightweight COM framework for building COM Objects.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
