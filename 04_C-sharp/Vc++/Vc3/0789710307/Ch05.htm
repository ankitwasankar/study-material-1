<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 10:01 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 5</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 5<BR>
Creating ActiveX Automation Servers Using BaseCtl</H1>

<UL>
	<LI><A HREF="#Heading1">Creating ActiveX Automation Servers Using BaseCtl</A>
	<UL>
		<LI><A HREF="#Heading2">Creating the Basic Project</A>
		<LI><A HREF="#Heading3">Registry</A>
		<UL>
			<LI><A HREF="#Heading4">Listing 5.1 TRACKER.H--Basic Registration Information in
			the DEFINE_AUTOMATIONOBJECT Structure</A>
		</UL>
		<LI><A HREF="#Heading5">Sample Server Support Code</A>
		<UL>
			<LI><A HREF="#Heading6">Listing 5.2 TRACKER.H--Sample Server Support Code Added to
			the Header File</A>
			<LI><A HREF="#Heading7">Listing 5.3 TRACKER.CPP--Sample Server Support Code Added
			to the Source File</A>
		</UL>
		<LI><A HREF="#Heading8">Adding Methods</A>
		<UL>
			<LI><A HREF="#Heading9">Listing 5.4 BCFSERVER.ODL--OutputLines Method ODL Declaration</A>
			<LI><A HREF="#Heading10">Listing 5.5 TRACKER.H--OutputLines Function Prototype Added
			to the Class Definition</A>
			<LI><A HREF="#Heading11">Listing 5.6 TRACKER.CPP--Member Initialization in the Constructor</A>
			<LI><A HREF="#Heading12">Listing 5.7 TRACKER.CPP--OutputLines Function Implementation
			Added to the Source File Tracker.cpp</A>
		</UL>
		<LI><A HREF="#Heading13">Adding Properties</A>
		<UL>
			<LI><A HREF="#Heading14">Listing 5.8 BCFSERVER.ODL--Indent Property Added to the
			ODL</A>
			<LI><A HREF="#Heading15">Listing 5.9 TRACKER.H--Indent Property Function Prototypes
			Added to the Class Definition</A>
			<LI><A HREF="#Heading16">Listing 5.10 TRACKER.CPP--Indent Property Implementation</A>
		</UL>
		<LI><A HREF="#Heading17">Generating OLE Exceptions</A>
		<UL>
			<LI><A HREF="#Heading18">Listing 5.11 BCFSERVER.ODL--Error Enumeration in the ODL
			File</A>
			<LI><A HREF="#Heading19">Listing 5.12 TRACKER.CPP--Rich Error Information Added to
			Tracker Implementation</A>
		</UL>
		<LI><A HREF="#Heading20">Dual-Interface</A>
		<LI><A HREF="#Heading21">Generating Dual-Interface OLE Exceptions</A>
		<LI><A HREF="#Heading22">Server Instantiation Using C++</A>
		<UL>
			<LI><A HREF="#Heading23">Listing 5.13 Example--Creating an OLE Server Using C++</A>
		</UL>
		<LI><A HREF="#Heading24">Shared Servers</A>
		<UL>
			<LI><A HREF="#Heading25">Listing 5.14 TRACKER.CPP--Create Function Implementation
			of Shared Object Support</A>
			<LI><A HREF="#Heading26">Listing 5.15 TRACKER.H--DECLARE_STANDARD_UNKNOWN_SHARED
			Macro Implementation</A>
			<LI><A HREF="#Heading27">Listing 5.16 TRACKER.H--New Macro</A>
		</UL>
		<LI><A HREF="#Heading28">Single Instance Servers</A>
		<UL>
			<LI><A HREF="#Heading29">Listing 5.17 TRACKER.CPP--Create Function Implementation
			Updated to Support Single Instance Servers</A>
		</UL>
		<LI><A HREF="#Heading30">User Interface and Events</A>
		<LI><A HREF="#Heading31">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Creating ActiveX Automation Servers Using BaseCtl</H1>

<UL>
	<LI><B>Server registration support</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Like ATL, the basic BaseCtl framework allows registration and unregistration support
	without additional code modification.
	<P>
	<LI><B>Adding methods and properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 The single greatest drawback in using BaseCtl is its lack of integration with the
	VC++ IDE. Properties provide a uniform mechanism for getting and setting the state
	of a server's data variables.
	<P>
	<LI><B>OLE exceptions</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Unlike MFC, BaseCtl does not support OLE exceptions through a C++ exception class;
	BaseCtl takes advantage of OLE error reporting mechanisms.
	<P>
	<LI><B>Dual-interface</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 BaseCtl servers implement dual-interface as a standard feature of the application.
	<P>
	<LI><B>Shared servers and single instance servers</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Adding shared server support to the BaseCtl framework gives insights into how the
	BaseCtl class factory is implemented.
</UL>

<P>The history of the BaseCtl framework has its roots in the Visual Basic (VB) group
where it was first developed. The single most unique thing about the BaseCtl Framework
is its lack of dependence on MFC, which was viewed by the VB team as a burden to
creating small and fast OCXs.</P>
<P>Several versions of the BaseCtl framework are floating around. The basic version
is the one that ships with the ActiveX SDK, consisting of a number of source files
and several samples. A more thorough version, consisting of more samples and even
an AppWizard written in VB, has been available to the members of the VB 5 beta testing
group for some time.</P>
<P>The BaseCtl framework is intended merely as a sample application and does not
have the same support and backing of Microsoft as do its other development products.</P>
<P>In addition to creating ActiveX Controls (see <A HREF="ch08.htm">Chapter 8</A>
for more information), the BaseCtl framework can be used to create ActiveX Automation
Servers, which are the focus of this chapter. Like ATL, the BaseCtl is not integrated
with the VC++ IDE and requires that all code be entered and modified by hand.</P>
<P>In this chapter, you will create a simple in-process Automation Server. As with
<A HREF="ch03.htm">Chapters 3</A> and <A HREF="ch04.htm">4</A>, your sample server
implementation will be used to log string data to a file.
<H2><A NAME="Heading2"></A>Creating the Basic Project</H2>
<P>Unfortunately, the BaseCtl framework that ships in the ActiveX SDK does not have
an AppWizard like its MFC and ATL counterparts. We have provided a sample project
based on the BaseCtl samples from which you can create new projects. The sample application
that we have created is a bare-bones project similar to the kind that would be generated
by an AppWizard. We've included our own sample application because the samples included
with the BaseCtl framework are already implemented with specific features and are
intended to demonstrate different aspects of BaseCtl development, whereas our sample
is meant as a starting point for your own component development.</P>
<P>To create a new project, you first need to define a new directory into which you
can copy the sample files; in this case, call the directory BCFServer. Copy all of
the files from the BCFBasicServer directory into your new directory, BCFServer. Rename
all of the files in the BCFServer directory as described in Table 5.1. The files
dispids.h, dwinvers.h, guids.cpp, guids.h, localobj.h, and resource.h will remain
as they are. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 5.1 </B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>New Filenames</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP"><B>Old Filename</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>New Filename</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BasicAutoObj.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Tracker.h</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BasicAutoObj.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Tracker.cpp</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BCFBasicServer.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">BCFServer.h</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BCFBasicServer.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">BCFServer.cpp</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BCFBasicServer.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">BCFServer.def</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BCFBasicServer.mak</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">BCFServer.mak</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BCFBasicServer.odl</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">BCFServer.odl</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD WIDTH="138" ALIGN="LEFT" VALIGN="TOP">BCFBasicServer.rc</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">BCFServer.rc</TD>
	</TR>
</TABLE>
</P>
<P>Open the VC++ IDE, and from the <U>F</U>ile menu select the Find In Files menu
item. Look for <TT>BCFBasicServer</TT> in all of the files in the <TT>BCFServer</TT>
directory. In all of the files that contain the string <TT>BCFBasicServer</TT>, replace
the text with <TT>BCFServer</TT>. Make sure to do the text replacement on a case-sensitive
basis. Repeat the <U>F</U>ind In Files search to ensure that you did not miss any
files or <TT>BCFBasicServer</TT> entries.</P>
<P>Next search for the string <TT>BasicAutoObj</TT> and replace all of the entries
with Tracker. Do the same for the string <TT>BasicAuto</TT>. Remember all text should
be replaced on a case-sensitive basis and should be done for all of the files in
the new project directory.</P>
<P>The last step is to generate new <TT>CLSID</TT> that are unique to the project.
Use the GUIDGEN.EXE to create the new <TT>CLSID</TT>, and add them to the ODL file.</P>
<P>After all of the files have been changed, from the <U>F</U>ile menu, select the
Open <U>W</U>orkspace menu item. In the Open Workspace dialog, open the BCFServer.mak
file. The VC++ IDE will automatically create the file BCFServer.mdp file, which should
be used from this point on when opening the project file. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> At the time of the writing of this book, VC++ 5.0 was still in beta.
	The file extensions .mak and .mdp have been replaced with the extensions .dsp and
	.dsw, respectively. Using the older file extensions will in no way affect the sample
	project or your development.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The last step is to ensure that the location of the BaseCtl include files directory
and the path of the BaseCtl libraries are correct. The BCFBasicServer sample assumes
that the include directory is established in the Directory tab of the Options dialog,
which can be accessed via the <U>T</U>ools menu and the <U>O</U>ptions menu item.
The link settings of the basic project is where the path of the BaseCtl libraries
is defined. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>Linking Got You Down?</B></P>
	<P>When building your projects utilizing the BaseCtl framework, make sure that you
	use exactly the same compile settings as those used to create the library. It is
	important to check all of the settings to ensure that they match exactly. If the
	compile options do not match, the linker will be unable to create your project and
	will generate a number of linker errors.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
At this point, you can compile the project and even register it in the system registry.
However, you can do very little with it since it does not contain any methods or
properties.</P>
<P>Like all ActiveX/OLE components, ActiveX Servers are required to support registration
and unregistration if they are to be used by other applications.
<H2><A NAME="Heading3"></A>Registry</H2>
<P>The basic registration and unregistration support for the server is already implemented
by BaseCtl. Remember that the MFC implementation only allows for registering the
server.</P>
<P>Registration support is handled completely by the BaseCtl framework and is hidden
from the developer. The registration information is part of the <TT>DEFINE_AUTOMATIONOBJECT</TT>
structure (see Listing 5.1). See the BaseCtl documentation and samples for information
about the structure and its content.
<H3><A NAME="Heading4"></A>Listing 5.1 TRACKER.H--Basic Registration Information
in the DEFINE_AUTOMATIONOBJECT Structure</H3>
<P><FONT COLOR="#0066FF"><TT>// TODO: modify anything appropriate in this structure,
such as the helpfile <BR>
// name, the version number, etc. <BR>
// <BR>
DEFINE_AUTOMATIONOBJECT(Tracker, <BR>
&amp;CLSID_Tracker, <BR>
&quot;Tracker&quot;, <BR>
CTracker::Create, <BR>
1, <BR>
&amp;IID_ITracker, </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
&quot;Tracker.Hlp&quot;); </TT></FONT></P>
<H2><A NAME="Heading5"></A>Sample Server Support Code</H2>
<P>Since the server is used to output data to a file, you need to add some support
code to the application before adding its methods and properties.</P>
<P>Listing 5.2 shows the additions that are made to the class header file. First
you added two new include files that are needed to support the file and timer functions
that the server uses. A set of member variables is added for storing the file handle
and timer information that will be used throughout the server implementation.
<H3><A NAME="Heading6"></A>Listing 5.2 TRACKER.H--Sample Server Support Code Added
to the Header File</H3>
<P><FONT COLOR="#0066FF"><TT>// <BR>
#ifndef _TRACKER_H_ <BR>
<BR>
#include &quot;AutoObj.H&quot; <BR>
#include &quot;BCFServerInterfaces.H&quot; <BR>
// needed for FILE services <BR>
#include &lt;stdio.h&gt; <BR>
// needed for the high resolution timer services <BR>
#include &lt;mmsystem.h&gt; <BR>
<BR>
class CTracker : public ITracker, public CAutomationObject, ISupportErrorInfo { <BR>
<BR>
public: <BR>
<BR>
. . . <BR>
<BR>
protected: <BR>
virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut); <BR>
<BR>
private: <BR>
// member variables that nobody else gets to look at. <BR>
// TODO: add your member variables and private functions here. <BR>
<BR>
protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
}; </TT></FONT></P>
<P>In the sample implementation, the constructor and destructor implementations are
updated to open and close the log file (see Listing 5.3). First a high resolution
timer is created and its current value is stored in the member variables. The timer
is useful for determining the number of milliseconds that have passed since the last
method call was made. This is great for tracking the performance of a particular
action or set of actions.</P>
<P>You then get the current date and create a filename with the format YYYYMMDD.tracklog.
After successfully opening the file, you output some startup data to the file and
exit the constructor.</P>
<P>The destructor does the exact opposite of the constructor. If you have a valid
file handle, you write some closing information to the file and close it. Next you
terminate the timer.
<H3><A NAME="Heading7"></A>Listing 5.3 TRACKER.CPP--Sample Server Support Code Added
to the Source File</H3>
<P><FONT COLOR="#0066FF"><TT>#pragma warning(disable:4355) // using `this' in constructor
<BR>
CTracker::CTracker <BR>
( <BR>
IUnknown *pUnkOuter <BR>
) <BR>
: CAutomationObject(pUnkOuter, OBJECT_TYPE_OBJTRACKER, (void *)this) <BR>
{ <BR>
<BR>
// setup our timer resolution <BR>
m_lTimeBegin = timeBeginPeriod(1); <BR>
m_lHiResTime = m_lLastHiResTime = timeGetTime(); <BR>
<BR>
SYSTEMTIME sTime; <BR>
// get the current date and time <BR>
::GetLocalTime(&amp;sTime); <BR>
<BR>
TCHAR tstrFileName[18]; <BR>
// format the file name based on the current date <BR>
sprintf(&amp;tstrFileName[0], &quot;%04d%02d%02d.tracklog&quot;, <BR>
sTime.wYear, sTime.wMonth, sTime.wDay); <BR>
<BR>
// open a file <BR>
m_fileLog = fopen(&amp;tstrFileName[0], &quot;a&quot;); <BR>
<BR>
// if we have a file handle <BR>
if(m_fileLog) <BR>
{ <BR>
// output some starting information <BR>
fprintf(m_fileLog, &quot;************************\n&quot;); <BR>
fprintf(m_fileLog, &quot;Start %02d/%02d/%04d - %02d:%02d:%02d\n&quot;, <BR>
sTime.wMonth, sTime.wDay, sTime.wYear, <BR>
sTime.wHour, sTime.wMinute, sTime.wSecond); <BR>
fprintf(m_fileLog, &quot;\n&quot;); <BR>
} <BR>
} <BR>
#pragma warning(default:4355) // using `this' in constructor <BR>
<BR>
//=--------------------------------------------------------------------------= <BR>
// CTracker::CTracker <BR>
//=--------------------------------------------------------------------------= <BR>
// &quot;We all labour against our own cure, for death is the cure of all diseases&quot;
<BR>
// - Sir Thomas Browne (1605 - 82) <BR>
// <BR>
// Notes: <BR>
// <BR>
CTracker::~CTracker () <BR>
{ <BR>
// if we have a file handle <BR>
if(m_fileLog) <BR>
{ <BR>
SYSTEMTIME sTime; <BR>
// get the current date and time <BR>
::GetLocalTime(&amp;sTime); <BR>
<BR>
// output some closing information <BR>
fprintf(m_fileLog, &quot;\n&quot;); <BR>
fprintf(m_fileLog, &quot;End %02d/%02d/%04d - %02d:%02d:%02d\n&quot;, <BR>
sTime.wMonth, sTime.wDay, sTime.wYear, <BR>
sTime.wHour, sTime.wMinute, sTime.wSecond); <BR>
fprintf(m_fileLog, &quot;************************\n&quot;); <BR>
<BR>
// close the file <BR>
fclose(m_fileLog); <BR>
} </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} </TT></FONT></P>
<P>The last thing you need to do is update the build settings for the project. Since
the sample implementation is using some timer functions defined in mmsystem.h, you
need to link with the appropriate library file that contains their implementation.
Under the <U>P</U>roject menu, select the <U>S</U>ettings menu item. In the Project
Settings dialog select the Link tab, and add the file winmm.lib to the Object/<U>l</U>ibrary
modules edit field. Click OK to close the dialog.</P>
<P>The basic support code needed for the sample implementation has been added. The
server will open a file in its constructor and leave the file open during its entire
lifetime. When the server is destroyed, the destructor will be called, and the file
will be closed.</P>
<P>The next step is to make the sample more meaningful by adding methods and properties,
which are used to output data to the open file.
<H2><A NAME="Heading8"></A>Adding Methods</H2>
<P>An automation method consists of zero to <I>n</I> parameters and may or may not
have a return value. The term method is synonymous with function or subroutine, depending
on the particular language you are familiar with. Since your server is <TT>IDispatch</TT>-based,
you are limited to a specific set of data types. Only those data types that are valid
<TT>VARIANT</TT> data types can be passed or returned via a method.</P>
<P>The rules for declaring parameters and how they are used is very much like C++
and VB. Methods can pass parameters by value or by reference and may also declare
them as optional, meaning that the parameter does not have to be supplied.</P>
<P>When passing a parameter by value, a copy of the data is sent to the method. When
passing by reference, the address of the parameter is passed, allowing the method
to change the data.</P>
<P>Optional parameters are handled a little differently than C++, however, because
you can't specify a default value in the traditional C++ sense. Optional parameters
must be passed as <TT>VARIANT</TT> data types and not the actual data type they represent.</P>
<P>For developers using VB to access a method with optional parameters, VB will supply
the parameter for you if one has not been provided. With C++, you are still required
to supply a <TT>VARIANT</TT> parameter, even though it may not contain any data.</P>
<P>As we stated at the beginning of the chapter, the sample automation server will
be used to log strings of data to a file. The server will define the method <TT>OutputLines</TT>,
which is used by the user of the server to supply the string data that is written
to the file. The method will accept an array of strings and an optional indentation
parameter and will output the strings to the file. The indentation parameter is used
to offset the strings by <I>n</I> number of tab characters to provide simple, yet
effective, formatting to the data as it is output to the file.</P>
<P>All work involving methods and properties in BaseCtl (and also ATL) starts with
the ODL (or IDL) file. Methods and properties are declared here, first, and then
implemented in the server.</P>
<P>BaseCtl Automation Servers are dual-interface by default, so you must declare
all of the methods and properties so as to conform to standard dual-interface rules.
Refer to <A HREF="ch03.htm">Chapters 3</A> and <A HREF="ch04.htm">4</A> for more
information on dual-interface.</P>
<P>Listing 5.4 shows the declaration of the <TT>OutputLines</TT> method.</P>
<P><TT>OutputLines</TT> is defined as having two parameters: <TT>varOutputArray</TT>,
as a <TT>VARIANT</TT> passed by reference that will contain a string array of data
to output to the file, and <TT>varIndent</TT>, as a <TT>VARIANT</TT> passed by value,
which is also an optional parameter indicating the amount of indentation when writing
the string data to the file. The third parameter is actually the return type of the
method and is defined as a <TT>Boolean</TT>.</P>
<P>See <A HREF="ch03.htm">Chapter 3</A> regarding the use of Boolean data types and
the differences between VB and VC++.</P>
<P>Due to data type restrictions imposed by OLE Automation, you cannot pass arrays
as parameters of methods. You can, however, pass <TT>VARIANT</TT> data types that
can contain arrays, thus the reason for defining <TT>varOutputArray</TT> as a Variant.
You are also required to pass <TT>varOutputArray</TT> by reference because the array
stored in the VARIANT does not get copied over when it is passed by value.</P>
<P>Optional parameters must fall at the end of the parameter list and must be of
type <TT>VARIANT</TT>. <TT>varIndent</TT> is an optional parameter that indents your
text output as an added formatting feature (see Listing 5.4).
<H3><A NAME="Heading9"></A>Listing 5.4 BCFSERVER.ODL--OutputLines Method ODL Declaration</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
[ <BR>
uuid(5ea29be0-5a82-11d0-bcbc-0020afd6738c), <BR>
helpstring(&quot;Tracker Object&quot;), <BR>
hidden, <BR>
dual, <BR>
odl <BR>
] <BR>
interface ITracker : IDispatch { <BR>
<BR>
// properties <BR>
// <BR>
<BR>
// methods <BR>
[id(2)] HRESULT OutputLines([in] VARIANT * varOutputArray, <BR>
[in, optional] VARIANT varIndent, [out, retval] boolean * RetVal); <BR>
}; <BR>
<BR>
// coclass for CTracker objects <BR>
// <BR>
</TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . </TT></FONT></P>
<P>When the ODL file is compiled into a type library, the compiler will create a
header file that contains all of the interface and <TT>CLSID</TT> declarations in
C++ format. It is from this file that you will copy all of the function prototypes
that are needed in your server implementation for defining the methods and properties
that it contains. From the file BCFServerInterfaces.h, copy the <TT>OutputLines</TT>
function prototype, and paste it into the class definition of the server (see Listing
5.5). Remember to remove the <TT>PURE</TT> keyword from the function prototype.</P>
<P>For the purposes of the sample implementation, you also need to add the <TT>m_lIndent</TT>
member variable, which is used in the <TT>OutputLines</TT> method implementation,
and later as a property of the server.
<H3><A NAME="Heading10"></A>Listing 5.5 TRACKER.H--OutputLines Function Prototype
Added to the Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . <BR>
<BR>
CTracker(IUnknown *); <BR>
virtual ~CTracker(); <BR>
<BR>
// ITracker methods <BR>
STDMETHOD(OutputLines)(VARIANT FAR* varOutputArray, VARIANT varIndent, <BR>
VARIANT_BOOL FAR* RetVal); <BR>
<BR>
// creation method <BR>
// <BR>
static IUnknown *Create(IUnknown *); <BR>
<BR>
protected: <BR>
virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut); <BR>
<BR>
private: <BR>
// member variables that nobody else gets to look at. <BR>
// TODO: add your member variables and private functions here. <BR>
<BR>
protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; <BR>
long m_lIndent; <BR>
}; <BR>
</TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
. . .</TT></FONT></P>
<PRE><FONT COLOR="#0066FF"><TT></TT></FONT></PRE>
<P>Before adding the <TT>OutputLines</TT> implementation, it is necessary to update
the constructor to initialize the <TT>m_lIndent</TT> member variable to a valid state
(see Listing 5.6).
<H3><A NAME="Heading11"></A>Listing 5.6 TRACKER.CPP--Member Initialization in the
Constructor</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . <BR>
<BR>
// output some starting information <BR>
fprintf(m_fileLog, &quot;************************\n&quot;); <BR>
fprintf(m_fileLog, &quot;Start %02d/%02d/%04d - %02d:%02d:%02d\n&quot;, <BR>
sTime.wMonth, sTime.wDay, sTime.wYear, <BR>
sTime.wHour, sTime.wMinute, sTime.wSecond); <BR>
fprintf(m_fileLog, &quot;\n&quot;); <BR>
} <BR>
<BR>
m_lIndent = 0; <BR>
} </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
#pragma warning(default:4355) // using `this' in constructor </TT></FONT></P>
<P>Next you add the <TT>OutputLines</TT> implementation to the source file as in
Listing 5.7. The implementation varies very little from the ATL sample.</P>
<P>As with the MFC and ATL implementations, the BaseCtl version checks the array
parameter to ensure its validity and, if so, outputs the data to the file, indenting
the text if appropriate. See <A HREF="ch03.htm">Chapter 3 </A>for more information
regarding the other implementation details.</P>
<P>For now, the implementation returns <TT>VARIANT_FALSE</TT> in the cases where
an error has occurred. Later in this chapter, you will learn how to create rich error
information.
<H3><A NAME="Heading12"></A>Listing 5.7 TRACKER.CPP--OutputLines Function Implementation
Added to the Source File Tracker.cpp</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::OutputLines(VARIANT FAR* varOutputArray, VARIANT varIndent,
VARIANT_BOOL FAR* RetVal) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
<BR>
*RetVal = VARIANT_TRUE; <BR>
<BR>
// if we have a file and if the variant contains a string array <BR>
if(m_fileLog &amp;&amp; varOutputArray-&gt;vt == (VT_ARRAY | VT_BSTR)) <BR>
{ <BR>
// lock the array so we can use it <BR>
if(::SafeArrayLock(varOutputArray-&gt;parray) == S_OK) <BR>
{ <BR>
LONG lLBound; <BR>
<BR>
// get the lower bound of the array <BR>
if(::SafeArrayGetLBound(varOutputArray-&gt;parray, 1, &amp;lLBound) == S_OK) <BR>
{ <BR>
LONG lUBound; <BR>
<BR>
// get the number of elements in the array <BR>
if(::SafeArrayGetUBound(varOutputArray-&gt;parray, 1, &amp;lUBound) == S_OK) <BR>
{ <BR>
SYSTEMTIME sTime; <BR>
BSTR bstrTemp; <BR>
<BR>
// if we have an indent parameter <BR>
if(varIndent.vt != VT_I4) <BR>
{ <BR>
// get a variant that we can use for conversion purposes <BR>
VARIANT varConvertedValue; <BR>
<BR>
// initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); <BR>
<BR>
// see if we can convert the data type to something useful <BR>
// - VariantChangeTypeEx() could also be used <BR>
if(S_OK == ::VariantChangeType(&amp;varConvertedValue, <BR>
(VARIANT *) &amp;varIndent, 0, VT_I4)) <BR>
// assign the value to our member variable <BR>
m_lIndent = varConvertedValue.lVal; <BR>
} <BR>
else <BR>
// assign the value to our member variable <BR>
m_lIndent = varIndent.lVal; <BR>
<BR>
// for each of the elements in the array <BR>
for(long lArrayCount = lLBound; lArrayCount &lt; <BR>
(lUBound + lLBound); lArrayCount++) <BR>
{ <BR>
// get the current date and time <BR>
::GetLocalTime(&amp;sTime); <BR>
m_lHiResTime = timeGetTime(); <BR>
<BR>
// get the data from the array <BR>
if(::SafeArrayGetElement(varOutputArray-&gt;parray, <BR>
&amp;lArrayCount, &amp;bstrTemp) == S_OK) <BR>
{ <BR>
// output the data <BR>
fprintf(m_fileLog, &quot;%02d:%02d:%02d(%10ld)-&quot;, <BR>
sTime.wHour, sTime.wMinute, sTime.wSecond, m_lHiResTime - m_lLastHiResTime); <BR>
<BR>
// if we have to indent the text <BR>
for(long lIndentCount = 0; lIndentCount &lt; m_lIndent; <BR>
lIndentCount++) <BR>
// add a tab to the string <BR>
fprintf(m_fileLog, &quot;\t&quot;); <BR>
<BR>
// output the data <BR>
fprintf(m_fileLog, &quot;%ls\n&quot;, bstrTemp); <BR>
<BR>
// store the last timer value <BR>
m_lLastHiResTime = m_lHiResTime; <BR>
<BR>
// free the bstr <BR>
::SysFreeString(bstrTemp); <BR>
} <BR>
} <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
<BR>
// unlock the array we don't need it anymore <BR>
::SafeArrayUnlock(varOutputArray-&gt;parray); </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} <BR>
else </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
*RetVal = VARIANT_FALSE; <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
<BR>
// return the result <BR>
return hResult; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} </TT></FONT></P>
<P>Now that you have added a method, you will learn how to implement its counterpart,
the Property.
<H2><A NAME="Heading13"></A>Adding Properties</H2>
<P>A <I>property</I> can be thought of as an exposed variable that is defined in
the automation server. Properties are useful for setting and retrieving information
about the state of the server.</P>
<P>The <TT>m_lIndent</TT> member variable that you added to the class definition
is a perfect candidate to be exposed as a property.</P>
<P>As with methods, properties are also added to a server via the ODL file. Listing
5.8 shows the ODL declaration for the <TT>Indent</TT> property. As stated in <A HREF="ch03.htm">Chapters
3</A> and <A HREF="ch04.htm">4</A>, properties are implemented as a pair of methods,
one to get the value and the other to set the value. Since the server is dual-interface
by default, the methods must also conform to dual-interface declaration rules.
<H3><A NAME="Heading14"></A>Listing 5.8 BCFSERVER.ODL--Indent Property Added to the
ODL</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
<BR>
interface ITracker : IDispatch { <BR>
<BR>
// properties <BR>
[id(1), propget] HRESULT Indent([out, retval] long * Value); <BR>
[id(1), propput] HRESULT Indent([in] long Value); <BR>
<BR>
// methods <BR>
[id(2)] HRESULT OutputLines([in] VARIANT * varOutputArray, <BR>
[in, optional] VARIANT varIndent, [out, retval] boolean * RetVal); <BR>
}; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
</TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . </TT></FONT></P>
<P>Compile the ODL file, and copy the function prototypes from the BCFServerInterfaces.h
file to the <TT>Tracker</TT> class definition (see Listing 5.9). Don't forget to
remove the <TT>PURE</TT> keyword from the new function declarations.
<H3><A NAME="Heading15"></A>Listing 5.9 TRACKER.H--Indent Property Function Prototypes
Added to the Class Definition</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . <BR>
<BR>
CTracker(IUnknown *); <BR>
virtual ~CTracker(); <BR>
<BR>
// ITracker methods <BR>
STDMETHOD(get_Indent)(long FAR* Value); <BR>
STDMETHOD(put_Indent)(long Value); <BR>
STDMETHOD(OutputLines)(VARIANT FAR* varOutputArray, VARIANT varIndent, VARIANT_BOOL
FAR* RetVal); <BR>
<BR>
// creation method <BR>
// <BR>
static IUnknown *Create(IUnknown *); </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
</TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . </TT></FONT></P>
<P>The actual implementation of the <TT>Indent</TT> property is very simple (see
Listing 5.10). <TT>Get_Indent</TT> returns the value currently stored in the member
variable, and <TT>Put_Indent</TT> stores the new value, after a little bit of error
checking, in the member variable.
<H3><A NAME="Heading16"></A>Listing 5.10 TRACKER.CPP--Indent Property Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::get_Indent(long FAR *Value) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
<BR>
// return the member variable <BR>
*Value = m_lIndent; <BR>
<BR>
// return the result <BR>
return hResult; <BR>
} <BR>
<BR>
STDMETHODIMP CTracker::put_Indent(long Value) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
<BR>
// if the new value is a least 0 <BR>
if(Value &gt;= 0) <BR>
// assign the value to our member variable <BR>
m_lIndent = Value; <BR>
<BR>
// return the result <BR>
return hResult; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} </TT></FONT></P>
<P>Properties, like methods, also have a wide variety of implementation options,
including parameterized and enumerated values. See <A HREF="ch06.htm">Chapters 6</A>
through <A HREF="ch11.htm">11</A> on developing ActiveX controls for descriptions
of more options and features when creating properties.</P>
<P>You've added methods and properties to the server, but you haven't really dealt
with the issue of error handling in their implementation. In some cases, simply returning
success or failure is not enough information for the developer to understand that
an error occurred and what caused it. You will communicate more error information
through the use of OLE exceptions.
<H2><A NAME="Heading17"></A>Generating OLE Exceptions</H2>
<P>While executing a method call or some other action, it is necessary at times to
terminate the process due to some critical error that has occurred or is about to
occur. For example, a method is called to write data to a file, but the method cannot
open the file because there is not enough room on the hard disk to do so. It is necessary
to halt further processing until the error can be resolved. This is known as an <I>exception</I>.
Any type of error can be treated as an exception; it depends on the requirements
of your application and how you choose to deal with the errors that may result.</P>
<P>You must become familiar with two forms of exceptions when creating ActiveX components.
The first is a <I>C++ exception. </I>A C++ exception is a language mechanism used
to create critical errors of the type described earlier and that are confined to
the application in which they are defined. The second is an <I>OLE exception. </I>OLE
exceptions are used to communicate the same kinds of errors externally to applications
that are using a component. The difference between the two is that C++ exceptions
are used internally to an application's implementation and OLE exceptions are used
externally to communicate errors to other applications.</P>
<P>The COM implementation of a method in a Dual-Interface Server does not have the
same kind of error management features that <TT>IDispatch</TT> interfaces have. To
generate the proper error information, an application must use the <TT>IErrorInfo</TT>
object, which is provided by the operating system. A server need only support the
<TT>ISupportErrorInfo</TT> interface, which lets an automation controller know that
it should look at the <TT>IErrorInfo</TT> object for more information when an error
occurs.</P>
<P>The first step is to add an enumeration of the types of errors that the server
can generate to the ODL file (see Listing 5.11). This step has the effect of publishing
the error constants to the user of the automation server. The enumeration can be
added anywhere within the ODL file and still produce the proper C++ declaration in
the BCFServerInterfaces.h file. Remember to generate a new <TT>CLSID</TT> for the
enumeration.
<H3><A NAME="Heading18"></A>Listing 5.11 BCFSERVER.ODL--Error Enumeration in the
ODL File</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
coclass Tracker { <BR>
[default] interface ITracker; <BR>
}; <BR>
<BR>
typedef [uuid(AA3DFE23-5C1C-11d0-BEE7-00400538977D), <BR>
helpstring(&quot;Tracker Error Constants&quot;)] <BR>
enum tagTrackerError <BR>
{ <BR>
MFCSERVER_E_NO_UBOUND = 46080, <BR>
MFCSERVER_E_NO_LBOUND = 46081, <BR>
MFCSERVER_E_NO_ARRAYLOCK = 46082, <BR>
MFCSERVER_E_NO_FILE = 46083, <BR>
MFCSERVER_E_BAD_ARRAY_PARAMETER = 46084, <BR>
MFCSERVER_E_INVALID_VALUE = 46085 <BR>
}TRACKERERROR; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
}; </TT></FONT></P>
<P>The next step is to add the actual error generating code. Listing 5.12 shows the
additional code that is added to the server implementation of <TT>OutputLines</TT>
and <TT>put_Indent</TT> to enable error generation.</P>
<P>BaseCtl provides a helper function <TT>Exception</TT> for generating rich error
information. This function takes three parameters: an error number, a string resource
ID, and a help context ID. See <A HREF="ch03.htm">Chapters 3</A> and <A HREF="ch04.htm">4</A>
for more information regarding rich error information.
<H3><A NAME="Heading19"></A>Listing 5.12 TRACKER.CPP--Rich Error Information Added
to Tracker Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::OutputLines(VARIANT FAR* varOutputArray, VARIANT varIndent,
VARIANT_BOOL FAR* RetVal) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
<BR>
*RetVal = VARIANT_TRUE; <BR>
<BR>
// if we have a file and if the variant contains a string array <BR>
if(m_fileLog &amp;&amp; varOutputArray-&gt;vt == (VT_ARRAY | VT_BSTR)) <BR>
{ <BR>
// lock the array so we can use it <BR>
if(::SafeArrayLock(varOutputArray-&gt;parray) == S_OK) <BR>
{ <BR>
LONG lLBound; <BR>
<BR>
// get the lower bound of the array <BR>
if(::SafeArrayGetLBound(varOutputArray-&gt;parray, 1, &amp;lLBound) == S_OK) <BR>
{ <BR>
LONG lUBound; <BR>
<BR>
// get the number of elements in the array <BR>
if(::SafeArrayGetUBound(varOutputArray-&gt;parray, 1, &amp;lUBound) <BR>
== S_OK) <BR>
{ <BR>
. . . <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
</TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
// create the error message <BR>
hResult = this-&gt;Exception( <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_NO_UBOUND), <BR>
IDS_E_NO_UBOUND, <BR>
NULL); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; <BR>
<BR>
// create the error message <BR>
hResult = this-&gt;Exception( <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_NO_LBOUND), <BR>
IDS_E_NO_LBOUND, <BR>
NULL); <BR>
} <BR>
<BR>
// unlock the array we don't need it anymore <BR>
::SafeArrayUnlock(varOutputArray-&gt;parray); <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; <BR>
<BR>
// create the error message <BR>
hResult = this-&gt;Exception( <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_ARRAYLOCK), <BR>
IDS_E_NO_ARRAYLOCK, <BR>
NULL); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; <BR>
<BR>
// if there wasn't a file <BR>
if(!m_fileLog) <BR>
// create the error message <BR>
hResult = this-&gt;Exception( <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_FILE), <BR>
IDS_E_NO_FILE, <BR>
NULL); <BR>
else <BR>
// create the error message <BR>
hResult = this-&gt;Exception( <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_BAD_ARRAY_PARAMETER), <BR>
IDS_E_BAD_ARRAY_PARAMETER, <BR>
NULL); <BR>
} <BR>
<BR>
// return the result <BR>
return hResult; <BR>
} <BR>
<BR>
STDMETHODIMP CTracker::get_Indent(long FAR *Value) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
<BR>
// return the member variable <BR>
*Value = m_lIndent; <BR>
<BR>
// return the result <BR>
return hResult; <BR>
} <BR>
<BR>
STDMETHODIMP CTracker::put_Indent(long Value) <BR>
{ <BR>
HRESULT hResult = S_OK; <BR>
<BR>
// if the new value is at least 0 <BR>
if(Value &gt;= 0) <BR>
// assign the value to our member variable <BR>
m_lIndent = Value; <BR>
else <BR>
{ <BR>
// create the error message <BR>
hResult = this-&gt;Exception( <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_INVALID_VALUE), <BR>
IDS_E_INVALID_VALUE, <BR>
NULL); <BR>
} <BR>
<BR>
// return the result <BR>
return hResult; </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} </TT></FONT></P>
<P>Take care when defining your interfaces and how they communicate errors and invalid
conditions. The use of rich error information is very helpful to the user of the
component and can be as critical to the implementation as the methods and properties
that the server supports.
<H2><A NAME="Heading20"></A>Dual-Interface</H2>
<P>In <A HREF="ch03.htm">Chapter 3</A>, the basic MFC server is implemented as <TT>IDispatch</TT>
only, and you are required to add dual-interface support as an extra step. With BaseCtl,
dual-interface support is built in and implemented as a normal aspect of the server.
<H2><A NAME="Heading21"></A>Generating Dual-Interface OLE Exceptions</H2>
<P>Again as in <A HREF="ch03.htm">Chapter 3</A>, the basic MFC server is implemented
as <TT>IDispatch</TT> only, and it is possible to throw standard C++ exceptions and
have the basic MFC <TT>IDispatch</TT> support code translate the error into an OLE
exception. When an MFC server is converted to dual-interface, you must implement
the exception translation code yourself.</P>
<P>For BaseCtl, the server has been implemented as dual-interface from the start,
and all error generation has been written as true OLE exceptions and does not require
translation as in MFC.
<H2><A NAME="Heading22"></A>Server Instantiation Using C++</H2>
<P>OLE is not the only method for creating and using automation servers. This chapter
will show you how to create OLE servers using C++ syntax.</P>
<P>At times, creating and using automation servers is necessary from within the application
in which they are defined. Take, for example, a case where an application contains
three servers, only one of which is directly creatable by outside applications using
OLE. The remaining two servers can be created by the exposed server using C++ and
returned via a method call to another application, which then uses the server as
though it were created via OLE.</P>
<P>For an MFC server, the inclusion or exclusion of the macros <TT>DECLARE_OLECREATE</TT>
and <TT>IMPLEMENT_OLECREATE</TT> determined whether a server is creatable by external
applications. For BaseCtl, it is a little simpler. All BaseCtl applications contain
a global variable called <TT>ObjectInfo</TT> for declaring all of the servers that
can be created via OLE. The <TT>ObjectInfo</TT> structure is declared in the main
application file:</P>
<P><FONT COLOR="#0066FF"><TT><BR>
OBJECTINFO g_ObjectInfo[] = { <BR>
EMPTYOBJECT </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
}; </TT></FONT></P>
<P>Each OLE server implemented within the application will have a single entry within
the body of the <TT>ObjectInfo</TT> structure, thus identifying it as an exposed
OLE server. The <TT>AUTOMATIONOBJECT</TT> macro defines the C++ class of the server
that can be created:</P>
<P><FONT COLOR="#0066FF"><TT><BR>
OBJECTINFO g_ObjectInfo[] = { <BR>
AUTOMATIONOBJECT(Tracker), <BR>
EMPTYOBJECT </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
}; </TT></FONT></P>
<P>To prevent an application from being exposed as an automation server, you only
need to remove or comment out the entry in the object map. On the opposite side,
when adding additional creatable servers to an application, it is important to add
an entry for each new server to the <TT>ObjectInfo</TT> structure.</P>
<P>All BaseCtl servers contain a static function <TT>Create</TT> that is used to
create instances of themselves. The <TT>Create</TT> function is the only way that
you should instantiate a server since it is implemented by the class factory of the
server and will manage the server creation correctly. This is critical in the cases
where the server is shared among two or more applications, as you will see in the
next sections.</P>
<P>Listing 5.13 shows an example of creating a server using C++ syntax. <TT>Create</TT>
returns an <TT>IUnknown *</TT>, which is used to retrieve the proper custom interface
that can then be cast to the C++ class of the server. Remember to check all of the
return values and pointers to ensure that all of the method calls returned successfully.
Don't forget to increment and decrement the reference counts of the server to ensure
that its lifetime is what you expect. You must also navigate to the correct interface
using the function <TT>QueryInterface</TT>, as is the case in Listing 5.13, which
is looking for the custom interface pointer of the <TT>IID_ITracker</TT> object.
A simple cast from the <TT>Create</TT> function <TT>IUnknown *</TT> to the C++ class
is not enough to get the correct function offsets.
<H3><A NAME="Heading23"></A>Listing 5.13 Example--Creating an OLE Server Using C++</H3>
<P><FONT COLOR="#0066FF"><TT>// create the server <BR>
IUnknown * pUnk = CTracker::Create(NULL); <BR>
<BR>
// if we have an IUnknown <BR>
if(pUnk) <BR>
{ <BR>
// custom interface reference <BR>
ITracker * pTrack = NULL; <BR>
<BR>
// QI for the custom interface and if successful <BR>
if(pUnk-&gt;QueryInterface(IID_ITracker, (LPVOID *) &amp;pTrack) == S_OK) <BR>
{ <BR>
// too many ref counts - release one <BR>
pTrack-&gt;Release(); <BR>
<BR>
// object reference <BR>
CTracker * opTracker = NULL; <BR>
<BR>
// cast to the object <BR>
opTracker = (CTracker *) pTrack; <BR>
<BR>
// use the object <BR>
opTracker-&gt;put_Indent(1); <BR>
<BR>
// release the object - this is the last one so the <BR>
// object should be destroyed <BR>
opTracker-&gt;Release(); <BR>
} <BR>
else <BR>
// release the IUnknown - we couldn't find the custom interface <BR>
pUnk-&gt;Release(); </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} </TT></FONT></P>
<P>After a server has been created this way, it can be used like any other C++ class
or OLE server. Since the server is a running OLE Object, all of the standard OLE
functions work, and the server can be used from other applications; for example,
<TT>QueryInterface</TT> can be used to retrieve <TT>IDispatch</TT> or custom interface
pointers that can be passed to other applications. See <A HREF="ch03.htm">Chapter
3</A> for more information regarding the creation and use of OLE servers with C++.</P>
<P>So far, you've looked only at how to create individual instances of objects. Next
you will find out how to share objects.
<H2><A NAME="Heading24"></A>Shared Servers</H2>
<P>OLE defines a facility, called the Running Object Table, for sharing objects.
An object that is shareable will publish its <TT>CLSID</TT> and an <TT>IUnknown</TT>
reference to itself in the Running Object Table. Any application that so desires
can ask for the running instance of the object rather than create a new instance.
This capability is useful for applications that may need to work with a single instance
of an application rather than create multiple copies. The <TT>Tracker</TT> object
is a perfect candidate for this kind of functionality. Multiple applications could
use the same <TT>Tracker</TT> object to log information thus saving on memory.</P>
<P>The first step is to register the server as running (see Listing 5.14). The BaseCtl
Framework allows access to the basic <TT>ClassFactory</TT> operation of creating
the server through the static <TT>Create</TT> function. Since this function is where
all instances of the server are created, the <TT>Create</TT> function is the most
logical location to register the server as running.</P>
<P>After the new object is created, you should <TT>QueryInterface</TT> for an <TT>IUnknown</TT>
reference to the server. If successful, you call the <TT>RegisterActiveObject</TT>
passing the <TT>IUnknown</TT> and the <TT>CLSID</TT> of the server. This sample implementation
passes the constant <TT>ACTIVEOBJECT_STRONG</TT>, which will result in the reference
count of the server being incremented by one. See the VC++ documentation for more
information regarding this parameter. You must also pass the address of a member
variable to store the ID of the running object. The ID is used later when revoking
the object from the Running Object Table. Last you must decrement the reference count
of the server to offset the <TT>QueryInterface</TT> call.
<H3><A NAME="Heading25"></A>Listing 5.14 TRACKER.CPP--Create Function Implementation
of Shared Object Support</H3>
<P><FONT COLOR="#0066FF"><TT>IUnknown *CTracker::Create <BR>
( <BR>
IUnknown *pUnkOuter <BR>
) <BR>
{ <BR>
// make sure we return the private unknown so that we support aggegation <BR>
// correctly! <BR>
// <BR>
CTracker *pNew = new CTracker(pUnkOuter); <BR>
<BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// QI for the IUnknown and if successful <BR>
if(pNew-&gt;QueryInterface(IID_IUnknown, (LPVOID *) &amp;pIUnknown) == S_OK) <BR>
{ <BR>
// register the clsid as an active object <BR>
// so other applications will get the same object <BR>
// and if it didn't succeed - this function will <BR>
// increment the reference count because of the ACTIVEOBJECT_STRONG <BR>
if(::RegisterActiveObject(pIUnknown, CLSID_Tracker, <BR>
ACTIVEOBJECT_STRONG, &amp;pNew-&gt;m_dwRegister) != S_OK) <BR>
// make sure that the reference ID is clear <BR>
pNew-&gt;m_dwRegister = NULL; <BR>
<BR>
// remove the extra refcount from the QI <BR>
pIUnknown-&gt;Release(); <BR>
} <BR>
<BR>
return pNew-&gt;PrivateUnknown(); </TT></FONT></P>
<P><FONT COLOR="#0066FF"><TT><BR>
} </TT></FONT></P>
<P>You've added the code to register the server in the Running Object Table, but
now you need to add code to remove the server from the table. The only practical
way to remove the server from the Running Object Table is to monitor the reference
counts of the server. When the reference count reaches one--indicating that the only
reference left is the Running Object Table's reference--revoke the server's reference
from the Running Object Table. The only location that you can use to accurately monitor
the reference count of the server is in the <TT>IUnknown::Release</TT> function implementation.</P>
<P>To aid in the implementation of the <TT>IUnknown::Release</TT> function, we have
supplied a new macro to handle the revoking the server from the Running Object Table
(see Listing 5.15). The implementation checks to see whether an ID is present for
the server and whether the reference count is one and revokes the server from the
Running Object Table. The implementation also increments the reference count and
clears the ID member variable to prevent the object from being destroyed before this
function has completed and also to prevent the code from becoming recursive. Incrementing
the reference count and clearing the member variable is necessary since the <TT>RevokeActiveObject</TT>
function call will result in another call to <TT>Release</TT> to decrement the reference
of the server. After <TT>RevokeActiveObject</TT> returns, the server removes its
last reference count, which results in the destruction of the server.
<H3><A NAME="Heading26"></A>Listing 5.15<SPACER TYPE="HORIZONTAL" SIZE="10"> RACKER.H--DECLARE_STANDARD_UNKNOWN_SHARED
Macro Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
#define DECLARE_STANDARD_UNKNOWN_SHARED() \ <BR>
STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \ <BR>
return ExternalQueryInterface(riid, ppvObjOut); \ <BR>
} \ <BR>
STDMETHOD_(ULONG, AddRef)(void) { \ <BR>
return ExternalAddRef(); \ <BR>
} \ <BR>
STDMETHOD_(ULONG, Release)(void) \ <BR>
{ \ <BR>
long lRefCount = this-&gt;ExternalRelease(); \ <BR>
if(this-&gt;m_dwRegister &amp;&amp; lRefCount == 1) \ <BR>
{ \ <BR>
this-&gt;ExternalAddRef(); \ <BR>
DWORD tdwRegister = this-&gt;m_dwRegister; \ <BR>
this-&gt;m_dwRegister = 0; \ <BR>
::RevokeActiveObject(tdwRegister, NULL); \ <BR>
return this-&gt;ExternalRelease(); \ <BR>
} \ <BR>
else \ <BR>
return lRefCount; \ <BR>
} \ <BR>
DWORD m_dwRegister; </TT></FONT></P>

<P>The last step is to update the class declaration of your server to use the new
macro (see Listing 5.16). Replace the <TT>DECLARE_STANDARD_UNKNOWN()</TT> with <TT>DECLARE_STANDARD_UNKNOWN_SHARED()</TT>.
<H3><A NAME="Heading27"></A>Listing 5.16 TRACKER.H--New Macro</H3>
<P><FONT COLOR="#0066FF"><TT>class CTracker : public ITracker, public CAutomationObject,
ISupportErrorInfo { <BR>
public: <BR>
// IUnknown methods <BR>
// <BR>
DECLARE_STANDARD_UNKNOWN_SHARED(); <BR>
// IDispatch methods <BR>
// <BR>
DECLARE_STANDARD_DISPATCH(); <BR>
. . . </TT></FONT></P>

<P>During the lifetime of the server, an application is capable of getting the instance
of the running server with a method call to OLE. In VB, you use the <TT>GetObject</TT>
method call, and in VC++, you use the <TT>GetActiveObject</TT> function. After the
pointer to the server is retrieved, the server can be used as though it were created
through normal OLE mechanisms.</P>

<P>This method of sharing objects is fine but requires that the developer of the
application using the server take an active role in deciding to use the shared object
versus creating a new instance of the object. Another approach can be taken, and
that is to supply the instance of a running server to an application that calls <TT>CreateObject</TT>
rather than <TT>GetObject</TT>. A server implemented to always return the same instance
to any application is referred to as a single instance server.
<H2><A NAME="Heading28"></A>Single Instance Servers</H2>
<P>A single instance server is used in the cases where you do not want the users
of the component to have a choice in using a shared instance of the server or a copy
that they create themselves. No matter what, you want to create only a single running
instance of the server that is shared by all applications.</P>
<P>To enable a BaseCtl server for single instance requires that you modify the code
that was added to the <TT>Create</TT> function in the section &quot;Shared Servers.&quot;
Listing 5.17 shows the changes that you made to the sample implementation to enable
single instance support. First, you must look to see whether the server is already
registered as running. If not, a server is created and registered as running.</P>
<P>If the server is already running, you must <TT>QueryInterface</TT> for the custom
interface pointer so that you can cast to the correct C++ class type. The last step
is to call <TT>Release</TT> since there will be an extra reference count from the
<TT>GetActiveObject</TT> and <TT>QueryInterface</TT> calls.
<H3><A NAME="Heading29"></A>Listing 5.17 TRACKER.CPP--Create Function Implementation
Updated to Support Single Instance Servers</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
IUnknown *CTracker::Create <BR>
( <BR>
IUnknown *pUnkOuter <BR>
) <BR>
{ <BR>
CTracker *pNew = NULL; <BR>
<BR>
// Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// see if the object is already running <BR>
::GetActiveObject(CLSID_Tracker, NULL, &amp;pIUnknown); <BR>
<BR>
// if we didn't get a reference to a running object <BR>
if(!pIUnknown) <BR>
{ <BR>
// make sure we return the private unknown so that we support // aggegation correctly!
<BR>
// <BR>
pNew = new CTracker(pUnkOuter); <BR>
<BR>
// QI for the IUnknown and if successful <BR>
if(pNew-&gt;QueryInterface(IID_IUnknown, (LPVOID *) &amp;pIUnknown) == S_OK) <BR>
{ <BR>
// register the clsid as an active object <BR>
// so other applications will get the same object <BR>
// and if it didn't succeed - this function will <BR>
// increment the reference count because of the ACTIVEOBJECT_STRONG <BR>
if(::RegisterActiveObject(pIUnknown, CLSID_Tracker, <BR>
ACTIVEOBJECT_STRONG, &amp;pNew-&gt;m_dwRegister) != S_OK) <BR>
// make sure that the reference ID is clear <BR>
pNew-&gt;m_dwRegister = NULL; <BR>
<BR>
// remove the extra refcount from the QI <BR>
pIUnknown-&gt;Release(); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
// custom interface reference <BR>
ITracker * pTrack = NULL; <BR>
<BR>
// QI for the custom interface and if successful <BR>
if(pIUnknown-&gt;QueryInterface(IID_ITracker, (LPVOID *) &amp;pTrack) == S_OK) <BR>
{ <BR>
// too many ref counts - release one <BR>
pTrack-&gt;Release(); <BR>
<BR>
// cast to the object <BR>
pNew = (CTracker *) pTrack; <BR>
} <BR>
else <BR>
{ <BR>
// release the IUnknown - we couldn't find the custom interface <BR>
pIUnknown-&gt;Release(); <BR>
<BR>
// go ahead and create an object <BR>
pNew = new CTracker(pUnkOuter); <BR>
<BR>
// QI for the IUnknown and if successful <BR>
if(pNew-&gt;QueryInterface(IID_IUnknown, (LPVOID *) &amp;pIUnknown) == S_OK) <BR>
{ <BR>
// register the clsid as an active <BR>
// object so other applications will get the same object <BR>
// and if it didn't succeed - this function will <BR>
// increment the reference count because of the ACTIVEOBJECT_STRONG <BR>
if(::RegisterActiveObject(pIUnknown, CLSID_Tracker, <BR>
ACTIVEOBJECT_STRONG, &amp;pNew-&gt;m_dwRegister) != S_OK) <BR>
// make sure that the reference ID is clear <BR>
pNew-&gt;m_dwRegister = NULL; <BR>
<BR>
// remove the extra refcount from the QI <BR>
pIUnknown-&gt;Release(); <BR>
} <BR>
} <BR>
} <BR>
return pNew-&gt;PrivateUnknown(); <BR>
} </TT></FONT></P>

<P>Shared server support is very straightforward to implement and use and adds a
level of functionality not normally available to standard server implementations.
<H2><A NAME="Heading30"></A>User Interface and Events</H2>
<P>Like MFC and ATL, BaseCtl servers can also benefit from the addition of User Interface
(UI) and Events. Again, since BaseCtl does not offer integration with MFC, you will
be forced to implement all of the UI with the standard Win32 functions, which is
not a very appealing prospect. At the time this book was written, only Visual Basic
5 was capable of using event interfaces in automation servers.
<H2><A NAME="Heading31"></A>From Here...</H2>
<P>In this chapter, you created a simple implementation of a BaseCtl automation server.
You also learned how to expand upon the basic framework provided by BaseCtl to create
new and interesting features within your implementation. BaseCtl provides a simple
and straightforward framework for creating Automation Servers. Unfortunately, the
lack of MFC integration and support from Microsoft as a development platform will
put it last on your list of choices when selecting a development direction.</P>
<P>For those of you who are willing to or interested in learning more about Automation
Servers and ActiveX architecture, the BaseCtl is a fine way to learn since it is
so lean. The BaseCtl is probably better in this area than ATL because you won't have
to understand the concept of templates while also learning ActiveX.</P>

<P>The next six chapters take a look at implementing ActiveX controls using the same
three tool sets: MFC, ATL, and BaseCtl.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
