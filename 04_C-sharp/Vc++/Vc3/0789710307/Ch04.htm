<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 9:46 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 4</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 4<BR>
Creating ActiveX Automation Servers Using ATL</H1>

<UL>
	<LI><A HREF="#Heading1">Creating ActiveX Automation Servers Using ATL</A>
	<UL>
		<LI><A HREF="#Heading2">Creating the Basic Project</A>
		<LI><A HREF="#Heading3">Adding an Automation Interface to the Application</A>
		<UL>
			<LI><A HREF="#Heading4">Listing 4.1 ATLSERVER.IDL--IDL File for the ATL Server Sample</A>
		</UL>
		<LI><A HREF="#Heading5">Registry</A>
		<UL>
			<LI><A HREF="#Heading6">Listing 4.2 ATLCONTROLWIN.RGS--Sample Registry Script File
			for the</A><A HREF="#Heading7">CTracker Server Object</A>
			<LI><A HREF="#Heading8">Listing 4.3 TRACKER.RGS--Updated Tracker.rgs File</A>
		</UL>
		<LI><A HREF="#Heading9">Sample Server Support Code</A>
		<UL>
			<LI><A HREF="#Heading10">Listing 4.4 Tracker.H--Sample Server Support Code Added
			to the</A> <A HREF="#Heading11">Tracker Header File</A>
			<LI><A HREF="#Heading12">Listing 4.5 TRACKER.CPP--Sample Server Support Code Added
			to the Source File</A>
		</UL>
		<LI><A HREF="#Heading13">Adding Methods</A>
		<UL>
			<LI><A HREF="#Heading14">Listing 4.6 ATLSERVER.IDL--OutputLines Method Added to the
			IDL File by the ATL ClassWizard</A>
			<LI><A HREF="#Heading15">Listing 4.7 TRACKER.H--OutputLines Function Prototype Added
			to the</A>
			<LI><A HREF="#Heading16">Tracker.h File</A>
			<LI><A HREF="#Heading17">Listing 4.8 TRACKER.CPP--OutputLines Function Implementation
			Added </A><A HREF="#Heading18">to the Tracker.cpp File</A>
			<LI><A HREF="#Heading19">Listing 4.9 TRACKER.H--m_1Indent Member Variable Added to
			the</A> <A HREF="#Heading20">Class Definition</A>
			<LI><A HREF="#Heading21">Listing 4.10 TRACKER.CPP--Member Initialization in the Constructor</A>
			<LI><A HREF="#Heading22">Listing 4.11 TRACKER.CPP--OutputLines Function Implementation
			Added to the Source File Tracker.cpp</A>
		</UL>
		<LI><A HREF="#Heading23">Adding Properties</A>
		<UL>
			<LI><A HREF="#Heading24">Listing 4.12 TRACKER.IDL--Indent Property Added to the IDL</A>
			<LI><A HREF="#Heading25">Listing 4.13 TRACKER.H--Indent Property Function Pair Prototypes
			Added to the Tracker.h File</A>
			<LI><A HREF="#Heading26">Listing 4.14 TRACKER.CPP--Indent Property Function Pair
			Implementation Added to the Tracker.cpp File</A>
			<LI><A HREF="#Heading27">Listing 4.15 TRACKER.CPP--Indent Property Implementation</A>
		</UL>
		<LI><A HREF="#Heading28">Generating OLE Exceptions</A>
		<UL>
			<LI><A HREF="#Heading29">Listing 4.16 ATLSERVER.IDL--Error Enumeration Added to the
			IDL File</A>
			<LI><A HREF="#Heading30">Listing 4.17 TRACKER.CPP--Rich Error Information Added to
			Tracker</A>
			<LI><A HREF="#Heading31">Implementation</A>
		</UL>
		<LI><A HREF="#Heading32">Dual-Interface</A>
		<LI><A HREF="#Heading33">Generating Dual-Interface OLE Exceptions</A>
		<LI><A HREF="#Heading34">Server Instantiation Using C++</A>
		<LI><A HREF="#Heading35">Shared Servers</A>
		<UL>
			<LI><A HREF="#Heading36">Listing 4.18 STDAFX.H--Shared Object Support Classes and
			Macros</A>
			<LI><A HREF="#Heading37">Listing 4.19 TRACKER.H--Shared Server Support Added to Ctracker
			Class</A>
		</UL>
		<LI><A HREF="#Heading38">Single Instance Servers</A>
		<UL>
			<LI><A HREF="#Heading39">Listing 4.20 STDAFX.G--Single Instance Server Support Added
			to StdAfx.h</A>
			<LI><A HREF="#Heading40">Listing 4.21 TRACKER.H--Single Instance Server Support Added
			to CTracker Class</A>
		</UL>
		<LI><A HREF="#Heading41">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Creating ActiveX Automation Servers Using ATL</H1>

<UL>
	<LI><B>Server registration support</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Automation servers depend on the registry for information about how they are implemented
	and used.
	<P>
	<LI><B>Adding methods and properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Methods allow the user of the server to access specific functionality in the server.
	Properties provide a uniform mechanism for getting and setting the state of a server's
	data variables.
	<P>
	<LI><B>OLE exceptions</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Unlike MFC, ATL does not support OLE exceptions through a C++ exception; rather
	it takes advantage of OLE error mechanisms.
	<P>
	<LI><B>Dual-interface</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 ATL servers implement dual- interface as a standard feature of the application.
	<P>
	<LI><B>Creating servers using C++</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 C++ can be used to launch servers from the application in which they are defined.
	<P>
	<LI><B>Shared and single instance servers</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Using a server that is already running is usually the choice of the controller of
	the server, not the implementer. With a single instance server, the server implementer
	is responsible for the reuse of a server that is already running.
</UL>

<P>The ActiveX Template Library (ATL) was created to answer the need for lightweight
and fast ActiveX COM components. In addition to creating COM Objects and Controls,
ATL can be used to create Automation Servers with a minimum of effort and overhead.
ATL consists of a set of template classes that are a relatively new concept to most
developers; however, the focus of this chapter is on creating Automation Servers.
Please see your favorite C++ book or manual for more information regarding the definition
and use of templates.</P>
<P>ATL is intended to solve the problems of COM com-ponent development and is not
an attempt to be an all-encompassing class library for creating applications. ATL
was designed to work with other class libraries, such as MFC or the Standard Template
Library (STL), that provide basic classes for string manipulation, array, lists,
memory management, and so on. You, the developer, have the freedom to choose which
class library best suits your needs and combine it with ATL to create small, fast
COM applications. In this chapter, you will create a simple in-process Automation
Server using ATL and MFC for logging string data to a file. The use of MFC will allow
you to concentrate on how to implement your server rather than on how to find alternative
methods to functions and classes you are familiar with. You could just as easily
opt not to use MFC, but then you would have to use the Windows API directly to implement
anything related to the OS. As it is, using MFC will not add much to your application
in terms of size.</P>
<P>As you proceed through the chapter, you will expand on your implementation, highlighting
some of the more advanced concepts of Automation Server creation using ATL.
<H2><A NAME="Heading2"></A>Creating the Basic Project</H2>
<P>When creating an Automation Server, the first step is to create a <I>basic project
</I>upon which you will build your application's features and functionality. Like
MFC, ATL has an AppWizard for creating the basic ATL project.</P>
<P>From the <U>F</U>ile menu, select the <U>N</U>ew menu item. In the New dialog
(see fig. 4.1), select the Projects tab. The Projects tab allows you the opportunity
to define several aspects of how the application will be created, for example, the
type of application to create, the name of the application, and the location where
you want the project created. For the type, select ATL COM AppWizard; enter the Project
<U>n</U>ame ATLServer, and the Lo<U>c</U>ation will be <TT>C:\que\ActiveX\ ATLServer</TT>.
Click the OK button to start the ATL COM AppWizard so you can further define the
properties of your server. <A HREF="art/04/dfig01.jpg"><B>FIG. 4.1</B></A> <I><BR>
Define the new ATL server project in the New dialog.</I></P>
<P>In the ATL COM AppWizard -- Step 1 of 1 dialog (see fig. 4.2), select a Server
Type of <U>D</U>ynamic Link Library (DLL), and check the Support <U>M</U>FC check
box. Click the <U>F</U>inish button to continue. <A HREF="art/04/dfig02.jpg"><B>FIG.
4.2</B></A> <I><BR>
Define the basic architecture of the ATL COM object with the ATL COM AppWizard.</I></P>
<P>The New Project Information dialog (see fig. 4.3) is used to confirm the settings
that were selected for the project prior to the creation of the actual source files.
This is the last step in the ATL COM AppWizard. &quot;But wait,&quot; you say, &quot;I
haven't defined any of my server properties.&quot; The ATL COM AppWizard takes a
slightly different approach from that of MFC. Only the basic source files are created
with the AppWizard, the remainder of the project is defined by the ATL ObjectWizard--thus
allowing for much better control of the project implementation versus MFC since the
developer can add any number of ActiveX Servers, Controls, or plain COM objects after
the basic project is created. After you have confirmed your project settings, click
the OK button to close the ATL COM AppWizard and create the ATLServer project. <A
HREF="art/04/dfig03.jpg"><B>FIG. 4.3</B></A> <I><BR>
Confirm the new project settings with the New Project Information dialog.</I></P>
<P>The ATL AppWizard generates all of the basic files that are needed to create a
DLL-based ATL Automation Server. Table 4.1 lists all of the files that are created
and a brief explanation of their purpose. 
<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 4.1 </B><SPACER TYPE="HORIZONTAL" SIZE="10"><B>Basic Source Files Created
		by the ATL AppWizard</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Filename</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.clw</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">The main application source file and entry point for the DLL.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard application DEF file. This file contains the function export declarations
			needed for all in-process servers.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.dsp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.dsw</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.idl</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Interface Definition Language file, which is used to create the type library for
			the server.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.ncb</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">VC++ project file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServer.rc</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard resource file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">StdAfx.cpp</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard precompiled header source file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServerps.def</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Proxy/Stub DLL definition file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">ATLServerps.mk</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Proxy/Stub MK file.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP">StdAfx.h</TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Standard precompiled header file. All of the MFC-specific include files are added
			here.</TD>
	</TR>
</TABLE>

<H2><A NAME="Heading3"></A>Adding an Automation Interface to the Application</H2>
<P>To be an <I>Automation Server</I>,<I> </I>an application must contain at least
one or more <TT>IDispatch</TT>-based interfaces. You will use the ATL ObjectWizard
to add your automation server interfaces to your application. From the <U>I</U>nsert
menu, select the New <U>A</U>TL Object menu item. Within the ATL ObjectWizard dialog
(see fig. 4.4), select the Objects item in the left panel to display the types of
ATL components that can be added. Your implementation will be an Automation Server,
so select the Simple Object icon. See the ATL documentation for more information
on the other types of objects that can be created. Click the <U>N</U>ext button to
continue. <A HREF="art/04/dfig04.jpg"><B><BR>
<BR>
FIG. 4.4</B></A> <I><BR>
Select the type of ATL object to add to your project.</I></P>
<P>The next dialog is the ATL Object Wizard Properties dialog, which is used to define
the specific properties of the new object that will be added to your project. Select
the Names tab (see fig. 4.5), and in the <U>S</U>hort Name edit field, type Tracker;
the remainder of the edit fields will automatically update, reflecting the short
name that you added. The other fields can be changed, but in this case, you will
use the default values.<BR>
<BR>
 <A HREF="art/04/dfig05.jpg"><B>FIG. 4.5</B></A> <I><BR>
Define the name of the new control object.</I></P>
<P>Select the Attributes tab so that you can define the attributes of the server
object (see fig. 4.6). Check the Support <U>I</U>SupportErrorInfo check box to add
OLE rich error. You can add events to the ATL object by checking the Support Connection
Points check box; however, for the purposes of the sample, you will not. Leave the
remainder of the settings on the Attributes tab at their default values. Click OK
to continue and to add the object to the project. <A HREF="art/04/dfig06.jpg"><B><BR>
<BR>
FIG. 4.6</B></A> <I><BR>
Define the attributes of the new server object.</I></P>
<P><A HREF="ch08.htm">Chapters 8</A> and <A HREF="ch09.htm">9</A> go into detail
about adding events to an ATL control; the same process is used for an ATL server.
At the time this book was being written, one drawback to having events was that only
VB5 was built to take advantage of them.</P>
<P>The ATL ObjectWizard added the files, Tracker.h, Tracker.cpp, and Tracker.rgs
to the project. Tracker.h and Tracker.cpp are the implementation files for your server
object. Tracker.rgs is the registry script file that is used to register your server
in the registration database. You will learn more about the Tracker.rgs file in the
section regarding server registration a little later in this chapter.</P>
<P>Before continuing with your server implementation, your newly created IDL file
deserves a quick review. Listing 4.1 shows the basic IDL file that is generated by
the AppWizard. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>TIP:</B> For clarity, you should add the <TT>hidden</TT> attribute to the <TT>IDispatch</TT>-based
	interfaces defined in the server (see Listing 4.1). This step prevents tools like
	VB from displaying both the <TT>IDispatch</TT> interface and its related <TT>CoClass</TT>
	within the VB Object browser. The <TT>CoClass</TT> is the only interface that needs
	to be visible since it is the only interface that VB uses. Using the <TT>IDispatch</TT>
	interface in VB will result in errors.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"> <BR>
<BR>
The most obvious difference between the ODL from the MFC sample and the IDL of this
sample is the location of the <TT>IDispatch</TT> interface relative to the rest of
the <I>type library</I> description. When using IDL, you must declare the interfaces
that will generate the C++ source files outside of the library declaration. For the
ODL, this step is not necessary. Other than a few minor language differences, the
IDL and ODL are identical in terms of syntax and organization.
<H3><A NAME="Heading4"></A>Listing 4.1 ATLSERVER.IDL--IDL File for the ATL Server
Sample</H3>
<P><FONT COLOR="#0066FF"><TT>import &quot;oaidl.idl&quot;; <BR>
// ATLServer.idl : IDL source for ATLServer.dll <BR>
// // This file will be processed by the MIDL tool to <BR>
// produce the type library (ATLServer.tlb) and marshalling code. [ <BR>
object, <BR>
uuid(03699612-809E-11D0-BEFF-00400538977D), <BR>
dual, <BR>
helpstring(&quot;ITracker Interface&quot;), <BR>
pointer_default(unique), <BR>
hidden <BR>
] <BR>
interface ITracker : IDispatch <BR>
{ <BR>
}; <BR>
[ <BR>
uuid(03699601-809E-11D0-BEFF-00400538977D), <BR>
version(1.0), <BR>
helpstring(&quot;ATLServer 1.0 Type Library&quot;) <BR>
] <BR>
library ATLSERVERLib <BR>
{ <BR>
importlib(&quot;stdole32.tlb&quot;); [ <BR>
uuid(03699613-809E-11D0-BEFF-00400538977D), <BR>
helpstring(&quot;Tracker Class&quot;) <BR>
] <BR>
coclass Tracker <BR>
{ <BR>
[default] interface ITracker; <BR>
}; }; </TT></FONT></P>
<P>Before another application can use the server, however, OLE has to know where
to find the server, which is done through the system registry. All ActiveX components
that are publicly available to other applications must support registration and must
create valid registry entries.
<H2><A NAME="Heading5"></A>Registry</H2>
<P>ActiveX components have one or more registry entries that are used to describe
various aspects of the application and how it can be used. The registry is critical
to the successful launching and using of ActiveX components.</P>
<P>All inproc ActiveX components expose registration support via two exported functions:
<TT>DllRegisterServer</TT> and <TT>DllUnregisterServer</TT>. For information regarding
the registration of local servers, see <A HREF="ch03.htm">Chapter 3</A>.</P>
<P>The basic registration and unregistration support for the server is already implemented
by ATL. You are not required to make code changes or additions to support it. Remember
that the MFC implementation allows only for registering the server and does not support
unregistration.</P>
<P>Unlike MFC which uses a set of constants, ATL relies on resource information in
the form of a registry script file to define the information that is added to the
registry database. The registry script file is added automatically to the project
when the server object is added; there is one script file for each server object.</P>
<P>The registry script file(s) are compiled into the server project as resources
and can be viewed in binary form in the resource editor. The files, which have the
extension .rgs, are normal text files that can be edited within the IDE. For more
information about the use of registry script files and their particular syntax, see
the VC++ books online subject &quot;Registry Scripting Examples--ActiveX Template
Library, Articles.&quot; Listing 4.2 shows the registry script file for the <TT>CTracker</TT>
server object that you added.
<H3><A NAME="Heading6"></A>Listing 4.2 ATLCONTROLWIN.RGS--Sample Registry Script
File for the CTracker Server Object<FONT COLOR="#0066FF"><TT></TT></FONT></H3>
<P><FONT COLOR="#0066FF"><TT>HKCR <BR>
{ <BR>
Tracker.Tracker.1 = s `Tracker Class' <BR>
{ <BR>
CLSID = s `{03699613-809E-11D0-BEFF-00400538977D}' <BR>
} <BR>
Tracker.Tracker = s `Tracker Class' <BR>
{ <BR>
CurVer = s `Tracker.Tracker.1' <BR>
} <BR>
NoRemove CLSID <BR>
{ <BR>
ForceRemove {03699613-809E-11D0-BEFF-00400538977D} = s `Tracker Class' <BR>
{ <BR>
ProgID = s `Tracker.Tracker.1' <BR>
VersionIndependentProgID = s `Tracker.Tracker' <BR>
ForceRemove `Programmable' <BR>
LocalServer32 = s `%MODULE%' <BR>
} <BR>
} <BR>
} </TT></FONT></P>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Unfortunately, at the time of the writing of this book, the ATL ClassWizard
	created the Tracker.rgs file incorrectly. Hopefully, this problem will be fixed by
	the time the product is released. Listing 4.3 shows the updated version of the Tracker.rgs
	file with the mistakes corrected. The first correction was to change the <TT>ProgID</TT>
	to <TT>ATLServer.Tracker</TT>, reflecting the parent module and the subordinate object.
	The next correction was to add the <TT>CLSID</TT> entry to the version- independent
	<TT>ProgID</TT> section. This may have been intentional on the part of the ATL team.
	The last and definitely most significant problem was the fact that the <TT>CLSID</TT>
	section listed the server as <TT>LocalServer32</TT> and not <TT>InprocServer32</TT>.
	After making the corrections, the server registered and ran as expected.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading8"></A>Listing 4.3 TRACKER.RGS--Updated Tracker.rgs File</H3>
<P><FONT COLOR="#0066FF"><TT>HKCR <BR>
{ <BR>
ATLServer.Tracker.1 = s `Tracker Class' <BR>
{ <BR>
CLSID = s `{03699613-809E-11D0-BEFF-00400538977D}' <BR>
} <BR>
ATLServer.Tracker = s `Tracker Class' <BR>
{ <BR>
CLSID = s `{03699613-809E-11D0-BEFF-00400538977D}' <BR>
CurVer = s `ATLServer.Tracker.1' <BR>
} <BR>
NoRemove CLSID <BR>
{ <BR>
ForceRemove {03699613-809E-11D0-BEFF-00400538977D} = s `Tracker <BR>
{ <BR>
ProgID = s `ATLServer.Tracker.1' <BR>
VersionIndependentProgID = s `ATLServer.Tracker' <BR>
ForceRemove `Programmable' <BR>
InprocServer32 = s `%MODULE%' <BR>
} <BR>
} } </TT></FONT></P>
<H2><A NAME="Heading9"></A>Sample Server Support Code</H2>
<P>Since the server is used to output data to a file, you first need to add some
support code to the application before adding its methods and properties.</P>
<P>Listing 4.4 shows the changes and additions that need to be made to the class
header file. First add a destructor to the class and remove the constructor implementation--you
will add it to the source file later. Then add a set of member variables for storing
the file handle and timer information that will be used throughout the server implementation.
<H3><A NAME="Heading10"></A>Listing 4.4 Tracker.H--Sample Server Support Code Added
to the Tracker Header File</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////
<BR>
// CTracker <BR>
class ATL_NO_VTABLE CTracker : <BR>
public CComObjectRootEx&lt;CComObjectThreadModel&gt;, <BR>
public CComCoClass&lt;CTracker, &amp;CLSID_Tracker&gt;, <BR>
public ISupportErrorInfo, <BR>
public IDispatchImpl&lt;ITracker, &amp;IID_ITracker, &amp;LIBID_ATLSERVERLib&gt;
<BR>
{ <BR>
public: <BR>
// constructor <BR>
CTracker(); <BR>
// destructor <BR>
~CTracker(); DECLARE_REGISTRY_RESOURCEID(IDR_TRACKER) BEGIN_COM_MAP(CTracker) <BR>
COM_INTERFACE_ENTRY(ITracker) <BR>
COM_INTERFACE_ENTRY(IDispatch) <BR>
COM_INTERFACE_ENTRY(ISupportErrorInfo) <BR>
END_COM_MAP() // ISupportsErrorInfo <BR>
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid); // ITracker <BR>
public: protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; }; </TT></FONT></P>

<P>The next step is to update the source file for the class. Add the include file,
mmsystem.h, before the Tracker.h include file (see Listing 4.5). This file is for
the timer functions that you take advantage of throughout the server implementation.</P>

<P>The following line is added within the constructor:</P>
<P><FONT COLOR="#0066FF"><TT><BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()); </TT></FONT></P>
<P>If you are using MFC with ATL, you must add this line as the first line in every
function that uses MFC. This line is needed to stabilize the state information that
is used by MFC. If you do not perform this step, the server will not function correctly
and can result in errors during program execution.</P>
<P>You must call the method <TT>AfxOleLockApp()</TT> to ensure that the application
will not be unloaded from memory until the reference count reaches zero.</P>
<P>Next you create a high resolution timer and store its current value in your member
variables. The timer is useful for determining the number of milliseconds that have
passed since the last method call was made. The timer output is great for tracking
the performance of a particular action or set of actions.</P>
<P>You then get the current date and create a filename with the format YYYYMMDD.tracklog.
After successfully opening the file, you output some start-up data to the file and
exit the constructor.</P>
<P>The destructor does the exact opposite of the constructor. If there is a valid
file handle, you write some closing information to the file and close it. Next you
terminate the timer. Remember to call the function <TT>AfxOleUnlockApp()</TT> to
allow the application to be removed from memory.
<H3><A NAME="Heading12"></A>Listing 4.5 TRACKER.CPP--Sample Server Support Code Added
to the Source File</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
// Tracker.cpp : Implementation of CTracker <BR>
#include &quot;stdafx.h&quot; <BR>
#include &quot;ATLServer.h&quot; <BR>
// needed for the high resolution timer services <BR>
#include &lt;mmsystem.h&gt; <BR>
#include &quot;Tracker.h&quot; /////////////////////////////////////////////////////////////////////////////
<BR>
// CTracker STDMETHODIMP CTracker::InterfaceSupportsErrorInfo(REFIID riid) <BR>
{ <BR>
static const IID* arr[] = <BR>
{ <BR>
&amp;IID_ITracker, <BR>
}; <BR>
for (int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++) <BR>
{ <BR>
if (InlineIsEqualGUID(*arr[i],riid)) <BR>
return S_OK; <BR>
} <BR>
return S_FALSE; <BR>
} // constructor <BR>
CTracker::CTracker() <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()); // To keep the application running as
LONG as an <BR>
// OLE automation object is active <BR>
::AfxOleLockApp(); // setup our timer resolution <BR>
m_lTimeBegin = timeBeginPeriod(1); <BR>
m_lHiResTime = m_lLastHiResTime = timeGetTime(); // get the current date and time
<BR>
CTime oTimeStamp = CTime::GetCurrentTime(); CString cstrFileName; // create a file
name based on the date <BR>
cstrFileName.Format(_T(&quot;%s.tracklog&quot;), (LPCTSTR) // open a file <BR>
m_fileLog = fopen(cstrFileName, _T(&quot;a&quot;)); <BR>
<BR>
// if we have a file handle <BR>
if(m_fileLog) <BR>
{ <BR>
// output some starting information <BR>
fprintf(m_fileLog, _T(&quot;************************\n&quot;)); <BR>
fprintf(m_fileLog, _T(&quot;Start %s\n&quot;), <BR>
(LPCTSTR) oTimeStamp.Format(&quot;%B %#d, %Y, %I:%M %p&quot;)); <BR>
fprintf(m_fileLog, _T(&quot;\n&quot;)); <BR>
} <BR>
} // destructor <BR>
CTracker::~CTracker() <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()); // if we have a file handle <BR>
if(m_fileLog) <BR>
{ <BR>
// output some closing information <BR>
CTime oTimeStamp = CTime::GetCurrentTime(); <BR>
fprintf(m_fileLog, _T(&quot;\n&quot;)); <BR>
fprintf(m_fileLog, _T(&quot;End %s\n&quot;), <BR>
oTimeStamp.Format(&quot;%B %#d, %Y, %I:%M %p&quot;)); <BR>
fprintf(m_fileLog,_T(&quot;************************\n&quot;)); // close the file
<BR>
fclose(m_fileLog); <BR>
} <BR>
<BR>
// if we have valid timer services <BR>
if(m_lTimeBegin == TIMERR_NOERROR) <BR>
// reset the timer to its original state <BR>
timeEndPeriod(1); // no longer necessary to keep the application in memory <BR>
::AfxOleUnlockApp(); <BR>
}</TT></FONT></P>
<P>Finally you update the build settings for the project. Since the sample implementation
is using some timer functions defined in mmsystem.h, you also need to be linked with
the appropriate library file that contains their implementation. Under the <U>P</U>roject
menu, select the <U>S</U>ettings menu item. In the Project Settings dialog, from
the <U>S</U>ettings For drop-down list box, select the All Configurations entry.
Select the Link tab, and add the file winmm.lib to the Object/<U>l</U>ibrary modules
edit field. Click OK to close the dialog.</P>
<P>The basic support code needed for the sample implementation is now added. The
server will open a file in its constructor and leave the file open during its entire
lifetime. When the server is destroyed, the destructor will be called, and the file
will be closed.</P>
<P>The following section describes how to make the sample more meaningful by adding
methods and properties that are used to output data to the open file.
<H2><A NAME="Heading13"></A>Adding Methods</H2>
<P>An automation method consists of zero to <I>n </I>parameters and may or may not
have a return value. The term <I>method</I> is synonymous with function or subroutine,
depending on the particular language you are familiar with. Since your server is
<TT>IDispatch</TT>-based, you are limited to a specific set of data types. Only those
data types that are valid <TT>VARIANT</TT> data types can be passed or returned via
a method.</P>
<P>The rules for declaring parameters and how they are used is very much like those
for C++ and VB. Methods can pass parameters by value or by reference and may declare
them as optional, meaning that the parameter does not have to be supplied.</P>
<P>When passing a parameter by value, a copy of the data is sent to the method; when
passing a parameter by reference, the address of the parameter is passed, which allows
the method to change the data.</P>
<P>However, because you can't specify a default value in the traditional C++ sense,
optional parameters are handled a little differently than in C++. Optional parameters
must be passed as <TT>VARIANT</TT> data types, not as the actual data type they represent.</P>
<P>When using VB to access a method with optional parameters, VB will supply the
parameter if one has not been provided. With C++, you are still required to supply
a <TT>VARIANT</TT> parameter, even though it may not contain data.</P>
<P>As we stated at the beginning of the chapter, the sample Automation Server will
be used to log strings of data to a file. The server will define the method <TT>OutputLines</TT>
used by the user of the server to supply the string data that is written to the file.
The method will accept an array of strings and an optional indentation parameter
and will output the strings to the file. The indentation parameter is used to offset
the strings by <I>n </I>number of tab characters to provide simple, yet effective,
formatting to the data as it is output to the file.</P>
<P>Adding methods to an ATL project differs from the process for adding them with
MFC, which uses the ClassWizard that we are all familiar with. ATL uses a custom
ClassWizard that is accessed from the ClassView tab in the Project Workspace window
by right mouse clicking the interface that you are adding the method to. From the
ClassView tab in the Project Workspace window, select the <TT>ITracker</TT> class
from the list of <TT>ATLServer</TT> classes, click the right mouse button, and select
the Add <U>M</U>ethod menu item (see fig. 4.7). <A HREF="art/04/dfig07.jpg"><B><BR>
<BR>
FIG. 4.7</B></A> <I><BR>
Add a new method to the server object.</I></P>
<P>In the Add Method to Interface dialog (see fig. 4.8), add the Method <U>N</U>ame,
<TT>OutputLines</TT>, and the <U>P</U>arameters, <TT>[in] VARIANT * varOutputArray,
[in, optional] VARIANT varIndent, and [out, retval] VARIANT_BOOL * RetVal</TT>. Note
that you add all of the parameters and their corresponding IDL attributes within
this dialog. Table 4.2 contains a list of the parameter direction attributes that
you add and their meanings. You are not required to modify the IDL after the method
has been added. 
<TABLE BORDER="1">
	<CAPTION><B>Table 4.2</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> Parameter Flow Attributes</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Direction</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>in</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>out</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is returned from callee to caller.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>in</TT>, <TT>out</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is passed from caller to callee, and the callee returns a parameter.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>out</TT>, <TT>retval</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">Parameter is the return value of the method and is returned from the callee to the
			caller.</TD>
	</TR>
</TABLE>
The <U>A</U>ttributes button displays a dialog for adding IDL attributes for the
entire function declaration. Click OK to close the dialog, and add the method to
your implementation. <A HREF="art/04/dfig08.jpg"><B><BR>
<BR>
FIG. 4.8</B></A> <I><BR>
Define the <TT>OutputLines </TT>method.</I></P>
<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> All optional parameters must be of type <TT>VARIANT</TT>, and they
	must fall at the end of the parameter list. Optional parameters are not managed in
	any way by OLE. It is the server application's responsibility to determine whether
	the <TT>VARIANT</TT> parameter passed to the method contains data and to either use
	the data passed to the method or convert the data to a useful type if possible, or
	to ignore the parameter if invalid data was passed and use the default value if appropriate,
	or to inform the user of an error condition if one of the above conditions was not
	met.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"> The ATL ClassWizard
will add an entry to the IDL file (see Listing 4.6) for the new method and will also
add the function prototype (see Listing 4.7) and implementation (see Listing 4.8)
to the header and source file of the object that the method is being added to. Note
that the ClassWizard automatically added the <TT>AFX_MANAGE_STATE</TT> macro to the
implementation, which is required for MFC support.
<H3><A NAME="Heading14"></A>Listing 4.6 ATLSERVER.IDL--OutputLines Method Added to
the IDL File by the ATL ClassWizard</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . [ <BR>
object, <BR>
uuid(03699612-809E-11D0-BEFF-00400538977D), <BR>
dual, <BR>
helpstring(&quot;ITracker Interface&quot;), <BR>
pointer_default(unique), <BR>
hidden <BR>
] <BR>
interface ITracker : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method OutputLines&quot;)] HRESULT OutputLines( <BR>
[in] VARIANT * varOutputArray, [in,optional] VARIANT <BR>
[out,retval] VARIANT_BOOL * RetVal); <BR>
}; . . . </TT></FONT></P>
<H3><A NAME="Heading15"></A>Listing 4.7 TRACKER.H--OutputLines Function Prototype
Added to the Tracker.h File</H3>
<P>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . // ISupportsErrorInfo <BR>
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid); // ITracker <BR>
public: <BR>
STDMETHOD(OutputLines)(/*[in]*/ VARIANT * varOutputArray, <BR>
/*[in,optional]*/ VARIANT varIndent, <BR>
/*[out,retval]*/ VARIANT_BOOL * RetVal); protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; . . . </TT></FONT></P>
<H3><A NAME="Heading17"></A>Listing 4.8 TRACKER.CPP--OutputLines Function Implementation
Added to the Tracker.cpp File</H3>
<P>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::OutputLines(VARIANT * varOutputArray, VARIANT varIndent, <BR>
VARIANT_BOOL * RetVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) // TODO: Add your implementation code
here return S_OK; } </TT></FONT></P>
<P><TT>OutputLines</TT> is defined as having two parameters: <TT>varOutputArray</TT>,
as a <TT>VARIANT</TT> passed by reference, that will contain a string array of data
to output to the file; and <TT>varIndent</TT>, as a <TT>VARIANT</TT> passed by value,
that is also an optional parameter indicating the amount of indentation when writing
the string data to the file. The third parameter is actually the return type of the
method and is defined as a <TT>VARIANT</TT>_<TT>BOOL</TT>.</P>
<P>See <A HREF="ch03.htm">Chapter 3</A> regarding the use of Boolean data types and
the differences between VB and VC++. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> If you are converting an existing ODL file to IDL, be sure to change
	all Boolean declarations to <TT>VARIANT_BOOL</TT>. Boolean in ODL refers to a 2-byte
	signed short data type, whereas Boolean in IDL is a 1-byte unsigned char data type
	and is not compatible with VB. To further complicate matters <TT>VARIANT_BOOL</TT>
	is an unrecognized data type in ODL, though not in IDL.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"> <BR>
<BR>
Due to data type restrictions imposed by OLE Automation, you cannot pass arrays as
pa-rameters of methods. You can, however, pass <TT>VARIANT</TT> data types that can
contain arrays, thus the reason for defining <TT>varOutputArray</TT> as a <TT>VARIANT</TT>.
You are also required to pass <TT>varOutputArray</TT> by reference because the array
stored in the <TT>VARIANT</TT> does not get copied over when it is passed by value.</P>
<P>Optional parameters must fall at the end of the parameter list and must be of
type <TT>VARIANT</TT>. <TT>varIndent</TT> is an optional parameter that indents the
text output as an added formatting feature.</P>
<P>The last step is to add the <TT>m_lIndent</TT> member variable to the class declaration,
which is used in the <TT>OutputLines</TT> method implementation and later as a property
of the server (see Listing 4.9).
<H3><A NAME="Heading19"></A>Listing 4.9 TRACKER.H--m_1Indent Member Variable Added
to the Class Definition</H3>
<P>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . // ISupportsErrorInfo <BR>
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid); // ITracker <BR>
public: <BR>
STDMETHOD(OutputLines)(/*[in]*/ VARIANT * varOutputArray, / *[in,optional]*/ VARIANT
varIndent, /*[out,retval]*/ VARIANT_BOOL * RetVal); protected: <BR>
FILE * m_fileLog; <BR>
long m_lTimeBegin; <BR>
long m_lHiResTime; <BR>
long m_lLastHiResTime; <BR>
long m_lIndent; }; </TT></FONT></P>
<P>Before adding the <TT>OutputLines</TT> implementation, you need to update the
constructor to initialize the <TT>m_lIndent</TT> member variable to a valid state
(see Listing 4.10).
<H3><A NAME="Heading21"></A>Listing 4.10 TRACKER.CPP--Member Initialization in the
Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>. . . <BR>
fprintf(m_fileLog, _T(&quot;Start %s\n&quot;), <BR>
(LPCTSTR) oTimeStamp.Format(&quot;%B %#d, %Y, %I:%M %p&quot;)); <BR>
fprintf(m_fileLog, _T(&quot;\n&quot;)); <BR>
} <BR>
m_lIndent = 0; } </TT></FONT></P>
<P>Next you add the <TT>OutputLines</TT> implementation to the source file (see Listing
4.11). The implementation varies very little from the MFC sample. The only obvious
difference is the return type of the function, which is now the last parameter of
the function.</P>
<P>As with the MFC implementation, the ATL version checks the array parameter to
ensure its validity and, if valid, outputs the data to the file, indenting the text
if appropriate. See <A HREF="ch03.htm">Chapter 3</A> for more information regarding
the other implementation details.</P>
<P>For now the implementation returns <TT>VARIANT_FALSE</TT> in the cases where an
error has occurred. Later in this chapter, you will learn how to create rich error
information.
<H3><A NAME="Heading22"></A>Listing 4.11 TRACKER.CPP--OutputLines Function Implementation
Added to the Source File Tracker.cpp</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::OutputLines(VARIANT * varOutputArray, VARIANT varIndent, <BR>
VARIANT_BOOL * RetVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) <BR>
HRESULT hResult = S_OK; *RetVal = VARIANT_TRUE; // if we have a file a if the variant
contains a string array <BR>
if(m_fileLog &amp;&amp; varOutputArray-&gt;vt == (VT_ARRAY | VT_BSTR)) <BR>
{ <BR>
// lock the array so we can use it <BR>
if(::SafeArrayLock(varOutputArray-&gt;parray) == S_OK) <BR>
{ <BR>
LONG lLBound; <BR>
// get the lower bound of the array <BR>
if(::SafeArrayGetLBound(varOutputArray-&gt;parray, 1, &amp;lLBound) == S_OK) <BR>
{ <BR>
LONG lUBound; <BR>
// get the number of elements in the array <BR>
if(::SafeArrayGetUBound(varOutputArray-&gt;parray, 1, &amp;lUBound) <BR>
== S_OK) <BR>
{ <BR>
CString cstrIndent; <BR>
CTime oTimeStamp; <BR>
BSTR bstrTemp; <BR>
// if we have an indent parameter <BR>
if(varIndent.vt != VT_I4) <BR>
{ <BR>
// get a variant that we can use for conversion purposes VARIANT varConvertedValue;
<BR>
// initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); <BR>
// see if we can convert the data type to something useful <BR>
// - VariantChangeTypeEx() could also be used <BR>
if(S_OK == :VariantChangeType(&amp;varConvertedValue, <BR>
(VARIANT *) &amp;varIndent, 0, VT_I4)) <BR>
// assign the value to our member variable <BR>
m_lIndent = varConvertedValue.lVal; <BR>
} <BR>
else <BR>
// assign the value to our member variable <BR>
m_lIndent = varIndent.lVal; <BR>
// if we have to indent the text <BR>
for(long lIndentCount = 0; lIndentCount &lt; m_lIndent; <BR>
lIndentCount++) <BR>
// add a tab to the string <BR>
cstrIndent += _T(&quot;\t&quot;); <BR>
// for each of the elements in the array <BR>
for(long lArrayCount = lLBound; lArrayCount &lt; <BR>
(lUBound + lLBound); lArrayCount++) <BR>
{ <BR>
// update the time <BR>
oTimeStamp = CTime::GetCurrentTime(); <BR>
m_lHiResTime = timeGetTime(); <BR>
// get the data from the array <BR>
if(::SafeArrayGetElement(varOutputArray-&gt;parray, <BR>
&amp;lArrayCount, &amp;bstrTemp) == S_OK) <BR>
{ <BR>
// output the data <BR>
fprintf(m_fileLog, _T(&quot;%s(%10ld)-%s%ls\n&quot;), <BR>
(LPCTSTR) oTimeStamp.Format (&quot;%H:%M:%S&quot;), <BR>
m_lHiResTime - m_lLastHiResTime, <BR>
(LPCTSTR) cstrIndent, bstrTemp); <BR>
// store the last timer value <BR>
m_lLastHiResTime = m_lHiResTime; <BR>
// free the bstr <BR>
::SysFreeString(bstrTemp); <BR>
} <BR>
} <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
// unlock the array we don't need it anymore <BR>
::SafeArrayUnlock(varOutputArray-&gt;parray); <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
} <BR>
else <BR>
*RetVal = VARIANT_FALSE; <BR>
// return the result <BR>
return hResult; } </TT></FONT></P>
<P>Now you have added a method. In the following section, you will learn how to implement
its counterpart, the property.
<H2><A NAME="Heading23"></A>Adding Properties</H2>
<P>A <I>property</I> can be thought of as an exposed variable that is defined in
the Automation Server. Properties are useful for setting and retrieving information
about the state of the server.</P>
<P>The <TT>m_lIndent</TT> member variable that you added to the class definition
is a perfect candidate to be exposed as a property.</P>
<P>Properties are added in much the same way as methods. From the ClassView tab in
the Project Workspace window, select the <TT>ITracker</TT> class, click the right
mouse button, and select the Add <U>P</U>roperty menu item (see fig. 4.9). <BR>
<BR>
<A HREF="art/04/dfig09.jpg"><B>FIG. 4.9</B></A> <I><BR>
Add a new property to the Server with the ATL ClassWizard.</I></P>
<P>In the Add Property to Interface dialog, set the Property <U>T</U>ype to <TT>long</TT>,
type the Property <U>N</U>ame as <TT>Indent</TT>, and leave the remainder of the
settings at their default values (see fig. 4.10). Click OK to confirm the entry and
close the dialog. <A HREF="art/04/dfig10.jpg"><B><BR>
<BR>
FIG. 4.10</B></A> <I><BR>
Define the <TT>Indent</TT> property attributes.</I></P>
<P>Like the <TT>OutputLines</TT> method, the ATL ClassWizard added entries to the
IDL file (see Listing 4.12), the Tracker.h header file (see Listing 4.13), and the
Tracker.cpp source file (see Listing 4.14) to support the new property. As in <A
HREF="ch03.htm">Chapter 3</A>, properties are added as a pair of related functions,
and the same is true for the ATL server and ActiveX components.
<H3><A NAME="Heading24"></A>Listing 4.12 TRACKER.IDL--Indent Property Added to the
IDL</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . interface ITracker : IDispatch <BR>
{ <BR>
[id(1), helpstring(&quot;method OutputLines&quot;)] HRESULT OutputLines( <BR>
[in] VARIANT * varOutputArray, [in,optional] VARIANT <BR>
varIndent, [out,retval] VARIANT_BOOL * RetVal); <BR>
[propget, id(2), helpstring(&quot;property Indent&quot;)] HRESULT Indent( <BR>
[out, retval] long *pVal); <BR>
[propput, id(2), helpstring(&quot;property Indent&quot;)] HRESULT Indent( <BR>
[in] long newVal); <BR>
}; . . .</TT></FONT></P>
<H3><A NAME="Heading25"></A>Listing 4.13 TRACKER.H--Indent Property Function Pair
Prototypes Added to the Tracker.h File</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . // ITracker <BR>
public: <BR>
STDMETHOD(get_Indent)(/*[out, retval]*/ long *pVal); <BR>
STDMETHOD(put_Indent)(/*[in]*/ long newVal); <BR>
STDMETHOD(OutputLines)(/*[in]*/ VARIANT * varOutputArray, <BR>
/*[in,optional]*/ VARIANT varIndent, /*[out,retval]*/ VARIANT_BOOL * RetVal); . .
. </TT></FONT></P>
<H3><A NAME="Heading26"></A>Listing 4.14 TRACKER.CPP--Indent Property Function Pair
Implementation Added to the Tracker.cpp File</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::get_Indent(long * pVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) // TODO: Add your implementation code
here return S_OK; <BR>
} STDMETHODIMP CTracker::put_Indent(long newVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) // TODO: Add your implementation code
here return S_OK; } </TT></FONT></P>
<P>The actual implementation of the <TT>Indent</TT> property is very simple (see
Listing 4.15). <TT>get_Indent</TT> returns the value currently stored in the member
variable, and <TT>put_Indent</TT> stores the new value, after a little bit of error
checking, in the member variable.
<H3><A NAME="Heading27"></A>Listing 4.15 TRACKER.CPP--Indent Property Implementation</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::get_Indent(long * pVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) HRESULT hResult = S_OK; // return the
member variable <BR>
*pVal = m_lIndent; // return the result <BR>
return hResult; <BR>
} STDMETHODIMP CTracker::put_Indent(long newVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) HRESULT hResult = S_OK; // if the new
value is a least 0 <BR>
if(newVal &gt;= 0) <BR>
// assign the value to our member variable <BR>
m_lIndent = newVal; // return the result <BR>
return hResult; <BR>
}</TT></FONT></P>
<P>Properties, like methods, also have a wide variety of implementation options,
including parameterized and enumerated values. See <A HREF="ch06.htm">Chapters 6</A>
through <A HREF="ch11.htm">11</A> on developing ActiveX controls for descriptions
of more options and features when creating properties.</P>
<P>You've added methods and properties to the server, but you haven't really dealt
with the issue of error handling in their implementation. In some cases, simply returning
success or failure is not enough information for the developer to understand that
an error occurred and what caused it. You will communicate more error information
through the use of OLE exceptions.
<H2><A NAME="Heading28"></A>Generating OLE Exceptions</H2>
<P>While executing a method call or some other action, at times you will find it
necessary to terminate the process due to some critical error that has occurred or
is about to occur. For example, a method is called to write data to a file, but the
method cannot open the file because there is not enough room on the hard disk to
do so. You must halt further processing until the error can be resolved. An error
of this kind is known as an <I>exception. </I>Any type of error can be treated as
an exception; it depends upon the requirements of your application and how you choose
to deal with the errors that may result.</P>
<P>You must become familiar with two forms of exceptions when creating ActiveX components.
The first is a C++ exception. A <I>C++ exception</I> is a language mechanism used
to generate critical errors of the type described earlier and is confined to the
application in which they are defined. The second is an OLE exception. <I>OLE exceptions</I>
are used to communicate the same kinds of errors externally to applications that
are using a component. The difference between the two is that C++ exceptions are
used internally to an application's implementation and OLE exceptions are used externally
to other applications.</P>
<P>The COM implementation of a method in a dual-interface server does not have the
same kind of error management features that <TT>IDispatch</TT> interfaces have. To
generate the proper error information, an application must use the <TT>IErrorInfo</TT>
object provided by the oper- ating system. A server need support only the <TT>ISupportErrorInfo</TT>
interface, which lets an automation controller know that it should look at the <TT>IErrorInfo</TT>
object for more infor-mation when an error occurs.</P>
<P>The first step is to add an enumeration of the types of errors that the server
can generate to the IDL file (see Listing 4.16). This step has the effect of publishing
the error constants to the user of the automation server. Unlike the <TT>ITracker</TT>
interface, the enumeration can be added anywhere within the IDL file and still produce
the proper C++ declaration in the ATLServer.h file. Remember to generate a new <TT>CLSID</TT>
for the enumeration using the GUIDGEN.EXE program. See <A HREF="ch02.htm">Chapter
2</A> for more information on how to use the GUIDGEN program.
<H3><A NAME="Heading29"></A>Listing 4.16 ATLSERVER.IDL--Error Enumeration Added to
the IDL File</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . coclass CTracker <BR>
{ <BR>
[default] interface ITracker; <BR>
}; typedef [uuid(2B2AF9C9-5452-11D0-BEDE-00400538977D), <BR>
helpstring(&quot;Tracker Error Constants&quot;)] <BR>
enum tagTrackerError <BR>
{ <BR>
MFCSERVER_E_NO_UBOUND = 46080, <BR>
MFCSERVER_E_NO_LBOUND = 46081, <BR>
MFCSERVER_E_NO_ARRAYLOCK = 46082, <BR>
MFCSERVER_E_NO_FILE = 46083, <BR>
MFCSERVER_E_BAD_ARRAY_PARAMETER = 46084, <BR>
MFCSERVER_E_INVALID_VALUE = 46085 <BR>
}TRACKERERROR; }; </TT></FONT></P>
<P>Since ATL servers are dual-interface by default, you must implement all errors
using OLE rich error information and not with C++ exceptions.</P>
<P>The next step is to add the actual error-generating code (see Listing 4.17). ATL
provides the helper function <TT>AtlReportError</TT> for generating rich error information.
The function accepts four parameters: the <TT>CLSID</TT> of the server, an error
message, the <TT>IID</TT> of the interface, and the error code. Error codes must
be formatted error codes, as in the implementation, or a predefined OLE error codes;
simply returning <TT>S_FALSE</TT> is not enough to generate an error. See the VC++
books online for more information regarding OLE error codes and their use.
<H3><A NAME="Heading30"></A>Listing 4.17 TRACKER.CPP--Rich Error Information Added
to Tracker Implementation</H3>
<P>
<P><FONT COLOR="#0066FF"><TT><BR>
STDMETHODIMP CTracker::OutputLines(VARIANT * varOutputArray, <BR>
VARIANT varIndent, VARIANT_BOOL * RetVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) HRESULT hResult = S_OK; *RetVal = VARIANT_TRUE;
// if we have a file a if the variant contains a string array <BR>
if(m_fileLog &amp;&amp; varOutputArray-&gt;vt == (VT_ARRAY | VT_BSTR)) <BR>
{ <BR>
// lock the array so we can use it <BR>
if(::SafeArrayLock(varOutputArray-&gt;parray) == S_OK) <BR>
{ <BR>
LONG lLBound; // get the lower bound of the array <BR>
if(::SafeArrayGetLBound(varOutputArray-&gt;parray, 1, &amp;lLBound) == S_OK) <BR>
{ <BR>
LONG lUBound; // get the number of elements in the array <BR>
if(::SafeArrayGetUBound(varOutputArray-&gt;parray, 1, &amp;lUBound) <BR>
== S_OK) <BR>
{ <BR>
CString cstrIndent; <BR>
CTime oTimeStamp; <BR>
BSTR bstrTemp; // if we have an indent parameter <BR>
if(varIndent.vt != VT_I4) <BR>
{ <BR>
// get a variant that we can use <BR>
// for conversion purposes <BR>
VARIANT varConvertedValue; // initialize the variant <BR>
::VariantInit(&amp;varConvertedValue); // see if we can convert the data type to
something <BR>
// useful - VariantChangeTypeEx() could also be used <BR>
if(S_OK == ::VariantChangeType (&amp;varConvertedValue, <BR>
(VARIANT *) &amp;varIndent, 0, VT_I4)) <BR>
// assign the value to our member variable <BR>
m_lIndent = varConvertedValue.lVal; <BR>
} <BR>
else <BR>
// assign the value to our member variable m_lIndent = varIndent.lVal; // if we have
to indent the text <BR>
for(long lIndentCount = 0; lIndentCount &lt; m_lIndent; <BR>
lIndentCount++) <BR>
// add a tab to the string <BR>
cstrIndent += _T(&quot;\t&quot;); // for each of the elements in the array <BR>
for(long lArrayCount = lLBound; lArrayCount &lt; <BR>
(lUBound + lLBound); lArrayCount++) <BR>
{ <BR>
// update the time <BR>
oTimeStamp = CTime::GetCurrentTime(); <BR>
m_lHiResTime = timeGetTime(); // get the data from the array <BR>
if(::SafeArrayGetElement (varOutputArray-&gt;parray, <BR>
&amp;lArrayCount, &amp;bstrTemp) == S_OK) <BR>
{ <BR>
// output the data <BR>
fprintf(m_fileLog, _T(&quot;%s(%10ld)-%s%ls\n&quot;), <BR>
(LPCTSTR) oTimeStamp.Format (&quot;%H:%M:%S&quot;), <BR>
m_lHiResTime - m_lLastHiResTime, <BR>
(LPCTSTR) cstrIndent, bstrTemp); // store the last timer value <BR>
m_lLastHiResTime = m_lHiResTime; // free the bstr <BR>
::SysFreeString(bstrTemp); <BR>
} <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; // create the error message <BR>
hResult = AtlReportError(CLSID_Tracker, <BR>
&quot;Unable to retrieve the upper bound dimension of the array.&quot;, <BR>
IID_ITracker, <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_NO_UBOUND)); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; // create the error message <BR>
hResult = AtlReportError(CLSID_Tracker, <BR>
&quot;Unable to retrieve the lower bound dimension of the array.&quot;, <BR>
IID_ITracker, <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_NO_LBOUND)); <BR>
} // unlock the array we don't need it anymore <BR>
::SafeArrayUnlock(varOutputArray-&gt;parray); <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; // create the error message <BR>
hResult = AtlReportError(CLSID_Tracker, <BR>
&quot;Unable to lock the array memory.&quot;, <BR>
IID_ITracker, <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_NO_ARRAYLOCK)); <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
*RetVal = VARIANT_FALSE; // if there wasn't a file <BR>
if(!m_fileLog) <BR>
// create the error message <BR>
hResult = AtlReportError(CLSID_Tracker, <BR>
&quot;Invalid File Handle. File could not be opened for output.&quot;, <BR>
IID_ITracker, <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_NO_FILE)); <BR>
else <BR>
// create the error message <BR>
hResult = AtlReportError(CLSID_Tracker, <BR>
&quot;The first parameter must be a string array passed by reference.&quot;, <BR>
IID_ITracker, <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, <BR>
MFCSERVER_E_BAD_ARRAY_PARAMETER)); <BR>
} // return the result <BR>
return hResult; <BR>
} STDMETHODIMP CTracker::get_Indent(long * pVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) HRESULT hResult = S_OK; // return the
member variable <BR>
*pVal = m_lIndent; // return the result <BR>
return hResult; <BR>
} STDMETHODIMP CTracker::put_Indent(long newVal) <BR>
{ <BR>
AFX_MANAGE_STATE(AfxGetStaticModuleState()) HRESULT hResult = S_OK; // if the new
value is a least 0 <BR>
if(newVal &gt;= 0) <BR>
// assign the value to our member variable <BR>
m_lIndent = newVal; <BR>
else <BR>
{ <BR>
// create the error message <BR>
hResult = AtlReportError(CLSID_Tracker, <BR>
&quot;Invalid value. Value must be 0 or greater.&quot;, <BR>
IID_ITracker, <BR>
MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, MFCSERVER_E_INVALID_VALUE)); <BR>
} // return the result <BR>
return hResult; } </TT></FONT></P>
<P>The use of C++ exceptions is still permitted with an ATL-implemented server. But
the exception cannot cross application boundaries, which is the case in any application
whether implemented in MFC, ATL, or some other framework.
<H2><A NAME="Heading32"></A>Dual-Interface</H2>
<P>In <A HREF="ch03.htm">Chapter 3</A>, the basic MFC server is implemented as <TT>IDispatch</TT>
only. You are required to add dual-interface support as an extra step. With the ATL,
dual-interface support is built-in and implemented as a normal aspect of the server.
<H2><A NAME="Heading33"></A>Generating Dual-Interface OLE Exceptions</H2>
<P>Again, as in <A HREF="ch03.htm">Chapter 3</A>, the basic MFC server is implemented
as <TT>IDispatch</TT> only, and it is possible to throw standard C++ exceptions and
have the basic MFC <TT>IDispatch</TT> support code translate the error into an OLE
exception. When an MFC server is converted to dual-interface, you must implement
the exception translation code yourself.</P>
<P>For ATL, the server has been implemented as dual-interface from the start, and
all error generation has been written as true OLE exceptions and does not require
translation.
<H2><A NAME="Heading34"></A>Server Instantiation Using C++</H2>
<P>OLE is not the only method for creating and using Automation Servers. This chapter
will show you how to create OLE servers using C++ syntax.</P>
<P>At times, you must create and use Automation Servers from within the application
in which they are defined. Take, for example, a case where an application contains
three servers, with only one being directly creatable by outside applications using
OLE. The remaining two servers can be created by the exposed server using C++ and
returned via a method call to another application, which then uses the server as
though it was created via OLE.</P>
<P>For an MFC server, the inclusion or exclusion of the macros <TT>DECLARE_OLECREATE</TT>
and <TT>IMPLEMENT_OLECREATE</TT> determines whether a server is creatable by external
applications. For ATL, it is a little simpler. All ATL applications contain a global
variable called an <TT>ObjectMap</TT> for declaring all of the servers that can be
created via OLE. The <TT>ObjectMap</TT> is declared in the main application file
(see the file ATLServer.cpp) as a pair of macros:</P>
<P><FONT COLOR="#0066FF"><TT>BEGIN_OBJECT_MAP(ObjectMap)<BR>
END_OBJECT_MAP() </TT></FONT>Each OLE server implemented within the application will
have a single entry within the body of the <TT>ObjectMap</TT> macro, thus identifying
the server as an exposed OLE server. The <TT>OBJECT_ENTRY</TT> macro defines the
<TT>CLSID</TT> and the C++ class of the server that can be created.</P>
<PRE></PRE>
<P><FONT COLOR="#0066FF"><TT>BEGIN_OBJECT_MAP(ObjectMap) <BR>
OBJECT_ENTRY(CLSID_Tracker, CTracker) END_OBJECT_MAP() </TT></FONT></P>
<P>To prevent an application from being exposed as an Automation Server, you just
remove or comment out the entry in the object map. When adding additional servers
to an application, you must add an entry for each new server to the <TT>ObjectMap</TT>
macro.</P>
<P>All ATL servers contain a static function <TT>CreateInstance</TT>, which is used
to instantiate instances of themselves. You must use only the <TT>CreateInstance</TT>
function to instantiate a server since it is implemented by the class factory of
the server and will manage the server instantiation correctly. This is very critical
in the cases where the server is shared among two or more applications, as you will
see in the following sections.</P>
<P>The first step is to declare the pointer to which you will store the reference
of the object when it is created. Because ATL servers are implemented using templates,
it may seem a little strange to declare the reference this way. However, this makes
sense when you see the architecture of ATL, which is documented fully in the VC++
books online.</P>
<P><FONT COLOR="#0066FF"><TT><BR>
CComObject&lt;CTracker&gt; * opTracker; </TT></FONT></P>
<P>The next step is to instantiate the server and store the reference of the new
object. Remember to check the return value of the function and the pointer to ensure
that the object was instantiated successfully.</P>
<P><FONT COLOR="#0066FF"><TT><BR>
CComObject&lt;CTracker&gt;::CreateInstance(&amp;opTracker); </TT></FONT></P>
<P>Once a server is instantiated this way, you can use it like any other C++ class
or OLE server. You can use <TT>QueryInterface</TT> to retrieve <TT>IDispatch</TT>
or custom interface pointers that can be passed to other applications. Refer to <A
HREF="ch03.htm">Chapter 3</A> for more information regarding the instantiation and
use of OLE servers with C++.</P>
<P>So far, you've only looked at how to create individual instances of objects. In
the following section, you will learn how to share objects.
<H2><A NAME="Heading35"></A>Shared Servers</H2>
<P>OLE defines a facility for sharing objects called the <I>Running Object Table.
</I>Essentially, a shareable object will publish its <TT>CLSID</TT> and an <TT>IUnknown</TT>
reference to itself in the Running Object Table. Any application that so desires
can ask for the running instance of the object rather than create a new instance.
Applications that may need to work with a single running instance of an application
may find it more useful to use shared objects than to create multiple copies. The
<TT>Tracker</TT> object is a perfect candidate for this kind of functionality. Multiple
applications could use the same <TT>Tracker</TT> object to log information, thus
saving on memory.</P>
<P>Unfortunately, the way ATL is implemented prevents you from adding shared object
support without actually creating new ATL template classes. This limitation occurs
because of dependence on the <TT>Release</TT> function implementation to revoke the
object from the Running Object Table, which you cannot override directly in the base
ATL classes.</P>
<P>Listing 4.18 shows the support code that has been added to the StdAfx.h file to
support shared objects. The new classes and macros are based on the original ATL
code and have been extended to register the server in the Running Object Table. The
code will also remove the server from the Running Object Table when the reference
count reaches 1.</P>
<P>The only real change made to the original ATL code is that a new class <TT>CComObjectShared</TT>
is added with an extra template parameter of the <TT>CLSID</TT> of the server. The
remaining changes to the code and macros are to reflect the use of the new class
versus its original implementation <TT>CComObject</TT>. Do note that the shared server
implementation is simple and does not support aggregatable objects. But that is not
to say it cannot be implemented; it just wasn't done for this sample.</P>
<P>The constructor of the <TT>CComObjectShared</TT> class adds the <TT>IUnknown</TT>
reference to the Running Object Table and stores the ID in a member variable to be
used later when revoking the server.</P>
<P>The <TT>Release</TT> function is implemented the same as the MFC sample in that
the <TT>Release</TT> implementation revokes the server from the Running Object Table.
The code must also protect the <TT>Release</TT> call by bumping up the reference
count of the server and clearing the member variable to prevent recursion.
<H3><A NAME="Heading36"></A>Listing 4.18 STDAFX.H--Shared Object Support Classes
and Macros</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
// ****** ATL 2.0 version - Added by Jerry Anderson for shared object support <BR>
// ** <BR>
#define DECLARE_NOT_AGGREGATABLE_SHARED(cBase, clsid) public:\ <BR>
typedef CComCreator2&lt; CComCreator&lt; CComObjectShared&lt;cBase, clsid&gt; &gt;,
CComFailCreator&lt;CLASS_E_NOAGGREGATION&gt; &gt; _CreatorClass; // if this object
was registered and the refcount is 1 (which is from the &quot;RegisterActiveObject&quot;)
<BR>
// then revoke the registration so the object can be destroyed properly - The AddRef/Release
pair <BR>
// is to protect the destruction and prevent the object from being deleted before
we are out of this call <BR>
// since the RevokeActiveObject is going to call &quot;Release&quot; also and the
refcount would be 0 if we didn't AddRef #define RELEASE_AND_DESTROY_SHARED() \ <BR>
InternalRelease(); \ <BR>
if(dwRegister &amp;&amp; m_dwRef == 1) \ <BR>
{ InternalAddRef(); DWORD dwtRegID = dwRegister; dwRegister = 0; ::RevokeActiveObject(dwtRegID,
NULL); InternalRelease(); } \ <BR>
if(m_dwRef == 0) \ <BR>
{ delete this; return 0; } \ <BR>
return m_dwRef //Base is the user's class that derives from CComObjectRoot and whatever
<BR>
//interfaces the user wants to support on the object <BR>
template &lt;class cBase, const CLSID * clsid&gt; <BR>
class CComObjectShared : public cBase <BR>
{ <BR>
public: <BR>
// this is here to prevent an ASSERT when executing &quot;InternalFinalConstructRelease()&quot;
<BR>
DECLARE_PROTECT_FINAL_CONSTRUCT(); <BR>
ULONG dwRegister; <BR>
typedef cBase _BaseClass; <BR>
CComObjectShared(void* = NULL) <BR>
{ <BR>
// protect the construction <BR>
this-&gt;InternalAddRef(); // lock down the application so it does not fall out from
under us <BR>
_Module.Lock(); // clear the member <BR>
dwRegister = NULL; // Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// QI for the IUnknown <BR>
if(_InternalQueryInterface(IID_IUnknown, (void **) &amp;pIUnknown) == S_OK) <BR>
{ <BR>
// register the clsid as an active object so other applications will get the same
object <BR>
if(::RegisterActiveObject(pIUnknown, *clsid, ACTIVEOBJECT_STRONG, &amp;dwRegister)
!= S_OK) <BR>
// clear the member <BR>
dwRegister = NULL; // release the IUnknown <BR>
pIUnknown-&gt;Release(); <BR>
} // protect the construction <BR>
this-&gt;InternalRelease(); <BR>
} <BR>
virtual ~CComObjectShared() <BR>
{ <BR>
// Set refcount to 1 to protect destruction <BR>
m_dwRef = 1L; <BR>
FinalRelease(); <BR>
_Module.Unlock(); <BR>
} //If InternalAddRef or InteralRelease is undefined then your class <BR>
//doesn't derive from CComObjectRoot <BR>
STDMETHOD_(ULONG, AddRef)() <BR>
{ <BR>
// release the IUnknown reference <BR>
return InternalAddRef(); <BR>
} <BR>
STDMETHOD_(ULONG, Release)() <BR>
{ <BR>
RELEASE_AND_DESTROY_SHARED(); <BR>
} <BR>
//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP <BR>
STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <BR>
{return _InternalQueryInterface(iid, ppvObject);} <BR>
static HRESULT WINAPI CreateInstance(CComObjectShared&lt;cBase, clsid&gt;**pp); <BR>
}; // needed for ATL version 1.1 <BR>
// template &lt;class cBase, const CLSID * clsid&gt; <BR>
// CComObjectShared&lt;cBase, clsid&gt;* CComObjectShared&lt;cBase, clsid&gt;::pSharedObject
= NULL; <BR>
<BR>
template &lt;class cBase, const CLSID * clsid&gt; <BR>
HRESULT WINAPI CComObjectShared&lt;cBase, clsid&gt;::CreateInstance(CComObjectShared&lt;cBase,
clsid&gt;** pp) <BR>
{ <BR>
_ASSERTE(pp != NULL); <BR>
HRESULT hRes = E_OUTOFMEMORY; CComObjectShared&lt;cBase, clsid&gt;* p = NULL; <BR>
ATLTRY((p = new CComObjectShared&lt;cBase, clsid&gt;())) <BR>
if (p != NULL) <BR>
{ <BR>
p-&gt;SetVoid(NULL); <BR>
p-&gt;InternalFinalConstructAddRef(); <BR>
hRes = p-&gt;FinalConstruct(); <BR>
// this line differs from the original code - <BR>
// for some reason the reference counts <BR>
// for the object are not correct when created this way <BR>
p-&gt;InternalAddRef(); <BR>
p-&gt;InternalFinalConstructRelease(); <BR>
if (hRes != S_OK) <BR>
{ <BR>
delete p; <BR>
p = NULL; <BR>
} <BR>
} <BR>
*pp = p; return hRes; <BR>
} // ** <BR>
// ****** ATL 2.0 version - Added by Jerry Anderson for shared object support</TT></FONT></P>
<P>As the server developer, the only thing you must do is add the macro <TT>DECLARE_NOT_AGGREGATABLE_SHARED(...)</TT>
to the ATL server class. Listing 4.19 shows the change that was made to the <TT>CTracker</TT>
sample to enable shared server support.
<H3><A NAME="Heading37"></A>Listing 4.19 TRACKER.H--Shared Server Support Added to
Ctracker Class</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . DECLARE_REGISTRY_RESOURCEID(IDR_TRACKER) BEGIN_COM_MAP(CTracker) <BR>
COM_INTERFACE_ENTRY(ITracker) <BR>
COM_INTERFACE_ENTRY(IDispatch) <BR>
COM_INTERFACE_ENTRY(ISupportErrorInfo) <BR>
END_COM_MAP() DECLARE_NOT_AGGREGATABLE_SHARED(CTracker, &amp;CLSID_Tracker) // ISupportsErrorInfo
<BR>
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid); // ITracker public:. . . </TT></FONT></P>
<P>During the lifetime of the server, you can get the same instance of the server
and use it from multiple applications. In VB, getting the running instance of a server
is done with the <TT>GetObject</TT> call and in VC++ with the <TT>GetActiveObject</TT>
function. After the pointer to the server is retrieved, the server can be used as
though it was created through normal OLE mechanisms.</P>
<P>This method of sharing objects is fine but requires that the application using
the server take an active role in deciding to use the shared object versus creating
its own instance of the object. Another approach is to supply the instance of a running
server to an application that calls <TT>CreateObject</TT> rather than <TT>GetObject</TT>.
This approach is known as a single instance server.
<H2><A NAME="Heading38"></A>Single Instance Servers</H2>
<P>To support single instance servers, you must perform all of the steps described
in the section entitled &quot;Shared Servers,&quot; earlier in this chapter, from
within the <TT>ClassFactory</TT> of the server, not from within the implementation
of the server itself. By implementing the object sharing code within the class factory,
you are able to control the number of instances of the server without having to rely
on the user of the server to program specifically for those cases.</P>
<P>As is the case with the shared server support, we have created a new set of classes
and macros for creating a server consisting of a single instance (see Listing 4.20).
The classes are based on the existing ATL classes and differ slightly from the original
implementation. In this case, two new classes were created: <TT>CComCreatorSingle</TT>
and <TT>CComObjectSingle</TT>.</P>
<P><TT>CComCreatorSingle</TT> is the class that is responsible for creating the server--if
one has not already been created--or retrieving the existing server and returning
it instead of creating a new instance. <TT>CComObjectSingle</TT> is also responsible
for registering the server in the Running Object Table. As with the shared server
implementation, <TT>CComObjectSingle</TT> removes itself from the Running Object
Table, thereby protecting itself from recursive entry into the <TT>Release</TT> function.
The <TT>CComObjectSingle</TT> also supports a <TT>CreateInstance</TT> function, which
is used to create copies of the server using C++ syntax. <TT>CComObjectSingle::CreateInstance</TT>
must also contain support to create a new server if one is not already running or
use the existing server if available.
<H3><A NAME="Heading39"></A>Listing 4.20 STDAFX.G--Single Instance Server Support
Added to StdAfx.h</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
// ****** ATL 2.0 version - Added by Jerry Anderson for single instance object support
<BR>
// ** <BR>
#define DECLARE_NOT_AGGREGATABLE_SINGLE(cBase, clsid, iBase, iid) public: \ <BR>
typedef CComCreator2&lt; CComCreatorSingle&lt; CComObjectSingle&lt;cBase, clsid,
iBase, \ <BR>
iid&gt;, clsid&gt;, CComFailCreator&lt;CLASS_E_NOAGGREGATION&gt; &gt; CreatorClass;
// if this object was registered and the refcount is 1 (which is from the <BR>
// &quot;RegisterActiveObject&quot;) <BR>
// then revoke the registration so the object can be destroyed properly - The <BR>
// AddRef/Release pair <BR>
// is to protect the destruction and prevent the object from being deleted before
we are <BR>
// out of this call <BR>
// since the RevokeActiveObject is going to call &quot;Release&quot; also and the
refcount would // be 0 if we didn't AddRef #define RELEASE_AND_DESTROY_SINGLE() \
<BR>
InternalRelease(); \ <BR>
if(dwRegister &amp;&amp; m_dwRef == 1) \ <BR>
{ InternalAddRef(); DWORD dwtRegID = dwRegister; dwRegister = 0; ::RevokeActiveObject(dwtRegID,
NULL); InternalRelease(); } \ <BR>
if(m_dwRef == 0) \ <BR>
{ delete this; return 0; } \ <BR>
return m_dwRef // Base is the user's class that derives from CComObjectRoot and whatever
<BR>
// interfaces the user wants to support on the object <BR>
template &lt;class cBase, const CLSID * clsid, class iBase, const IID * iid&gt; <BR>
class CComObjectSingle : public cBase <BR>
{ <BR>
public: <BR>
// this is here to prevent an ASSERT when executing &quot;InternalFinalConstructRelease()&quot;
<BR>
DECLARE_PROTECT_FINAL_CONSTRUCT(); <BR>
ULONG dwRegister; <BR>
typedef cBase _BaseClass; <BR>
CComObjectSingle(void* = NULL) <BR>
{ <BR>
// protect the construction <BR>
this-&gt;InternalAddRef(); // lock down the application so it does not fall out from
under us <BR>
_Module.Lock(); // clear the member <BR>
dwRegister = NULL; // Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// se if the object is already running <BR>
::GetActiveObject(*clsid, NULL, &amp;pIUnknown); // if we didn't get a reference
to a running object <BR>
if(!pIUnknown) <BR>
{ <BR>
// QI for the IUnknown <BR>
if(_InternalQueryInterface(IID_IUnknown, (void **) &amp;pIUnknown) <BR>
== S_OK) <BR>
{ <BR>
// register the clsid as an active object so other applications <BR>
// will get the same object <BR>
::RegisterActiveObject(pIUnknown, *clsid, ACTIVEOBJECT_STRONG, <BR>
&amp;dwRegister); // release the IUnknown <BR>
pIUnknown-&gt;Release(); <BR>
} // clear the reference just to be safe <BR>
pIUnknown = NULL; <BR>
} <BR>
else <BR>
// release the IUnknown <BR>
pIUnknown-&gt;Release(); // protect the construction <BR>
this-&gt;InternalRelease(); <BR>
} <BR>
virtual ~CComObjectSingle() <BR>
{ <BR>
// Set refcount to 1 to protect destruction <BR>
m_dwRef = 1L; <BR>
FinalRelease(); <BR>
_Module.Unlock(); <BR>
} //If InternalAddRef or InteralRelease is undefined then your class <BR>
//doesn't derive from CComObjectRoot <BR>
STDMETHOD_(ULONG, AddRef)() <BR>
{ <BR>
// release the IUnknown reference <BR>
return InternalAddRef(); <BR>
} <BR>
STDMETHOD_(ULONG, Release)() <BR>
{ <BR>
RELEASE_AND_DESTROY_SINGLE(); <BR>
} <BR>
//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP <BR>
STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) <BR>
{return _InternalQueryInterface(iid, ppvObject);} <BR>
static HRESULT WINAPI CreateInstance(CComObjectSingle&lt;cBase, clsid, iBase, <BR>
iid&gt;** pp); <BR>
}; // needed for ATL version 1.1 <BR>
// template &lt;class cBase, const CLSID * clsid, class iBase, const IID * iid&gt;
<BR>
// CComObjectSingle&lt;cBase, clsid, iBase, iid&gt;* CComObjectSingle&lt;cBase, clsid,
iBase, <BR>
// iid&gt;::pSingleObject = NULL; template &lt;class cBase, const CLSID * clsid,
class iBase, const IID * iid&gt; <BR>
HRESULT WINAPI CComObjectSingle&lt;cBase, clsid, iBase, iid&gt;::CreateInstance(CComObjectSingle&lt;cBase,
clsid, iBase, iid&gt;** pp) <BR>
{ <BR>
_ASSERTE(pp != NULL); <BR>
HRESULT hRes = E_OUTOFMEMORY; // Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// se if the object is already running <BR>
::GetActiveObject(*clsid, NULL, &amp;pIUnknown); // if we didn't get a reference
to a running object <BR>
if(!pIUnknown) <BR>
{ <BR>
CComObjectSingle&lt;cBase, clsid, iBase, iid&gt;* p = NULL; <BR>
ATLTRY((p = new CComObjectSingle&lt;cBase, clsid, iBase, iid&gt;())) <BR>
if (p != NULL) <BR>
{ <BR>
p-&gt;SetVoid(NULL); <BR>
p-&gt;InternalFinalConstructAddRef(); <BR>
hRes = p-&gt;FinalConstruct(); <BR>
// this line differs from the original code - <BR>
// for some reason the reference counts <BR>
// for the object are not correct when created this way <BR>
p-&gt;InternalAddRef(); <BR>
p-&gt;InternalFinalConstructRelease(); <BR>
if (hRes != S_OK) <BR>
{ <BR>
delete p; <BR>
p = NULL; <BR>
} <BR>
} <BR>
*pp = p; <BR>
} <BR>
else <BR>
{ <BR>
// get a pointer <BR>
iBase * piBase = NULL; // QI for the interface <BR>
pIUnknown-&gt;QueryInterface(*iid, (LPVOID*) &amp;piBase); // cast the interface
pointer to the class <BR>
*pp = (CComObjectSingle&lt;cBase, clsid, iBase, iid&gt;*) piBase; // release the
IUnknown reference <BR>
pIUnknown-&gt;Release(); <BR>
} return hRes; <BR>
} template &lt;class T1, const CLSID* clsid&gt; <BR>
class CComCreatorSingle <BR>
{ <BR>
public: <BR>
static HRESULT PASCAL CreateInstance(void* pv, REFIID riid, LPVOID* ppv) <BR>
{ <BR>
_ASSERTE(*ppv == NULL); <BR>
HRESULT hRes = E_OUTOFMEMORY; // Initialize an IUnknown reference <BR>
LPUNKNOWN pIUnknown = NULL; <BR>
<BR>
// se if the object is already running <BR>
::GetActiveObject(*clsid, NULL, &amp;pIUnknown); // if we didn't get a reference
to a running object <BR>
if(!pIUnknown) <BR>
{ <BR>
T1* p = NULL; <BR>
ATLTRY(p = new T1(pv)) <BR>
if (p != NULL) <BR>
{ <BR>
p-&gt;SetVoid(pv); <BR>
p-&gt;InternalFinalConstructAddRef(); <BR>
hRes = p-&gt;FinalConstruct(); <BR>
p-&gt;InternalFinalConstructRelease(); <BR>
if (hRes == S_OK) <BR>
hRes = p-&gt;QueryInterface(riid, ppv); <BR>
if (hRes != S_OK) <BR>
delete p; <BR>
} <BR>
} <BR>
else <BR>
{ <BR>
// get the IID that was requested <BR>
hRes = pIUnknown-&gt;QueryInterface(riid, ppv); // release the IUnknown reference
<BR>
pIUnknown-&gt;Release(); <BR>
} <BR>
return hRes; <BR>
} <BR>
}; // ** <BR>
// ****** ATL 2.0 version - Added by Jerry Anderson for single instance object support</TT></FONT></P>
<P>As with shared server support, you must add a new macro to your class definition
to enable your server for single instance support. Add the macro <TT>DECLARE_NOT_AGGREGATABLE_SINGLE</TT>
to the <TT>CTracker</TT> class definition supplying the class name, <TT>CLSID</TT>,
interface name, and <TT>IID</TT> of your server. Listing 4.21 shows the <TT>CTracker</TT>
implementation of single instance server support.
<H3><A NAME="Heading40"></A>Listing 4.21 TRACKER.H--Single Instance Server Support
Added to CTracker Class</H3>
<P><FONT COLOR="#0066FF"><TT><BR>
. . . DECLARE_REGISTRY_RESOURCEID(IDR_TRACKER) BEGIN_COM_MAP(CTracker) <BR>
COM_INTERFACE_ENTRY(ITracker) <BR>
COM_INTERFACE_ENTRY(IDispatch) <BR>
COM_INTERFACE_ENTRY(ISupportErrorInfo) <BR>
END_COM_MAP() // DECLARE_NOT_AGGREGATABLE_SHARED(CTracker, &amp;CLSID_Tracker) <BR>
DECLARE_NOT_AGGREGATABLE_SINGLE(CTracker, &amp;CLSID_Tracker, ITracker, &amp;IID_ITracker)
// ISupportsErrorInfo <BR>
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid); // ITracker . . .</TT></FONT></P>
<P>Shared server support is very straightforward to implement and use and adds a
level of functionality not normally available to standard server implementations.
<H2><A NAME="Heading41"></A>From Here...</H2>
<P>In this chapter, you created a basic implementation of an Automation Server. You
also expanded upon the basic framework provided by ATL to create new and interesting
features within your implementation. ATL provides a clean and easy way to implement
Automation Servers. Combined with MFC or STL (Standard Template Library), ATL is
a powerful platform for creating ActiveX components. ATL has the added benefit of
being a product supported by Microsoft, which is not the case with the BaseCtl framework.</P>
<P>Like MFC, ATL servers can benefit from the addition of User Interface and Events.
The creation of services and remote servers also makes the prospect of implementing
ActiveX servers enticing.</P>
<P>Automation Servers provide a flexible way to create lightweight ActiveX components
for use by your applications. The support of both <TT>IDispatch</TT> interfaces and
custom interfaces (a dual-interface server) also gives the user of the server a lot
of flexibility in terms of implementation styles and methods.</P>

<P>The <A HREF="ch05.htm">next chapter</A> looks at creating an Automation Server
using the BaseCtl framework.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
