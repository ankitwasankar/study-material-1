<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Tue, Apr 15, 1997 9:00 AM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 7</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 7<BR>
Advanced ActiveX Control Development with MFC</H1>

<UL>
	<LI><A HREF="#Heading1">Advanced ActiveX Control Development with MFC</A>
	<UL>
		<LI><A HREF="#Heading2">Properties</A>
		<UL>
			<LI><A HREF="#Heading3">Creating Asynchronous Properties</A>
			<LI><A HREF="#Heading4">Listing 7.1 MFCONTROLWINCTL.CPP--Constructor Initialization
			of ReadyState</A>
			<LI><A HREF="#Heading5">Listing 7.2 MYDATAPATH.H--CString Member Variable Added to
			the CMyDataPath Class</A>
			<LI><A HREF="#Heading6">Listing 7.3 MFCCONTROWINCTL.H--CMFCControlWinCtrl Class Updated
			to Include the CMyDataPath Class</A>
			<LI><A HREF="#Heading7">Listing 7.4 MYDATAPATH.CPP--OnDataAvailable Implementation</A>
			<LI><A HREF="#Heading8">Listing 7.5 MFCCONTROLWINCTL.CPP--oMyDataPath Object Initialized
			in the CMFCControlWinCtrl Class Constructor</A>
			<LI><A HREF="#Heading9">Listing 7.6 MFCCONTROLWINCTRL.CPP--oMyDataPath Added to DoPropExchange</A>
			<LI><A HREF="#Heading10">Listing 7.7 MFCCONTROLWINCTL.H--Get/Set TextData Property
			Implementation</A>
			<LI><A HREF="#Heading11">Static and Dynamic Property Enumeration</A>
			<LI><A HREF="#Heading12">Listing 7.8 MFCCONTROL.ODL--EALIGNMENT Enumeration Added
			to the MFCControl.odl File</A>
			<LI><A HREF="#Heading13">Listing 7.9 MFCCONTROLWINCTL.H--Dynamic Property Enumeration
			Function Prototypes Added to the CMFCControlWinCtrl Class</A>
			<LI><A HREF="#Heading14">Listing 7.10 MFCCONTROLWINCTL.CPP--OnGetPredefinedStrings
			Implementation</A>
			<LI><A HREF="#Heading15">Listing 7.11 MFCCONTROLWINCTL.H--Control dispid Enumeration</A>
			<LI><A HREF="#Heading16">Listing 7.12 MFCCONTROLWINCTL.CPP-- OnGetPredefinedValue
			Implementation</A>
			<LI><A HREF="#Heading17">Listing 7.13 MFCCONTROLWINCTL.CPP--OnGetDisplayString Implementation</A>
		</UL>
		<LI><A HREF="#Heading18">Drawing the Control</A>
		<UL>
			<LI><A HREF="#Heading19">Listing 7.14 MFCCONTROWINCTL.CPP--Optimized OnDraw Function</A>
		</UL>
		<LI><A HREF="#Heading20">Adding Clipboard and Drag and Drop Support</A>
		<UL>
			<LI><A HREF="#Heading21">Clipboard Support</A>
			<LI><A HREF="#Heading22">Listing 7.15 MFCCONTROLWINCTL.CPP--OnKeyDown Implementation</A>
			<LI><A HREF="#Heading23">Listing 7.16 MFCCONTROLWINCTL.H--Clipboard Source Support
			Helper Function Prototypes</A>
			<LI><A HREF="#Heading24">Listing 7.17 MFCCONTROLWINCTL.CPP--CopyDataToClipboard Implementation</A>
			<LI><A HREF="#Heading25">Listing 7.18 MFCCONTROLWINCTL.CPP-- PrepareDataForTransfer
			Implementation</A>
			<LI><A HREF="#Heading26">Listing 7.19 MFCCONTROLWINCTL.H--Clipboard Target Support
			Helper Function Prototypes</A>
			<LI><A HREF="#Heading27">Listing 7.20 MFCCONTROLWINCTL.CPP--GetDataFromClipboard
			Implementation</A>
			<LI><A HREF="#Heading28">Listing 7.21 MFCCONTROLWINCTL.CPP--GetDataFromTransfer Implementation</A>
			<LI><A HREF="#Heading29">Drag and Drop Support</A>
			<LI><A HREF="#Heading30">Listing 7.22 MFCCONTROLWINCTL.CPP--OnLButtonDown Implementation</A>
			<LI><A HREF="#Heading31">Listing 7.23 MFCCONTROLWINCTL.H--CMyOleDropTarget Class
			Declaration Added to the CMFCControlWinCtl Class</A>
			<LI><A HREF="#Heading32">Listing 7.24 MFCCONTROLWINCTL.CPP--OnCreate Implementation</A>
			<LI><A HREF="#Heading33">Listing 7.25 MFCCONTROLWINCTL.CPP--OnDragOver Implementation</A>
			<LI><A HREF="#Heading34">Listing 7.26 MFCCONTROLWINCTL.CPP--OnDrop Implementation</A>
			<LI><A HREF="#Heading35">Custom Clipboard and Drag and Drop Formats</A>
			<LI><A HREF="#Heading36">Listing 7.27 MFCCONTROLWINCTL.H--m_uiCustomFormat Member
			Variable Added to the CMFCControlWinCtrl Class</A>
			<LI><A HREF="#Heading37">Listing 7.28 MFCCONTROLWINCTL.CPP--Custom Clipboard Format
			Registered in the CMFCControlWinCtrl Constructor</A>
			<LI><A HREF="#Heading38">Listing 7.29 MFCCONTROLWINCTL.CPP--PrepareDataForTransfer
			Function Updated to Support Custom Clipboard Formats</A>
			<LI><A HREF="#Heading39">Listing 7.30 MFCCONTROLWINCTL.CPP--GetDataFromTransfer Function
			Updated to Support Custom Clipboard Formats</A>
		</UL>
		<LI><A HREF="#Heading40">Subclassing Existing Windows Controls</A>
		<UL>
			<LI><A HREF="#Heading41">Listing 7.31 MFCCONTROLSUBWINCTL.CPP--Additional Code Requirements
			for ActiveX Controls that Subclass Existing Windows Controls</A>
		</UL>
		<LI><A HREF="#Heading42">Dual-Interface Controls</A>
		<LI><A HREF="#Heading43">Other ActiveX Features</A>
		<UL>
			<LI><A HREF="#Heading44">Windowless Activation</A>
			<LI>
			<LI><A HREF="#Heading46">Flicker-Free Activation</A>
			<LI><A HREF="#Heading47">Unclipped Device Context</A>
			<LI><A HREF="#Heading48">Mouse Pointer Notifications When Inactive</A>
		</UL>
		<LI><A HREF="#Heading49">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>Advanced ActiveX Control Development with MFC</H1>

<UL>
	<LI><B>Adding asynchronous properties</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 MFC hides many details of support of asychronous properties, allowing you to focus
	on your control implementation.
	<P>
	<LI><B>Optimized drawing</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Optimized drawing with MFC is easy and can enhance the overall performance of the
	control.
	<P>
	<LI><B>Clipboard and Drag and Drop support</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Using MFC to add Clipboard and Drag and Drop support to mundane control implementations
	can have profound effects.
	<P>
	<LI><B>Subclassing Windows controls</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 Subclassing an existing Windows control can reduce your development time when creating
	new controls, and MFC can be a hinderance.
	<P>
	<LI><B>Dual-interface controls</B> 
<SPACER TYPE="VERTICAL" SIZE="2">
 MFC does not support creation of dual-interface controls by default, but you can
	add them.
</UL>

<P>This chapter expands upon the information in <A HREF="ch06.htm">Chapter 6</A>
about creating a basic MFC ActiveX control. In addition to the features that you
are familiar with, such as Clipboard and Drag and Drop support, you will learn how
to implement asynchronous properties and optimized drawings, which are the result
of the adoption of OC 96 specification.
<H2><A NAME="Heading2"></A>Properties</H2>
<P><A HREF="ch06.htm">Chapter 6</A> tells you how to add the various types of properties
to your control implementation. One type of property has yet to be examined: asynchronous
properties.
<H3><A NAME="Heading3"></A>Creating Asynchronous Properties</H3>
<P><I>Asynchronous properties</I> are those properties that typically represent a
large amount of data, such as a text file or a bitmap, and are loaded as a background
process so as not to interfere with the normal processing of the control and the
container. This statement can be somewhat misleading. Asynchronous refers only to
the call to load the data; it does not refer to the actual loading. For example,
a control uses a bitmap as its background and has defined it as an asynchronous property.
If OLE determines that the bitmap is already on the local machine, the data is considered
to be available to the control and, subsequently, will instruct the control that
<I>all</I> of the data is available. If OLE determines that the bitmap is not available
on the local machine, OLE will load the data as fast as possible and inform the control
as data becomes available. After the data is in a location that is considered accessible,
the property essentially behaves as any other property would. If you require the
asynchronous loading of the data regardless of its location, you must implement it
yourself.</P>
<P>Except for a few changes, asynchronous properties are added in the same fashion
as any other property. In <A HREF="ch06.htm">Chapter 6</A>, when you initially create
your control, you have the opportunity to define some ActiveX features, one being
Loads Properties Asynchronously. Choosing this option adds some code to your application
that normally would not be implemented.</P>
<P>First, the stock property <TT>ReadyState</TT> was added to your control. This
property is used to notify the container of the state that the control is in while
loading its properties. The stock event <TT>ReadyStateChange</TT>, which is used
to notify the container that the <TT>ReadyState</TT> of the control has changed,<TT>
</TT>was also added. The last thing that was added was the initialization of the
member variable <TT>m_lReadyState</TT> to <TT>READYSTATE_LOADING</TT> in the controls
constructor (see Listing 7.1).
<H3><A NAME="Heading4"></A>Listing 7.1 MFCONTROLWINCTL.CPP--Constructor Initialization
of ReadyState</H3>
<P><FONT COLOR="#0066FF"><TT>CMFCControlWinCtrl::CMFCControlWinCtrl()<BR>
{<BR>
       InitializeIIDs(&amp;IID_DMFCControlWin, &amp;IID_DMFCControlWinEvents);<BR>
       m_lReadyState = READYSTATE_LOADING;<BR>
       // TODO: Call InternalSetReadyState when the readystate changes.<BR>
       // set the alignment to the default of left<BR>
       m_lAlignment = EALIGN_LEFT;<BR>
}</TT></FONT></P>

<P>This is the extent of the work that is done for you at the time your project is
created.</P>
<P>The control must have an entry point for OLE to communicate with when notifying
the control when and how much data is available. This is accomplished through the
<TT>CDataPathProperty</TT> or the <TT>CCachedDataPathProperty</TT> class.</P>
<P><TT>CDataPathProperty</TT> is used for data that typically arrives in a continuous
fashion, such as stock market data. <TT>CCachedDataPathProperty</TT> is used for
data that is retrieved once and then stored or cached, such as a file. You must implement
a class in your control that is inherited from one of these classes. To add a new
class, you use the ClassWizard.</P>
<P>For the purposes of this chapter and the sample application, you will implement
an asynchronous property that reads string data from a file and outputs the data
as the caption of the control.</P>
<P>Open the ClassWizard, click the Add C<U>l</U>ass button on any one of the tab
pages, and select the New menu item. In the New Class dialog (see fig. 7.1), enter
the <U>N</U>ame CMyDataPath, select a <U>B</U>ase class of <TT>CCachedDataPathProperty</TT>,
and click the OK button to add the new class. <B><BR>
<BR>
</B><A HREF="art/07/w_fig01.jpg"><B>FIG. 7.1</B></A> <I><BR>
Add a new <TT>CCachedDataPath Property</TT> class with the ClassWizard.</I></P>
<P>Your control must override the <TT>OnDataAvailable</TT> function within the <TT>CMyDataPath</TT>
class in order to receive data as it becomes available. From the open ClassWizard
dialog, select the Message Maps tab and locate the <TT>OnDataAvailable</TT> message
within the Messa_ges list box. Double-click the <TT>OnDataAvailable</TT> message
to add the method to your class. Click the OK button to close the ClassWizard.</P>
<P>The first step is to add the <TT>cstrMyBuffer</TT> member variable to the <TT>CMyDataPath</TT>
class (see Listing 7.2). The member variable, <TT>cstrMyBuffer</TT>, is used to store
all of the data as it is passed to the <TT>OnDataAvailable</TT> function.
<H3><A NAME="Heading5"></A>Listing 7.2 MYDATAPATH.H--CString Member Variable Added
to the CMyDataPath Class</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
// Implementation<BR>
protected:<BR>
       CString cstrMyBuffer;<BR>
};</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>The next step is to update the control class, <TT>CMFCControlWinCtrl</TT>, to
include the header file of the <TT>CMyDataPath</TT> class and also to add a new member
variable, <TT>oMyDataPath</TT> (see Listing 7.3). The <TT>CMyDataPath</TT> class
also needs access to the function <TT>CaptionMethod</TT> in the control so that the
data can be placed in the control when it is all available. Since the <TT>CaptionMethod</TT>
is a protected function, it is necessary to allow the <TT>CMyDataPath</TT> class
access to the function using the C++ <TT>friend</TT> declaration.
<H3><A NAME="Heading6"></A>Listing 7.3 MFCCONTROWINCTL.H--CMFCControlWinCtrl Class
Updated to Include the CMyDataPath Class</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
#include &quot;alignmentenums.h&quot;<BR>
#include &quot;mydatapath.h&quot;<BR>
/////////////////////////////////////////////////////////////////////////////<BR>
// CMFCControlWinCtrl : See MFCControlWinCtl.cpp for implementation.<BR>
. . .<BR>
       friend class CMyDataPath;<BR>
       CMyDataPath oMyDataPath;<BR>
};<BR>
. . .</TT></FONT></P>

<P>The next step is to add the code to the <TT>OnDataAvailable</TT> function in the
<TT>CMyDataPath</TT> class to deal with the data as it is sent to the control. The
<TT>OnDataAvailable</TT> method is straightforward (see Listing 7.4). It has two
properties, <TT>dwSize</TT> and <TT>bscfFlag</TT>. <TT>DwSize</TT> is the number
of bytes of data that are currently available in this call to the function. <TT>BscfFlag</TT>
is a set of flags indicating the current operation taking place (see Table 7.1).

<TABLE BORDER="1" WIDTH="100%">
	<CAPTION><B>Table 7.1</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> <I>BSCF</I> Notifications</B></CAPTION>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Notification Message</B></TD>
		<TD ALIGN="LEFT" VALIGN="TOP"><B>Description</B></TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>BSCF_FIRSTDATANOTIFICATION</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This message is sent the first time that the <TT>OnDataAvailable</TT> function is
			called. It is important to note that this message can be sent along with the <TT>BSCF_LASTDATANOTIFICATION</TT>
			message.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>BSCF_INTERMEDIATEDATANOTIFICATION</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This message is sent while the OLE is still loading data.</TD>
	</TR>
	<TR ALIGN="LEFT" rowspan="1">
		<TD ALIGN="LEFT" VALIGN="TOP"><TT>BSCF_LASTDATANOTIFICATION</TT></TD>
		<TD ALIGN="LEFT" VALIGN="TOP">This message is sent when a control has been given all of the data that is available
			to the property. It is important to note that this message can be sent along with
			the <TT>BSCF_FIRSTDATANOTIFICATION</TT> message.</TD>
	</TR>
</TABLE>
<BR>
<BR>
Note the use of the <TT>BSCF</TT> notification messages and how you must respond
to each. Do not process the messages exclusive of each other; you must process each
message individually. Remember that you can receive more than one notification message
in each call to <TT>OnDataAvailable</TT>.</P>
<P>The <TT>OnDataAvailable</TT> implementation first clears the string buffer if
this is the first call to the function. Next it creates a buffer of the appropriate
size to receive the data from the <TT>Read</TT> function. If the data was successfully
read, the data is added to the member variable <TT>cstrMyBuffer</TT>. Finally if
this is the last call to the <TT>OnDataAvailable</TT> function, the <TT>CaptionMethod</TT>
is called supplying the new data and an empty variant parameter for the alignment.
The last thing you must do is change the state of the control to <TT>READYSTATE_COMPLETE</TT>,
which indicates that all of the asynchronous properties have been loaded.
<H3><A NAME="Heading7"></A>Listing 7.4 MYDATAPATH.CPP--OnDataAvailable Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMyDataPath::OnDataAvailable(DWORD dwSize, DWORD
bscfFlag) <BR>
{<BR>
        // if this is the first notification<BR>
         if(bscfFlag &amp; BSCF_FIRSTDATANOTIFICATION)<BR>
               // clear the string buffer<BR>
               cstrMyBuffer.Empty();<BR>
        CString cstrTempBuffer;<BR>
        // get a temp buffer<BR>
        LPTSTR lptstrTempBuffer = cstrTempBuffer.GetBuffer(dwSize);<BR>
        // read the data to a temp buffer<BR>
        UINT uiBytesRead = this-&gt;Read(lptstrTempBuffer, dwSize);<BR>
        // if we read in any data<BR>
        if(uiBytesRead)<BR>
        {<BR>
               // store the data<BR>
               cstrTempBuffer.ReleaseBuffer(uiBytesRead);<BR>
               cstrMyBuffer += cstrTempBuffer;<BR>
        }<BR>
        // if this is our last notification<BR>
        if(bscfFlag &amp; BSCF_LASTDATANOTIFICATION)<BR>
        {<BR>
        VARIANT varAlignment;<BR>
        ::VariantInit(&amp;varAlignment);<BR>
        varAlignment.vt = VT_EMPTY;<BR>
        ((CMFCControlWinCtrl *) this-&gt;GetControl())-&gt;CaptionMethod(cstrMyBuffer,
            <BR>
varAlignment);<BR>
        this-&gt;GetControl()-&gt;InternalSetReadyState(READYSTATE_COMPLETE);<BR>
    }<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>Next you need to add an OLE property to store the actual location of the data
that is to be loaded asynchronously. Open the ClassWizard, select the Automation
tab, select the <TT>CMFCControlWinCtrl</TT> class, and click the Add Property button.
In the Add Property dialog, enter the <U>E</U>xternal name TextData, select the <U>T</U>ype
<TT>BSTR</TT> and an Implementation of <TT>Get/Set</TT> <U>m</U>ethods. Do not use
the <TT>OLE_DATAPATH</TT> type for this property, as it doesn't work; the type must
be a <TT>BSTR</TT>. Use of the OLE_DATAPATH and its related problems is a known bug
with Microsoft and MFC. Click the OK button to close the dialog and add the property
to the class. Double-click the <TT>TextData</TT> entry in the E<U>x</U>ternal names
list box to close the ClassWizard and open the source file.</P>
<P>To complete your implementation, you need to add some code to the <TT>CMFCControlWinCtrl</TT>
class source file. First update the class constructor to set the control class in
the <TT>oMyDataPath</TT> object (see Listing 7.5). Doing this is absolutely necessary
for the <TT>DoPropExchange</TT> function to work correctly when loading the data
path property.
<H3><A NAME="Heading8"></A>Listing 7.5 MFCCONTROLWINCTL.CPP--oMyDataPath Object Initialized
in the CMFCControlWinCtrl Class Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>CMFCControlWinCtrl::CMFCControlWinCtrl()<BR>
{<BR>
       InitializeIIDs(&amp;IID_DMFCControlWin, &amp;IID_DMFCControlWinEvents);<BR>
       // TODO: Call InternalSetReadyState when the readystate changes.<BR>
       m_lReadyState = READYSTATE_LOADING;<BR>
<BR>
       // set the alignment to the default of left<BR>
       m_lAlignment = EALIGN_LEFT;<BR>
<BR>
       // don't forget this - DoPropExchange won't work without it<BR>
       oMyDataPath.SetControl(this);<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>Next add the <TT>oMyDataPath</TT> property persistence to the <TT>DoPropExchange</TT>
function (see Listing 7.6). Remember that without the call to <TT>SetControl</TT>
in the constructor, this code will not function correctly.
<H3><A NAME="Heading9"></A>Listing 7.6 MFCCONTROLWINCTRL.CPP--oMyDataPath Added to
DoPropExchange</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::DoPropExchange(CPropExchange*
pPX)<BR>
{<BR>
        ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));<BR>
        COleControl::DoPropExchange(pPX);<BR>
<BR>
        // TODO: Call PX_ functions for each persistent custom property.<BR>
        // if we are loading the properties<BR>
        if(pPX-&gt;IsLoading())<BR>
        {<BR>
                PX_Long(pPX, _T(&quot;Alignment&quot;), m_lAlignment, EALIGN_LEFT);<BR>
                PX_String(pPX, _T(&quot;CaptionProp&quot;), m_cstrCaption, _T(&quot;&quot;));<BR>
                PX_DataPath(pPX, _T(&quot;TextData&quot;), oMyDataPath);<BR>
        }<BR>
<BR>
        // if we are saving the properties<BR>
        if(!pPX-&gt;IsLoading())<BR>
        {<BR>
                PX_Long(pPX, _T(&quot;Alignment&quot;), m_lAlignment, EALIGN_LEFT);<BR>
                PX_String(pPX, _T(&quot;CaptionProp&quot;), m_cstrCaption, _T(&quot;&quot;));<BR>
                PX_DataPath(pPX, _T(&quot;TextData&quot;), oMyDataPath);<BR>
        }<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>Finally you add the code to the <TT>GetTextData</TT> and <TT>SetTextData</TT>
methods (see Listing 7.7). The <TT>GetTextData</TT> function simply returns a UNICODE
version of the property value. The <TT>SetTextData</TT> implementation calls the
<TT>Load</TT> function to load the data pointed to by the <TT>lpszNewValue</TT> parameter.
After the <TT>Load</TT> function returns, the <TT>SetModifiedFlag</TT> and <TT>InvalidateControl</TT>
functions are called to update the control and the data with the new information.
<H3><A NAME="Heading10"></A>Listing 7.7 MFCCONTROLWINCTL.H--Get/Set TextData Property
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BSTR CMFCControlWinCtrl::GetTextData() <BR>
{<BR>
        // retrieve the path and allocate a BSTR from it<BR>
        return (oMyDataPath.GetPath()).AllocSysString();<BR>
}<BR>
<BR>
void CMFCControlWinCtrl::SetTextData(LPCTSTR lpszNewValue) <BR>
{<BR>
        // load the DataPath variable based on the new information<BR>
        this-&gt;Load(lpszNewValue, oMyDataPath);<BR>
<BR>
        // update the property<BR>
        this-&gt;SetModifiedFlag();<BR>
<BR>
        // redraw the control<BR>
        this-&gt;InvalidateControl();<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>Again, it is very important to understand that asynchronous properties are not
a guarantee of improved performance in a general sense. They are merely an option
available to you for creating Internet controls that are more responsive across slower
network connections.
<H3><A NAME="Heading11"></A>Static and Dynamic Property Enumeration</H3>
<P><I>Property enumeration</I> is a way of restricting a property to a specific set
of valid values. An example of an enumeration is a property for determining the alignment
of a control's displayed text: left-justified, centered, and right-justified, in
your case. Another case is a property used to select the different languages a control
supports. This is a good candidate for both a static set, say English and German,
and a dynamic set, say for all the languages on a particular machine.</P>
<P>Adding property enumeration greatly enhances the look and feel of your control.
This addition gives the user all the options that are possible, with a simple click
of a mouse. As a result the user doesn't have to rather than trying to search through
documentation or, worse yet, trying to guess the acceptable values.</P>
<P>When editing the value of an enumerated property within a property browser, note
that development tools such as Visual Basic display all the values of the enumeration
using a string representation rather than just the actual value that the control
can accept. For a Boolean data type, the strings used are <TT>TRUE</TT> and <TT>FALSE</TT>,
representing -1 or 0, respectively.</P>
<P>Two approaches can be taken when creating an enumeration for a property: You can
use a static approach, with an enumeration defined in the control's ODL file, or
a dynamic approach, with enumeration code implemented in the control itself. <B><BR>
<BR>
Static Property Enumeration </B><SPACER TYPE="HORIZONTAL" SIZE="10">ODL allows for
the creation of C/C++ style enumeration declarations that conform to the same rules
as C/C++. Like C/C++, the new enumeration can be used as data type within the ODL
file. While this style of enumeration is by far the easiest, it is also the most
restrictive because the enumeration is static to the type library. The <TT>Alignment</TT>
property is a good candidate for an enumeration because internally that is how it
is validated and used. Listing 7.8 contains the code that was added to your ODL file
to support the <TT>Alignment</TT> enumeration.</P>
<P>Remember to generate a new <TT>UUID</TT> for the enumeration with the GUIDGEN.EXE
application included with VC++.</P>
<P>The <TT>helpstring</TT> is what the user will see within the property browser
of your development environment. If you leave off the <TT>helpstring</TT>, the actual
numeric value will appear instead.</P>
<P>The last thing you did was to change the data type of the <TT>Alignment</TT> property
from <TT>long</TT> to <TT>EALIGNMENT</TT>. This is required if the property is to
display the enumerated values within the property browser. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> ODL is very flexible in that it allows much the same style of data
	type declaration and use as that of C or C++. Any data type that can be declared
	in ODL can also be referenced and used within the same and other ODL files, including
	interface declarations. In addition, other type libraries can be imported into an
	ODL file to provide access to other user-defined data types. In the case of the sample
	control, two types of libraries, <TT>STDOLE_TLB</TT> and <TT>STDTYPE_TLB</TT>, are
	included for the standard OLE interface and data type declarations. <BR>
	<BR>
	The ODL documentation can be a little difficult to decipher, but we recommend that
	you at least review the documentation. It is well worth the effort just to see what
	you can and cannot do with your type library and how it will affect the container
	of your control or component. <BR>
	<BR>
	It is absolutely critical that the developer of containers adhere to the standards
	established in the ODL documentation. You will find that some of the aspects of type
	library creation and use are based on cooperation and trust and that component developers
	depend on that.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H3><A NAME="Heading12"></A>Listing 7.8 MFCCONTROL.ODL--EALIGNMENT Enumeration Added
to the MFCControl.odl File</H3>
<P><FONT COLOR="#0066FF"><TT>    typedef<BR>
    [ uuid(7F369B90-380D-11d0-BCB6-0020AFD6738C) ]<BR>
    enum tagAlignmentEnum<BR>
    {<BR>
            [helpstring(&quot;Left Justify&quot;)] EALIGN_LEFT = 0,<BR>
            [helpstring(&quot;Right Justify&quot;)] EALIGN_RIGHT = 1,<BR>
            [helpstring(&quot;Center&quot;)] EALIGN_CENTER = 2,<BR>
    }EALIGNMENT;<BR>
<BR>
    //  Primary dispatch interface for CMFCControlWinCtrl<BR>
<BR>
    [ uuid(14DD5C04-60DE-11D0-BEE9-00400538977D),<BR>
      helpstring(&quot;Dispatch interface for MFCControlWin Control&quot;), hidden
]<BR>
    dispinterface _DMFCControlWin<BR>
           {<BR>
           properties:<BR>
                  // NOTE - ClassWizard will maintain property information here.<BR>
                  //    Use extreme caution when editing this section.<BR>
                  //{{AFX_ODL_PROP(CMFCControlWinCtrl)<BR>
                  [id(DISPID_READYSTATE), readonly] long ReadyState;<BR>
                  [id(1)] EALIGNMENT Alignment;<BR>
                  [id(DISPID_BACKCOLOR), bindable, requestedit] OLE_COLOR BackColor;<BR>
                  [id(2)] BSTR TextData;<BR>
                  //}}AFX_ODL_PROP<BR>
           methods:<BR>
. . .</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><B>Dynamic Property Enumeration </B><SPACER TYPE="HORIZONTAL" SIZE="10">Dynamic
property enumeration is the most flexible of the two types of property enumeration.
It requires only a little more work on the part of the developer, and is worth the
effort. Dynamic enumeration is perfect for situations where you need to restrict
the data that can be entered into a property but are unable to determine until runtime
what the valid values are. For example, a <TT>LocaleID</TT> property can enumerate
all of the available <TT>LocaleIDs</TT> on the machine that the application is running
on. Another property could enumerate the key field of a SQL database table. The possibilities
are limitless and will provide your control a look and feel that goes far beyond
the effort that was required to enable it. Dynamic property enumeration using MFC
requires the implementation of three methods within your control: <TT>OnGetPredefinedStrings</TT>,
<TT>OnGetPredefinedValue</TT>, and <TT>OnGetDisplayString</TT>, all of which are
virtual functions declared in the <TT>COleControl</TT> class. Listing 7.9 shows the
function prototypes that need to be added to the control's class declaration.
<H3><A NAME="Heading13"></A>Listing 7.9 MFCCONTROLWINCTL.H--Dynamic Property Enumeration
Function Prototypes Added to the CMFCControlWinCtrl Class</H3>
<P><FONT COLOR="#0066FF"><TT>class CMFCControlWinCtrl : public COleControl<BR>
{<BR>
         DECLARE_DYNCREATE(CMFCControlWinCtrl)<BR>
<BR>
// Constructor<BR>
public:<BR>
         CMFCControlWinCtrl();<BR>
<BR>
         BOOL OnGetPredefinedStrings(DISPID dispid, CStringArray* pStringArray, 
              CDWordArray* pCookieArray);<BR>
         BOOL OnGetPredefinedValue(DISPID dispid, DWORD dwCookie, VARIANT FAR*  
           lpvarOut);<BR>
         BOOL OnGetDisplayString( DISPID dispid, CString&amp; strValue );<BR>
<BR>
// Overrides<BR>
. . .</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><TT>OnGetPredefinedStrings</TT> is called by the container application when it
needs to load the strings and cookies for the enumeration (see Listing 7.10). The
string is used as the text representation of the enumerated value to make it more
meaningful to the user. The cookie is a 32-bit value that can be used in any way
that is appropriate to identify the value associated with the display string of the
enumeration. In your case, you are going to store the actual value that the string
represents, but it could just as easily have been a pointer or index into some form
of storage.
<H3><A NAME="Heading14"></A>Listing 7.10 MFCCONTROLWINCTL.CPP--OnGetPredefinedStrings
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CMFCControlWinCtrl::OnGetPredefinedStrings(DISPID
dispid, CStringArray* pStringArray, CDWordArray* pCookieArray)<BR>
{<BR>
       BOOL bResult = FALSE;<BR>
<BR>
       // which property is it<BR>
    switch(dispid)<BR>
    {<BR>
    case dispidAlignment:<BR>
    {<BR>
           // add the string to the array<BR>
           pStringArray-&gt;Add(_T(&quot;Left Justify&quot;));<BR>
           // add the value to the array<BR>
           pCookieArray-&gt;Add(EALIGN_LEFT);<BR>
<BR>
           // add the string to the array<BR>
           pStringArray-&gt;Add(_T(&quot;Center&quot;));<BR>
           // add the value to the array<BR>
           pCookieArray-&gt;Add(EALIGN_CENTER);<BR>
<BR>
           // add the string to the array<BR>
           pStringArray-&gt;Add(_T(&quot;Right Justify&quot;));<BR>
           // add the value to the array<BR>
           pCookieArray-&gt;Add(EALIGN_RIGHT);<BR>
<BR>
           // set the return value<BR>
           bResult = TRUE;<BR>
    }<BR>
    break;<BR>
    }<BR>
<BR>
    return bResult;<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>The <TT>OnGetPredefinedStrings</TT> function is called for every one of the properties
in your control, so your code will have to check the <TT>dispid</TT> that is passed
to the function to make sure that the correct enumeration is going to the correct
property. The <TT>dispid</TT>s of the control properties can be found in the class
declaration of your control and are maintained automatically by the ClassWizard (see
Listing 7.11).
<H3><A NAME="Heading15"></A>Listing 7.11 MFCCONTROLWINCTL.H--Control dispid Enumeration</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
// Dispatch and event IDs<BR>
public:<BR>
       enum {<BR>
       //{{AFX_DISP_ID(CMFCControlWinCtrl)<BR>
       dispidAlignment = 1L,<BR>
       dispidTextData = 2L,<BR>
       dispidCaptionMethod = 3L,<BR>
       dispidCaptionProp = 4L,<BR>
       eventidChange = 1L,<BR>
       //}}AFX_DISP_ID<BR>
       };<BR>
<BR>
. . .</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>When the user selects one of the enumerated values in the property browser, the
control's <TT>OnGetPredefinedValue</TT> function is fired (see Listing 7.12). This
allows the container to retrieve the actual value that should be stored in the property
in place of the string representation. The function is passed the <TT>dispid</TT>
identifying the property that is being changed and the cookie value that was assigned
to the string representation in the <TT>OnGetPredefinedStrings</TT> function.
<H3><A NAME="Heading16"></A>Listing 7.12 MFCCONTROLWINCTL.CPP-- OnGetPredefinedValue
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CMFCControlWinCtrl::OnGetPredefinedValue(DISPID
dispid, DWORD dwCookie,       VARIANT FAR* lpvarOut)<BR>
{<BR>
    BOOL bResult = FALSE;<BR>
<BR>
    // which property is it<BR>
    switch(dispid)<BR>
    {<BR>
    case dispidAlignment:<BR>
            // clear the variant<BR>
            ::VariantInit(lpvarOut);<BR>
            // set the type to a long<BR>
            lpvarOut-&gt;vt = VT_I4;<BR>
            // set the value to the value that was stored with the string<BR>
            lpvarOut-&gt;lVal = dwCookie;<BR>
            // set the return value<BR>
            bResult = TRUE;<BR>
    break;<BR>
    }<BR>
<BR>
    return bResult;<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><TT>OnGetDisplayString</TT> (see Listing 7.13) is the last method to be called
and is required if the programmer wants the text representation to appear next to
the property in the property browser when the property is not being edited. The function
is passed a <TT>dispid</TT>, again reflecting the current property, and a <TT>CString</TT>
object reference. The control should place the string, as reflected by the current
state of the property, into the <TT>CString</TT> object and exit the function.
<H3><A NAME="Heading17"></A>Listing 7.13 MFCCONTROLWINCTL.CPP--OnGetDisplayString
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CMFCControlWinCtrl::OnGetDisplayString( DISPID
dispid, CString&amp; strValue )<BR>
{<BR>
        BOOL bResult = FALSE;<BR>
<BR>
        // which property is it<BR>
        switch(dispid)<BR>
        {<BR>
        case dispidAlignment:<BR>
           {<BR>
           switch(m_lAlignment)<BR>
           {<BR>
           case EALIGN_LEFT:<BR>
               strValue = _T(&quot;Left Justify&quot;);<BR>
           break;<BR>
           case EALIGN_CENTER:<BR>
               strValue = _T(&quot;Center&quot;);<BR>
           break;<BR>
           case EALIGN_RIGHT:<BR>
               strValue = _T(&quot;Right Justify&quot;);<BR>
           break;<BR>
           }<BR>
<BR>
           // set the return value<BR>
           bResult = TRUE;<BR>
        }<BR>
        break;<BR>
        }<BR>
<BR>
        return bResult;<BR>
}</TT></FONT>
<H2><A NAME="Heading18"></A>Drawing the Control</H2>
<P>Optimized drawing allows you to create drawing objects, such as pens or brushes,
and rather than removing them when you are finished drawing, you can store them in
your control member variables and use them again the next time your control draws
itself. The benefit is that you create a pen once for the drawing lifetime of your
control, instead of every time it draws. One thing to remember, though: Optimized
drawing does not guarantee performance improvements. It simply supplies a framework
for how drawing should be performed and how drawing resources should be used. A poorly
written control is still poorly written, no matter how you slice it.</P>
<P>Standard and optimized drawings have a single tradeoff, and that is size versus
speed. Standard drawing does not require member variables for the drawing objects
that are created and used--thus requiring less instance data but more processing
time--whereas optimized code will be the opposite.</P>
<P>An additional drawback to optimized drawing is that a container may not support
it. A control must, at the very least, support standard drawing functionality, deferring
to optimized only if appropriate.</P>
<P>For MFC, the scope of optimized drawing is very narrow compared to the OC 96 specification,
but it will, nonetheless, result in performance improvements if taken advantage of.
The OC 96 specification further breaks optimized drawing into what is known as <I>aspects</I>,
but MFC is not designed to allow that kind of drawing. For more information on aspect
drawing, please see the OLE Control 96 Specification that ships with the ActiveX
SDK. <B><BR>
<BR>
Optimized Drawing</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>In <A HREF="ch06.htm">Chapter
6</A>, you learn how to implement standard drawing. In this chapter, you will enhance
the original implementation to take advantage of drawing optimization. Listing 7.14
reflects the change that is made to the original drawing code to use optimization.
That's it. You just check to see whether the container supports optimized drawing.
If the container supports optimized drawing, you leave the <TT>CBrush</TT> object
alone and use it again when you have to draw the control's UI. Thus, you save time
every time you redraw the UI because you load the brush only once. When the control
is destroyed, the <TT>CBrush</TT> object will go out of scope and will remove the
brush object for you. Optimized drawing is that simple, but it depends on the container
application for support.
<H3><A NAME="Heading19"></A>Listing 7.14 MFCCONTROWINCTL.CPP--Optimized OnDraw Function</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
<BR>
        // set the old font back<BR>
        pdc-&gt;SelectObject(pOldFont);<BR>
// **<BR>
// ****** Get the text font ******<BR>
<BR>
        // The container does not support optimized drawing.<BR>
        if(!IsOptimizedDraw())<BR>
        {<BR>
                // select the old brush back<BR>
                pdc-&gt;SelectObject(pOldBrush);<BR>
        }<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<H2><A NAME="Heading20"></A>Adding Clipboard and Drag and Drop Support</H2>
<P>The <I>Clipboard</I> is an area of the Windows operating system that acts like
a bulletin board for data that can be shared between applications. By means of a
series of keystrokes or menu options, a user can copy data to the Clipboard from
one application and paste the data from the Clipboard into another application.</P>
<P><I>Drag and Drop</I> provides the user with the ability to transfer data between
two applications by means of a mouse only. The user selects the data to transfer,
holds down a mouse button on the selected data, drags the data to the location where
is it to be added, and releases the mouse button, thus dropping the data into the
new location. Drag and Drop support is similar in its implementation to Clipboard
support, and you will take full advantage of it in your implementa</P>
<P>Adding Clipboard and Drag and Drop support to a control can make even the simplest
implementations appear more professional and well-rounded.
<H3><A NAME="Heading21"></A>Clipboard Support</H3>
<P>The first step is deciding which keystrokes will be used to initiate the cut,
copy, or paste operation. Fortunately, the Windows operating system already has a
number of standards in this area. You will use Ctrl+X or Shift+Delete for Cut, Ctrl+C
or Ctrl+Insert for Copy, and Ctrl+V or Shift+Insert for Paste.</P>
<P>Open the ClassWizard and select the Message Maps tab for the <TT>CMFCControlWinCtrl</TT>
class. Double-click <TT>WM_KEYDOWN</TT> in the list of messages to add the <TT>OnKeyDown</TT>
function to your message map (see fig. 7.2). The <TT>OnKeyDown</TT> function is where
you are going to add your code to look for the keystroke combinations that will initiate
the Clipboard transfers. Double-click the <TT>OnKeyDown</TT> member function to close
the ClassWizard and open the source file for editing. <B><BR>
<BR>
</B><A HREF="art/07/w_fig02.jpg"><B>FIG. 7.2</B></A> <I><BR>
Add the <TT>OnKeyDown</TT> message map with the ClassWizard.</I></P>
<P>Listing 7.15 shows the code that is added to <TT>OnKeyDown</TT> to support the
keystroke combinations listed in the preceding paragraph. The implementation is simple;
based on the particular state of the Ctrl or Shift keys and the correct keystroke,
the function either copies the data to or copies the data from the Clipboard.
<H3><A NAME="Heading22"></A>Listing 7.15 MFCCONTROLWINCTL.CPP--OnKeyDown Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::OnKeyDown(UINT nChar, UINT
nRepCnt, UINT nFlags) <BR>
{<BR>
       BOOL bHandled = FALSE;<BR>
<BR>
       // find out if the shift key is being held down<BR>
       short sShift = ::GetKeyState(VK_SHIFT);<BR>
       // find out if the control key is being held down<BR>
       short sControl = ::GetKeyState(VK_CONTROL);<BR>
<BR>
       switch(nChar)<BR>
       {<BR>
       case 0x56: // `V'    // PASTE<BR>
       case 0x76: // `v' <BR>
               // if the control key is being held down<BR>
               if(sControl &amp; 0x8000)<BR>
               {<BR>
                      // get any text from the clipboard<BR>
                      this-&gt;GetDataFromClipboard();<BR>
                      // force the control to redraw itself<BR>
                      this-&gt;InvalidateControl(NULL);<BR>
                      // we don't need to pass this key to the base implementation<BR>
                      bHandled = TRUE;<BR>
               }<BR>
       case 0x43: // `C'    // COPY or PASTE<BR>
       case 0x63: // `c'                     <BR>
       case VK_INSERT:<BR>
               // if the control key is being held down<BR>
               if(sControl &amp; 0x8000)<BR>
               {<BR>
                       // copy the data to the clipboard<BR>
                       this-&gt;CopyDataToClipboard();<BR>
<BR>
                       // we don't need to pass this key to the base implementation<BR>
                       bHandled = TRUE;<BR>
               }<BR>
               // if the shift key is being held down it is a PASTE<BR>
               else if(sShift &amp; 0x8000 &amp;&amp; nChar == VK_INSERT)<BR>
               {<BR>
               // get any text from the clipboard<BR>
               this-&gt;GetDataFromClipboard();<BR>
<BR>
               // force the control to redraw itself<BR>
               this-&gt;InvalidateControl(NULL);<BR>
<BR>
               // we don't need to pass this key to the base implementation<BR>
               bHandled = TRUE;<BR>
               }<BR>
<BR>
       break;<BR>
       case 0x58: // `X'        // CUT<BR>
       case 0x78: // `x'<BR>
       case VK_DELETE:<BR>
               // if this is a shift delete OR CTRL-X/x<BR>
               if((nChar == VK_DELETE &amp;&amp; (sShift &amp; 0x8000)) || ((nChar
== 0x58                                   || nChar == 0x78) &amp;&amp; (sControl
&amp; 0x8000)))<BR>
               {<BR>
                       this-&gt;CopyDataToClipboard();<BR>
<BR>
                       // clear the string since this is a CUT operation<BR>
                       m_cstrCaption.Empty();<BR>
<BR>
                       // fire the global change event<BR>
                       this-&gt;FireChange();<BR>
<BR>
                       // force the control to repaint itself<BR>
                       this-&gt;InvalidateControl(NULL);<BR>
<BR>
                       // we don't need to pass this key to the base implementation<BR>
                       bHandled = TRUE;<BR>
                       }<BR>
       break;<BR>
       }<BR>
<BR>
       // if we didn't handle the character<BR>
       if(!bHandled)<BR>
       {<BR>
           // and the control key is not being held down<BR>
           if(!(sControl &amp; 0x8000))<BR>
                   // send to the default handler<BR>
                   COleControl::OnKeyDown(nChar, nRepCnt, nFlags);<BR>
       }<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>In addition to the code that you added to trap the keystrokes, you also need to
add four methods, which you will examine in detail in the next section, for dealing
with the Clipboard transfers.</P>
<P><TT>CopyDataToClipboard</TT> will, as the name implies, get the data from the
control, and using the helper function, <TT>PrepareDataForTransfer</TT>, will package
the data and put it on the Clipboard.</P>
<P><TT>GetDataFromClipboard</TT> will open the Clipboard and look for data formats
that the control understands. Upon finding a suitable format, <TT>GetDataFromClipboard</TT>
will use the helper function <TT>GetDataFromTransfer</TT> to store the data in the
control.</P>
<P>The fact that the data transfer functions have been separated into two separate
methods for each type of transfer, to and from the Clipboard, and then further broken
down in each type of transfer into two separate steps will aid you when you enable
the control for Drag and Drop support. This is because the basic data transfer mechanism
is the same between the Clipboard and Drag and Drop and will allow you to rely on
a large portion of shared code for each implementation. <B><BR>
<BR>
Using Built-In Clipboard Formats</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>The
Windows operating system defines a number of built-in data transfer formats for use
with the Clipboard. You see the formats in the following list:</P>


<BLOCKQUOTE>
	<P>CF_TEXT <BR>
	CF_BITMAP <BR>
	CF_METAFILEPICT <BR>
	CF_SYLK CF_DIF <BR>
	CF_TIFF CF_OEMTEXT<BR>
	CF_DIB CF_PALETTE <BR>
	CF_PENDATA <BR>
	CF_RIFF <BR>
	CF_WAVE <BR>
	CF_UNICODETEXT <BR>
	CF_ENHMETAFILE <BR>
	CF_HDROP <BR>
	CF_LOCALE <BR>
	CF_MAX <BR>
	CF_OWNERDISPLAY <BR>
	CF_DSPTEXT <BR>
	CF_DSPBITMAP <BR>
	CF_DSPMETAFILEPICT <BR>
	CF_DSPENHMETAFILE <BR>
	CF_GDIOBJFIRST <BR>
	CF_GDIOBJLAST

</BLOCKQUOTE>

<P>The first implementation of Clipboard data transfer will rely on the <TT>CF_TEXT</TT>
format. This is a general format for transferring non-UNICODE text data. There are
two aspects to using the Clipboard: being a Clipboard source and being a Clipboard
target. Being a Clipboard source refers to an application's capability to copy data
<I>to</I> the Clipboard. Being a Clipboard target refers to an application's capability
to copy data <I>from</I> the Clipboard. You will first learn how to enable a control
as a Clipboard source and then how to enable a control as a Clipboard target. <B><BR>
<BR>
Enabling a Control as a Clipboard Source </B><SPACER TYPE="HORIZONTAL" SIZE="10">A
<I>Clipboard source</I> is an application that puts data on the Clipboard for other
applications to copy. An application must support two COM interfaces, <TT>IDataObject</TT><B>
</B>and<B> </B><TT>IEnumFORMATETC</TT>, in order to qualify as a valid Clipboard
source. MFC provides the classes <TT>COleDataSource</TT><B> </B>and<B> </B><TT>COleDataObject</TT>,
which perform all of the work of implementing the interfaces for you. The <TT>OnKeyDown</TT>
implementation takes advantage of two helper functions, <TT>CopyDataToClipboard</TT>
and <TT>PrepareDataForTransfer</TT>, when copying data to the Clipboard. First you
need to add the two function prototypes to the <TT>CMFCControlWinCtrl</TT> class
(see Listing 7.16).
<H3><A NAME="Heading23"></A>Listing 7.16 MFCCONTROLWINCTL.H--Clipboard Source Support
Helper Function Prototypes</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
       void CopyDataToClipboard(void);<BR>
       void PrepareDataForTransfer(COleDataSource * opOleDataSource);<BR>
};<BR>
. . .</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><TT>CopyDataToClipboard</TT> uses the <TT>COleDataSource</TT> class provided by
MFC to connect to the Clipboard (see Listing 7.17). By calling the <TT>GetClipboardOwner</TT>
function, your implementation first checks to see whether you already have an object
on the Clipboard. <TT>GetClipboardOwner</TT> returns a pointer to a <TT>COleDataSource</TT>
object if the Clipboard contains a <TT>COleDataSource</TT> object that you had previously
set to the Clipboard using the <TT>SetClipboard</TT> function. If you are not the
owner of the Clipboard, the method returns <TT>NULL</TT>. If you didn't get a reference
to a <TT>COleDataSource</TT> object, you need to create one. Next you call the general
method <TT>PrepareDataForTransfer</TT> passing in your <TT>COleDataSource</TT> object,
which will copy the data from the control to the <TT>COleDataSource</TT> object.
The final thing you do is put the <TT>COleDataSource</TT> object on the Clipboard,
but only if you weren't the owner of the Clipboard at the time the transfer occurred.
Setting the Clipboard again with the same object will result in an error.
<H3><A NAME="Heading24"></A>Listing 7.17 MFCCONTROLWINCTL.CPP--CopyDataToClipboard
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::CopyDataToClipboard(void)<BR>
{<BR>
       // get the clipboard if we are the owner<BR>
       COleDataSource * opOleDataSource = COleDataSource::GetClipboardOwner();<BR>
       BOOL bSetClipboard = FALSE;<BR>
       // if we didn't get back a pointer<BR>
       if(opOleDataSource == NULL)<BR>
       {<BR>
               // if this is a new clipboard object<BR>
               bSetClipboard = TRUE;<BR>
               // get a new data source object<BR>
               opOleDataSource = new COleDataSource;<BR>
               }<BR>
       // call the common data preparation function<BR>
       this-&gt;PrepareDataForTransfer(opOleDataSource);<BR>
       // did we get a new clipboard object?<BR>
       if(bSetClipboard)<BR>
               // pass the data to the clipboard<BR>
               opOleDataSource-&gt;SetClipboard();<BR>
               }</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><TT>PrepareDataForTransfer</TT> is used to create the necessary memory structures
and to prepare the <TT>COleDataSource</TT> object that will be used in the data transfer
(see Listing 7.18). For your data transfer, you are going to place the Caption on
the Clipboard using the Clipboard format <TT>CF_TEXT</TT>. In order to put the text
data on the Clipboard, you have to create a global memory object and copy the data
to it. After you create the global object, you store it in the <TT>COleDataSource</TT>
object using the <TT>CacheGlobalData</TT> function. Don't worry about cleaning up
any data that was previously set in the <TT>COleDataSource</TT> object; the <TT>CacheGlobalData</TT>
function will do that for you.
<H3><A NAME="Heading25"></A>Listing 7.18 MFCCONTROLWINCTL.CPP-- PrepareDataForTransfer
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::PrepareDataForTransfer(COleDataSource
*            <BR>
opOleDataSource)<BR>
{<BR>
       // get the length of the data to copy<BR>
       long lLength = m_cstrCaption.GetLength() + 1;<BR>
       // create a global memory object<BR>
       HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, sizeof(TCHAR)
     <BR>
      * lLength);<BR>
     <BR>
       // lock the memory down<BR>
       LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(hGlobal);<BR>
       // copy the string<BR>
       for(long lCount = 0; lCount &lt; lLength - 1; lCount++)<BR>
       lpTempBuffer[lCount] = m_cstrCaption.GetAt(lCount);<BR>
       // null terminate the string<BR>
       lpTempBuffer[lCount] = `\0';<BR>
       // unlock the memory<BR>
       ::GlobalUnlock(hGlobal);<BR>
       // cache the data <BR>
       opOleDataSource-&gt;CacheGlobalData(CF_TEXT, hGlobal);<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF">
</FONT></PRE>
<P><B>Enabling a Control as a Clipboard Target</B> The opposite of being a Clipboard
source is being a Clipboard target. First you need to update the <TT>CMFCControlWinCtrl</TT><B>
</B>class to include two new helper functions (see Listing 7.19).
<H3><A NAME="Heading26"></A>Listing 7.19 MFCCONTROLWINCTL.H--Clipboard Target Support
Helper Function Prototypes</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
       void GetDataFromClipboard(void);<BR>
. . .<BR>
       BOOL GetDataFromTransfer(COleDataObject * opOleDataObject);<BR>
};<BR>
. . .</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>Getting data from the Clipboard is almost as simple as it is to put the data on
the Clipboard in the first place. <TT>GetDataFromClipboard</TT> uses the <TT>COleDataObject</TT>
MFC class to attach to the Clipboard and, if successful, passes the object to the
<TT>GetDataFromTransfer</TT> helper function (see Listing 7.20).
<H3><A NAME="Heading27"></A>Listing 7.20 MFCCONTROLWINCTL.CPP--GetDataFromClipboard
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::GetDataFromClipboard(void)<BR>
{<BR>
       // get a data object<BR>
       COleDataObject oOleDataObject;<BR>
       // attach it to the clipboard<BR>
       if(!oOleDataObject.AttachClipboard())<BR>
               return;<BR>
       // transfer the data to the control<BR>
       this-&gt;GetDataFromTransfer(&amp;oOleDataObject);<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><TT>GetDataFromTansfer</TT> enumerates all of the available formats in the <TT>COleDataObject</TT>
object using <TT>BeginEnumFormats</TT> (see Listing 7.21). To optimize the search
a little bit, you should first see whether the Clipboard even contains any data that
you can use. In this case, you are looking for the <TT>CF_TEXT</TT> format. The implementation
contains a simple <TT>while</TT> loop that will execute as many times as there are
formats in the <TT>COleDataObject</TT> object. When you locate a <TT>CF_TEXT</TT>
format, you retrieve its global memory object with the function <TT>GetGlobalData</TT>
and copy the data that it points to into the control. Do not destroy the data that
was retrieved with this method--you are not its owner; the <TT>COleDataObject</TT>
is.
<H3><A NAME="Heading28"></A>Listing 7.21 MFCCONTROLWINCTL.CPP--GetDataFromTransfer
Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CMFCControlWinCtrl::GetDataFromTransfer(COleDataObject
* opOleDataObject)<BR>
{    <BR>
       BOOL bReturn = FALSE;<BR>
       // prepare for an enumeration of the clipboard formats available<BR>
       opOleDataObject-&gt;BeginEnumFormats();<BR>
       // is there a text format available <BR>
       if(opOleDataObject-&gt;IsDataAvailable(CF_TEXT))<BR>
       {<BR>
               FORMATETC etc;<BR>
               // while there are formats to enumerate<BR>
               while(opOleDataObject-&gt;GetNextFormat(&amp;etc))<BR>
               {<BR>
                       // is this a format that we are looking for?<BR>
                       if(etc.cfFormat == CF_TEXT)<BR>
                       {<BR>
                              // get the global data for this format<BR>
                              HGLOBAL hGlobal = opOleDataObject-&gt;GetGlobalData
                                 (etc.cfFormat, &amp;etc);<BR>
                              // lock down the memory<BR>
                              LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock       
                          (hGlobal);<BR>
                              // store the data<BR>
                              m_cstrCaption = lpTempBuffer;<BR>
                              // call the global routine<BR>
                              this-&gt;FireChange();<BR>
                              // unlock the memory<BR>
                              ::GlobalUnlock(hGlobal);<BR>
                              // return success<BR>
                              bReturn = TRUE;<BR>
                         }<BR>
                 }<BR>
        }<BR>
       // if we found a format<BR>
       if(bReturn == TRUE)<BR>
               // force the control to repaint itself<BR>
               this-&gt;InvalidateControl(NULL);<BR>
       // return the result<BR>
       return bReturn;<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P><B>Custom Clipboard Formats</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>The
Clipboard is able to support custom formats, as well as built-in formats, defined
by the operating system. Fortunately, the implementation of custom formats for the
Clipboard is the same as for Drag and Drop. First you will learn how to support Drag
and Drop and then how to support custom formats.
<H3><A NAME="Heading29"></A>Drag and Drop Support</H3>
<P>The fundamentals of Drag and Drop support are very similar to Clipboard support
and rely on the same MFC classes, <TT>COleDataSource</TT> and <TT>COleDataObject</TT>,
for their implementation. Since you have broken your code into separate functions--that
is, the Clipboard specific code is isolated from the basic data transfer functions--most
of your implementation is complete. <B><BR>
<BR>
Using Built-In Drag and Drop Formats </B><SPACER TYPE="HORIZONTAL" SIZE="10">Since
Drag and Drop is essentially a Clipboard transfer, with fewer steps involved, Drag
and Drop uses the same built-in data formats as the Clipboard transfers do. See the
list of supported formats earlier in this chapter. As with Clipboard transfers, there
are two sides to the Drag and Drop coin. An application can be a Drag and Drop source
or a Drag and Drop target, or both.<BR>
<BR>
<B><I>Enabling a Control as a Drag and Drop Source</I></B><SPACER TYPE="HORIZONTAL"
SIZE="10"><B><I> </I></B>To qualify as a Drag and Drop source, your only implementation
requirements are that you create a <TT>COleDataSource</TT> object, call the method
<TT>DoDragDrop</TT>, and have some way of initiating the Drag and Drop operation
in the first place. In addition to the <TT>IDataObject</TT><B><I> </I></B>and <TT>IEnumFORMATETC</TT>
interfaces, the <TT>COleDataSource</TT> defines the <TT>IDropSource</TT> interface,
all of which are necessary for Drag and Drop source support. The first step is to
initiate a Drag and Drop operation. You are going to use the left mouse button down
event, provided by MFC, to initiate the Drag and Drop operation. Open the ClassWizard,
and select the Message Maps tab. Select the class <TT>CMFCControlWinCtrl</TT>, and
double-click the <TT>WM_LBUTTONDOWN</TT> message to add the <TT>OnLButtonDown</TT>
function (see fig. 7.3).</P>
<P>To open the source file and add your code, double-click the <TT>OnLButtonDown</TT>
function in the Member <U>f</U>unctions list box. <BR>
<BR>
<A HREF="art/07/w_fig03.jpg"><B>FIG. 7.3</B></A> <I><BR>
Add the <TT>WM_LBUTTONDOWN</TT> message map.</I></P>
<P>The <TT>OnLButtonDown</TT> implementation is similar to the Clipboard method <TT>CopyDataToClipboard</TT>
(see Listing 7.22). Again, you are using a <TT>COleDataSource</TT> object and loading
it with your data with the <TT>PrepareDataForTransfer</TT> call.</P>
<P>To actually initiate the Drag and Drop operation, you call <TT>DoDragDrop</TT>
specifying the constant <TT>DROPEFFECT_COPY</TT>, which indicates that this is a
copy operation. The constant <TT>DROPEFFECT_COPY</TT> is used for two purposes. The
first, and most obvious to the user, is that the mouse cursor will change to indicate
that a copy drag is in progress. The second is to inform the drop target as to the
intent of the drop operation.
<H3><A NAME="Heading30"></A>Listing 7.22 MFCCONTROLWINCTL.CPP--OnLButtonDown Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::OnLButtonDown(UINT nFlags,
CPoint point) <BR>
{<BR>
        COleDataSource oOleDataSource;<BR>
        // call the common data preparation function<BR>
        this-&gt;PrepareDataForTransfer(&amp;oOleDataSource);<BR>
        // start the Drag and Drop operation<BR>
        oOleDataSource.DoDragDrop(DROPEFFECT_COPY);<BR>
        // call the base class implementation<BR>
        COleControl::OnLButtonDown(nFlags, point);<BR>
}</TT></FONT>
<PRE><FONT COLOR="#0066FF"></FONT></PRE>
<P>Now that the control has been enabled as a Drag and Drop source, it only makes
sense to enable it as a Drag and Drop target. <B><I><BR>
<BR>
Enabling a Control as a Drop Target </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">To
qualify as a Drag and Drop target, a control must register itself as a Drag and Drop
target and must implement the <TT>IDropTarget</TT> interface. The MFC class <TT>COleDropTarget</TT>
provides the needed interface definition. However, it is not enough to rely on the
default implementation of the <TT>COleDropTarget</TT> class to enable the control
as a Drag and Drop target. You are required to inherit your own specialized version
of the class so that you can override some of its functions. Call the new class <TT>CMyOleDropTarget</TT>,
and add it to the <TT>CMFCControlWinCtl</TT> class (see Listing 7.23). You need to
overload the methods <TT>OnDragOver</TT> and <TT>OnDrop</TT> for your specific implemen-
tation as a drop target. Also added is a member variable of type <TT>CMyOleDropTarget</TT>
called <TT>oMyOleDropTarget</TT>.</P>
<P>The class <TT>CMyOleDropTarget</TT> needs to be a friend of the CMFCControlWinCtrl
class so that the <TT>CMyOleDropTarget</TT> class may call the general <TT>GetDataFromTransfer</TT>
function to store the data in the control.
<H3><A NAME="Heading31"></A>Listing 7.23 MFCCONTROLWINCTL.H--CMyOleDropTarget Class
Declaration Added to the CMFCControlWinCtl Class</H3>
<P><FONT COLOR="#0066FF"><TT>class CMyOleDropTarget: public COleDropTarget<BR>
{<BR>
public:<BR>
           CMFCControlWinCtrl * opMFCControlWinCtrl;<BR>
           DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD 
                   dwKeyState, CPoint point);<BR>
           BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT      
            dropEffect, CPoint point);<BR>
} oMyOleDropTarget;<BR>
friend CMyOleDropTarget;<BR>
</TT></FONT></P>

<P>As we stated earlier, an application must register itself with the operating system
in order to be a valid Drag and Drop target. Register the control as a Drag and Drop
target using the function, <TT>Register</TT>, in your <TT>OnCreate</TT> method for
the control. To add the <TT>OnCreate</TT> function to the class, you use the ClassWizard.
Open the ClassWizard, and select the Message Maps tab. Select the class <TT>CMFCControlWinCtrl</TT>,
and double-click the <TT>WM_CREATE</TT> message to add the <TT>OnCreate</TT> function
to your class (see fig. 7.4). <B><BR>
<BR>
</B><A HREF="art/07/w_fig04.jpg"><B>FIG. 7.4</B></A> <I><BR>
Add the WM_CREATE message map.</I></P>

<P>To add your code, open the source file by double-clicking the <TT>OnCreate</TT>
function in the Member <U>f</U>unctions list box.</P>

<P><TT>Register</TT> is the only call that is required to enable your control as
a drop target (see Listing 7.24). The member variable <TT>opMFCControlWinCtrl</TT>
is set with a reference to the control so you can call the general method <TT>GetDataFromTransfer</TT>
to put the data into your control; this is specific to your implementation and not
a requirement for Drag and Drop target support.
<H3><A NAME="Heading32"></A>Listing 7.24 MFCCONTROLWINCTL.CPP--OnCreate Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>int CMFCControlWinCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
<BR>
{<BR>
       if (COleControl::OnCreate(lpCreateStruct) == -1)<BR>
              return -1;<BR>
 <BR>
       // let's register ourselves as drop targets<BR>
       oMyOleDropTarget.Register(this);<BR>
       // store a reference to the control so we can communicate back to the    
        control<BR>
       oMyOleDropTarget.opMFCControlWinCtrl = this;<BR>
 <BR>
       return 0;<BR>
}<BR>
</TT></FONT></P>

<P>The <TT>OnDragOver</TT> function is used to instruct Windows that your control
is a valid or invalid drop target for the current drag operation (see Listing 7.25).
The implementation of <TT>OnDragOver</TT> first looks to see whether the mouse button
is being held down. If it is, <TT>OnDragOver</TT> then looks for the availability
of the CF_TEXT format. If it finds the <TT>CF_TEXT</TT> format, the <TT>OnDragOver</TT>
function returns the constant <TT>DROPEFFECT_COPY</TT>, indicating to Windows that
the control is a valid drop target for the particular drop operation that is currently
in effect. Otherwise, <TT>OnDragOver</TT> returns <TT>DROPEFFECT_NONE</TT>, indicating
that a drop should not be allowed.
<H3><A NAME="Heading33"></A>Listing 7.25 MFCCONTROLWINCTL.CPP--OnDragOver Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>DROPEFFECT CMFCControlWinCtrl::CMyOleDropTarget::OnDragOver(CWnd*
pWnd,        <BR>
COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)<BR>
{<BR>
       // if the left mouse button is being held down<BR>
       if(dwKeyState | MK_LBUTTON)<BR>
       {<BR>
           // is there a text format available<BR>
           if(pDataObject-&gt;IsDataAvailable(CF_TEXT))<BR>
                   return DROPEFFECT_COPY;<BR>
           // everything else we can't deal with<BR>
           else<BR>
                   return DROPEFFECT_NONE;<BR>
    }<BR>
    else<BR>
           // not the left mouse<BR>
           return DROPEFFECT_NONE;<BR>
}<BR>
<BR>
</TT></FONT></P>

<P><TT>OnDrop</TT> is where you call <TT>GetDataFromTransfer</TT>, the same function
that you created for your Clipboard operations, to copy the data from the drop source
into your control (see Listing 7.26).
<H3><A NAME="Heading34"></A>Listing 7.26 MFCCONTROLWINCTL.CPP--OnDrop Implementation</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CMFCControlWinCtrl::CMyOleDropTarget::OnDrop(CWnd*
pWnd, COleDataObject*        pDataObject, DROPEFFECT dropEffect, CPoint point)<BR>
{<BR>
          // transfer the data to the control<BR>
          return opMFCControlWinCtrl-&gt;GetDataFromTransfer(pDataObject);<BR>
}<BR>
<BR>
</TT></FONT></P>

<P><B>Custom Drag and Drop Formats</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>Like
the Clipboard, Drag and Drop can also support custom data transfer formats. The next
section will examine in detail how to modify your existing code to support custom
data formats for Clipboard and Drag and Drop operations, both with only a single
code change to the source and target data transfer operations.
<H3><A NAME="Heading35"></A>Custom Clipboard and Drag and Drop Formats</H3>
<P>Custom Clipboard and Drag and Drop formats are a way for applications to trade
information on a more intimate basis. The data transferred can be of any type and
structure that the applications can create and use. When using custom Clipboard formats,
all applications that will use the format must first call <TT>RegisterClipboardFormat</TT>
passing in the name of the format.</P>
<P>Before you add the code to register your custom format, add a member variable,
<TT>m_uiCustomFormat</TT>, to your class definition (see Listing 7.27). You will
use the value that this member variable holds later in your implementation to determine
whether a valid format has been registered.
<H3><A NAME="Heading36"></A>Listing 7.27 MFCCONTROLWINCTL.H--m_uiCustomFormat Member
Variable Added to the CMFCControlWinCtrl Class</H3>
<P><FONT COLOR="#0066FF"><TT>. . .<BR>
       // custom format storage variable<BR>
       UINT m_uiCustomFormat;<BR>
};<BR>
<BR>
</TT></FONT></P>

<P>Now add the custom format registration code to the constructor of the class <TT>CMFCControlWinCtrl</TT>
(see Listing 7.28).</P>

<P>The <TT>RegisterClipboardFormat</TT> function, if it succeeds, will return the
ID of the newly registered or already existing (in the case where the format is already
registered) custom Clipboard format. It is important that all applications that are
going to use the custom format call this method.
<H3><A NAME="Heading37"></A>Listing 7.28 MFCCONTROLWINCTL.CPP--Custom Clipboard Format
Registered in the CMFCControlWinCtrl Constructor</H3>
<P><FONT COLOR="#0066FF"><TT>CMFCControlWinCtrl::CMFCControlWinCtrl()<BR>
{<BR>
        InitializeIIDs(&amp;IID_DMFCControlWin, &amp;IID_DMFCControlWinEvents);<BR>
        // TODO: Call InternalSetReadyState when the readystate changes.<BR>
        m_lReadyState = READYSTATE_LOADING;<BR>
        // set the alignment to the default of left<BR>
        m_lAlignment = EALIGN_LEFT;<BR>
        // don't forget this - DoPropExchange won't work without it<BR>
        oMyDataPath.SetControl(this);<BR>
        // register a custom clipboard format<BR>
        m_uiCustomFormat =                     <BR>
::RegisterClipboardFormat(_T(&quot;MFCControlWinCustomFormat&quot;));<BR>
}<BR>
</TT></FONT></P>

<P>After the custom format has been registered, it is a simple matter to add the
code to your implementation that stores or retrieves the data from the <TT>COleDataSource</TT>
and <TT>COleDataObject</TT> objects. Using the code that was created for your standard
data transfers as a base, you will now add the custom data transfer code.</P>

<P><TT>PrepareDataForTransfer</TT> (see Listing 7.29) differs only slightly from
its original implementation. For the custom data transfer, you are going to send
the <TT>m_lAlignment</TT> value in addition to the caption. You can use any data
type or structure, including user-defined data types, for your custom format. The
only requirement is that both the source and the target applications understand the
format being transferred.
<H3><A NAME="Heading38"></A>Listing 7.29 MFCCONTROLWINCTL.CPP--PrepareDataForTransfer
Function Updated to Support Custom Clipboard Formats</H3>
<P><FONT COLOR="#0066FF"><TT>void CMFCControlWinCtrl::PrepareDataForTransfer(COleDataSource
*       <BR>
opOleDataSource)<BR>
{<BR>
       // get the length of the data to copy<BR>
       long lLength = m_cstrCaption.GetLength() + 1;<BR>
       // create a global memory object<BR>
       HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, sizeof(TCHAR)
           * lLength);<BR>
     <BR>
       // lock the memory down<BR>
       LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(hGlobal);<BR>
       // copy the string<BR>
       for(long lCount = 0; lCount &lt; lLength - 1; lCount++)<BR>
              lpTempBuffer[lCount] = m_cstrCaption.GetAt(lCount);<BR>
       // null terminate the string<BR>
       lpTempBuffer[lCount] = `\0';<BR>
       // unlock the memory<BR>
       ::GlobalUnlock(hGlobal);<BR>
      // cache the data <BR>
       opOleDataSource-&gt;CacheGlobalData(CF_TEXT, hGlobal);<BR>
       // if we have custom clipboard format support<BR>
       if(m_uiCustomFormat)<BR>
       {<BR>
              // create a global memory object<BR>
              HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,       
           sizeof(m_lAlignment));<BR>
           <BR>
             // lock the memory down<BR>
              LONG * lpTempBuffer = (LONG *) ::GlobalLock(hGlobal);<BR>
              // set our data buffer<BR>
              *lpTempBuffer = m_lAlignment;<BR>
              // unlock the memory<BR>
              ::GlobalUnlock(hGlobal);<BR>
              // cache the data <BR>
              opOleDataSource-&gt;CacheGlobalData(m_uiCustomFormat, hGlobal);<BR>
       }<BR>
}<BR>
<BR>
</TT></FONT></P>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Any number of data formats can be transferred at one time for a single
	data source object. It is up to the receiving application to deal with this possibility
	and retrieve the data correctly. The MFC implementation of the <TT>COleDataSource</TT>
	class does not allow duplicate formats to be available in the same object, but that's
	not to say that this can't happen. Non-MFC applications have complete freedom to
	implement data sources any way they see fit. Remember yours may not be the only data
	being transferred.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
The <TT>GetDataFromTransfer</TT> implementation is almost identical to your original
implementation (see Listing 7.30). The only difference is that the function now looks
for the custom format as well as the <TT>CF_TEXT</TT> format.
<H3><A NAME="Heading39"></A>Listing 7.30 MFCCONTROLWINCTL.CPP--GetDataFromTransfer
Function Updated to Support Custom Clipboard Formats</H3>
<P><FONT COLOR="#0066FF"><TT>BOOL CMFCControlWinCtrl::GetDataFromTransfer(COleDataObject
* opOleDataObject)<BR>
{    <BR>
        BOOL bReturn = FALSE;<BR>
        // prepare for an enumeration of the clipboard formats available<BR>
        opOleDataObject-&gt;BeginEnumFormats();<BR>
        // is there a text format available <BR>
        // &amp;&amp; there is no custom format <BR>
        // || there is a custom format and the format is available<BR>
        if(opOleDataObject-&gt;IsDataAvailable(CF_TEXT) &amp;&amp; (!m_uiCustomFormat
||               (m_uiCustomFormat &amp;&amp; opOleDataObject-&gt;IsDataAvailable
           (m_uiCustomFormat))))<BR>
        {<BR>
                FORMATETC etc;<BR>
                // while there are formats to enumerate<BR>
                while(opOleDataObject-&gt;GetNextFormat(&amp;etc))<BR>
                {<BR>
                        // is this a format that we are looking for?<BR>
                        if(etc.cfFormat == CF_TEXT)<BR>
                        {<BR>
                                // get the global data for this format<BR>
                                HGLOBAL hGlobal = opOleDataObject-&gt;GetGlobalData
                                   (etc.cfFormat, &amp;etc);<BR>
                                // lock down the memory<BR>
                                LPTSTR lpTempBuffer = (LPTSTR) ::GlobalLock(hGlobal);<BR>
                                // store the data<BR>
                                m_cstrCaption = lpTempBuffer;<BR>
                                // call the global routine<BR>
                                this-&gt;FireChange();<BR>
                                // unlock the memory<BR>
                                ::GlobalUnlock(hGlobal);<BR>
                                // return success<BR>
                                bReturn = TRUE;<BR>
                        }<BR>
                        // if we have custom clipboard format support<BR>
                         else if(m_uiCustomFormat &amp;&amp; etc.cfFormat == m_uiCustomFormat)<BR>
                        {<BR>
                                // get the global data for this format<BR>
                                HGLOBAL hGlobal = opOleDataObject-&gt;GetGlobalData
                                   (etc.cfFormat, &amp;etc);<BR>
         <BR>
                                // lock the memory down<BR>
                                LONG * lpTempBuffer = (LONG *) ::GlobalLock(hGlobal);<BR>
                                // get the data from our data buffer<BR>
                                m_lAlignment = *lpTempBuffer;<BR>
                                // unlock the memory<BR>
                                ::GlobalUnlock(hGlobal);<BR>
                                // return success<BR>
                                bReturn = TRUE;<BR>
                        }<BR>
                }<BR>
        }<BR>
        // if we found a format<BR>
        if(bReturn == TRUE)<BR>
                // force the control to repaint itself<BR>
                this-&gt;InvalidateControl(NULL);<BR>
        // return the result<BR>
        return bReturn;<BR>
}</TT></FONT></P>

<P>Because both the Clipboard support and the Drag and Drop support rely on the same
data transfer routines to exchange data, you have the added benefit of supporting
the custom data formats for each, while having to maintain only two functions, instead
of four.
<H2><A NAME="Heading40"></A>Subclassing Existing Windows Controls</H2>
<P>Since the early days of Windows programming, programmers have enjoyed the option
of using the default behavior of existing Windows controls and extending them slightly
to create new and more powerful controls. This technique of creating Windows controls
is referred to as subclassing (and there is also superclassing, depending on the
technique you use). The same is still true for ActiveX controls.</P>
<P>When you created the original application code with the MFC AppWizard, you created
a total of three controls. One of those controls, <TT>CMFCControlSubWin</TT>, subclassed
a Windows <TT>BUTTON </TT>control.</P>
<P>Listing 7.31 contains all of the additional code that is required of an ActiveX
control to subclass a control, which, by the way, was generated for you automatically
by the MFC AppWizard when you created the project.
<H3><A NAME="Heading41"></A>Listing 7.31 MFCCONTROLSUBWINCTL.CPP--Additional Code
Requirements for ActiveX Controls that Subclass Existing Windows Controls</H3>
<P><FONT COLOR="#0066FF"><TT>/////////////////////////////////////////////////////////////////////////////<BR>
<BR>
// CMFCControlSubWinCtrl::OnDraw - Drawing function<BR>
void CMFCControlSubWinCtrl::OnDraw(<BR>
                      CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)<BR>
{<BR>
       DoSuperclassPaint(pdc, rcBounds);<BR>
}<BR>
. . .<BR>
/////////////////////////////////////////////////////////////////////////////<BR>
// CMFCControlSubWinCtrl::PreCreateWindow - Modify parameters for CreateWindowEx<BR>
BOOL CMFCControlSubWinCtrl::PreCreateWindow(CREATESTRUCT&amp; cs)<BR>
{<BR>
     cs.lpszClass = _T(&quot;BUTTON&quot;);<BR>
     return COleControl::PreCreateWindow(cs);<BR>
}<BR>
/////////////////////////////////////////////////////////////////////////////<BR>
// CMFCControlSubWinCtrl::IsSubclassedControl - This is a subclassed control<BR>
BOOL CMFCControlSubWinCtrl::IsSubclassedControl()<BR>
{<BR>
     return TRUE;<BR>
}<BR>
/////////////////////////////////////////////////////////////////////////////<BR>
// CMFCControlSubWinCtrl::OnOcmCommand - Handle command messages<BR>
LRESULT CMFCControlSubWinCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)<BR>
{<BR>
#ifdef _WIN32<BR>
     WORD wNotifyCode = HIWORD(wParam);<BR>
#else<BR>
     WORD wNotifyCode = HIWORD(lParam);<BR>
#endif<BR>
     // TODO: Switch on wNotifyCode here.<BR>
     return 0;<BR>
}<BR>
</TT></FONT></P>

<P><TT>OnDraw</TT> is where you call <TT>DoSuperClassPaint</TT> to instruct the subclassed
control to paint itself. Calling <TT>DoSuperClassPaint</TT> will work only for those
controls that accept a device context handle (<TT>HDC</TT>) as the <TT>WPARAM</TT>
of their <TT>WM_PAINT</TT> message.</P>

<P><TT>PreCreateWindow</TT> is where the most important action of the whole subclassing
process occurs; you identify, by name, the control to subclass. The name used can
be any valid Windows control, including user-defined controls. As long as the control
is a registered, valid Windows control, you can subclass it.</P>

<P>It's pretty obvious what <TT>IsSubclassedControl</TT> is used for. MFC queries
the function to determine whether it subclasses a Windows control.</P>

<P><TT>OnOcmCommand</TT> is where you get all of your reflected windows messages.
Within this function, you can respond to messages like button clicks and edit change
notifications.</P>

<P>Microsoft has created sample code and plenty of documentation regarding control
subclassing, so we won't get into any implementation details here. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>NOTE:</B> Note that a subclassed control may not behave exactly as its original
	implementation does. In the case of subclassing a list box, the font that the control
	uses may not match that of the container. Getting the subclassed list box to use
	the correct font can be a little difficult and may require sending messages directly
	to the subclassed window rather than allowing the MFC base implementation to define
	the font. <BR>
	<BR>
	Subclassing an existing control is a risky proposition at best. The implementation
	of the particular Windows control you are subclassing may make it difficult, if not
	impossible, to subclass from within the confines of the MFC control framework. The
	concept of multiple windows' handles within a single control is one area where subclassing
	using MFC will come up short. It may be very difficult to reliably retrieve the secondary
	window handles of the control if the original implementation does not provide access
	to its child windows. <BR>
	<BR>
	Also, some of the ActiveX features detailed in this chapter may not be appropriate
	or possible because you are simply wrapping an existing window's control. Creating
	a windowless control is impossible because you are depending on the window's control
	for the implementation.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0">
<H2><A NAME="Heading42"></A>Dual-Interface Controls</H2>
<P>At this time, none of the control containers can, or will, take advantage of dual-interfaces
implemented in a control, but that is not to say that they won't in the future. The
addition of dual-interface support to your control is exactly the same as adding
dual-interface to ActiveX Automation Servers. It will add only a little more code
to your application and should result in significant performance improvement for
the control if and when containers are built to support dual-interface.</P>
<P>Microsoft strongly suggests that controls be created with dual-interface support,
in spite of the fact that, at the time of the writing of this book, none of Microsoft's
containers can use them.
<H2><A NAME="Heading43"></A>Other ActiveX Features</H2>
<P>Finally, the section that you all have been waiting for: Advanced ActiveX features.
Don't stand up and jump just yet. Most of the features require little code, if any
at all, and really aren't intended for anything more than trimming a few more precious
milliseconds from your load times and runtimes.</P>
<P>When the AppWizard creates the basic source files for your control, it adds a
member function <TT>GetControlFlags</TT> to your class header and source files. <TT>GetControlFlags</TT>
is where the control informs MFC about the kind of ActiveX support it has by returning
a set of flags. The documentation for <TT>GetControlFlags</TT> lists all of the valid
flags that can be returned from this function, thereby indicating the control's level
of ActiveX support.</P>
<P>You covered the features, optimized drawing and asynchronous properties, earlier
in the chapter. Now take a look at the implementation specifics for the rest of the
features.
<H3><A NAME="Heading44"></A>Windowless Activation</H3>
<P>Setting this flag will allow a control to be created without the burden of creating
a window, significantly improving the control's start-up time.</P>
<P>The implementation of windowless controls versus windowed controls, for the most
part, will remain unchanged since most of the windowless details are hidden from
the control programmer.</P>
<P>For your own implementation of the <TT>CMFCControlWinCtrl</TT> class, nothing
that you did in your implementation would prevent you from using this feature. The
main restriction when writing a windowless control is that you cannot access the
window handle directly without first checking to see whether it is valid. If your
control implementation never uses the window handle, you should be fine.</P>
<P>To prove the point regarding the implementation of windowed and windowless controls,
the <TT>CMFCControlNoWin</TT> class's implementation of <TT>OnDraw</TT> contains
the same code as your windowed implementation.</P>
<P>One thing to note though is that the container is the deciding factor when it
comes to windowed versus windowless support. A window will be created for the control
automatically if the container does not have windowless support. This is a requirement
for <I>all </I>controls, regardless of the tool used to create them.</P>
<P>See the VC++ books online article &quot;OLE Controls: Optimization&quot; for the
specific implementation details regarding message maps and routing for windowless
controls.
<H3><A NAME="Heading46"></A>Flicker-Free Activation</H3>
<P>Flicker-free activation simply says that the control will not receive a notification
to draw its UI when it transitions between an active and inactive state, and vice
versa. The only requirement of a control with this feature is that the control's
UI remains the same regardless of the state of the control.
<H3><A NAME="Heading47"></A>Unclipped Device Context</H3>
<P>Unclipped device context is a commitment more than a feature. When this flag is
set, the control is telling the container that it will not draw outside of its client
area. Setting the unclipped device context flag will improve performance by eliminating
unnecessary clipping tests. Unclipped device context cannot be used with the windowless
controls.
<H3><A NAME="Heading48"></A>Mouse Pointer Notifications When Inactive</H3>
<P>Mouse pointer notifications when inactive allows the control to receive mouse
notification messages, even though the window may not be active. Mouse pointer notifications
when inactive is used for those users who turned off the feature &quot;Activate when
visible&quot; when first creating their control project with the AppWizard.</P>
<P>The only special circumstance to be concerned with is the case of Drag and Drop
operations, which require an activated window. The programmer of the control must
override the control's <TT>GetActivationPolicy</TT> function to instruct the container
how to activate the control when it becomes the target of a Drag and Drop operation.</P>
<P>See the VC++ books online article &quot;OLE Controls: Optimization&quot; for the
specific implementation details regarding this feature.
<H2><A NAME="Heading49"></A>From Here...</H2>
<P>In this chapter, we demonstrated fairly simple techniques for creating unique
and interesting controls and control features. We built upon simple concepts and
methods that, in turn, resulted in a control that is far greater than the sum of
its parts. A little bit of work and forethought can go a long way when using MFC.</P>
<P>MFC provides a large and robust framework for creating ActiveX controls. The ease
of use and support provided by the AppWizard, ClassWizard, and the VC++ IDE make
MFC unbeatable for rapid control development. Unfortunately, those very same features
and functionality make MFC a hard choice when building small, fast controls for use
over the Internet or in applications where performance is an issue. DLL load times
and unnecessary code overhead can make MFC unreasonable to use for simple, lightweight
controls. On the other hand, MFC hides a large number of the details surrounding
control implementation and leaves you free to focus on the control and its specific
implementation details. All of these things must be considered when choosing MFC
as a control development framework.</P>

<P>The next four chapters examine in detail how to create a similar control implementation
using ATL and BaseCtl.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
