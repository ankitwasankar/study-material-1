<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!--last modified on Thu, Apr 10, 1997 4:25 PM-->
<HTML>

<HEAD>
<!-- This document was created from RTF source by rtftohtml version 3.0.1 -->

	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0">
	<META NAME="Author" Content="Steph Mineart">
	
	<title>ActiveX Programming with Visual C++ -- Chapter 2</TITLE>
</HEAD>
<MAP NAME="leftnav">
<AREA SHAPE=RECT COORDS="2,2,111,33" HREF="/reference/dir.programminglanguages.html">
<AREA SHAPE=RECT COORDS="3,35,111,63" HREF="/reference/dir.databases.html">
<AREA SHAPE=RECT COORDS="1,62,111,95" HREF="/reference/dir.security1.html">
<AREA SHAPE=RECT COORDS="0,94,111,125" HREF="/reference/dir.webservices.html">
<AREA SHAPE=RECT COORDS="1,127,111,156" HREF="/reference/dir.networkservices1.html">
<AREA SHAPE=RECT COORDS="2,157,111,185" HREF="/reference/dir.middleware.html">
<AREA SHAPE=RECT COORDS="2,185,111,217" HREF="/reference/dir.components.html">
<AREA SHAPE=RECT COORDS="2,218,111,248" HREF="/reference/dir.operatingsystems.html">
<AREA SHAPE=RECT COORDS="2,247,111,277" HREF="/reference/dir.userinterfaces.html">
<AREA SHAPE=RECT COORDS="2,278,111,307" HREF="/reference/dir.groupwareandcollaboration1.html">
<AREA SHAPE=RECT COORDS="2,307,111,339" HREF="/reference/dir.contentmanagement.html">
<AREA SHAPE=RECT COORDS="2,338,111,370" HREF="/reference/dir.funandgames1.html">
<AREA SHAPE=RECT COORDS="0,369,111,404" HREF="/reference/dir.hardware1.html">
</MAP>

<MAP NAME="othersites">
<AREA SHAPE=RECT COORDS="1,1,116,13" HREF="http://www.developer.com/">
<AREA SHAPE=RECT COORDS="1,13,116,26" HREF="http://www.earthwebdirect.com/">
<AREA SHAPE=RECT COORDS="1,26,116,39" HREF="http://www.htmlgoodies.com/">
<AREA SHAPE=RECT COORDS="1,39,116,53" HREF="http://www.javagoodies.com/">
<AREA SHAPE=RECT COORDS="1,53,116,65" HREF="http://www.jars.com/">
<AREA SHAPE=RECT COORDS="1,65,116,77" HREF="http://www.intranetjournal.com/">
<AREA SHAPE=RECT COORDS="1,77,116,92" HREF="http://www.itlibrary.com/">
<AREA SHAPE=RECT COORDS="1,92,116,105" HREF="http://www.javascripts.com/">
<AREA SHAPE=RECT COORDS="1,105,116,118" HREF="http://www.datamation.com/">
<AREA SHAPE=RECT COORDS="0,118,116,130" HREF="http://www.gamelan.com/">
<AREA SHAPE=RECT COORDS="0,130,116,142" HREF="http://www.roadcoders.com/">
<AREA SHAPE=RECT COORDS="0,142,116,156" HREF="http://www.itknowledge.com/">
<AREA SHAPE=RECT COORDS="0,155,116,167" HREF="http://www.y2kinfo.com/">
</MAP>

<BODY BACKGROUND="/images/curve_itlibrary_white.gif" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#DD0000" VLINK="#999999" ALINK="#FF0000">

<!--Begin Header Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>
<TD VALIGN="TOP" WIDTH="640" COLSPAN="3">
<A HREF="http://www.earthweb.com" target="resource window"><IMG SRC="/images/eweb_banner.gif" VSPACE="6" WIDTH="640" HEIGHT="25" ALT="Brought to you by EarthWeb" border="0"><BR></a>
</TD>
</TR>
<TR>
<TD VALIGN="TOP" WIDTH="150">

<A HREF="/"><IMG SRC="/images/small_logo.gif" WIDTH=103 HEIGHT=82 ALT="IT Library Logo" border="0"></a>
<P>
<!--Begin Subscribe Box Table -->
<TABLE border="0" cellpadding="0" cellspacing="0" WIDTH="100">
<TR>
<TD>

</TD>
</TR>
</TABLE>
<!--End Subscribe Box Table -->


</td>
<TD>
<img src="/images/dotclear.gif" WIDTH="15" HEIGHT="1">
</TD>
<TD>

<!--  Begin Ads ITLBAN //-->

<SCRIPT LANGUAGE="JavaScript">
<!-- Hide from old browsers

now = new Date();
random = now.getTime();

// Modify to reflect site specifics
site = "http://diradserver.developer.com";
target = "/AREA=ITLBAN";
//target = "/AREA=ITLBAN"; //Testing
browser = browserCheck();

if(browser == "NAV") {
 document.write(layerCode());
} else if (browser == "IE") {
 document.write(frameCode());
} else if (browser == "OTHER") {
 document.write(htmlCode());
}

//returns string - browser ID -- either NAV . IE . OTHER
function browserCheck() {
 var out = "";
 if (navigator.appName.indexOf('Netscape') != -1) {     //browser is netscape
  //checking version numbers
  if(navigator.appVersion.substring(0,4) >= "4.02") {
   out = "OTHER";
  } else {
   out = "OTHER";
  }
 } else if (navigator.appName.indexOf('Microsoft') != -1) {    //browser is Explorer
  out = "OTHER";
 } else {
  out = "OTHER";
 }
 return out;
}

//returns a string - layer code for nav 4.05
function layerCode() {
 var out = '<ILAYER SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' VISIBILITY=show WIDTH=500 HEIGHT=60 BGCOLOR="#ffffff"></ILAYER>';
 return out;
}

//returns a string - frame code for ie 4.05
function frameCode() {
 var out = '<IFRAME SRC="' + site + '/hserver' + target + '?' + random + '"';
 out = out + ' NORESIZE SCROLLING=NO HSPACE=0 VSPACE=0 FRAMEBORDER=0 MARGINHEIGHT=0 MARGINWIDTH=0 WIDTH=500 HEIGHT=60></IFRAME>';
 return out;
}

//returns a string - html code for non capable browsers
function htmlCode() {
 var out = '<A target="new win" HREF="' + site + '/accipiter/adclick.exe' + target + '?' + random + '">';
 out = out + '<IMG SRC="' + site + '/accipiter/adserver.exe' + target + '?' + random + '"><BR><CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>';
 return out;
}

// End Hide -->
</SCRIPT>
<NOSCRIPT>
<A target="new win"  HREF="http://diradserver.developer.com/accipiter/adclick.exe/AREA=ITLBAN">
<IMG SRC="http://diradserver.developer.com/accipiter/adserver.exe/AREA=ITLBAN" WIDTH=500 HEIGHT=60><BR>
<CENTER><FONT SIZE="-2">Click here to visit our sponsor</FONT></CENTER></A>
</NOSCRIPT>

<!-- ITLBAN End Ads //-->


</td>
</TR>
</TABLE>

<!--End Header Table -->

<!--Begin Main Table -->

<TABLE width="640" cellpadding="0" cellspacing="0" border="0">
<TR>

<!--Begin Left Navigation column -->

<TD VALIGN="TOP" WIDTH="140">
<FORM action="/subscribe/list.cgi" method="post">

<INPUT name='email' value='your e-mail' size="11"><INPUT type='hidden'  name='state' value='Subscribe'><br><INPUT type='image' value='subscribe' img src='/images/subscribe.gif' border='0' vspace='3' ></center>

</form>

<IMG SRC="/images/leftnav.gif" WIDTH=111 HEIGHT=404 ALT="nav" border="0"  ISMAP USEMAP="#leftnav">
<p>
<a href="http://www.earthwebdirect.com/"><IMG SRC="/images/earthwebdirect.gif" WIDTH=126 HEIGHT=30 ALT="EarthWeb Direct" border="0"></a>
<P>
<font color="ffffff" face="arial, helvetica" size="2">EarthWeb sites:</FONT>
<IMG SRC="/images/sitelisting.gif" WIDTH="102" HEIGHT="167" ALT="other sites" border="0" USEMAP="#othersites" ismap>
</td>

<!--End Left Navigation column -->
<!-- spacer column  -->

<TD width="40">
<img src="/images/dotclear.gif" WIDTH="40" HEIGHT="1" border=0>
</TD>

<!--Begin Content Column -->

<TD VALIGN="TOP" width="500">

<P>



<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1>Chapter 2<BR>
What Can ActiveX Do for You?</H1>

<UL>
	<LI><A HREF="#Heading1">What Can ActiveX Do for You?</A>
	<UL>
		<LI><A HREF="#Heading2">Defining the Needs and Requirements of Your Application</A>
		<LI><A HREF="#Heading3">What Type of ActiveX Component Do You Need?</A>
		<UL>
			<LI><A HREF="#Heading4">Automation Servers and Controllers</A>
			<LI><A HREF="#Heading5">ActiveX Controls</A>
			<LI><A HREF="#Heading6">COM Objects</A>
		</UL>
		<LI><A HREF="#Heading7">Selecting the Right Tool for the Right Job</A>
		<UL>
			<LI><A HREF="#Heading8">Microsoft Foundation Classes</A>
			<LI><A HREF="#Heading9">ActiveX Template Library</A>
			<LI><A HREF="#Heading10">BaseControl Framework</A>
			<LI><A HREF="#Heading11">Create Your Own Framework</A>
		</UL>
		<LI><A HREF="#Heading12">Basic ActiveX Component Architecture</A>
		<UL>
			<LI><A HREF="#Heading13">ActiveX Automation Servers</A>
			<LI><A HREF="#Heading14">ActiveX Controls</A>
		</UL>
		<LI><A HREF="#Heading15">Support Tools Needed for Building ActiveX Components</A>
		<UL>
			<LI><A HREF="#Heading16">MIDL Compiler</A>
			<LI><A HREF="#Heading17">Mktyplib</A>
			<LI><A HREF="#Heading18">GUIDGEN</A>
			<LI><A HREF="#Heading19">RegEdit</A>
			<LI><A HREF="#Heading20">Registration Server</A>
			<LI><A HREF="#Heading21">Ole2View</A>
			<LI><A HREF="#Heading22">Adding the Tools to the Visual C++ Development Environment</A>
		</UL>
		<LI><A HREF="#Heading23">From Here...</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H1><A NAME="Heading1"></A>What Can ActiveX Do for You?</H1>
<P>

<UL>
	<LI><B>Application requirements</B>
<SPACER TYPE="VERTICAL" SIZE="2">
It is important to understand as many of the requirements as possible before starting
	your development project.
	<P>
	<LI><B>Choosing the correct architecture and component type</B>
<SPACER TYPE="VERTICAL" SIZE="2">
The various ways in which ActiveX components can be created are crucial to a successful
	project. You don't want to do too much or too little.
	<P>
	<LI><B>Choosing the correct tool</B>
<SPACER TYPE="VERTICAL" SIZE="2">
The tool used to develop your component also affects the success of the project.
	Picking the right tool for the job is as important as is understanding the job itself.
	<P>
	<LI><B>Basic ActiveX component architecture</B>
<SPACER TYPE="VERTICAL" SIZE="2">
Each ActiveX Component type has its particular architecture and construction. Understanding
	this architecture is important.
	<P>
	<LI><B>Basic ActiveX support tools</B>
<SPACER TYPE="VERTICAL" SIZE="2">
You will find a collection of development support to tools that are invaluable to
	your ActiveX development.
</UL>

<P>Gone are the days of hacking together simple stand-alone applications that had
all the interoperability of two semi-trailer trucks screaming toward each other at
100 miles an hour. With the advent of OLE (Object Linking and Embedding) and more
recently ActiveX and the Internet, applications are expected to be flexible, modifiable,
and extendible (with &quot;clairvoyant&quot; running a close fourth).</P>

<P>Spending a little time up front working out the design and architecture of your
application can and will make all the difference in the world. Almost any application
worth its salt has resulted from some forethought, regardless of whether that information
is crammed into the head of one of your developers, scribbled on restaurant napkins,
or written in formal documentation. I recommend the latter two since removing your
developer's head to take to a strategy meeting is probably not an option.</P>
<P>The basic principles of OLE and ActiveX are going to determine most of the specific
component architecture and design. For example, ActiveX Controls and Documents are
developed within a specific set of parameters and rules so that they will interact
with Containers correctly. Automation Servers and Controllers have to conform to
OLE Automation rules. And COM Objects have to support the basic fundamentals of COM.
But what about component relationships and lifetimes? What about access to interfaces
and support for security? What if your component is going to be utilized by users
who speak another language?
<H2><A NAME="Heading2"></A>Defining the Needs and Requirements of Your Application</H2>
<P>A specification is important to establish the basic requirements of the component
you are asked to create. Before you can proceed, you must have a clear understanding
of what kind of component or application is needed and why you are creating it. Appropriate
questions to ask are, &quot;What created the need for the component, and how is it
going to be used?&quot; If the person or persons can't describe the problem, they
probably don't understand the problem. The last thing anyone needs is an incomplete
picture of the problem, which tends to create delays and promote last minute changes
that can cause unexpected results. Try to get as much of the specification as possible
on paper.</P>
<P>After you determine the need, you can move on to designing the component. Again,
it is critical to get as much information as possible. Does the problem require a
single component or multiple components? Do the components need the capability to
interact together? And, if so, is speed an issue? What about the skill level of your
developers? How are they able to cope with change or possibly new and unfamiliar
development methods? What are the support and maintenance requirements?</P>
<P>What is the problem? And what is going to be the solution? Take for example the
need for creating in-house purchase requests. Is it simple enough to say, &quot;We
will create an ActiveX Document and use our Web browsers to interact with the Document&quot;?
Probably not. What about e-mail integration? What about training for how to use the
Web browser and the purchase request application? What if the purchase request application
must integrate with a legacy application in-house? What if the development tool that
you normally use can't create ActiveX Documents? What if there aren't any developers
on staff who can handle the effort? Most of these issues can be boiled down to a
single question, &quot;What is the level of effort versus the amount of gain?&quot;
That is, is it worthwhile to pursue a development project that is difficult to understand,
implement, and maintain? Or is it worthwhile to use a simpler approach and live with
its limitations?</P>
<P>All these issues and more will affect the kind of component you create and how
you will develop it. As a developer of ActiveX components, it is your responsibility
to know the answers to these questions. You have the specific domain knowledge, that
is, the capabilities and limitations of yourself and the tools that you use. This
book will hopefully aid you in making the correct choices when choosing and implementing
a development plan.
<H2><A NAME="Heading3"></A>What Type of ActiveX Component Do You Need?</H2>
<P>The first thing you must decide is what kind of component best fits your requirements.
<H3><A NAME="Heading4"></A>Automation Servers and Controllers</H3>
<P>Automation Servers and Controllers probably have the greatest amount of flexibility.
The Servers' <TT>IDispatch</TT> interface can be used from just about every major
application available from Microsoft and hundreds of other manufacturers. Because
it won't suffer from the same versioning requirements placed on strict COM interfaces,
the interface also lends itself well to prototyping and modeling component interactions.</P>
<P>A dual-interface Automation Server created in-process is the fastest type of Automation
Server. Dual-interface refers to the fact that a Server contains two interfaces one
based on <TT>IDispatch</TT> and the other based on COM. The COM interface is actually
the fastest of the two. An in- process Server means that the application resides
in the same memory address space as the application that created it. This allows
the invocation of methods defined within the Server to be performed significantly
faster because there is no burden of having to cross process boundaries every time
a method is called. For the same reason, Server load times are fast because of the
minimal number of steps involved in creating the Server and getting its <TT>IDispatch</TT>
or COM interface pointer.</P>
<P>Nothing inherent to Automation architecture promotes the use of User Interface
(UI), and nothing prevents its use either. You have complete freedom and control
over how the Servers are implemented and used. Your Automation Servers could potentially
contain UI in the form of a dialog or a form.</P>
<P>Automation Servers also lend themselves well to the increasingly popular multitiered
applications architectures that have appeared in recent years. The separation of
UI from function is perfect for Automation Servers because you have complete freedom
over how your Servers are implemented and used. Creating Servers with thin UI layers
that utilize other Servers with no UI to accomplish a task is at the heart of multitiered
applications development. Automation Servers should be used in the same fashion as
any other DLL. The only difference between an Automation Server and a standard Windows
DLL is the fact that the Server uses only a restricted set of data types whereas
a DLL can use any type.</P>
<P>Designing Automation Servers that work without the need for UI also makes them
prime candidates for Distributed COM (DCOM) and other distributing technologies.
<H3><A NAME="Heading5"></A>ActiveX Controls</H3>
<P>You should use ActiveX Controls primarily as they were intended to be used: as
UI components to enhance or support a dialog, form, or document. Controls can be
expensive to load because they can potentially require a large number of interfaces,
depending on the functionality the Control supports. The OC 96 specification added
the QuickActivate interface to help with Control load times, but the improvement
was not significant. In addition, the OC 96 specification identified a number of
interfaces that are considered optional or conditional, depending on the type of
Control you are implementing. It is wise to review the specification to determine
what can and cannot be removed from your implementation in order to improve its performance
and overall size.</P>
<P>When creating Controls, be sure to make them as lean as possible. If the Control
will not be commercially distributed, remove the &quot;AboutBox&quot; code. Also,
see whether you can get away with relying on the property editor of the application's
development tool that will be used rather than supporting property pages. Avoid large
amounts of persistence, and save the data only if you must. The real message here
is to implement only those features that are truly useful and helpful for your Control
implementation.
<H3><A NAME="Heading6"></A>COM Objects</H3>
<P>COM Objects (Custom Interfaces) are far more flexible than any other component
type when it comes to interface design. They are also the fastest interfaces in terms
of execution times, although that is with the caveat that the COM interface is in-process
to the application using it. COM Objects can use any data type within their interface
definitions and do not suffer from the same restrictions as Automation Servers. This
situation does present a problem when crossing process boundaries because the Object
will then require its own proxy-stub marshaling code.</P>
<P>Proxy-stub marshaling is what takes place when an application resides in a process
space other than the application it is communicating with. It is necessary to translate
function calls and data to a context that can be understood by both applications.
This is the responsibility of the proxy-stub code and is true for all types of OLE
components. Going out-of-process with any type of component will have a profound
effect on the performance of the application because a lot more work is taking place
in order to perform the specific set of operations.</P>
<P>Automation Servers rely on built-in proxy-stub marshaling code, whereas COM interfaces
are required to create their own. This problem is not insurmountable, but it does
add to the development time and effort, maintenance of the code, distribution of
the Object, and overall performance of the application, so it needs to be considered
when deciding on what type of component to develop. If you are going to go out-of-process
with the COM Object, you should probably consider using an Automation Server because
the performance will be comparable between the two, that is unless you are going
to come up with your own marshaling code that significantly outperforms the built-in
mechanisms.</P>
<P>COM Objects are useful for the cases where the limited set of data types available
to Automation Servers has a significant impact on the type of interface that can
be created. An example of a COM Object might be a simple implementation that performs
calculations of a large volume of user-defined data. Instead of copying the data
and passing it to the COM Object, it might be more useful to pass a pointer to the
data and allow the COM Object to manipulate the data directly. Automation Server
data type restrictions would not allow for the creation of this kind of interface.
COM does, however. Although in this case, the COM Object can execute only in-process
because it needs direct access to the data.
<H2><A NAME="Heading7"></A>Selecting the Right Tool for the Right Job</H2>
<P>Microsoft is going hog-wild with its tools development. Every product coming out
these days seems to have the capability of building one kind of ActiveX component
or another. Applications like Visual C++, Visual Basic (VB), J++, Access, FoxPro,
Microsoft Word, and Microsoft Excel, just to name a few, can create anything from
ActiveX COM Objects to ActiveX Documents. This book addresses creating ActiveX components
by using Microsoft Visual C++ (VC++). Deciding whether to use VC++ for your development
is usually based on one issue: limitations. All other products and tools capable
of creating ActiveX components are going to suffer from some form of limitation.
VC++ is the most powerful and flexible tool for creating ActiveX components, and
now that you have decided VC++ is the way to go, you need to decide on a development
strategy.</P>
<P>When creating your ActiveX component with Visual C++, you have four options, which
are all described in the following sections.
<H3><A NAME="Heading8"></A>Microsoft Foundation Classes</H3>
<P>The Microsoft Foundation Class Library (MFC) is the easiest choice of all the
tools available for ActiveX development. The VC++ IDE (Integrated Development Environment)
is designed specifically with MFC in mind and provides very useful application and
ClassWizards for developing your application. MFC is robust and will probably cover
90 percent of your application's needs. Unfortunately, like every other software
project that you have probably worked on, the last 10 percent is where you spend
90 percent of your time.</P>
<P>Going outside the bounds of what MFC defines can be difficult and, in some cases,
impossible. Take for example the requirement to have an Object that is single instance
only. No matter how the Object is created by the client application, you always want
the same instance returned. Providing this kind of functionality is impossible with
MFC without modifying the built-in Class Factory classes, and these are not normally
exposed to the developer.</P>
<P>Supporting dual-interfaces in Automation Servers is not impossible, but it does
cause enough changes in your code so that the ClassWizard can no longer be used to
completely maintain your methods and properties. Some work will have to be done by
hand. MFC does provide a number of features and functions when developing ActiveX
components, but be prepared to live by its rules. Occasionally, you can bend the
rules, but you can almost never break them. The following chapters discuss how to
successfully bend the rules in MFC and implement both single instance and dual-interface
servers.</P>
<P>A good rule of thumb when working with MFC is to avoid using the built-in classes
as much as possible by utilizing the basic Windows API instead.</P>
<P>Avoiding use of the MFC classes to solve your application problems has two benefits.
The first is that your application will generally run faster; the second is that
moving to an alternative development tool such as ATL or BaseCtl will prevent a large
amount of code rewrite. A large portion of the MFC classes have equivalent Windows
API functions, especially in the area of GDI and drawing, and is not that much of
a departure from MFC. Basic storage classes, such as lists and arrays, could be better
provided by a general purpose class library, such as the Standard Template Library
(STL), which can be used in combination with all of the ActiveX development frameworks
you will be seeing in this book.
<H3><A NAME="Heading9"></A>ActiveX Template Library</H3>
<P>ActiveX Template Library (ATL as it has come to be known), is a newcomer to the
ActiveX arena. It first appeared in the summer of 1996 and quickly became a favorite
among developers. Based on the amount of development taking place by using ATL and
the fact that, unlike the BaseCtl framework, it is actually a supported product,
Microsoft and the industry have obviously seen ATL as a viable platform for creating
ActiveX components and it should be around for a long time.</P>
<P>The initial implementation, versions 1.0 and 1.1, focused on the creation of small
and fast Automation Servers and COM Objects. With the introduction of 2.0, ATL expanded
its coverage to include ActiveX Controls and other ActiveX components. The level
of integration with the VC++ IDE originally consisted only of an AppWizard used to
create the basic ATL project, which, by the way, was more complete than its MFC counterpart.
Also the ClassWizard could be used to maintain the Objects, methods, and properties
as it can with MFC. ATL version 2.0 and VC++ 5.0 are now fully integrated, supplying
the same level of tool support, such as AppWizards, ObjectWizards, and ClassWizards.</P>
<P>An added bonus to ATL is that it can be integrated into existing MFC applications
without dire consequences or enormous amounts of work. This capability gives you
complete freedom to develop your component without the restrictions that MFC imposes,
while still being able to use nice MFC classes and features (like structures, arrays,
and lists, to name a few).
<H3><A NAME="Heading10"></A>BaseControl Framework</H3>
<P>BaseControl (BaseCtl) Framework and the ActiveX SDK is without a doubt the most
difficult route to choose for ActiveX component development. The BaseCtl was first
developed by the Visual Basic 4 (VB 4) development group in late 1995 and early 1996
in response to growing demands for better performance when using OCXs and VB. BaseCtl
(then referred to as the &quot;MarcWan&quot; framework because of its primary developer,
Marc Wandschnieder at Microsoft) was intended as a bare-bones framework to be used
to create lightweight OLE Controls.</P>
<P>In an effort to quell the demand for tools to create OLE Controls, the framework
was put into the hands of various Control developers and vendors who were in contact
with Microsoft and the VB group. At the Internet PDC, Microsoft packaged the BaseCtl
Framework as part of the ActiveX SDK, and the rest, as they say, is history.</P>
<P>The BaseCtl has no integration with the VC++ environment. In fact, the version
of the BaseCtl framework that ships with the ActiveX SDK is little more than sample
programs from which you can create new applications. Another version of the baseCtl
framework that has been available to members of the VB 4 and 5 beta testers actually
contains an AppWizard. The AppWizard used to create the base set of source files
is written in VB and is ad hoc at best. The BaseCtl relies on a series of Object
and library files that have to be built by you, the developer, before they can be
used. All of the source files that come with the SDK and those generated by the AppWizard
depend on command-line compilation. With a little bit of effort on your part, the
projects can all be converted to VC++ projects, including the Object and library
files that come with the SDK. The documentation for the BaseCtl is rudimentary and
somewhat cryptic.</P>
<P>Basic Control development with the BaseCtl framework can be difficult, as well.
A fair number of the functions and capabilities that you're used to in MFC aren't
present in the BaseCtl. A number of the function names are different, and the architecture
for persistence is completely different. BaseCtl is meant to get the job done with
as little code as possible, and unfortunately it's obvious.</P>
<P>For those of you who have already written Controls in MFC and want to port them
to the BaseCtl, I have only one thing to say, &quot;Roll up your sleeves because
it's going to get messy.&quot; With the BaseCtl, you're expected to dig into the
guts of the framework and build a lot of the function yourself.</P>
<P>One thing the BaseCtl has going for it is a fair number of samples. When installing
the BaseCtl, it is recommended that you install the samples as well. Chances are
that if you need to do something, it's in one of the samples. VC++ has a nice feature
called &quot;Find in Files.&quot; Take advantage of it. Another nice feature of the
BaseCtl is the capability to access all the source code in the BaseCtl framework
directly, so if you find a bug (and there are a couple), you can fix it yourself
and move on.</P>
<P>Also, you have a lot more freedom to model your Control as you want. For example,
you have two Controls that you want to develop; one is a Number Control, for basic
numeric data input, and the other is a Currency Control, for basic currency data
input. Both can rely heavily on the C++ inheritance model at the code and interface
levels by creating a BaseNumeric Control.</P>
<P>You don't have this kind of freedom with MFC. BaseCtl should not be taken lightly,
and you can expect a lot of work when implementing a component with it. Even worse,
the results may not justify the work. In one case, after converting an existing MFC
Control to the BaseCtl, a 40 percent improvement was realized in the average load
time of the two versions of the Control. You might think &quot;Wow--40 percent! That's
pretty good.&quot; Unfortunately, the load times were already so low for both Controls
that you literally had to have hundreds of Controls on the form before the improvement
was noticeable.
<H3><A NAME="Heading11"></A>Create Your Own Framework</H3>
<P>The last method for Control development is to just sit down and do it. Get code
from the class libraries, samples, books, and so on, and come up with your own framework,
tools, or whatever you want. But you can expect the work to be hard and time-consuming.
To get an idea of how much work is actually involved, stop for a minute and take
a look at some of the source files in MFC, ATL, and the BaseCtl. Literally thousands
of lines of code have been implemented over the course of months and even years.
Due to the constantly changing nature of OLE and ActiveX requirements, it is wiser
to choose an existing platform rather than trying to reinvent the wheel.</P>
<P>The key to successful Control development is not in the framework that you choose
to develop in, but in how you apply it.
<H2><A NAME="Heading12"></A>Basic ActiveX Component Architecture</H2>
<P>Before moving on to the actual implementation of each type of ActiveX component,
you need to review some of the basic concepts and architecture surrounding each component.</P>
<P>Even though you can develop a wide variety of ActiveX components--controls, servers,
documents, and so on--one thing is true for all of them: Underlying every component
is the Component Object Model or COM architecture. COM defines the standard that
all ActiveX components rely on when interacting with other ActiveX components.</P>
<P>In addition to COM, all ActiveX components are further defined or restricted by
the operating system in how they are created and used. The type of ActiveX component
you create will further define or restrict your options when creating components.
A wide variety of choices are available to you as a developer and it is important
to understand the ramifications of each.
<H3><A NAME="Heading13"></A>ActiveX Automation Servers</H3>
<P>Probably the easiest to implement and most flexible form of ActiveX component
is the Automation Server. An <I>Automation Server</I> is an application that contains
one or more <TT>IDispatch</TT>-based interfaces. An <I>interface</I> is a collection
of related methods and properties and an <TT>IDispatch</TT> interface is the name
of the COM interface that is used to generically invoke those methods and properties.
For more information on <TT>IDispatch</TT> interfaces please see the VC++ books online.
The capability to define unique methods and properties for each server and have them
be accessible through a generic mechanism is the real power of Automation Servers.</P>
<P>An automation server may or may not be directly creatable by other applications
via a <TT>CreateObject</TT> or similar call. It is possible to have what are referred
to as nested objects that represent a hierarchy of objects. A single creatable automation
object is responsible for the creation and distribution of other automation objects.
For example, an application may expose a Document automation interface that can be
created and manipulated by another application but that only exposes a <TT>Page</TT>
interface as a method call to the document object. The lifetime of the <TT>Page</TT>
object is less than or equal to the <TT>Document</TT> object and cannot exist on
its own. (The terms object and server are used synonymously throughout this book.)</P>
<P>Three of the chapters in this book focus on creating ActiveX Automation servers
using MFC, ATL, and the BaseCtl framework. Each of the tools has its own set of strengths
and weaknesses and, depending on your specific application requirements, will determine
which tool you should use.</P>
<P>MFC is great for rapid development and ease of modification. Servers created with
MFC will be the largest and slowest of the three types. Deviating from the standard
MFC implementation of Automation Servers can also be a limiting factor when using
this tool. MFC's greatest strength is its integration with the VC++ IDE and the speed
with which an implementation can be up and running. In only minutes developers can
create a server and implement its methods and properties, assuming that they are
familiar with the tools available.</P>

<P>ATL by itself can create small, lightweight servers that are easy to use and modify.
ATL is limited to the creation of COM-based objects only and is lacking in generic
or utility class support. Combined with MFC and the Standard Template Library (STL),
ATL is a very powerful framework for ActiveX development. For those developers who
are willing to take the time to learn it, ATL is by far the best route.</P>

<P>The BaseCtl also allows you to create small, lightweight servers. Unfortunately,
the BaseCtl lacks support from Microsoft as a product which impacts its capability
to be a practical long-term development tool. It has, however, a very straightforward
and easy-to-understand architecture that is helpful to those developers who are learning
OLE and ActiveX from the ground up and who are not afraid of all the gory details.
<B><BR>
<BR>
Types of Automation Servers</B><SPACER TYPE="HORIZONTAL" SIZE="10"><B> </B>When creating
an Automation Server, you must decide how to implement the server relative to how
it is going to be used. You can create two basic types of servers: DLL-based and
EXE-based. <B><I><BR>
<BR>
DLL-based Servers</I></B><SPACER TYPE="HORIZONTAL" SIZE="10">If the server does not
have to run as a stand-alone application and performance is a critical issue, you
should implement your server as a DLL. A DLL-based server is typically referred to
as an in-process server because of how it normally executes relative to its controller.</P>

<P><B><I>EXE-based Servers </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">If the server
application does have a requirement to run as a stand-alone application, you must
implement it as an EXE. An EXE-based Automation Server is typically referred to as
a local Server or out-of-process Server, and it will execute in its own process space.
<B><BR>
<BR>
Types of Server Execution </B><SPACER TYPE="HORIZONTAL" SIZE="10">Automation Servers
also have an execution model that is independent of how the server is written. Automation
Servers can execute either in-process, locally or remotely, relative to the application
that has invoked or is using it. <B><I><BR>
<BR>
In-Process Execution </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">An in-process Server
is called <I>in-process</I> because it executes within the same process space as
that of the application that created it. Only DLL-based automation Servers can execute
as in-process, but that is not a guarantee. This is very important to note when using
nested objects or shared objects. If an object is created in a process space, say
Process A, and it is passed to another application in another process space, Process
B, the Server in Process A will execute as a local Server relative to the application
in Process B regardless of the fact that the Server in Process A is a DLL-based Server.
This issue is very critical since more times than not in-process Servers are used
to improve performance of the application using them.</P>

<P><B><I>Local Execution </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">Local execution
is when an Automation Server is executing in a process space other than the process
space of the controller application. As was stated earlier, a DLL-based Server may
execute locally to its controller, depending on how it was created versus which application
is using it. The main issue with local Servers is performance since all of the method
calls have to cross process boundaries. This condition requires additional code overhead
to move data back and forth between the Server and its Controller.</P>
<P><B><I>Remote Execution </I></B><SPACER TYPE="HORIZONTAL" SIZE="10">Remote Execution
is when the Server is executing on a machine other than the application that is controlling
it. As with local Servers, performance is an issue with this type of execution.
<H3><A NAME="Heading14"></A>ActiveX Controls</H3>
<P>An ActiveX Control, for all intents and purposes, is still the same OCX or OLE
Control that you have come to know and love over the past several years. In fact,
the only change with the coming of ActiveX is a decrease in the requirements to qualify
as a control.</P>
<P>To qualify as an ActiveX Control, a component must be a COM Object, implement
an <TT>IUnknown</TT> interface, and support registration and unregistration through
the exported functions, DLLRegisterServer and DLLUnregisterServer. That's it! Pretty
easy, right? Well, not really.</P>
<P>Even though your component qualifies as an ActiveX control, if all it supports
is the preceding features, it will not do much more than take up space on your hard
disk. If it needs UI, persistence, events, or any other feature common to controls,
the control must implement other categories of interfaces. The exact requirements
are in the <I>OLE Control and Control Container Guidelines, Version 1.1</I> published
by Microsoft. All of the guidelines for ActiveX development are available on the
Internet at the Microsoft Web site or on the ActiveX SDK CD.</P>
<P>You have three tools at your disposal for creating ActiveX controls: MFC, ATL,
and BaseCtl. As we pointed out earlier in the section &quot;ActiveX Automation Servers,&quot;
each tool has its strengths and weaknesses. With ActiveX Controls you only have one
option when creating and executing the control: as a DLL and in-process to the Control's
container application. Even though the extension of the Control is .ocx, it is still
in fact just a .dll.
<H2><A NAME="Heading15"></A>Support Tools Needed for Building ActiveX Components</H2>
<P>When creating your ActiveX Components, a few tools are essential to successful
ActiveX development. Most of these tools are automatically installed as part of the
Visual C++ development environment. As ActiveX development matures, more and more
tools will become available. Using as many tools as you can will greatly improve
your understanding of how your components work, as well as improve their overall
implementation.
<H3><A NAME="Heading16"></A>MIDL Compiler</H3>
<P>The Microsoft MIDL compiler is now a standard component of the Microsoft Visual
C++ environment. The MIDL compiler compiles COM interface definitions (IDL) files
into C code, which is then compiled into the project by the Visual C++ compiler.</P>
<P>The MIDL compiler also provides support for marshaling interfaces across process
boundaries. Starting with Visual C++ 4.0, the MIDL compiler started shipping as a
standard component of Visual C++. The MIDL compiler is also available via the Win32
SDK from Microsoft.
<H3><A NAME="Heading17"></A>Mktyplib</H3>
<P>Mktyplib is a type library compiler for compiling ODL files. Mktyplib is the predecessor
to MIDL and produces the same type of output as MIDL. The use of Mktyplib will decrease
as Microsoft moves from ODL to IDL files.
<H3><A NAME="Heading18"></A>GUIDGEN</H3>
<P>GUIDGEN is a tool that is used to generate Global Unique Identifiers (GUID), which
can be used for Interface IDs, Class IDs or any other 128-bit UUID, such as an RPC
interface. GUIDGEN is installed only when the OLE development option is selected
during the Visual C++ installation. When GUIDGEN is run, a GUID is created and placed
in the Windows clipboard. After running the GUIDGEN application, the resultant GUID
is pasted from the clipboard into the code that needs a GUID.
<H3><A NAME="Heading19"></A>RegEdit</H3>
<P>RegEdit, or the registration editor, is a standard component of both the Windows
95 and Windows NT operating systems. The registration editor is used for browsing
and altering operating system and application settings. The registration editor can
also be used for installing and registering your COM objects. <BR>
<BR>
<IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"></P>


<BLOCKQUOTE>
	<P><B>CAUTION:<BR>
	RegEdit</B> is a very powerful tool and must be used with extreme caution by experienced
	users. If used improperly, systems can be damaged, resulting in a loss of data or
	a malfunctioning computer.

</BLOCKQUOTE>

<P><IMG SRC="bar.gif" WIDTH="480" HEIGHT="6" ALIGN="BOTTOM" BORDER="0"><BR>
<BR>
In Windows 95, this program is called regedit.exe. In Windows NT, this program is
called regedt32.exe.
<H3><A NAME="Heading20"></A>Registration Server</H3>
<P>The Registration Server is an application that can be used to register the settings
of a COM object in the Windows registry without the need to create a separate registration
file. The application is called regsvr32.exe and is automatically installed if the
OLE development option is selected during Visual C++ installation or if the ActiveX
SDK is installed.
<H3><A NAME="Heading21"></A>Ole2View</H3>
<P>Ole2View is a program that lists ActiveX components relative to their function
and category. Ole2View is extremely helpful in the test and use of your components.
Ole2View can be used to determine whether your component is registered properly and
the type and number of interfaces your component defines. It even allows you to instantiate
and access various components and interfaces within your application, and now it
has expanded support for configuring components to use DCOM. When attempting to determine
what is the cause of problems with a troublesome component, Ole2View is invaluable.
<H3><A NAME="Heading22"></A>Adding the Tools to the Visual C++ Development Environment</H3>
<P>In order to maximize development productivity, the tools needed for COM programming
should be integrated into the Visual C++ environment. Each of the tools needed can
be added to the IDE's (Integrated Development Environment) <U>T</U>ools menu. The
following section illustrates how to incorporate the tools into the IDE.</P>
<P>Adding GUIDGEN to the Visual C++ environment enables the generation of a UUID
from a single menu command. The generated UUID is placed in the Windows clipboard
and must be pasted into the project code.</P>
<P>To add GUIDGEN to the Visual C++ environment:

<OL>
	<LI>Select the <U>C</U>ustomize command from the <U>T</U>ools menu. Select the Tools
	tab from the Customize dialog.
	<P>
	<LI>In the <U>M</U>enu Contents list box, scroll to the bottom of the list, and select
	a blank line, and type <B>&amp;Generate New UUID</B>.
	<P>
	<LI>In the Command edit box, type <B>GUIDGEN.EXE</B>.
	<P>
	<LI>Clear all text from the <U>A</U>rguments edit box.
	<P>
	<LI>Clear all text from the <U>I</U>nitial Directory edit box.
	<P>
	<LI>Click the Close button to add the entry to the Tools menu.
</OL>

<P>In addition to the GUIDGEN program, you may want to consider adding the registry
editor, the ability to unregister a component, and any other tool that you find useful
for your development.
<H2><A NAME="Heading23"></A>From Here...</H2>
<P>All of the frameworks described in this chapter have their strengths and weaknesses.
MFC allows for rapid component creation and implementation and the level of support
built into the VC++ IDE for MFC is beyond comparison with ATL or BaseCtl. MFC offers
a very large and robust class library for solving most, if not all, of your development
problems. MFC does, however, suffer from the problem that it is everything to everyone,
which results in a slower application or one that cannot deviate from the &quot;norm&quot;
fairly easily.</P>
<P>ATL provides a small and deliberate framework for creating ActiveX components.
ATL, however, falls very short in the area of common class and utility support, which
is the thing that is MFC's strength. In addition, ATL's integration with the VC++
IDE also leaves room for improvement.</P>
<P>BaseCtl is similar to ATL in that it is focused specifically on small, fast component
development. Like ATL, it lacks the same common class and utility support that makes
MFC so attractive. BaseCtl has an added negative of being considered only as a sample
and not as a supported product by Microsoft.</P>
<P>The level of experience of the development team and the intended life cycle of
the code and applications will also affect the decision of which tool to choose to
create ActiveX components. Take the time to investigate all of the options available
to you before deciding on a platform and a direction.</P>

<P>The following chapters examine in detail how to implement some of the components
described so far using MFC, ATL, and BaseCtl. Even with all of the information presented
so far, the only true way to know that you have made the right choice is to do it
yourself.


<!-- </td>

</td>
</tr>
</table> -->
</td>

</td>
</tr>
</table>

<!-- begin footer information -->

<MAP NAME="footer">
<AREA SHAPE=RECT COORDS="0,0,62,26" HREF="/">
<AREA SHAPE=RECT COORDS="62,0,135,26" HREF="http://www.developer.com/about/">
<AREA SHAPE=RECT COORDS="135,0,199,26" HREF="/search.html">
<AREA SHAPE=RECT COORDS="200,0,274,26" HREF="/subscribe/">
<AREA SHAPE=RECT COORDS="275,0,335,25" HREF="http://www.developer.com/contact/adinfo.html">
<AREA SHAPE=RECT COORDS="335,0,417,25" HREF="http://www.developer.com/contact/">
<AREA SHAPE=RECT COORDS="418,0,467,26" HREF="http://www.developer.com/about/faq.html">
</MAP>

<P>
<table width="640" cellpadding="0" cellspacing="0" border="0">
<tr>
<TD WIDTH="130"></TD>
<td width="468">
<IMG SRC="/images/footer/footerfile.gif" ALT="footer nav" width="467" height="26" BORDER="0" usemap="#footer" ismap>
</td>
</tr>
<tr>
<TD WIDTH="130"></TD>
<td width="468"> 
<font face=arial,helvetica size="1"> Use of this site is subject certain <a href="http://www.developer.com/legal/">Terms &amp; Conditions.</a><br>
Copyright (c) 1996-1999 <A HREF="http://www.earthweb.com/">EarthWeb, Inc.</A>.  All rights reserved.  Reproduction in whole or in part in any form or medium without express written permission of EarthWeb is prohibited.
<a href="http://www.earthweb.com/privacy.html">Please read our privacy policy for details.</a>
</td>
</tr>
</table>

</BODY>
</HTML>
