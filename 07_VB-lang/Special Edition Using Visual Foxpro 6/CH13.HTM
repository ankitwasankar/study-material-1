<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">
<!--
function popUp(pPage) {
 var fullURL = document.location;
 var textURL = fullURL.toString();
 var URLlen = textURL.length;
 var lenMinusPage = textURL.lastIndexOf("/");
 lenMinusPage += 1;
 var fullPath = textURL.substring(0,lenMinusPage);
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '</head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + fullPath + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 window.popUpWin.document.write(zhtm);
 window.popUpWin.document.close();
 // Johnny Jackson 4/28/98
 }
//-->
</SCRIPT>

<META>
<TITLE>Special Edition Using Visual FoxPro 6 -- Ch 13 - Introduction to Object-Oriented Programming</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">
<center><img src="que.gif">
<H1>Special Edition Using Visual FoxPro 6</H1>

<A HREF="ch12.htm"><IMG SRC="previous.gif" BORDER="0"></A>
<A HREF="index.htm"><IMG SRC="contents.gif" BORDER=0></A>
<A HREF="ch14.htm"><IMG SRC="next.gif" BORDER=0></A>
</CENTER>
<HR>

<H1>Chapter&nbsp;13</H1>
<H1>Introduction to Object-Oriented Programming</H1>

<UL>
<LI><A HREF="#UnderstandingObjectOrientedProgramming">
Understanding Object-Oriented Programming</A>
<LI><A HREF="#TheSoftwareCrisis">
The Software Crisis</A>
<LI><A HREF="#ObjectsandEncapsulation">
Objects and Encapsulation</A>
<UL>
<LI><A HREF="#Properties">
Properties</A>
<LI><A HREF="#Methods">
Methods</A>
<LI><A HREF="#Events">
Events</A>
<LI><A HREF="#Classes">
Classes</A>
</UL>
<LI><A HREF="#InstantiatingObjects">
Instantiating Objects</A>
<LI><A HREF="#ReferencingaMethodorPropertyinaClass">
Referencing a Method or Property in a Class</A>
<LI><A HREF="#SubclassingBasingaClassonAnotherClass">
Subclassing-Basing a Class on Another Class</A>
<LI><A HREF="#OverridingInheritedBehavior">
Overriding Inherited Behavior</A>
<LI><A HREF="#ProtectingMethodsandProperties">
Protecting Methods and Properties</A>
<LI><A HREF="#UnderstandingPolymorphism">
Understanding Polymorphism</A>
<LI><A HREF="#MessagesMessagesMessages">
Messages, Messages, Messages</A>
<UL>
<LI><A HREF="#CreatinganObject">
Creating an Object</A>
<LI><A HREF="#GettingtheValueofaProperty">
Getting the Value of a Property</A>
<LI><A HREF="#CallingaMethod">
Calling a Method</A>
<LI><A HREF="#EncapsulationRevisited">
Encapsulation Revisited</A>
</UL>
<LI><A HREF="#OOPanditsEffectonDevelopment">
OOP and its Effect on Development</A>
<LI><A HREF="#AnalysisandDesignwithOOP">
Analysis and Design with OOP</A>
<LI><A HREF="#MultideveloperIssueswithObjectOrientedSoftware">
Multideveloper Issues with Object-Oriented Software</A>
<LI><A HREF="#SystemMaintenancewithOOP">
System Maintenance with OOP</A>
</UL></UL>

<HR>
<H2><A NAME="UnderstandingObjectOrientedProgramming"><FONT SIZE=5 COLOR=#FF0000>
Understanding Object-Oriented Programming</FONT></A></H2>
<P>
Object-oriented programming (OOP) revolutionizes nearly every
aspect of application development with Visual FoxPro, from the
analysis and design phases to the coding and testing of applications
and application components. Object-oriented programming was introduced
in Visual FoxPro Version 3.0 and has become one of its standard
and most useful features.
<P>
This and the next four chapters discuss object-oriented programming
with Visual FoxPro in detail and include the following information:
<UL>
<LI>This chapter discusses the basic concepts
of object-oriented programming with examples shown in Visual FoxPro.
<LI><A HREF="ch14.htm" >Chapter 14</A>, &quot;OOP with Visual FoxPro,&quot;
covers how to create classes with Visual FoxPro using programs
and the Visual Class Designer.
<LI><A HREF="ch15/ch15.htm" >Chapter 15</A>, &quot;Creating Classes with
Visual FoxPro,&quot; covers the different kinds of classes typically
created in Visual FoxPro with examples of each.
<LI><A HREF="ch16/ch16.htm" >Chapter 16</A>, &quot;Managing Classes with
Visual FoxPro,&quot; delves into the critical issue of managing
class libraries and reviews the commands related to managing class
libraries. The Class Browser, a powerful new addition to the FoxPro
suite of tools, is also covered.
<LI><A HREF="ch17/ch17.htm" >Chapter 17</A>, &quot;Advanced Object-Oriented
Programming,&quot; discusses some advanced topics related to OOP
with Visual FoxPro.
</UL>
<P>
Visual FoxPro, like Visual C++, is a <I>hybrid</I> language. This
means that the developers have the option of developing applications
using OOP methods or modular programming. If you develop applications
in other languages, such as SmallTalk, you must use OOP.
<P>
If Visual FoxPro does not require the use of OOP, why should you
consider leaving the warm comfort of developing the old way to
go to the radically new mind-set of OOP? To answer this question,
it is first necessary to review the background of what is called
the <I>software crisis</I>.
<H2><A NAME="TheSoftwareCrisis"><FONT SIZE=5 COLOR=#FF0000>
The Software Crisis</FONT></A></H2>
<P>
Businesses today are experiencing a software crisis that stems
from the inability of today's programming methodologies to adapt
to the rapidly changing world of business. Applications developed
in modular form often require a long development cycle, are based
on marginally reusable code bases, and are frequently outdated
before they hit the user's desk. The premise of modular development
is to create software based on modules that are typically, by
their very nature, different from business to business and even
from department to department within a single company. In today's
global business environment, companies need the diversity of an
operating system or programming language that will enable them
to develop programs or software that is cost efficient to produce
and deploy in many working environments. For example, an inventory
control program written to work in an American company might not
have all the functionality that would be needed to work in a Mexican
company. Visual FoxPro is one of the programming languages that
is adaptable enough to enable the developer the versatility to
quickly meet the needs of most companies in many situations.
<P>
Take the example of accounting applications. At the most basic
level, they are the same: accounts receivable programs that manage
and track the money owed to the company, accounts payable programs
manage the bills owed by the company, and so on. However, when
you drill down to the operations of the individual business functions,
differences typically arise from organization to organization.
For example, the format of a bill for a service organization is
different from the format of a bill for a merchandising firm.
<P>
When software is developed in modules, as it was in FoxPro 2.x,
individual programs are combined to create an application. If
an application is brought from one company to another, or even
from one department to another, typically the software is copied
and the source code is modified to fit the requirements of the
new users. Imagine what happens when an upgrade is released for
the original software. The new users do not get the benefits of
the new upgrade unless a second effort is made to incorporate
the changes into the copied version. If a bug is found in one
version of the software, the software must be fixed in two places.
Obviously, this is not the best way to do things.
<P>
OOP takes a radically different approach. Software is created
not in modules but rather in terms of <I>entities</I> (or objects).
For example, using OOP, you do not create an accounts receivable
module per se but instead create customer objects, invoice objects,
and so on and then combine them into an application<I>.</I> In
effect, <I>components</I> are developed that are put together
to form an application.
<P>
Using this new method of development, you focus on the entities
being modeled in the <I>problem domain</I> (a fancy term meaning
the business problem you are trying to solve with software). The
design of a customer object is based on the simple concept of
trying to determine what a customer does and what a customer knows
within the context of a business. &quot;Within the context&quot;
means that you will come up with a <I>theoretical</I> model for
the customer based on what the &quot;customer&quot; is within
the business environment. For example, a customer knows his or
her name, address, telephone number, and credit balance. The customer
would also know how to print itself, save itself, and more. This
does not mean that Joe Customer knows how to print his own record
or save himself to the database. Rather, it means that a customer
<I>object</I> would have these responsibilities.
<P>
If an application is taken from one business to another, the differences
can be accommodated by basing new objects on existing ones (a
process known as <I>subclassing</I>). The behaviors and attributes
of the original object are automatically brought  forward (<I>inherited</I>)
and are changed as needed for the new software. This results in
radically fewer code modifications. If changes are made to an
original object, they are automatically brought forward to the
new objects.
<P>
Why would you want to change to OOP from the familiar old world
of modular programming? Because the old world is broken and OOP
can fix it. Specifically, object orientation is designed to provide
the following:
<UL>
<LI>Enhanced code reusability
<LI>Enhanced code maintenance
</UL>
<P>
Now that you know what to look for from OOP, the following is
an overview of the concepts that make up object orientation.
<H2><A NAME="ObjectsandEncapsulation"><FONT SIZE=5 COLOR=#FF0000>
Objects and Encapsulation</FONT></A></H2>
<P>
If you've ever read a book or article about object orientation,
you nght have noticed many terms thrown about as if they were
self-explanatory. Terms such as <I>inheritance</I>, <I>encapsulation</I>,
and <I>polymorphism</I> are used to express OOP concepts. Because
of these odd and difficult terms, OOP is often thought to be complex.
The truth could not be more different.
<P>
The first and most important key concept in OOP is an object.
An <I>object</I> is a package of information and actions. An object
is self-contained. An object has things on the inside that only
it knows about, characteristics that everyone can see, and ways
of doing things.
<P>
Use an elevator as an example. An elevator is an object in that
it has properties (such as a maximum weight load), it performs
actions (such as opening and closing the door), and it has a public
interface (the control buttons) that enables it to interact with
the environment around it. An object has precisely these qualities.
<P>
The key to understanding objects is to view them like an elevator.
When you think about an elevator, all you think about is the public
interface: the buttons that tell the elevator where to go, the
door that opens to let you in and out, and so on. However, there
is a great deal more to the elevator that you never think about.
For example, you probably don't know how the elevator interprets
the buttons you press into a destination or how the elevator knows
which floor it is on. And, for that matter, you probably don't
care. These functions, although a significant part of the elevator,
do not concern you.
<P>
This introduces a few more concepts. First, all the knowledge
and behaviors of an object are contained within the object. This
is known as <I>encapsulation</I>. An object knows what it needs
to know and how to do what it needs to do without relying on the
outside world. The data and behaviors are encapsulated within
the object.
<H3><A NAME="Properties">
Properties</A></H3>
<P>
The data in an object is called a property. A <I>property</I>
(in Visual FoxPro terms) is simply a memory variable that is attached
and scoped to an object. You query the value and modify it by
using the object name followed by a period (<TT>.</TT>) and then
the name of the property. (For the record, properties are also
called <I>member variables</I> in some texts.) Properties can
have any data types that are valid for a plain old Visual FoxPro
memory variable. A property exists as long as the object it is
attached to exists.
<P>
For example, if you have a property called <TT>lIsNew</TT> that
is attached to an object called <TT>oCust</TT>, you could query
the value of the property by stating the following:
<BLOCKQUOTE>
<PRE>
? oCust.lIsNew
</PRE>
</BLOCKQUOTE>
<H3><A NAME="Methods">
Methods</A></H3>
<P>
In addition to having attached data, objects have actions to perform.
These actions are coded in procedures that are attached to the
object. These procedures are known as <I>methods</I>. There is
little difference between a &quot;regular&quot; procedure and
a method except in the way they are called. You call a method
by stating the name of the object followed by a period (<TT>.</TT>)
and then the name of the method. For example, the following line
illustrates how to call a method named <TT>Print</TT> that is
attached to the <TT>oCust</TT> object:
<BLOCKQUOTE>
<PRE>
oCust.Print()
</PRE>
</BLOCKQUOTE>
<P>
Technically, the parentheses at the end of the method name are
only required if you expect a return value or if you are passing
parameters to the method. I suggest that you always use the parentheses
for consistency. It also makes it clear that you're calling a
method.
<P>
Notice, by the way, the manner in which this method is called.
Unlike Visual FoxPro procedures and user-defined functions, you
do not have to use a <TT>DO</TT>-type syntax or specify the function
with an expression. To call a method that is a procedure (assuming
you do not expect a return value), all you need to do is call
the method as shown in the previous example. If you expect a return
value, you can use the old UDF-type syntax. For example, if the
<TT>Print</TT> method returns a logical stating whether the customer
was properly printed, you could capture the value with this:
<BLOCKQUOTE>
<PRE>
llReturnValue = oCust.Print()
</PRE>
</BLOCKQUOTE>
<H3><A NAME="Events">
Events</A></H3>
<P>
<I>Events</I> are things that happen. For example, clicking the
mouse is an event. Events can be caused by a user's action (such
as clicking a mouse) or by the system itself (such as when an
error occurs). When you are creating a class (such as a pushbutton)
in Visual FoxPro, you can attach code (such as methods) to events.
When the event happens (for example, the user clicks the left
mouse button while on the object), the associated method (that
is, the <TT>click</TT> method) is automatically called.
<P>
Events are not new. Developers have been using them since the
advent of FoxPro 2.0. Valid clauses, for example, are simply procedures
that are attached to an event (such as attempting to exit a modified
field or clicking a pushbutton). Part of the power of using objects
comes from attaching methods to an object that automatically execute
when something specific happens. In Visual FoxPro, you can attach
methods to all kinds of events: when the mouse is clicked, when
the mouse is released, and so on. You can even attach code to
events that execute automatically when the object is created (the
<TT>Init</TT> event) and when the object is released (the <TT>Destroy</TT>
event).
<P>
There is one major difference between events in an object-oriented
development environment and the old <TT>Valid</TT> and <TT>When</TT>
clauses. In FoxPro 2.6, there was no direct method for manually
executing the code snippet attached to an event (well, there <I>was</I>
a way, but it was a kludge). In other words, there was no single
command that ran the procedure attached to a screen object's <TT>Valid</TT>
event. In an object-oriented development environment you can do
this easily by calling the event the same way you would call a
method. For example, if you have a pushbutton called <TT>cmdOK</TT>,
you could execute the code attached to the <TT>Click</TT> event
(that is, the <TT>Click()</TT> method) at any time by issuing
the following:
<BLOCKQUOTE>
<PRE>
cmdOk.Click()
</PRE>
</BLOCKQUOTE>
<P>
By attaching code to events, you greatly increase the control
you have over the behavior of an object. In fact, with the myriad
of events to which Visual FoxPro enables you to respond, you can
have acute, pinpoint control over forms and objects.
<P>
So far, you have seen that you can create objects as well as assign
properties to them and create methods for them. If you had to
write code to fine-tune an object every time you created it, you
would be in for a lot of coding. Fortunately, OOP has the answer
for this as well-classes.
<H3><A NAME="Classes">
Classes</A></H3>
<P>
To this point, all of the discussion in this chapter has centered
around the object. But, what is the basis for an object? How is
an object coded?
<P>
Consider a candle for a moment. A candle maker typically creates
a candle from a mold rather than creating each one individually
by hand. If the design of a candle needs to change, where would
it be changed? On every individual candle? Not likely. Instead,
the mold would be changed. When the mold is changed, all new candles
get the change automatically.
<P>
In object-oriented programming, objects are never coded<I>.</I>
Rather, object molds (called <I>classes</I>) are coded. All objects
are then <I>instantiated</I> (that is, created) from that class.
All coding is done at the class level. Once an object is instantiated
from a class, all you do is interact with it. You do not add methods
or change existing methods in an object, but rather you add and
change methods in a class.
<P>
Here's an example of a class:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS myClass AS Custom
     cName = &quot;&quot;
     cType = &quot;&quot;
     lIsNew = .F.

     PROCEDURE ShowVals
          ? this.cName
          ? this.cType

          IF this.lIsNew
               ? &quot;I'M NEW&quot;
          ELSE
               ? &quot;I'M OLD&quot;
          ENDIF
     ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
A brief dissection of this block of code follows; however, for
a more definitive description of the syntax associated with coding
classes, refer to <A HREF="ch14.htm" >Chapter 14</A>.
<BLOCKQUOTE>
<PRE>
Define Class myClass as Custom
</PRE>
</BLOCKQUOTE>
<P>
This line of code tells Visual FoxPro that you are defining a
new class called <TT>MyClass</TT> that is based on another class
called <TT>Custom</TT>, which is discussed in more detail later
in the chapter.
<BLOCKQUOTE>
<PRE>
cName = &quot;&quot;
cType = &quot;&quot;
lIsNew = .F.
</PRE>
</BLOCKQUOTE>
<P>
The preceding lines are known as <I>declaration code</I>. In this
part of the class definition, you list the member variables (properties)
of the object and their initial values. If one of the member variables
is an array, the <TT>DECLARE</TT> statement would be placed here.
<BLOCKQUOTE>
<PRE>
PROCEDURE ShowVals
     ? this.cName
     ? this.cType

     IF this.lIsNew
          ? &quot;I'M NEW&quot;
     ELSE
          ? &quot;I'M OLD&quot;
     ENDIF
ENDPROC
</PRE>
</BLOCKQUOTE>
<P>
This is a method definition. Calling a method executes all the
code from the <TT>PROCEDURE</TT> line to the <TT>ENDPROC</TT>
line. A method is very similar to a procedure in a FoxPro 2.x
procedure file, except that the method is called through its object.
<H2><A NAME="InstantiatingObjects"><FONT SIZE=5 COLOR=#FF0000>
Instantiating Objects</FONT></A></H2>
<P>
An object is instantiated with the <TT>CREATEOBJECT()</TT> function.
Here is the syntax for creating an instance of <TT>MyClass</TT>:
<BLOCKQUOTE>
<PRE>
oMyClass = CREATEOBJECT(&quot;MyClass&quot;)
</PRE>
</BLOCKQUOTE>
<P>
By the way, <TT>oMyClass</TT> is simply a memory variable of type
<TT>Object</TT>.
<P>
In order to access the members of <TT>oMyClass</TT>, you could
use the following commands:
<BLOCKQUOTE>
<PRE>
? oMyClass.cName    &amp;&amp; Initially blank
oMyClass.cName = &quot;Menachem Bazian&quot;
? oMyClass.cName    &amp;&amp; Now shows &quot;Menachem Bazian&quot;
oMyClass.ShowVals() &amp;&amp; Runs the showvals method
</PRE>
</BLOCKQUOTE>
<H2><A NAME="ReferencingaMethodorPropertyinaClass"><FONT SIZE=5 COLOR=#FF0000>
Referencing a Method or Property in a Class</FONT></A></H2>
<P>
An issue that arises with this method of development is that it
is difficult to know what the name of an object's instance variable
is inside a class. When coding the class, the name of the variable
that holds the instance should be, and is, irrelevant.
<P>
In order to refer to an object's properties or methods within
itself, the identifier <TT>THIS</TT>, in place of the object name,
is used. (You saw this previously in procedure <TT>SHOWVALS</TT>.)
<BLOCKQUOTE>
<PRE>
IF this.lIsNew
          ? &quot;I'M NEW&quot;
     ELSE
          ? &quot;I'M OLD&quot;
     ENDIF
</PRE>
</BLOCKQUOTE>
<P>
The keyword <TT>THIS</TT> means that you are accessing the method
or member variable of the object itself. It's that simple.
<H2><A NAME="SubclassingBasingaClassonAnotherClass"><FONT SIZE=5 COLOR=#FF0000>
Subclassing-Basing a Class on Another Class</FONT></A></H2>
<P>
So far, you have learned just about all there is to know about
objects, and you have also learned about properties, methods,
and events. You have also seen how to create an object's blueprint
with a class, which you then use to instantiate the object. However,
one more important piece remains (the really exciting part as
it turns out): creating classes based on prior classes.
<P>
Suppose you have a class called <TT>Light</TT> that models a light
in a room. The class would need a method for turning the light
on and off and a property for the current status of the light.
It might look something like this:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS light AS custom
  status = &quot;OFF&quot;

  PROCEDURE Toggle
   IF this.status = &quot;OFF&quot;
     this.status = &quot;ON&quot;
   ELSE
     this.status = &quot;OFF&quot;
   ENDIF
  ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
In the sample <TT>Light</TT> class, you create an object that
basically has one property and one method. This works well for
light switches that just turn on and off. But suppose you want
to create a light switch that can dim as well? What do you do?
Do you have to write a whole new class? The toggle is still applicable:
the light can still be turned on and off. What you need is a modified
version of the <TT>Light</TT> class that has all the same capabilities
of the <TT>Light</TT> class plus the capability of dimming the
light.
<P>
For the purposes of this illustration, I'll set the following
rules: When you attempt to use the dimmer, it goes from full light
to half light and then back again. In order to turn the light
on or off, you still need to use the original light switch method.
<P>
Here's how you could accomplish this using an OOP model:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS dimmer AS light
  intensity = &quot;FULL&quot;

  PROCEDURE DimmIt
   IF this.status = &quot;OFF&quot;
     RETURN
   ENDIF

   this.intensity = IIF(this.intensity = &quot;FULL&quot;, ;
              &quot;HALF&quot;, &quot;FULL&quot;)
   WAIT WINDOW &quot;Lights are now &quot;+this.intensity+&quot; power.&quot;
  ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
Notice the original <TT>DEFINE</TT> of the class. In the original
<TT>DEFINE</TT> (class <TT>Light</TT>), I used <TT>Custom</TT>
as the base class. <TT>Custom</TT> is the simplest base class
that is built into Visual FoxPro; you use it when you are creating
objects of your own from scratch. (In <A HREF="ch15/ch15.htm" >Chapter 15</A> you learn what
<TT>Custom</TT> is in more detail and how you use it.) In the
<TT>DEFINE</TT> used here, the base class is <TT>Light</TT>. 
This means that class <TT>Dimmer</TT> automatically <I>inherits</I>
everything that <TT>Light</TT> has. Thus, although no code exists
in the <TT>Dimmer</TT> class to handle the <TT>LightSwitch</TT>
method and the <TT>Status</TT> property, <TT>Dimmer</TT> gets
the method and property automatically because it is a subclass
of <TT>Light</TT>. This process is known as <I>inheritance</I>.
<P>
In effect, a subclass (<TT>Dimmer</TT>) is a more specialized
version of the <I>superclass</I> (<TT>Light</TT>).
<H2><A NAME="OverridingInheritedBehavior"><FONT SIZE=5 COLOR=#FF0000>
Overriding Inherited Behavior</FONT></A></H2>
<P>
One of the nice things about inheritance is that you can accept
what you like from the superclass and override the rest. A method
is overridden when it is &quot;recoded&quot; in the subclass.
Here is an example:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS offdimmer AS dimmer
     intensity = &quot;FULL&quot;

     PROCEDURE DimmIt
          WAIT WINDOW &quot;Dimmer is DIsabled&quot;
     ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
In this case, the <TT>DimmIt</TT> method has been overridden.
The <TT>DimmIt</TT> method from the <TT>Dimmer</TT> class is not
called.
<P>
Suppose you want to run the method from the <TT>Dimmer</TT> class's
<TT>DimmIt</TT> method and then add additional code. Here's how
you could do it:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS AnotherDimmer AS offdimmer
     intensity = &quot;FULL&quot;

     PROCEDURE DimmIt
          Dimmer::Dimmit()
          OffDimmer::Dimmit()
          WAIT WINDOW &quot;Isn't this cool?&quot;
     ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
The double colon operator (<TT>::</TT>) is used to call methods
from classes higher in the class hierarchy. Notice that you can
only call methods from classes that have been inherited from.
<H2><A NAME="ProtectingMethodsandProperties"><FONT SIZE=5 COLOR=#FF0000>
Protecting Methods and Properties</FONT></A></H2>
<P>
When you create an object, you should take great care to decide
what the public interface of the class is going to be. A class
will typically have properties and methods that are intended for
use inside the class only. Other properties and methods, if accessed
from the outside, can have a disastrous effect on the inner workings
of a class.
<P>
Consider the sample <TT>Light</TT> class and suppose that the
<TT>Toggle</TT> method has code in it that turns the light on
and off based on the <TT>Status</TT> property. If you modify the
<TT>Status</TT> property by accessing it outside of the class,
the <TT>Toggle</TT> method will not work properly.
<P>
The solution to this problem is to protect the methods and properties
that should not be accessible outside of the class. When you code
the classes you can protect the properties by adding <TT>PROTECTED
<I>propertyname</I></TT> definitions
in the declaration section of the code. For methods, add the keyword
<TT>PROTECTED</TT> to the <TT>PROCEDURE</TT> line. Here is an
example:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS myClass AS Custom
     PROTECTED cName
     cName = &quot;&quot;
     cType = &quot;&quot;
     lIsNew = .F.

     PROTECTED PROCEDURE ShowVals
          ? this.cName
          ? this.cType

          IF this.lIsNew
               ? &quot;I'M NEW&quot;
          ELSE
               ? &quot;I'M OLD&quot;
          ENDIF
     ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
In this example, both the <TT>cName</TT> property and the <TT>Showvals</TT>
method are protected. Attempts to access them from outside of
the class will produce an error as if the property and method
did not exist (and as far as the world outside of the class is
concerned, they don't exist).
<P>
If a class has a property that has to be tightly controlled (such
as the <TT>Status</TT> property, which can only be changed by
the <TT>Toggle</TT> method), you should protect it. If the user
needs to read the value of that property, provide a method that
returns the value of the protected property. For example, in order
to access the <TT>cName</TT> property in the sample class (shown
previously) you might create a method called <TT>ShowName</TT>
as follows:
<BLOCKQUOTE>
<PRE>
FUNCTION ShowName
     RETURN (this.cName)
ENDFUNC
</PRE>
</BLOCKQUOTE>
<H2><A NAME="UnderstandingPolymorphism"><FONT SIZE=5 COLOR=#FF0000>
Understanding Polymorphism</FONT></A></H2>
<P>
Polymorphism is the next term that needs to be covered in this
discussion<I>.</I> <I>Polymorphism</I> is the capability to give
methods and properties in different classes the same name even
if they mean different things.
<P>
For example, consider the <TT>Light</TT> objects. They all have
a method called <TT>Toggle</TT>, which turns the light on and
off. Suppose now that you were to create an entirely different
object: a telephone. The <TT>Telephone</TT> object might not have
anything to do with a <TT>Light</TT> object, but there is a method
attached to it that is also called <TT>Toggle</TT>. The <TT>Toggle</TT>
method in the <TT>Telephone</TT> class might or might not do anything
like the <TT>Toggle</TT> method in the <TT>Light</TT> classes.
<P>
Compare the following commands:
<BLOCKQUOTE>
<PRE>
oLight = CREATEOBJECT(&quot;Light&quot;)
oPhone = CREATEOBJECT(&quot;Telephone&quot;)
oLight.Toggle()  &amp;&amp;Runs the Toggle method from
                 &amp;&amp;the Light object
oPhone.Toggle()  &amp;&amp;Runs the Toggle method from
                 &amp;&amp;the Phone object
</PRE>
</BLOCKQUOTE>
<P>
Notice how similar the code is between <TT>oLight</TT> and <TT>oPhone</TT>.
You can call the <TT>Toggle</TT> method from either object in
a similar fashion although they might do different things.
<P>
Polymorphism is an extremely useful way to develop classes. It
enables you to put standards in place for naming methods that
do similar things. For example, you can have a <TT>Show</TT> method
for different objects that is designed to bring up the display
portion of the object (for example, <TT>oCust.Show()</TT> might
display the customer form, whereas <TT>oInv.Show()</TT> might
display the invoice form). The beauty of this comes from a user
perspective. It means that you can use the objects with much greater
ease because you can develop a consistent interface when you work
with your classes (imagine the difficulty you would have if the
display method were called <TT>Show</TT> in one class and <TT>Display</TT>
in another).
<H2><A NAME="MessagesMessagesMessages"><FONT SIZE=5 COLOR=#FF0000>
Messages, Messages, Messages</FONT></A></H2>
<P>
Everything you have learned so far that deals with working with
OOP-based systems can be described as &quot;sending a message.&quot;
The following sections redefine previous examples of working with
objects and discuss them in terms of messages.
<H3><A NAME="CreatinganObject">
Creating an Object</A></H3>
<BLOCKQUOTE>
<PRE>
oInv = CREATEOBJECT(&quot;Invoice&quot;)
</PRE>
</BLOCKQUOTE>
<P>
This line of code sends a message to the <TT>Invoice</TT> class
telling it to create an object called <TT>oInv</TT> based on itself.
<H3><A NAME="GettingtheValueofaProperty">
Getting the Value of a Property</A></H3>
<BLOCKQUOTE>
<PRE>
lnAmount = oInv.nAmount
</PRE>
</BLOCKQUOTE>
<P>
This can be described as sending a message to the <TT>oInv</TT>
object and telling it to get the value of the <TT>nAmount</TT>
property and to return it to <TT>lnAmount</TT>.
<H3><A NAME="CallingaMethod">
Calling a Method</A></H3>
<BLOCKQUOTE>
<PRE>
oInv.Display &amp;&amp; Show the Invoice
</PRE>
</BLOCKQUOTE>
<P>
This can be described as sending a message to the <TT>oInv</TT>
object and telling it to execute its <TT>Display</TT> method.
<P>
If you understand the concept of a message, a great deal of the
gobbledygook you read in OOP literature becomes understandable.
For example, polymorphism has been defined in OOP literature as
&quot;the capability to send the same message to different objects
and have different actions take place.&quot; The practical definition
of a message presented in this chapter means the same thing, but
it is easier to understand than the OOP literature definition.
<P>
The moral of this story is this: Do not let the language throw
you.
<H3><A NAME="EncapsulationRevisited">
Encapsulation Revisited</A></H3>
<P>
Taking the concepts that you have seen so far in this chapter,
the concept of <I>encapsulation</I> becomes clearer. Basically,
encapsulation means that an object is a self-contained unit. The
object contains data in the form of properties (also called <I>member
variables</I>) and methods that are associated with the object
to perform whatever actions need to be done.
<P>
You can also create a <TT>Customer</TT> class if you want. You
can associate data and methods with it that encapsulate customer
information and actions.
<P>
A <TT>Customer</TT> object's data could be items such as a name,
address, phone number, credit limit, and so on. Methods associated
with the object could be actions related to displaying customer
data, enabling the user to edit or add customers, printing a customer,
and so on. If you develop naming conventions for your object methods
and properties, using the objects become a breeze.
<P>
<I>Naming conventions</I> means adopting standards for the names
of the methods and properties. A good example would be a method
that displays an object (for example, the form associated with
a customer object). This method could be called <TT>Show()</TT>,
<TT>Display()</TT>, <TT>ShowForm()</TT>, or even <TT>ShowTheFormForThisClassRightNow()</TT>.
To a degree, what you call it really doesn't matter as long as
you are consistent. The only area where you might have problems
is with some of the more popular type of actions such as <TT>Print()</TT>.
If Microsoft has a method that does the type of action the method
does (such as the <TT>Show()</TT> method that shows a form), it
might make sense to adhere to that standard. I am not suggesting
that you are bound to someone else's standard, but imagine the
tower of Babel-type development that will occur if one class calls
the method <TT>Show()</TT>, another calls it <TT>Display()</TT>,
and yet a third uses the name <TT>ShowForm()</TT>. This is not
a situation I would want to be in.
<P>
To illustrate polymorphism, take a look at the following example,
which uses two sample classes: <TT>Customer</TT> and <TT>Invoice</TT>.
Notice how the code, in order to work with the two classes, can
be exceedingly similar at this level. In fact, by using OOP, the
developer who takes the objects and puts them together in the
form of a system will have a much easier job.
<BLOCKQUOTE>
<PRE>
oCust = CREATEOBJECT(&quot;Customer&quot;)
oCust.Show()        &amp;&amp; Show the customer
oCust.Edit()        &amp;&amp; Edit the Customer
oCust.Save()        &amp;&amp; Save Customer
oCust.Print()       &amp;&amp; Print the customer

oInv = CREATEOBJECT(&quot;Invoice&quot;)
oInv.Display()      &amp;&amp; Show the Invoice
oInv.Edit()         &amp;&amp; Edit the Invoice
oInv.Save()         &amp;&amp; Save Invoice
oInv.Print()        &amp;&amp; Print the Invoice
</PRE>
</BLOCKQUOTE>
<H2><A NAME="OOPanditsEffectonDevelopment"><FONT SIZE=5 COLOR=#FF0000>
OOP and its Effect on Development</FONT></A></H2>
<P>
Now that you have seen what objects are and what all the 10-dollar
words mean, the next question is &quot;Big deal. What does this
do for me?&quot;
<P>
OOP shifts the focus of development from coding procedures to
the designing and defining of classes. Because objects are, in
effect, complete and independent modules, it is possible to have
developers who just work on classes of objects. The application
developers can then use these classes, either directly or by subclassing
them, and put them together to form a system.
<P>
Does this mean that after you have a library of classes you will
never need to write code again? Not quite, but a class library
will make your life a lot easier once it is developed, debugged,
and ready to go.
<H2><A NAME="AnalysisandDesignwithOOP"><FONT SIZE=5 COLOR=#FF0000>
Analysis and Design with OOP</FONT></A></H2>
<P>
Object-oriented programming does not start with code. Although
the discussions in this chapter basically center around the implementation
phase of writing objects, this step is the last step in creating
object-oriented software.
<P>
The first step is to analyze the problem domain and to design
the class hierarchies that make up the system. Sounds simple,
right? In fact, object-oriented analysis and object-oriented design
(<I>OOA</I> and <I>OOD</I>) are not difficult processes to perform,
they just require discipline. Many different methodologies have
been proposed and written about over the years. The more popular
authors in this realm are Grady Booch, Ivar Jacobsen, and Rebecca
Wirfs-Brock. Personally, I use the Wirfs-Brock method of CRC cards,
but that is a whole different story. Her book, <I>Designing Object-Oriented
Software</I>, should be required reading for all developers working
on object-oriented analysis and design, in my opinion. But don't
go by just what I recommend because others feel strongly about
other authors.
<P>
Analysts have stated that as much as 70 percent of the time allotted
for an object-oriented project is spent on analysis and design.
That's a lot of time. Therefore, you should take the time you
need to do your research and to find a methodology with which
you are comfortable.
<P>
Whichever methodology you choose, the end result of object-oriented
analysis and design is a coherent, well thought-out, logical class
design that will clearly show the classes in the application as
well as the public interface (that is, the unprotected properties
and methods) and how they interact. When you have all this, coding
can begin.
<H2><A NAME="MultideveloperIssueswithObjectOrientedSoftware"><FONT SIZE=5 COLOR=#FF0000>
Multideveloper Issues with Object-Oriented Software</FONT></A></H2>
<P>
The focus of object orientation, which is based on objects rather
than modules, has another interesting effect on the development
process: It makes multi-developer situations much easier to handle.
If the analysis and design phases have been properly done, the
system is broken down into discrete pieces. The design will call
for a particular class hierarchy and will state what each class
can expect from other classes in the system. After you accomplish
this, coding each class tree can be done independently of others
in the system.
<P>
For example, the design document for a system calls for a <TT>Customer</TT>
class and a <TT>Statement</TT> class. The <TT>Customer</TT> class
calls the <TT>Statement</TT> class to create and print a statement
that shows open invoices for customers. The design document states
what methods and properties are available in the <TT>Statement</TT>
class. There might be a <TT>Create()</TT> method that creates
the statement and accepts a customer number as a parameter, a
<TT>Print()</TT> method that prints the statement, and a property
called <TT>cStatementNumber</TT> for the statement number. The
developer of the <TT>Customer</TT> class could write the following
method:
<BLOCKQUOTE>
<PRE>
PROCEDURE CustomerStatement
     LOCAL loStatement

     *-- The next line creates the object
     loStatement = CREATEOBJECT(&quot;statement&quot;)

     *-- Now create the statement's contents.
     loStatement.Create(this.CustomerNumber)

     *-- Now print the statement
     loStatement.Print()

     *-- Finally, tell the user that we are done
     WAIT WINDOW &quot;Statement number &quot; + ;
                    loStatement.cStatementNumber + ;
                    &quot; has been created and printed!&quot;
ENDPROC
</PRE>
</BLOCKQUOTE>
<P>
You can write this method without ever seeing a line of the <TT>Statement</TT>
object's code. In fact, this is part of the whole point. Just
like you could not care less what makes an elevator work, you
could not care less what makes the <TT>Statement</TT> object tick.
As long as the developer who created the <TT>Statement</TT> class
did the job properly, you can rely on the design document to know
how you need to interact with the class. That's all you need.
<P>
You can test the method by trading files. You should never have
to modify someone else's code-it's none of your business.
<P>
By segregating development in this theoretical manner, OOP creates
a situation that minimizes the need to modify shared code and,
therefore, makes multi-developer teams easier to manage.
<P>
Of course, there is another issue to be dealt with here: the issue
of integrating classes created by developers into the application's
class libraries. This is the job of the class librarian. For more
information on the class librarian, refer to <A HREF="ch16/ch16.htm" >Chapter 16</A>.
<H2><A NAME="SystemMaintenancewithOOP"><FONT SIZE=5 COLOR=#FF0000>
System Maintenance with OOP</FONT></A></H2>
<P>
Users like to change things, right? Using the light example, suppose
that the user changes the base definition of the light switch.
In this example, a light switch has only one property (<TT>Status</TT>)
and one method (<TT>Toggle</TT>). Suppose that the company redefined
the base light switch (the <TT>Light</TT> class) to add another
feature. Now, when the user turns the light off or on, the system
tells the user what has been done.
<P>
In order to accomplish this, all you need to do is to modify the
<TT>Light</TT> class definition as follows:
<BLOCKQUOTE>
<PRE>
DEFINE CLASS light AS custom
     status = &quot;OFF&quot;

     PROCEDURE LightSwitch
          IF this.status = &quot;OFF&quot;
               this.status = &quot;ON&quot;
          ELSE
               this.status = &quot;OFF&quot;
          ENDIF
          WAIT WINDOW &quot;Light is now &quot; + this.status
     ENDPROC
ENDDEFINE
</PRE>
</BLOCKQUOTE>
<P>
From this point on, all objects instantiated from the <TT>Light</TT>
class get the changed method. In effect, you have changed the
behavior of every object based on this class by adding one line
of code to the class definition.
<P>
But wait, there's more. Not only have you modified all the objects
based on the <TT>Light</TT> class, but you have also modified
every object based on subclasses of light (<TT>Dimmer</TT>, for
example). This is a powerful way to develop reusable code.
<P>
The flip side of this is that if you break a class, you might
also break all the subclasses based on it, regardless of the application
in which the class is used. If you have used a class in a production
application, you'll need to be very careful with this.
<HR>
<CENTER>

<A HREF="ch12.htm"><IMG SRC="previous.gif" BORDER="0"></A>
<A HREF="index.htm"><IMG SRC="contents.gif" BORDER=0></A>
<A HREF="ch14.htm"><IMG SRC="next.gif" BORDER=0></A>

<P>&#169; <A HREF="copy.htm">Copyright</A>, Sams Publishing. All
rights reserved.
</CENTER>
</BODY>
</HTML>
