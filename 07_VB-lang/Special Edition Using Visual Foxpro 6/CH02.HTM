<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<SCRIPT LANGUAGE="JavaScript">

<!--

function popUp(pPage) {

 var fullURL = document.location;

 var textURL = fullURL.toString();

 var URLlen = textURL.length;

 var lenMinusPage = textURL.lastIndexOf("/");

 lenMinusPage += 1;

 var fullPath = textURL.substring(0,lenMinusPage);

 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');

 figDoc= popUpWin.document;

 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';

 zhtm += '</head>';

 zhtm += '<BODY bgcolor="#FFFFFF">';

 zhtm += '<IMG SRC="' + fullPath + pPage + '">';

 zhtm += '<P><B>' + pPage + '</B>';

 zhtm += '</BODY></HTML>';

 window.popUpWin.document.write(zhtm);

 window.popUpWin.document.close();

 // Johnny Jackson 4/28/98

 }

//-->

</SCRIPT>
<META>

	<META NAME="Author" Content="Steph Mineart">
	<TITLE>Special Edition Using Visual FoxPro 6 -- Ch 2 - Introduction to Programming Concepts</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<P ALIGN="CENTER"><IMG SRC="que.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM"
BORDER="0">
<H1 ALIGN="CENTER">Special Edition Using Visual FoxPro 6</H1>
<CENTER>
<P><A HREF="ch01.htm"><IMG SRC="previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" BORDER="0"></A> <A HREF="index.htm"><IMG SRC="contents.gif"
WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="ch03.htm"><IMG
SRC="next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> 
<HR>

</CENTER>
<H1>Chapter&nbsp;2</H1>

<H1>Introduction to Programming Concepts</H1>

<UL>
	<LI><A HREF="#WhatIsProgramming">What Is Programming?</A>
	<UL>
		<LI><A HREF="#WhyWriteCode">Why Write Code?</A>
		<LI><A HREF="#LearningtoProgram">Learning to Program</A>
	</UL>
	<LI><A HREF="#CodeElements">Code Elements</A>
	<UL>
		<LI><A HREF="#CommandsandFunctions">Commands and Functions</A>
		<LI><A HREF="#LiteralsandConstants">Literals and Constants</A>
		<LI><A HREF="#MemoryVariables">Memory Variables</A>
		<LI><A HREF="#DataFields">Data Fields</A>
		<LI><A HREF="#Comments">Comments</A>
		<LI><A HREF="#Operators">Operators</A>
		<LI><A HREF="#Evaluators">Evaluators</A>
		<LI><A HREF="#ConditionalExecution">Conditional Execution</A>
		<LI><A HREF="#Loops">Loops</A>
	</UL>
	<LI><A HREF="#CodePackaging">Code Packaging</A>
	<UL>
		<LI><A HREF="#ProgramFiles">Program Files</A>
		<LI><A HREF="#ProceduresandFunctions">Procedures and Functions</A>
		<LI><A HREF="#ObjectMethods">Object Methods</A>
	</UL>
	<LI><A HREF="#SQLVersusProceduralCode">SQL Versus Procedural Code</A>
	<LI><A HREF="#NewinVFP">New in VFP 6</A>
</UL>

<P>
<HR>

<H2><A NAME="WhatIsProgramming"></A><FONT SIZE="5" COLOR="#FF0000"> What Is Programming?</FONT></H2>
<P>Many years ago, when I encountered my first computer, the term &quot;programming&quot;
had a very limited connotation. In fact, the word &quot;computer&quot; itself invariably
evoked an image of a roomful of equipment set off in its own climate-controlled domain,
surrounded by whirring tape drives and ablaze with flashing lights. Programming one
of those iron workhorses meant setting out line after line of cryptic coded symbols
in the mysterious act of communicating with the machine.</P>

<P>There was no GUI. The tools at that time were mainly of the hardware variety,
such as keypunch machines to transform handwritten programs into machine-readable
format and console dials to display and alter problematic memory locations. Debugging
relied heavily on the primitive art of &quot;desk-checking,&quot; a time-consuming
but necessary evil in the days of 24-hour turnaround time. Programmers visually traced
line by line through every branch of a program in order to exercise its logic and
head off failures.</P>

<P>In the most general terms, <I>programming</I> means getting a machine to do what
you want it to do. But the current computer scene is many magnitudes different from
the early days of mainframes, having grown up in a variety of directions. Today's
seemingly infinite combinations of hardware and software have produced correspondingly
complex environments. As the selection of hard and soft components has broadened,
so has the number of ways to accomplish that communication, and programming has come
to mean many things to many people.</P>

<P>Some of the most casual computer users refer to using their employers' custom
applications as &quot;programming.&quot; Others use the term when they undertake
a mail-merge operation through their word-processing program, or enter formulas into
a spreadsheet, or design a building renovation using CAD. Macros and other scripting
tools in some sophisticated programs enable the more adventuresome user to string
together an intricate series of keystrokes and visual commands to perform a complicated
task. In some cases, such as the Microsoft Office suite of applications, the system
generates code from the user's macro entries. This Visual Basic for Applications
(VBA) code can be displayed, saved as a program file, modified by the user, and rerun
in its customized form. Examining code generated by tools is an excellent way to
learn programming syntax.</P>

<P>In the world of Visual FoxPro, with its rich cache of development tools and apparently
overwhelming choices of how to perform any particular task, there are also many different
activities that can be classified as programming, a situation compounded by FoxPro's
own evolution.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>A Brief History of Visual FoxPro</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
In 1984, Fox Software introduced FoxBase to compete with the desktop database product
			it was modeled after, Ashton-Tate's dBASE II. At that time FoxBase was little more
			than a programming language and a data-handling engine. FoxPro acquired a GUI in
			1989, and in 1991 took off solidly in its own innovative territory with the release
			of FoxPro 2.0. That product contained a fully integrated version of SQL, unequalled
			performance capabilities, open architecture in its development tools, and several
			design surfaces that actually generated code and applications from a user's onscreen
			manipulations.</BR> FoxPro evolved into Visual FoxPro in 1995. It retained its procedural
			capabilities, primarily to maintain backward-compatibility, but added tremendously
			to its professional stature by becoming a fully realized object-oriented language
			as well. And, of course, there were still more development tools to work with! VFP
			is now in its third major release, version 6. Its outlook is very much expanded to
			encompass interaction with other major desktop and client/server products, and to
			build Web-based applications.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>At the heart of all such activities, both in and out of the VFP environment, there
is a type of interaction that goes back to the earliest days of computing. In the
remainder of this chapter, you will explore what it means to produce your own programs
using VFP elements and stylistic conventions.
<H3><A NAME="WhyWriteCode"></A>Why Write Code?</H3>
<P>Over the years, FoxPro has grown into Visual FoxPro, and each evolutionary step
has enabled programmers to do more by simply and directly manipulating the tools
supplied with the product. When you used FoxBase, you were responsible for coding
everything, including your application's user interface. With FoxPro 2.0, you were
given Power Tools that generated interface programs for you. Now there are wizards,
builders, and design surfaces that mostly bypass code generation, but create a sophisticated
interface for your applications nonetheless. You don't need to write much code at
all.</P>

<P>So, before you get to the specifics of &quot;how,&quot; let's address the issue
of &quot;why&quot; you should learn to write programs:

<UL>
	<LI>Generic interface components don't know your business rules. You need to add
	code at strategic points to customize an application to your requirements. You can
	make better use of the object model by understanding how and when to extend it with
	code.
	<LI>Code construction concepts apply to all forms of code packaging, whether a program
	of several printed pages or an object method of few lines.
	<LI>The tools themselves are written in code. Understand programming concepts, and
	you will better understand what is going on behind the scenes. As well, some of those
	tools are available as programs for you to examine, study, emulate, or even modify.
	For example, take a look at <TT>GenDBC.prg</TT>, found in the <TT>Tools\GenDBC\</TT>
	subdirectory below your VFP home directory.
	<LI>Invariably you will reach the point where even the most powerful tools don't
	accomplish what you want. You can get around such weaknesses or holes with code.
	A good example of this is the View Designer, which shows you the SQL code generated
	from your selections. The View Designer covers a lot of bases, but sometimes you
	just can't get what you want without resorting to hand coding.
</UL>

<H3><A NAME="LearningtoProgram"></A>Learning to Program</H3>
<P>One of the best ways to learn good programming practices is to find examples and
study them. Well-commented, clearly laid out code will show you the possibilities.</P>

<P>The FoxPro line of development products has historically maintained an open architecture.
Many of the tools that come with it are written in VFP's own language. When you use
the design surfaces to build forms, classes, projects, reports, and database containers,
the details of the entities you create are stored in VFP tables. Many developers
use these programs and components as guidelines for their own programming efforts.</P>

<P>VFP 6 comes with a host of new tools beyond what was supplied in previous versions.
Look for some of them in the subdirectories below the one in which VFP is installed,
also known as <TT>HOME()</TT>. You can switch to it by simply typing <B>CD HOME()</B>
in the Command window, or use the Windows Explorer to browse through the offerings.
You should see subdirectories named Tools and Wizards, which contain many source
items used to build the various applications.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Visual FoxPro versions 3 and 5 came with wizards that generated application components
			to accomplish typical tasks. You could work with what the wizards created, but the
			wizards themselves were supplied in the form of compiled applications. In other words,
			you had no way of knowing how they worked their wizardry. In response to considerable
			outcry from the development community, Microsoft has supplied an even larger number
			of wizards with VFP 6 and a full set of source code for these and other tools. Look
			for a file named <TT>Xsource.zip</TT> in the subdirectory <TT>\Tools\Xsource\</TT>
			under the VFP home directory. Unzip this file and use your software's option to maintain
			the directory structure in the zip file. This will enable you to view all of these
			programs, libraries, project files, and other components.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>As if this weren't enough, VFP 6 comes with a variety of samples that are enhanced
to take advantage of this version's new features. The samples have been moved, along
with the help files, into subdirectories of the MSDN Library that comes with Visual
FoxPro. You can access information about the samples and utilities through the Help
interface, as shown in Figure 2.1, or by typing <B>?HOME(2)</B> in the Command window
to locate the path where you can find the files directly.</P>

<P><IMG SRC="f2-01.gif"><B>Figure 2.1 : </B><I>You can use the
Help file to obtain information about the samples and utilities supplied with VFP.
Click on the appropriate hyperlinks to either run or view source for the various
applications</I>.</A></P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
The term &quot;online help&quot; takes on a whole new meaning with this release of
			VFP. Whether you purchase the standard, standalone development product or the entire
			Visual Studio suite, you receive a single-edition MSDN CD containing all the help
			files, samples, source, and additional support documentation for all the development
			tools. For a nominal yearly fee, you can become an MSDN Library subscriber and receive
			periodic updates. For free, you can access the MSDN Library contents by visiting
			Microsoft's new documentation Web site at <TT>msdn.microsoft.com</TT> (or go directly
			to the Visual FoxPro section at <TT>msdn.microsoft.com/vfoxpro</TT>). The Web site
			contains current technical and marketing product information for all the tools in
			Visual Studio, including samples, demos, and a considerable amount of downloadable
			resources. You will also find links to other sites relating to Visual FoxPro, third-party
			marketing sites, and independent support locations.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>
<H2><A NAME="CodeElements"></A><FONT SIZE="5" COLOR="#FF0000"> Code Elements</FONT></H2>
<P>Just as every spoken language contains nouns, verbs, adjectives, and syntax rules
for putting them all together, so every computer programming language contains certain
basic features. Visual FoxPro's language is no exception, and contains the following:

<UL>
	<LI>Native commands and built-in functions to perform pre-defined actions.
	<LI>Literals and named constants that are used as-is in program operations.
	<LI>Memory variables and arrays to hold transient values of various types.
	<LI>Permanent data stored in tables, and the capability to perform I/O manipulations
	on these structures.
	<LI>Arithmetic operators to use with numbers, and string operators to manipulate
	character data.
	<LI>Logical evaluators to compare entities and select an appropriate response path.
	<LI>Looping constructs that specify conditions for repetitively running portions
	of code.
	<LI>Comments.
	<LI>Syntax, packaging rules, and construction principles that define how all the
	elements fit together.
</UL>

<H3><A NAME="CommandsandFunctions"></A>Commands and Functions</H3>
<P>Visual FoxPro provides a rich supply of instructions to accomplish individual
tasks. Each subsequent release of FoxPro since the earliest days of Xbase has aimed
to maintain backward compatibility with previous versions. Consequently, the language
has become &quot;bloated&quot; with commands that are infrequently used but require
continued support only because their removal would break legacy code. And, of course,
each new release adds exciting new features to the language.
<H4>Syntax</H4>
<P>Documentation for all native VFP commands and functions is available in the Language
Reference portion of the online Help file. Figure 2.2 shows the broad range of activities
handled by the language components. To get to this view, select Help, Microsoft Visual
FoxPro Help Topics from the system menu (or press F1) to bring up the new help file
supplied on a separate CD, MSDN Library Visual Studio 6.0. In the left pane, drill
down through Visual FoxPro Documentation, Reference, Language Overview, Language
Categories, and through the list of command groups. Click on any category to display
a list of instructions in the right-hand pane related by their intended use. Click
on an individual command's hyperlink to reveal more detailed information about its
syntax and use.</P>

<P><IMG SRC="f2-02.gif"><B>Figure 2.2 : </B><I>The numerous categories
of commands appear on the left. Click individual instructions that appear on the
right in order to view more detailed documentation about each command</I>.</A></P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
The lists within each category are not exhaustive. The lists are a start, but check
			the alphabetical listing of the entire set if you don't find what you want in this
			breakdown.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>If you know what instruction you want to use, you can go directly to its detailed
description in various ways:

<OL>
	<LI>Look for the alphabetical list in the Help file's Language Reference.
	<LI>Press F1, click Index, and type in the name you are looking for.
	<LI>Simply type the name of the command you want to know about in the Command Window
	or any editing window, highlight it, and press F1.
</OL>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>TIP</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
The VFP color-coded program editor can provide unexpected visual cues to more information.
			For example, suppose you think you need to write a function to accomplish a task
			you don't know is covered in the native language. If you type a name for it and notice
			it change from standard black to the color of a keyword, you've stumbled over a resource
			you might not have to re-create! Highlight it and press F1 for more information.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>However you arrive at it, you must follow the syntax exactly. VFP provides many
options for issuing and using instructions, but it expects precision in terms of
spelling, arrangement of parameters, and punctuation between clauses and lists.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Since its earliest days, FoxPro has followed the Xbase convention that enables you
			to reduce keywords to their initial four letters. This feature was easier to count
			on with the limited command set of older versions, but it continues to be a handy
			convenience, especially when typing in the Command window. You can type your programs
			this way too, but be forewarned that programs in this format can be hard to follow.
			Not only must you unravel the logic of a routine, but you might first have to translate
			each four-letter root into its expanded keyword.<BR>
			Moreover, Visual FoxPro now includes so many more built-in language components than
			in earlier versions that it has become impossible to ensure uniqueness of those first
			four letters in all cases. Obviously, VFP must recognize a command before it can
			run it, which means you might have to type more than four letters to achieve significance.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>VFP is not case sensitive. Typically, developers adhere to their own standards,
or those of their employers, to differentiate between VFP keywords and user-supplied
options. While some developers type everything in lowercase so that they don't have
to be bothered with the Shift key at all, many follow the practice of coding keywords
in all uppercase, using mixed case for user-defined functions, filenames, variables,
and so on. This is strictly a readability convention, as there are no restrictions
within the language itself that dictate such rules. The same is true of blank lines
and spaces. Within a program, one space is the same as several spaces between words,
and many blank lines are no different from one blank line. The best practice is to
use plenty of blank space and indentations to produce source code that is easy to
read and therefore easy to maintain.
<H4>Behavior</H4>
<P><I>Commands</I>, like direct orders, are words grouped together to instruct the
computer to take an action. Visually, they differ from functions, which are also
computer instructions, in that functions end in a pair of parentheses. The parentheses
can be empty or they can contain any parameters recognized by that function. Traditionally,
a function returns a result, and that result is available at the point where the
function call is made, as shown in this example:


<BLOCKQUOTE>
	<PRE>ldDate = DATE()

</PRE>

</BLOCKQUOTE>

<P>In this line of code, the variable <TT>ldDate</TT> contains today's date after
the function executes.</P>

<P>There are various ways to issue a function call:

<UL>
	<LI>Include a function call in an assignment, which is then available for further
	use by your program.
</UL>



<BLOCKQUOTE>
	<PRE>lnStart = SECONDS()                  &amp;&amp; Number of seconds since midnight

     &lt; Other program commands &gt;

lnDuration = SECONDS() - lnStart     &amp;&amp; Calculate elapsed time

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>Embed it in a logical test.
</UL>



<BLOCKQUOTE>
	<PRE>IF TABLEUPDATE()

     &lt; Some processing if function was successful &gt;

ENDIF

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>Make it the object of a command of some sort.
</UL>



<BLOCKQUOTE>
	<PRE>?SEEK(lcRecord, lcTable, lcIndex)     &amp;&amp; Display results of search

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>Nest it within another function call.
</UL>



<BLOCKQUOTE>
	<PRE>lnCurentMonth = MONTH( DATE() )

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>Precede it with an equal sign.
</UL>



<BLOCKQUOTE>
	<PRE>=ASORT(laArray)     &amp;&amp; Sort an array

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>Make an unadorned function call.
</UL>



<BLOCKQUOTE>
	<PRE>ADIR(laFiles, '*.PRG')     &amp;&amp; Create array, one entry per program file




</PRE>

</BLOCKQUOTE>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Sometimes you don't care what the return value is. You want a function to perform
			simply as a command, and you're willing to accept its default behavior. Unadorned
			function calls, which didn't exist prior to VFP 5.0, can apply to native functions,
			user-defined functions, and object methods.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>
<H3><A NAME="LiteralsandConstants"></A>Literals and Constants</H3>
<P>The simplest form of information you can use in your code is unvarying data that
you supply directly to your routines. A value that is coded into the routine that
uses it is taken literally and thus is called a <I>literal</I>. For example:


<BLOCKQUOTE>
	<PRE>lnWeeks = lnDays / 7                &amp;&amp; The number of days in a week is always 7

MessageBox('Processing Complete')   &amp;&amp; The message is always the same

lnElapsed = DATE() - {06/01/1998}   &amp;&amp; The start date remains the same

DIMENSION aArray[15,3]              &amp;&amp; The size of this array is fixed

</PRE>

</BLOCKQUOTE>

<P>If you assign a name to a literal, it becomes a <I>constant</I>. All references
to that name in your code will be replaced by the value you supply. If you need to
change the value, you only have to change it in one place, where the assignment is
made, as shown in this example:


<BLOCKQUOTE>
	<PRE>lnEmployeeCount = 53

     &lt;Some processing&gt;



FOR lnI = 1 TO lnEmployeeCount

     &lt;Print invitations to the company picnic&gt;

ENDFOR


</PRE>

</BLOCKQUOTE>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>TIP</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
It's not a good idea to embed literals throughout your programs, particularly if
			there's the slightest chance that these values can change. Name them descriptively
			as constants and place them prominently in your code, usually in the beginning, for
			easier maintenance. Better yet, find a central place to store constants that pertain
			to your application. You can read such constants out of a data table or locate them
			in object properties.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>

<H4>Runtime Versus Compile Time</H4>
<P>Constants can be assigned at runtime, as shown in the previous example, or at
compile time with <TT>#DEFINE</TT> directives, such as the following:


<BLOCKQUOTE>
	<PRE>#DEFINE ZERO 0.

</PRE>

</BLOCKQUOTE>

<P>Groups of <TT>#DEFINE</TT> statements can be maintained in a separate <TT>#INCLUDE</TT>
file that you add to the beginning of your programs. Memory usage is reduced somewhat
because the substitution is made during compilation, and resources are immediately
released. This can, arguably, increase performance because the named constants don't
need to stay in memory and references have already been resolved by the time they
are encountered.
<H3><A NAME="MemoryVariables"></A>Memory Variables</H3>
<P>It's not always reasonable to expect to know ahead of time all the values that
you want your code to use. Just as in an algebraic expression, you can assign a name
to a value and then use that name as a stand-in for the actual value anywhere in
your program code.</P>

<P>The simplest way to assign a value to a name is with the equal sign (<TT>=</TT>).
You can also use <TT>STORE SomeValue TO SomeName</TT>. This syntax is convenient
when you want to assign a single value to many variables at once:


<BLOCKQUOTE>
	<PRE>STORE 0 TO lnOne, lnTwo, lnThree, lnFour, lnFive

</PRE>

</BLOCKQUOTE>

<H4>Data Types</H4>
<P>Visual FoxPro enables you to manage a rich assortment of data types in memory.</P>

<P>In VFP, a variable takes on the characteristics of the data it contains. If <TT>x
= 5</TT>, <TT>x</TT> is a numeric variable. If the value of <TT>x</TT> is changed
so that <TT>x = 'ABC'</TT>, the variable's type is also changed to character. Furthermore,
a variable that hasn't been established in any formal way is simply created the first
time you refer to it by assigning it a value.</P>

<P>This chameleon-like quality of VFP variables is known as <I>weak-typing</I>, a
distinguishing characteristic of the language that is not universally shared. Other
languages, such as C++, require that you declare variables before you use them and
that you identify and stick to their assigned data type.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Weak-typing can get you in trouble in your programs. Commands and functions expect
			to find data in a particular form. If you refer to a variable of the wrong type,
			as shown in Figure 2.3, your code will generate an error.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P><IMG SRC="2-03.gif"><B>Figure 2.3 : </B><I>Even though the
value of x is 4, it's in character form, not numeric as the square root function
expects it to be</I>.</A></P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Prior to VFP 6, the only sure way to determine a variable's current type was to test
			it with the <TT>TYPE()</TT> function. Unfortunately, the syntax for this function
			causes untold confusion. <BR>
			The argument you pass to <TT>TYPE()</TT> within the parentheses must be a character
			expression. This means that you pass the name of the variable surrounded by quotes,
			not the variable itself. If you are passing an expression or a literal, it must also
			be in quotes. It is very easy to get <TT>&quot;U&quot;</TT> (for undefined) or an
			error message returned from the <TT>TYPE()</TT> function. <BR>
			VFP 6 has a new and very welcome <TT>VARTYPE()</TT> function that is much more straightforward.
			You simply pass the variable, data, or expression you are interested in, and the
			return value is its current type.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>
<H4>Scope</H4>
<P><I>Scope</I> refers to the life span and visibility of a variable. Variables can
be

<UL>
	<LI>Public
	<LI>Private
	<LI>Local
</UL>

<P><I>Public variables</I>, also known as <I>global variables</I>, can be seen and
used in any routine during the current VFP session. They remain in memory until they
are released or until VFP terminates.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Traditionally one program passed information to others via global variables. These
			might include logical flags indicating that certain processes had finished, so it
			was okay for something else to start. Now that VFP provides an object-oriented environment,
			many developers prefer to pass object references instead of memory variables because
			an object can contain a whole range of related data and behavior in its packaging.
			See Part IV, &quot;Object-Oriented Programming,&quot; for more information on how
			this is accomplished.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P><I>Private variables</I> exist in the current program. They are automatically
released when the current program terminates if they haven't been specifically released
before then. Private variables are also visible to any routines called by this one,
which can lead to confusion in the called routine if it has its own variables with
the same name. If no other declaration is made about a variable's type, VFP assumes
that it is private.</P>

<P><I>Local variables</I> have been around since VFP 3, and they only exist in the
current routine. If a variable is local to an object method or other subroutine,
it is released when the routine finishes.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>TIP</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">


			<BLOCKQUOTE>
			<P>Subroutines should declare all their variables as local in order to guard against
			using an unintended variable from a higher level program. This is done with a statement
			like this: </P>
			<PRE><TT>LOCAL lcName, lnNumber, ldDate</TT>
</PRE>
			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>CAUTION</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Explicit declarations of scope do not create variables or guarantee data type. <TT>PUBLIC
			gcPubVar</TT>, <TT>PRIVATE pnNumVar</TT>, and <TT>LOCAL ldDateVar</TT> only establish
			the intended life span of those variables once they are created. Until values are
			assigned, the variable type remains undefined, regardless of scope.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P><B>Arrays&nbsp;&nbsp;</B>An <I>array</I> is a group of memory variables maintained
as a unit. It can be visualized as a spreadsheet, where horizontal rows intersect
with vertical columns at individual points called <I>cells</I>, and each cell can
hold a piece of information. In fact, each cell can hold information of a different
type from that of its neighboring cells.</P>

<P>Arrays are akin to data tables, with which they share terminology. Table records
are sometimes called <I>rows</I>, table fields are referred to as <I>columns</I>,
and the many fields in a given record can be of mixed types.</P>

<P>Of course, tables are permanent representations of data that can be used from
session to session, whereas arrays are more like variables in that they remain in
memory for the duration of their processing life, and then they are released. While
an array is in scope, you can access any single cell of data by its row and column
numbers, like this:


<BLOCKQUOTE>
	<PRE>laPayment[1,5] = laPayment[1,3] * lnRate

  &amp;&amp; Multiply hours x Rate for this entry


</PRE>

</BLOCKQUOTE>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Notice in the preceding line of code that the array coordinates are set off between
			square brackets (<TT>[]</TT>). This is not a requirement, as parentheses could just
			as easily be used for the same purpose. Many developers use brackets, however, to
			distinguish array cell references from function calls.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>Arrays are very handy constructs for preparing intermediate results in the course
of a routine. Because they remain entirely in memory, access is very fast. VFP has
many native array-handling functions that are very efficient at filling, searching,
sorting, and arranging data in arrays.</P>

<P><B>Naming Conventions&nbsp;&nbsp;</B>Because of the confusion that can arise when
a routine uses data of the wrong type or references a variable that has gone out
of scope, many developers have adopted the recommended practice of embedding scope
and type information into variable names. Typically a two-letter, lowercase prefix
is concatenated to a descriptive name, such as <TT>lcStudentID</TT>, <TT>pdToday</TT>,
or <TT>glOkToContinue</TT>. The prefix letters and their meanings are listed in Table
2.1.</P>

<P><B>Table 2.1&nbsp;&nbsp;Typical Prefixes for Variable Naming Conventions<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD COLSPAN="2"><B>Scope (First Letter)</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><B>Letter</B>
		</TD>
		<TD WIDTH="192">
			<P ALIGN="CENTER"><B>Meaning</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">l
		</TD>
		<TD WIDTH="192">Local</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">p
		</TD>
		<TD WIDTH="192">Private</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">g
		</TD>
		<TD WIDTH="192">Public (global)</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">t
		</TD>
		<TD WIDTH="192">Parameter</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD COLSPAN="2"><B>Type (Second Letter)</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">a
		</TD>
		<TD WIDTH="192">Array</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">c
		</TD>
		<TD WIDTH="192">Character</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">y
		</TD>
		<TD WIDTH="192">Currency</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">d
		</TD>
		<TD WIDTH="192">Date</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">t
		</TD>
		<TD WIDTH="192">Datetime</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">b
		</TD>
		<TD WIDTH="192">Double</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">f
		</TD>
		<TD WIDTH="192">Float</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">l
		</TD>
		<TD WIDTH="192">Logical</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">n
		</TD>
		<TD WIDTH="192">Numeric</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">o
		</TD>
		<TD WIDTH="192">Object</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">U
		</TD>
		<TD WIDTH="192">Unknown</TD>
	</TR>
</TABLE>
</P>

<P><B>Indirect Referencing and Macro Expansion&nbsp;&nbsp;</B>So far, you've looked
at instructions and memory resident data. You've learned that commands and functions
pose direct instructions to the computer and pass arguments that are actual pieces
of information or named variables that stand in for data.</P>

<P>Some commands, particularly those that work with data in tables, expect names
as arguments: names of tables, names of fields, names of reports. Names aren't subject
to assignment in the same way that data can be assigned to a variable name. Yes,
you can populate a variable with a name, but then it is simply a character string
that has lost its inherent meaning.</P>

<P><I>Indirect referencing </I>enables you to issue commands using names that vary.
For example, you might read the name of the current backup file out of a field in
a system table. In your program, you then surround that name with parentheses to
indicate that the character string actually represents a name of another entity,
and it's that other entity you want to reference:


<BLOCKQUOTE>
	<PRE>lcFileName =  System.Backup

USE (lcFileName) IN 0 ALIAS Backfile

</PRE>

</BLOCKQUOTE>

<P>You can take the issue of indirection a step further. Sometimes you are not even
sure what <I>instructions</I> you want to run. In that case, you can extend the power
of the VFP language by building strings of commands, clauses, and other reserved
keywords, and then use them as if they were written into your program.</P>

<P>To accomplish this feat, you use a technique called <I>macro expansion</I>. Simply
add an ampersand (<TT>&amp;</TT>) to the front of a variable name, which signals
to VFP that the literal contents of the variable should become part of the current
execution string. The following is a simple example that shows how this feature works.
Type it in the Command window and press F9:


<BLOCKQUOTE>
	<PRE>x = &quot;ON KEY LABEL F9 WAIT WINDOW 'I pressed F9' &quot;

&amp;x

</PRE>

</BLOCKQUOTE>

<P>Macro expansion is often used to restore environment settings at the end of a
routine in which they have been changed. For example:


<BLOCKQUOTE>
	<PRE>lcTalk = SET( 'TALK' )       &amp;&amp; Capture the setting of TALK

SET TALK ON

SELECT * FROM MyDBF ;

     WHERE &lt; criteria &gt;

SET TALK &amp;lcTalk             &amp;&amp; Restore TALK the way it was before

</PRE>

</BLOCKQUOTE>

<H3><A NAME="DataFields"></A>Data Fields</H3>
<P>Data that is kept in a table is subject to more rigorous identification than data
in memory variables. Each field in the table has a fixed size and data type. Further,
if the table is part of a database, there can be rules set up in database stored
procedures that monitor values, conditions of uniqueness, and relationships with
other tables.</P>

<P>Because data fields are limited to some predefined presentation, it is not as
important to impose naming conventions on them. A data field of numeric type will
not accept characters, for example. A logical field can only accept values of <TT>.T.</TT>
(True) or <TT>.F.</TT> (False), no matter what you might try to enter instead. Field
characteristics are stored in the table header and are available to the application
on request.</P>

<P>See Part II, &quot;Working with Data,&quot; for more information about data in
tables and databases.
<H3><A NAME="Comments"></A>Comments</H3>
<P>A comment line is one that starts with an asterisk (<TT>*</TT>) or the word <TT>NOTE</TT>.
You can also add comments to any line of code by skipping at least one space and
typing two ampersands (<TT>&amp;&amp;</TT>). Everything from the ampersands to the
end of the line is considered a comment and is ignored by VFP.</P>

<P>Even though they are not compiled or run, comments serve a very important purpose
in programming. Code can be very complex. Once it is written and in use, a program
might not be looked at for months. Frequently the only reason to go back through
a working program is that some new set of circumstances has caused it to fail. Code
that is difficult to read is even more difficult to fix and maintain. Liberal additions
of comments that spell out a routine's intended behavior make the task much easier
for whoever has to pick up the logical threads. You will appreciate the effort even
if it is your own code you are reviewing.</P>

<P>It is also a very good idea to place a heading of comment lines at the beginning
of your coded routines. You might include such things as program author, creation
date, purpose, expected output, parameter identification, and calling syntax. Many
development shops set a standard look for such headers, which then serve as part
of the overall project documentation.
<H3><A NAME="Operators"></A>Operators</H3>
<P>VFP supplies a full set of symbol <I>operators </I>that manipulate data according
to its type. The operations can be strung together to form complex expressions, but
all data within such an expression must be of the same type. Some of the symbols
produce different behaviors for different data types, as shown in Tables 2.2 through
2.5.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Each table's set of symbols is presented in the priority order in which they are
			evaluated within an expression. It is the same concept that you learned in high school
			math: My Dear Aunt Sally stood for Multiplication, Division, Addition, Subtraction.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P><B>Table 2.2&nbsp;&nbsp;Character String Operators<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><B>Operator</B>
		</TD>
		<TD WIDTH="288">
			<P ALIGN="CENTER"><B>Action</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>+</TT>
		</TD>
		<TD WIDTH="288">Concatenates two character values.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>-</TT>
		</TD>
		<TD WIDTH="288">Concatenates, while removing trailing blanks from the first value.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>$</TT>
		</TD>
		<TD WIDTH="288">Searches for one character string within a second.</TD>
	</TR>
</TABLE>
</P>

<P><B>Table 2.3&nbsp;&nbsp;Arithmetic Operators<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><B>Operator</B>
		</TD>
		<TD WIDTH="288">
			<P ALIGN="CENTER"><B>Action</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>(&nbsp;)</TT>
		</TD>
		<TD WIDTH="288">Groups values to increase execution priority</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>**</TT>, <TT>^</TT>
		</TD>
		<TD WIDTH="288">Exponentiation</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">*
		</TD>
		<TD WIDTH="288">Multiplication</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER">/
		</TD>
		<TD WIDTH="288">Division</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>%</TT>
		</TD>
		<TD WIDTH="288">Modulus (remainder from division)</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>+</TT>
		</TD>
		<TD WIDTH="288">Addition</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>-</TT>
		</TD>
		<TD WIDTH="288">Subtraction</TD>
	</TR>
</TABLE>
</P>

<P><B>Table 2.4&nbsp;&nbsp;Logical Operators<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><B>Operator</B>
		</TD>
		<TD WIDTH="288">
			<P ALIGN="CENTER"><B>Action</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>()</TT>
		</TD>
		<TD WIDTH="288">Groups values to increase execution priority</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>NOT</TT>, <TT>!</TT>
		</TD>
		<TD WIDTH="288">Logical negative; reverses an item's value</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>AND</TT>
		</TD>
		<TD WIDTH="288">Logical <TT>AND</TT></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>OR</TT>
		</TD>
		<TD WIDTH="288">Logical inclusive <TT>OR</TT></TD>
	</TR>
</TABLE>
</P>

<P><B>Table 2.5&nbsp;&nbsp;Date Math Operators<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><B>Operator</B>
		</TD>
		<TD WIDTH="288">
			<P ALIGN="CENTER"><B>Action</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>+</TT>
		</TD>
		<TD WIDTH="288">Addition (produces a date in the future)</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>-</TT>
		</TD>
		<TD WIDTH="288">Subtraction (calculates duration)</TD>
	</TR>
</TABLE>
</P>

<P>
<H3><A NAME="Evaluators"></A>Evaluators</H3>
<P>VFP uses a set of symbols, listed in Table 2.6, to evaluate the logical truth
of an expression. These symbols, also known as <I>relational operators</I>, compare
two values of the same type, resulting in a value of <TT>.T.</TT> if true or <TT>.F.</TT>
if false.</P>

<P><B>Table 2.6&nbsp;&nbsp;Logical Evaluators<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><B>Symbol</B>
		</TD>
		<TD WIDTH="288">
			<P ALIGN="CENTER"><B>Comparison</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>&lt;</TT>
		</TD>
		<TD WIDTH="288">Less than</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>&gt;</TT>
		</TD>
		<TD WIDTH="288">Greater than</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>=</TT>
		</TD>
		<TD WIDTH="288">Equal to</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>&lt;&gt;</TT>, <TT>#</TT>, <TT>!=</TT>
		</TD>
		<TD WIDTH="288">Not equal to</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>&lt;=</TT>
		</TD>
		<TD WIDTH="288">Less than or equal to</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>&gt;=</TT>
		</TD>
		<TD WIDTH="288">Greater than or equal to</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="96">
			<P ALIGN="CENTER"><TT>==</TT>
		</TD>
		<TD WIDTH="288">Exact string comparison</TD>
	</TR>
</TABLE>
</P>

<P>
<H3><A NAME="ConditionalExecution"></A>Conditional Execution</H3>
<P>You won't always want your code to run every line for every condition. The power
of programming languages comes from the capability to decide whether a particular
action is appropriate to each and every different type of data or some other environmental
circumstance. In VFP, you use these constructs to determine whether to proceed with
one or another set of options:

<UL>
	<LI>Use <TT>IF…ENDIF</TT> for one or two options. You can nest <TT>IF</TT> statements,
	but this can result in unwieldy levels of complexity.
</UL>



<BLOCKQUOTE>
	<PRE>IF lnAge &gt; 10

     IF lnAge &gt; 15

          IF llAllRequirementsFilled

               &lt; Schedule graduation &gt;

          ELSE

               &lt; Schedule counseling &gt;

          ENDIF

     ELSE

          &lt; Schedule a particular test &gt;

     ENDIF

ELSE

     &lt; Schedule a practice session &gt;

ENDIF

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>A single <TT>IIF()</TT> (Immediate <TT>IF</TT>) function is permissible in place
	of the <TT>IF…ENDIF</TT> construct, and is particularly useful when you are restricted
	to one line, such as in a report, label, or SQL statement. You supply three parameters
	to <TT>IIF()</TT>: a logical expression to test, an action to take if the expression
	evaluates to true, and an action to follow if the expression is false. As with <TT>IF…ENDIF</TT>,
	you can nest <TT>IIF()</TT> statements. Be forewarned that such complexity can be
	<I>very</I> difficult to debug.
</UL>



<BLOCKQUOTE>
	<PRE>lcGrade = IIF(lnGPA &gt; 2.0, 'Passed', 'Failed')

lcMaritalStatus = IIF(UPPER(lcCode) = 'M', 'Married', ;

IIF(UPPER(lcCode) = 'D', 'Divorced', ;

IIF(UPPER(lcCode) = 'S', 'Single', 'Unknown') ) )

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>To evaluate a series of mutually exclusive conditions and specify different actions
	for each, use <TT>DO CASE…ENDCASE</TT>.
</UL>



<BLOCKQUOTE>
	<PRE>DO CASE

     CASE lnGroupSize &lt; 10

          lnRate = lnFullRate

     CASE lnGroupSize &lt; 25

          lnRate = lnFullRate * ln1stDiscount

     OTHERWISE

          lnRate = lnFullRate * ln2ndDiscount

ENDCASE

</PRE>

</BLOCKQUOTE>

<H3><A NAME="Loops"></A>Loops</H3>
<P><I>Looping constructs</I> are special types of commands that divert program execution
from its straight-line path. Loops enable you to specify some logical condition that
determines whether to repeat a selected set of instructions or continue with the
processing stream beyond the loop.</P>

<P>A loop consists of a pair of commands that bracket a coded routine. A condition
is tested at the beginning of the loop, and if it evaluates to true, the subsequent
instructions are run; otherwise, control continues after the <TT>END</TT> statement.
VFP offers the following ways to execute loops:

<UL>
	<LI><TT>DO WHILE…ENDDO</TT>&nbsp;&nbsp;The condition included on the first line is
	evaluated. If it is true, VFP runs through the subsequent code. Whenever execution
	reaches <TT>ENDDO</TT>, VFP reevaluates the initial expression. As long as the condition
	remains true, the same set of instructions will be run over and over again.
</UL>



<BLOCKQUOTE>
	<PRE>DO WHILE lnNumEnrolled &lt; lnMaxSize

     &lt; Continue enrolling students until the class is full &gt;

ENDDO

</PRE>

</BLOCKQUOTE>


<UL>
	<LI><TT>SCAN…ENDSCAN</TT>&nbsp;&nbsp; This command construct is used to process an
	entire data file. When VFP encounters <TT>ENDSCAN</TT>, control returns to the top
	of the loop, where it tests for an end-of-file condition. As long as the implied
	<TT>!EOF()</TT> condition remains true, each record in turn is subjected to the code
	that follows. Additional conditions can be applied by including <TT>FOR</TT> and/or
	<TT>WHILE</TT> clauses:
</UL>



<BLOCKQUOTE>
	<PRE>SCAN FOR Employee.Status = 'Active'

     &lt; Processing applies only to current employees &gt;

ENDSCAN

</PRE>

</BLOCKQUOTE>


<UL>
	<LI><TT>FOR…ENDFOR</TT>&nbsp;&nbsp; VFP can be instructed to run through a loop a
	certain number of times. Use fixed values, variables, or expressions to determine
	the number of iterations of the loop:
</UL>



<BLOCKQUOTE>
	<PRE>For lnI = 1 TO ALEN(aVendors, 1)

     &lt; Write checks for each of the vendors in the array &gt;

ENDFOR

</PRE>

</BLOCKQUOTE>


<UL>
	<LI>A VFP variant: <TT>FOR EACH…ENDFOR</TT>&nbsp;&nbsp;This loop can be applied to
	every item in an array or in a VFP collection, without having to know how many items
	meet the existence test. This example looks at each column in turn, regardless of
	how many there are in the grid, and increases its size:
</UL>



<BLOCKQUOTE>
	<PRE>FOR EACH oColumn IN THIS.oGrid.Columns

     oColumn.Width = oColumn.Width * 1.25

     oColumn.Text1.Width = oColumn.Width

ENDFOR

</PRE>

</BLOCKQUOTE>

<P>All of these looping mechanisms enable you to use a <TT>LOOP</TT> or an <TT>EXIT</TT>
command to escape processing before reaching the <TT>END</TT> statement. <TT>LOOP</TT>
sends you back to the top to reevaluate the continuation condition. <TT>EXIT</TT>
takes program control beyond the end of the loop to the remainder of the program.
See <A HREF="ch23.htm">Chapter 23</A>, &quot;Error Detection and Handling,&quot;
for more information about loops.
<H2><A NAME="CodePackaging"></A><FONT SIZE="5" COLOR="#FF0000"> Code Packaging</FONT></H2>
<P>You can enter and run lines of code in the VFP Command window. In earlier versions
of FoxPro, you could only enter a single line of code at a time followed by a press
of the Enter key. Certain coding constructs that require multiple lines, such as
<TT>IF…ENDIF</TT> or <TT>DO…ENDDO</TT>, could not be run in the Command window because
the Enter key also acted as a signal to run whatever was typed.</P>

<P>In VFP, this limitation has been lifted. You can enter as many lines of code as
you want and use the mouse or keyboard arrow keys to reposition the cursor. When
you're done, highlight all the lines you typed and press Enter, or right-click the
mouse and choose Execute Selection. The entire block runs as if it were a single
line of code.</P>

<P>Running code in the Command window is a good way to test that it performs as you
expect it to and to work out any kinks. If you want to be able to run it again without
typing it every time, you must save the code block in a file as a program, procedure,
function, or method.
<H3><A NAME="ProgramFiles"></A>Program Files</H3>
<P>A VFP <I>program </I>is simply a text file with a <TT>.PRG</TT> extension. You
create such a file when you type <B>MODIFY COMMAND</B> in the Command window. VFP
opens an editing window with the default name <TT>Program1.prg</TT>. You have the
option of changing that name when you save the file for the first time, or you can
choose File, Save As from the system menu. If you type <B>MODIFY COMMAND MyProg</B>,
VFP will first look for a program named <TT>MyProg.prg</TT> in its path. If it finds
the file, VFP opens it for editing. If it doesn't find a match, it opens a new empty
window with that name.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>TIP</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
Remember that because you can abbreviate most VFP instructions to four characters,
			you can type <B>MODI COMM</B> to accomplish the same thing as <B>MODIFY COMMAND</B>.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>Now that you have an open window, enter your program, one instruction per line.
It improves program readability to keep lines of code to a length that is viewable
on a computer screen or a printed page. If one line isn't enough to complete an instruction,
VFP enables you to continue onto the next line by typing a semicolon (<TT>;</TT>)
at the end of the current line. Program readability is more than a stylistic concern.
You will find that your programs are easier for you and others to maintain if you
format them simply and clearly and keep a minimal amount of information on each line.</P>

<P>After you enter all required lines of source code into your program, you can direct
VFP to convert it into object code by selecting Program, Compile from the menu. This
step is not required, however, because VFP will compile it when it needs to-for example,
when you type <B>DO MyProg</B> in the Command window. Regardless of when the program
is compiled, VFP creates an <TT>.FXP</TT> file of the same name (<TT>MyProg.fxp</TT>)
in the same directory where it finds the <TT>.PRG</TT> file (<TT>MyProg.prg</TT>).</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>TIP</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
VFP bases its decision to compile on DOS file dates. Unless you issue a specific
			directive to compile, VFP will not recompile if it finds an <TT>.FXP</TT> file that
			is newer than the <TT>.PRG</TT> file of the same name in the same directory. This
			can lead to confusion over which version of code you are running. It is always safe
			to delete any questionable <TT>.FXP</TT> files and let VFP recompile what it needs.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>For purposes of compiling or running code, VFP assumes that anything it finds
in a program file is program code, with the exception of comments.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>CAUTION</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
If a comment line ends in a semicolon, VFP treats the following line as a continuation
			of the comment, even if the next line doesn't begin with an asterisk. VFP continues
			to concatenate lines as long as it encounters semicolons, excluding more code than
			you might intend, as shown in the following code sample:			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>


<BLOCKQUOTE>
	<PRE>SET PATH TO

* I've changed the first line of the SET PATH statement,

* but I want to save it so I can change it back.

* SET PATH TO \olddata, \oldlibs, ;

SET PATH TO data, libs, ;

     progs, include, ;

     graphics, menus, ;

     metadata, reports

DO MyProg     &amp;&amp; VFP will not be able to find progs\MyProg.prg

</PRE>

</BLOCKQUOTE>

<H3><A NAME="ProceduresandFunctions"></A>Procedures and Functions</H3>
<P>By definition, a program file is a standalone <TT>.PRG</TT> file. There are no
other special directives to identify it as such. A program file, however, can contain
subroutines known as <I>procedures</I> and <I>functions</I> that you can run from
within or outside your program. Functions are also known as <I>UDFs</I>, or <I>user-defined
functions</I>. Subroutines can be packaged with other commonly used routines into
a procedure file that makes no pretense of being anything more than a container.
Such a file can be identified by a <TT>.PRC</TT> or <TT>.PRG</TT> extension.</P>

<P>A procedure is a routine in which the first and last lines are defined as follows:


<BLOCKQUOTE>
	<PRE>PROCEDURE ProcedureName

     &lt;your code lines&gt;

ENDPROC

</PRE>

</BLOCKQUOTE>

<P>Likewise, a function is a coded routine bracketed by <TT>FUNCTION…ENDFUNC</TT>
commands.</P>

<P>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="600"><B>NOTE</B></TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="600">

			<BLOCKQUOTE>
<TT>ENDPROC</TT> and <TT>ENDFUNC</TT> can be replaced with <TT>RETURN</TT>, but any
			of the three are strictly for readability. You actually don't need to enter any type
			of terminating command, because VFP will recognize the end of the routine when it
			encounters an end of file or the start of another <TT>PROCEDURE</TT> or <TT>FUNCTION</TT>.			</BLOCKQUOTE>
		</TD>
	</TR>
</TABLE>
</P>

<P>Typically, you execute a procedure the same way you would a program: via <TT>DO
ProcedureName</TT> or <TT>DO ProcedureName IN ProgramName</TT>. A function call looks
different. You simply type the function name followed by a set of parentheses:


<BLOCKQUOTE>
	<PRE><I>FunctionName</I>()

</PRE>

</BLOCKQUOTE>

<P><B>Program Flow&nbsp;&nbsp;</B> At runtime, program instructions are executed
line by line, one after another, except in the case of subroutines. When your program
encounters an instruction to run a procedure or a function, it's as if all the lines
of code in that routine were inserted immediately after your call. This is true whether
the subroutine is in the same or a different file. At the completion of the subroutine
code, execution continues at the line following the call, as shown in this example:


<BLOCKQUOTE>
	<PRE>* This is the main program.

ACTIVATE SCREEN

?'Executing main program code.'

DO Proc1

?'Back in the main program after Proc 1'

x = Func1()

?'x = ' + x

?'Remaining program statements go here.'

RETURN



PROCEDURE Proc1

     ?'Executing 1st line of subroutine: Proc1'

     ?'Executing 2nd line of subroutine: Proc1'

ENDPROC



FUNCTION Func1

     LOCAL lcReturnVal

     ?'Executing subroutine code: Func1'

     lcReturnVal = 'Character string prepared in Func1'

RETURN lcReturnVal

</PRE>

</BLOCKQUOTE>

<P>You can place as many procedures and/or functions as you want within a single
file, but they must all appear after the last line of your main program. Don't type
any lines of main program code following the subroutines, as they will never be reached
at runtime.</P>

<P><B>What's the Point?&nbsp;&nbsp;</B>You might be asking: If a subroutine is executed
as if it were an inline part of the main program, why bother with moving it off to
another location?</P>

<P>Subroutines add power and flexibility to a program. Name them descriptively, pass
them parameters, and you can do any of the following:

<UL>
	<LI>Rerun the same routine many times without recoding.
	<LI>Run the same routine from different parts of the program, or even from different
	programs.
	<LI>Expect different results based on variable information passed in to the routines
	in the form of parameters.
	<LI>Maintain an uncluttered, readable main program that clearly outlines the major
	steps without getting bogged down in detail.
</UL>

<P><B>What's the Difference?&nbsp;&nbsp;</B>Up to now I've talked about procedures,
functions, and subroutines as if they were all the same. So, what is the difference?
The simple answer is that conceptually there is no difference! They are all just
routines subordinate to a program with many variations in how you can interact with
them.</P>

<P>By convention, a function returns a value (but it doesn't have to) and a procedure
probably does not return anything (but it can). After the first line, the differences
are so easily overridden as to be academic. The major difference is that procedures
and functions make different default assumptions about the nature of parameters passed
to them. But again, these default assumptions are easily changed to suit your needs.</P>

<P>Even the different calling styles for procedures and functions are not hard-and-fast
rules. You can run a function as if it were a procedure:


<BLOCKQUOTE>
	<PRE>DO FunctionName

</PRE>

</BLOCKQUOTE>

<P>And you can call a procedure as you would a function, via assignment to a variable:


<BLOCKQUOTE>
	<PRE>lcVar = <I>ProcedureName</I>()

</PRE>

</BLOCKQUOTE>

<P><B>Passing Parameters&nbsp;&nbsp;</B> Much of a subroutine's power comes from
being able to perform actions on a variety of data. If you want the calling program
to supply information for use in the subroutine, the first non-comment line of code
after <TT>PROCEDURE</TT> or <TT>FUNCTION</TT> must be <TT>PARAMETERS</TT> or <TT>LPARAMETERS</TT>.
<TT>LPARAMETERS</TT>, like the <TT>LOCAL</TT> declaration itself, specifies that
the scope is local to the subroutine. Parameters can be any type of data or expressions,
up to 27 in a single routine.</P>

<P>By default, parameters are passed to a procedure by reference and to a function
by value. <I>By reference</I> means that the subroutine receives a pointer to the
actual variable. Any changes the subroutine makes are applied directly to the original.
<I>By value</I> means that the subroutine sees a copy of the original variable. Its
value at the time it is passed can be used in the subroutine, but the original remains
intact in the calling program.</P>

<P>It's easy to override default parameter-passing behavior:

<UL>
	<LI><TT>SET UDFPARMS TO VALUE</TT> or <TT>SET UDFPARMS TO REFERENCE</TT>
	<LI>Surround a variable with parentheses (by value)
	<LI>Preface a variable with an at sign (@) (by reference)
</UL>

<H3><A NAME="ObjectMethods"></A>Object Methods</H3>
<P><I>Methods</I> are simply a form of object-oriented packaging for subroutines.
Methods use the same code construction principles as always, but the execution of
that code is timed to coincide with an event that a particular object senses and
responds to. You can find out more about the object model and adding method code
to objects in <A HREF="ch09.htm">Chapter 9</A> &quot;Creating Forms,&quot;
<A HREF="ch15.htm">Chapter 15</A>, &quot;Creating Classes with Visual FoxPro,&quot;
and <A HREF="ch17.htm">Chapter 17</A>, &quot;Advanced Object-Oriented Programming.&quot;</P>

<P>The principal distinguishing characteristic of method code is the means by which
it is fired. You run a method by entering its name as a command any place that you
can enter program instructions. The name of the method must be fully qualified by
the entire object hierarchy that defines its location. For example:


<BLOCKQUOTE>
	<PRE>THISFORM.pgfPageFrame.Page1.cntPageObj.cntMover.cmdMoveButton.Click()

</PRE>

</BLOCKQUOTE>

<P>Although parentheses are not required, many developers usually follow a method
name with a set of parentheses to identify it as a routine rather than object property.</P>

<P>Methods are not as universally available within an application as programs and
subroutines tend to be. Access to a method is restricted by runtime conditions: Has
the object been instantiated? Is there an available object reference? Is the method
hidden or protected? The chapters in Part IV, &quot;Object-Oriented Programming,&quot;
explain how to gain access to method code.</P>

<P>As with other types of subroutines, you can pass parameters to a method, and you
can expect it to pass back its results.
<H2><A NAME="SQLVersusProceduralCode"></A><FONT SIZE="5" COLOR="#FF0000"> SQL Versus
Procedural Code</FONT></H2>
<P>SQL is not new to VFP. One of FoxPro's major strengths, early on and all along,
has been its subset of SQL code fully integrated into the language. You can find
out more about the commands and their syntax from the VFP help system and from the
chapters of this book that deal with the Query and View Designers: <A HREF="ch06.htm">Chapter
6</A>, &quot;Creating Basic Queries,&quot; <A HREF="ch07.htm">Chapter 7</A>
&quot;Advanced Queries and Views,&quot; and <A HREF="ch08.htm">Chapter 8</A>
&quot;Accessing Remote Data.&quot; After you start using the actual builders, you
will continue to learn the nuances of SQL because the design surfaces generate and
display code in response to your entries.</P>

<P>Anything you can imagine doing to data in tables can be accomplished via procedural
code. Procedural code works on data one record at a time, and requires that your
programs handle all the necessary I/O.</P>

<P>SQL, on the other hand, delivers a set of data that meets conditions you specify
in a single command. Admittedly, that command can potentially contain a very complex
arrangement of clauses. Given the right set of conditions, however, VFP is free to
optimize its access to the data. All I/O is handled behind the scenes. The process
can be lightening fast.
<H2><A NAME="NewinVFP"></A><FONT SIZE="5" COLOR="#FF0000"> New in VFP 6</FONT></H2>
<P>This section is not intended to be an exhaustive list of new features in Visual
FoxPro 6. Look for information on new <TT>Access</TT> and <TT>Assign</TT> methods
in <A HREF="ch09.htm">Chapter 9</A> &quot;Creating Forms,&quot; and <A HREF="ch15.htm">Chapters
15</A>-<A HREF="ch17.htm">17</A> on class creation and management. See also
<A HREF="ch19.htm">Chapter 19</A>, &quot;The Visual FoxPro Component Gallery,&quot;
and <A HREF="ch18.htm">Chapter 18</A>, &quot;The Visual FoxPro Foundation
Classes.&quot; <A HREF="ch23.htm">Chapter 23</A>, &quot;Error Detection and
Handling,&quot; talks about the enhanced Coverage Profiler application. And Part
V, &quot;COM,&quot; deals with many of the new interoperability features.</P>

<P>In terms of the VFP programming language, there are minor enhancements throughout
that support the other new features. This mainly amounts to new clauses for existing
commands and new properties, events, and methods in support of such features as OLE
Drag and Drop, Active Document Applications, Coverage.app, and the new <TT>ProjectHook</TT>
class.</P>

<P>There are some new and enhanced functions as well:

<UL>
	<LI><TT>AGETCLASS()</TT>, <TT>AVCXCLASSES()</TT>, and <TT>COMCLASSINFO()</TT> create
	arrays of class information.
	<LI><TT>ALINES()</TT> parses lines from character and memo fields into an array;
	<TT>FILETOSTR()</TT> and <TT>STRTOFILE()</TT> convert files into character strings,
	and vice versa.
	<LI><TT>AMOUSEOBJ()</TT> creates an array of mouse pointer information.
	<LI><TT>GETHOST()</TT> and <TT>ISHOSTED()</TT> return information about the host
	of an Active Document.
	<LI><TT>INDEXSEEK()</TT> performs a <TT>SEEK</TT> into an indexed table without moving
	the record pointer.
	<LI><TT>NEWOBJECT()</TT> creates an object directly from the class library (<TT>.VCX</TT>
	file) in which it resides. Prior to this version, the only available function for
	object instantiation was <TT>CREATEOBJECT()</TT>. <TT>CREATEOBJECT()</TT> is still
	available, but it requires that the class library already be loaded in memory via
	a command such as <TT>SET CLASSLIB TO MyLib.vcx ADDITIVE</TT>.
	<LI><TT>VARTYPE()</TT> identifies an expression's data type directly.
	<LI><TT>HOME(2)</TT> points to the directory where VFP samples are loaded.
	<LI><TT>TRANSFORM()</TT> now enables you to omit a format code and use a default
	supplied by the function.
	<LI><TT>COMPILE DATABASE</TT> now automatically packs memo fields.
	<LI><TT>CREATE FORM</TT> now enables you to specify a form or formset other than
	the default base class.
	<LI>Several handy functions from the separate <TT>Foxtools.fll</TT> library are now
	supported as native functions, as described in Table 2.7.
</UL>

<P><B>Table 2.7&nbsp;&nbsp;Foxtools.fll Functions Added to VFP 6<BR>
</B>
<TABLE BORDER="1">
	<TR VALIGN="TOP">
		<TD WIDTH="192">
			<P ALIGN="CENTER"><B>Function</B>
		</TD>
		<TD WIDTH="288">
			<P ALIGN="CENTER"><B>Description</B>
		</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>ADDBS()</TT></TD>
		<TD WIDTH="288">Adds a backslash to a path.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>DEFAULTEXT()</TT></TD>
		<TD WIDTH="288">Adds an extension if there is none.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>DRIVETYPE()</TT></TD>
		<TD WIDTH="288">Identifies drive type.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>FORCEEXT()</TT></TD>
		<TD WIDTH="288">Changes filename to include new extension.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>FORCEPATH()</TT></TD>
		<TD WIDTH="288">Changes filename to use new path.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>JUSTDRIVE()</TT></TD>
		<TD WIDTH="288">Returns the drive letter from a filename.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>JUSTEXT()</TT></TD>
		<TD WIDTH="288">Returns only the extension from a filename.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>JUSTFNAME()</TT></TD>
		<TD WIDTH="288">Returns only the filename, without extension.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>JUSTPATH()</TT></TD>
		<TD WIDTH="288">Returns only the path from a filename.</TD>
	</TR>
	<TR VALIGN="TOP">
		<TD WIDTH="192"><TT>JUSTSTEM()</TT></TD>
		<TD WIDTH="288">Reduces filename to first eight characters.</TD>
	</TR>
</TABLE>

<HR>

<P ALIGN="CENTER"><A HREF="ch01.htm"><IMG SRC="previous.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="index.htm"><IMG SRC="contents.gif"
WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A> <A HREF="ch03.htm"><IMG
SRC="next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" BORDER="0"></A></P>

<P ALIGN="CENTER">&copy; <A HREF="copy.htm">Copyright</A>, Sams Publishing. All
rights reserved.

</BODY>

</HTML>
