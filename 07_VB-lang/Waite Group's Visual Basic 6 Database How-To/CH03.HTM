<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<SCRIPT LANGUAGE="JavaScript">

<!--

function popUp(pPage) {
 var fullURL = document.location;
 var textURL = fullURL.toString();
 var URLlen = textURL.length;
 var lenMinusPage = textURL.lastIndexOf("/");
 lenMinusPage += 1;
 var fullPath = textURL.substring(0,lenMinusPage);
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '</head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + fullPath + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 window.popUpWin.document.write(zhtm);
 window.popUpWin.document.close();
 // Johnny Jackson 4/28/98
 }

//-->
                                                                
</SCRIPT>
<link rel="stylesheet" href="ebooks.css" tppabs="http://pbs.mcp.com/includes/stylesheets/ebooks.css">

	<META NAME="GENERATOR" Content="Symantec Visual Page Mac 1.1.1">
	<TITLE>Visual Basic 6 Database How-To -- Ch 3 -- CREATING QUERIES WITH SQL</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><IMG SRC="sams.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/sams.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM"
BORDER="0"></H1>

<H1 ALIGN="CENTER">Visual Basic 6 Database How-To</H1>
<CENTER>
<P><A HREF="ch02.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch02/ch02.htm"><IMG SRC="previous.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch04.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch04/ch04.htm"><IMG
SRC="next.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index-21.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/index.htm"><IMG SRC="contents.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> 
<HR>

</CENTER>
<H1></H1>
<H1 ALIGN="CENTER">- 3 -<BR>
Creating Queries with SQL</H1>

<UL>
	<LI>How Do I...
	<UL>
		<LI><A HREF="#Create recordsets by selecting records from single tables?">3.1 Create
		recordsets by selecting records from single tables?</A>
		<LI><A HREF="#Select unique field values in a  SQL query?">3.2 Select unique field
		values in a SQL query?</A>
		<LI><A HREF="#Use variables and Visual Basic functions in a SQL query?">3.3 Use variables
		and Visual Basic functions in a SQL query?</A>
		<LI><A HREF="#Use wildcards and ranges of values in a SQL query?">3.4 Use wildcards
		and ranges of values in a SQL query?</A>
		<LI><A HREF="#Define and use a parameter query?">3.5 Define and use a parameter query?</A>
		<LI><A HREF="#Create recordsets by joining fields from multiple tables?">3.6 Create
		recordsets by joining fields from multiple tables?</A>
		<LI><A HREF="#Find records in a table without corresponding entries in a related table?">3.7
		Find records in a table without corresponding entries in a related table?</A>
		<LI><A HREF="#Retrieve information such as counts, averages, and sums and display it by binding it to a Data control?">3.8
		Retrieve information such as counts, averages, and sums and display it by binding
		it to a Data control?</A>
		<LI><A HREF="#Create a recordset consisting of records with duplicate values?">3.9
		Create a recordset consisting of records with duplicate values?</A>
		<LI><A HREF="#Use Visual Basic functions within a SQL statement?">3.10 Use Visual
		Basic functions within a SQL statement?</A>
		<LI><A HREF="#Make bulk updates to database records?">3.11 Make bulk updates to database
		records?</A>
		<LI><A HREF="#Create and delete tables?">3.12 Create and delete tables?</A>
		<LI><A HREF="#Append and delete records?">3.13 Append and delete records?</A>
		<LI><A HREF="#Create a new table with data from existing tables?">3.14 Create a new
		table with data from existing tables?</A>
		<LI><A HREF="#Modify a table's structure?">3.15 Modify a table's structure?</A>
		<LI><A HREF="#Create a crosstab query?">3.16 Create a crosstab query?</A>
	</UL>
</UL>

<P>
<HR SIZE="4">
</P>
<P>The Structured Query Language (SQL) is a standard language for defining and manipulating
relational databases. Virtually all relational database products on the market today
support SQL. The Jet database engine, the heart of Visual Basic and Microsoft Access,
uses SQL as its primary definition and manipulation method.</P>
<P>For truly flexible, powerful database programming, SQL is a vital element. You
<I>can</I> work with Visual Basic databases without SQL, of course; the Jet database
engine provides a robust set of objects and capabilities to enable you to accomplish
in Visual Basic almost anything you could accomplish in SQL.</P>
<P>Because of the versatility of the Jet database engine, the benefits of SQL are
not readily apparent. To help you visualize the power that SQL can add to your database
applications, examine the following example. Assume that you want to delete all the
records with a <TT>ShipmentDate</TT> earlier than January 1, 1993, from the Orders
table in your ACCOUNTS.MDB database. Your program could delete the records this way
by using Jet Data Access Objects (commonly known as <TT>DAO</TT> objects):</P>


<BLOCKQUOTE>
	<PRE><TT>Dim dbfAccounts as Database</TT>
<TT>Dim recOrders as Recordset</TT>
<TT>Set dbfAccounts = DBEngine.Workspaces(0).OpenDatabase(&quot;ACCOUNTS.MDB&quot;)</TT>
<TT>Set recOrders = dbfAccounts.OpenRecordset(&quot;Orders&quot;, dbOpenTable)</TT>
<TT>If recOrders.RecordCount &gt; 0 Then</TT>
<TT>    recOrders.MoveFirst</TT>
<TT>    Do Until recOrders.EOF</TT>
<TT>        If recOrders(&quot;ShipmentDate&quot;) &lt; #1/1/1993# Then recOrders.Delete</TT>
<TT>        recOrders.MoveNext</TT>
<TT>    Loop</TT>
<TT>End If</TT>
<TT>recOrders.Close</TT>
<TT>dbfAccounts.Close</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Now, examine the following SQL example. (For an explanation of the <TT>dbfAccounts.Execute</TT>
statement in this example, see How-To 3.13.)</P>


<BLOCKQUOTE>
	<PRE><TT>Dim dbfAccounts as Database</TT>
<TT>Set dbfAccounts = DBEngine.Workspaces(0).OpenDatabase(&quot;ACCOUNTS.MDB&quot;)</TT>
<TT>dbfAccounts.Execute(&quot;DELETE Orders.* FROM Orders &quot; &amp; _</TT>
<TT>                    &quot;WHERE Orders.ShipmentDate &lt; #1/1/1993#&quot;)</TT>
<TT>dbfAccounts.Close</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Both examples achieve the same result. However, the SQL result not only uses less
code but also, in most cases, provides faster results than the Jet database example.
The first example, employing Data Access Object (DAO) techniques, is forced to retrieve
the entire table and then check each record one by one, deleting it if necessary.
The second example, however, selects, checks, and deletes in one step, allowing the
database, rather than Visual Basic, to manage the deletion.</P>
<P>Although the prospect of learning another language might be disquieting, you'll
find that you can accomplish most SQL programming tasks with a very basic level of
SQL training. The How-To's in this chapter illustrate the most important SQL statements
and techniques. Furthermore, if you have a copy of Microsoft Access, you don't need
to <I>learn</I> SQL to <I>use</I> SQL in Visual Basic. Access can write even the
most difficult SQL for you by way of the various query design tools and wizards packaged
with the application.</P>
<P>
<H4>3.1 Create Recordsets by Selecting Records from Single Tables</H4>
<P>The <TT>SELECT</TT> statement is the basic building block for retrieving records
from a database with SQL. In this How-To, you'll learn how to create a <TT>SELECT</TT>
statement that specifies fields, records, and a sort order.</P>
<P>
<H4>3.2 Select Unique Field Values in a SQL Query</H4>
<P>The <TT>SELECT</TT> statement normally returns one record for every record in
the source table that meets the designated criteria. This How-To shows you how to
modify the basic <TT>SELECT</TT> statement to ensure that the resulting recordset
contains no duplicated records.</P>
<P>
<H4>3.3 Use Variables and Visual Basic Functions in a SQL Query</H4>
<P>The choice between SQL and regular Visual Basic code is not an either-or proposition.
You can combine Visual Basic variables with SQL statements to create a powerful data
management environment. In this How-To, you'll extend the basic <TT>SELECT</TT> statement
with variables.</P>
<P>
<H4>3.4 Use Wildcards and Ranges of Values in a SQL Query</H4>
<P>Much of the power of SQL comes from the many ways you can specify recordsets.
This How-To demonstrates the use of wildcards and the <TT>Between</TT> operator in
SQL <TT>SELECT</TT> statements.</P>
<P>
<H4>3.5 Define and Use a Parameter Query</H4>
<P>The optimization process Microsoft Access uses on queries is more effective if
the query is stored in the database and used multiple times. That can be difficult,
however, when the query's parameters change often. A parameter query can bridge that
difficult gap to give you both speed and flexibility, with remarkable ease of programming.
This How-To demonstrates how to create and use a parameter query involving a single
parameter.</P>
<P>
<H4>3.6 Create Recordsets by Joining Fields from Multiple Tables</H4>
<P>A properly designed relational database splits data into multiple tables and then
relates those tables through key fields. Visual Basic SQL can &quot;cement&quot;
fields from multiple tables together into dynaset- and snapshot-type recordsets.
This How-To shows the technique for joining fields from multiple tables into unified
recordsets through SQL <TT>INNER JOIN</TT> operations.</P>
<P>
<H4>3.7 Find Records in a Table Without Corresponding Entries in a Related Table</H4>
<P>You might need to identify records that have no corresponding entries in a related
table--perhaps you're looking for Customer table records with no records in the Orders
table, for example. This How-To shows how to use a SQL <TT>OUTER JOIN</TT> statement
to locate these orphans.</P>
<P>
<H4>3.8 Retrieve Information such as Counts, Averages, and Sums and Display It by
Binding It to a Data Control</H4>
<P>Sometimes you don't need the records themselves, just some statistics on records
that meet certain criteria. This How-To shows you how to use SQL aggregate functions
in <TT>SELECT</TT> statements to retrieve record counts, averages, sums, and other
statistics.</P>
<P>
<H4>3.9 Create a Recordset Consisting of Records with Duplicate Values</H4>
<P>It's often useful to find duplicated values in a table--for example, you might
want to find all cases in which the same customer was invoiced more than once on
the same day. This How-To shows how to find the duplicate values in a table.</P>
<P>
<H4>3.10 Use Visual Basic Functions Within a SQL Statement</H4>
<P>Although SQL is a flexible and powerful method of database manipulation, sometimes
you need extra power. Access and Visual Basic can make use of Visual Basic functions
directly in a SQL query, ensuring your complete control over your data. This How-To
illustrates how to employ Visual Basic functions in a <TT>SELECT</TT> query.</P>
<P>
<H4>3.11 Make Bulk Updates to Database Records</H4>
<P>In addition to <TT>SELECT</TT> statements, which retrieve recordsets from a database,
SQL also provides a rich set of action statements. Action statements let you modify
the contents of database tables. In this How-To, you'll see how to change values
in existing records through SQL.</P>
<P>
<H4>3.12 Create and Delete Tables</H4>
<P>You can use SQL to create empty tables with a list of fields you specify. You
can also use SQL to delete tables from your database. This How-To shows you how to
accomplish both of these operations.</P>
<P>
<H4>3.13 Append and Delete Records</H4>
<P>Another type of action statement enables you to create a recordset and then append
the records in that recordset to an existing table. In this How-To, you'll see how
to accomplish this useful task, as well as how to delete records from a table.</P>
<P>
<H4>3.14 Create a New Table with Data from Existing Tables</H4>
<P>SQL action statements can also create new tables from records in existing tables.
In this How-To, you'll create a new table from a recordset that you specify through
SQL.</P>
<P>
<H4>3.15 Modify a Table's Structure</H4>
<P>SQL's capabilities don't stop at data manipulation. The data definition capabilities
of SQL allow a great deal of control over a database's structure, as well as its
data. This How-To demonstrates several ways a table can easily be modified with SQL
statements.</P>
<P>
<H4>3.16 Create a Crosstab Query</H4>
<P>A crosstab report allows data to be cross-indexed in a compact, spreadsheet-like
format. Once a difficult report to design, crosstab reports are now quick and easy.
In this How-To, you'll receive an introduction in the ways of crosstab query design.</P>
<P>
<H2>3.1 How do I...</H2>
<H3><A NAME="Create recordsets by selecting records from single tables?"></A><B>Create
recordsets by selecting records from single tables?</B></H3>
<P><B>Problem</B></P>
<P>I want to select a subset of the records in a table, based on criteria I specify.
I don't need to see all the fields for each record, but I do want to specify the
order in which the records appear. How can I accomplish this task in Visual Basic
by using SQL?</P>
<P><B>Technique</B></P>
<P>You create recordsets from data in tables through the SQL <TT>SELECT</TT> statement.
You can embed the SQL statement in your Visual Basic code, or you can use it as the
<TT>RecordSource</TT> for a Data control.</P>
<H3><B>THE SQL </B><TT>SELECT</TT><B> STATEMENT</B></H3>
<P>A basic single-table SQL <TT>SELECT</TT> statement has four basic parts, as shown
in Table 3.1. Parts 1 and 2 are required in every <TT>SELECT</TT> statement. Parts
3 and 4 are optional. If you omit Part 3, the record-selection criteria, your recordset
will consist of all the records in the table. If you omit Part 4, the sort order,
the records will be ordered as they are in the table.</P>
<P>
<H4>Table 3.1. The four parts of a basic SQL SELECT statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>PURPOSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>EXAMPLE</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">1. Specify which fields you want to see</TD>
		<TD ALIGN="LEFT"><TT>SELECT [Name], [Telephone]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">2. Specify the table</TD>
		<TD ALIGN="LEFT"><TT>FROM [Publishers]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">3. Specify the record-selection criteria</TD>
		<TD ALIGN="LEFT"><TT>WHERE [State] = &quot;NY&quot;</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">4. Specify the sort order</TD>
		<TD ALIGN="LEFT"><TT>ORDER BY [Name]</TT></TD>
	</TR>
</TABLE>
</P>
<P>Combining the four example lines in the table produces this complete SQL <TT>SELECT</TT>
statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Name], [Telephone] FROM [Publishers] WHERE [State] = &quot;NY&quot; ORDER BY [Name]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>This example is from the BIBLIO.MDB database supplied with Visual Basic. This
database has a table named Publishers. Among the fields in the Publishers table are
<TT>Name</TT>, <TT>Telephone</TT>, and <TT>State</TT>.</P>
<P>In the example, the field names and the table name are surrounded by square brackets,
and the text <TT>NY</TT> is enclosed within quotation marks. These syntax requirements
help the Jet database engine interpret the SQL statement. Table 3.2 lists the enclosure
syntax requirements for SQL statements.</P>
<P>
<H4>Table 3.2. The enclosure syntax requirements for SQL statements.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>ELEMENT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>ENCLOSURES</I></B></TD>
		<TD ALIGN="LEFT"><B><I>EXAMPLES</I></B></TD>
		<TD ALIGN="LEFT"><B><I>WHEN REQUIRED</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Numeric data</TD>
		<TD ALIGN="LEFT">None</TD>
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Text data</TD>
		<TD ALIGN="LEFT">Single or double</TD>
		<TD ALIGN="LEFT"><TT>&quot;NY&quot; or `NY'</TT></TD>
		<TD ALIGN="LEFT">Always quotation marks</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Date data</TD>
		<TD ALIGN="LEFT">Pound signs</TD>
		<TD ALIGN="LEFT"><TT>#6/11/1996#</TT></TD>
		<TD ALIGN="LEFT">Always</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Field names</TD>
		<TD ALIGN="LEFT">Square brackets</TD>
		<TD ALIGN="LEFT"><TT>[Name], [Zip Code]</TT></TD>
		<TD ALIGN="LEFT">When name has spaces or punctuation</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Table names</TD>
		<TD ALIGN="LEFT">Square brackets</TD>
		<TD ALIGN="LEFT"><TT>[Publisher Comments]</TT></TD>
		<TD ALIGN="LEFT">When name has spaces or punctuation</TD>
	</TR>
</TABLE>



<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>CAPITALIZATION DOESN'T MATTER</STRONG></B> </P>

	<P>In the Table 3.1 example, the SQL keywords (<TT>SELECT</TT>, <TT>FROM</TT>, <TT>WHERE</TT>,
	and <TT>ORDER BY</TT>) appear in capital letters. This is a convention, and it is
	completely optional. Neither Visual Basic nor the Jet database engine cares about
	the capitalization of SQL keywords or about the capitalization of table names and
	field names. 
<HR>


</BLOCKQUOTE>

<P>Note that in the example from Table 3.1, the field and table names do not require
brackets because all the names consist of a single word with no spaces or punctuation
characters. The brackets are optional when there are no spaces or punctuation.</P>
<P><B>Multiple Fields and Multiple Criteria</B></P>
<P>If you need more than one field in the returned recordset, specify the fields
by separating the field names with commas. Do the same to designate multiple-field
sorts. The following example returns three fields sorted first by the <TT>State</TT>
field and then by the <TT>City</TT> field:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Name], [City], [State], FROM [Publishers]</TT>
<TT>ORDER BY [State], [City]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Specify multiple criteria through the <TT>AND</TT> and <TT>OR</TT> keywords. Assume
that you have a table consisting of invoices with the fields shown in Table 3.3.</P>
<P>
<H4>Table 3.3. Fields for a hypothetical Invoices table.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>FIELD</I></B></TD>
		<TD ALIGN="LEFT"><B><I>TYPE</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Invoice Number</TD>
		<TD ALIGN="LEFT">Numeric</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Issue Date</TD>
		<TD ALIGN="LEFT">Date</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Amount</TD>
		<TD ALIGN="LEFT">Currency</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Customer Number</TD>
		<TD ALIGN="LEFT">Numeric</TD>
	</TR>
</TABLE>
</P>
<P>You want to create a recordset consisting of invoices to customer number 3267
that were dated on or after August 1, 1995. Your SQL <TT>SELECT</TT> statement might
look like this:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Invoice Number], [Issue Date], [Amount] FROM [Invoices]</TT>
<TT>WHERE [Customer Number] = 3267 AND [Issue Date] &gt;= #8/1/95#</TT>
<TT>ORDER BY [Issue Date]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Notice the use of the greater-than-or-equal-to operator (<TT>&gt;=</TT>) in that
statement. SQL comparison operators mimic those available in Visual Basic. Also notice
that because the customer number is a numeric field, not a text field, the customer
number is not enclosed in quotation marks.</P>
<P>In another situation, perhaps you want to find all invoices issued to customers
3267 and 3396. Your statement might be this:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Invoice Number], [Issue Date], [Amount] FROM [Invoices]</TT>
<TT>WHERE [Customer Number] = 3267 OR [Customer Number] = 3396</TT>
<TT>ORDER BY [Issue Date]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>You can combine <TT>AND</TT> and <TT>OR</TT> to select the invoices to customers
3267 and 3396 that were issued on or after August 1, 1995:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Invoice Number], [Issue Date], [Amount] FROM [Invoices]</TT>
<TT>WHERE ([Customer Number] = 3267 OR [Customer Number] = 3396)</TT>
<TT>AND [Issue Date] &gt;= #8/1/95# ORDER BY [Issue Date]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>In the last example, the <TT>OR</TT>'d criteria are enclosed in parentheses. You
do this to specify to the Jet engine the order in which it should evaluate the criteria.
In this situation, &quot;the <TT>OR</TT>s go together.&quot; You want to select the
invoices that were sent to both customers after the specified date.</P>
<P><B>Using SQL Statements with the Data Control</B></P>
<P>When you use the Data control, you set the control's <TT>RecordSource</TT> property
to specify the records that the control will display. The <TT>RecordSource</TT> property
can be set to a table, to a stored query, or to a SQL <TT>SELECT</TT> statement.
When you use a SQL <TT>SELECT</TT> statement as the <TT>RecordSource</TT>, you can
specify records within a table by criteria you specify, and you can specify the order
in which the records are presented. Because you cannot use indexes with the Data
control, the ability to define the sort order is an important one.</P>
<P><B>Using SQL Statements with </B><TT>OpenRecordset</TT></P>
<P>The <TT>Database</TT> object includes a method called <TT>OpenRecordset</TT>,
with which you can create a dynaset or snapshot by using a SQL statement as the first
argument. The SQL statement must be in the form of a string (that is, enclosed in
quotation marks).</P>
<P>Assume that you have declared <TT>dbfTemp</TT> to be a <TT>Database</TT> object
and <TT>recTemp</TT> to be a <TT>Recordset</TT> object and that you have set <TT>dbfTemp</TT>
to point to a database. You can then create the recordset with the following statement
(the statement must be all on one line, of course):</P>


<BLOCKQUOTE>
	<PRE><TT>Set recTemp = dbfTemp.OpenRecordset(&quot;SELECT [Name], [Telephone] FROM [Publishers]</TT>
&Acirc;<TT>WHERE [State] = `NY' ORDER BY [Name]&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>After this statement has executed, <TT>recTemp</TT> represents a set of records
that meet the criteria specified in the SQL statement. You can use any of the <TT>Recordset</TT>
object's methods to work with these records.</P>
<P>Notice in the previous example that because the entire SQL statement is enclosed
in double quotation marks, the text data within the SQL statement requires single
quotation marks. If the text being enclosed contains single quotation marks, you
should use a pair of double quotation marks. For example, assume that you are looking
for records in which the company name is Joe's Beanery. The <TT>WHERE</TT> clause
in your SQL statement would be this:</P>


<BLOCKQUOTE>
	<PRE><TT>WHERE [Company Name] = &quot;Joe's Beanery&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>You can also assign the <TT>SELECT</TT> statement to a string variable and then
use the string variable as the argument to the <TT>OpenRecordset</TT> method. Assume
that <TT>sqlStmt</TT> has been declared as a string and that the following assignment
statement appears all on one line:</P>


<BLOCKQUOTE>
	<PRE><TT>sqlStmt = &quot;SELECT [Name], [Telephone] FROM [Publishers] WHERE [State] = `NY'</TT>
&Acirc;<TT>ORDER BY [Name]&quot; Set recTemp = dbfTemp.OpenRecordset(sqlStmt)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Because SQL statements can get very long--and you can't use Visual Basic's line-continuation
feature in the middle of a quoted string--assigning SQL statements to strings often
produces more readable code. You can build the string with the concatenation operator:</P>


<BLOCKQUOTE>
	<PRE><TT>sqlStmt = &quot;SELECT [Invoice Number], [Issue Date], [Amount] FROM [Invoices]&quot;</TT>
<TT>sqlStmt = sqlStmt &amp; &quot; WHERE ([Customer Number] = 3267 OR [Customer Number] = 3396)&quot;</TT>
<TT>sqlStmt = sqlStmt &amp; &quot; AND [Issue Date] &gt;= #8/1/95# ORDER BY [Issue Date]&quot;</TT>
<TT>Set recTemp = dbfTemp.OpenRecordset(sqlStmt) </TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>Open the project SELECT1.VBP. Change the <TT>DatabaseName</TT> property of the
Data control <TT>Data1</TT> to point to the copy of BIBLIO.MDB installed on your
system (probably in the directory where VB6.EXE is installed). Then run the project.
The form shown in Figure 3.1 appears. Scroll the top list to see the publishers in
the database. Scroll the bottom list to see the titles in the database.</P>
<P><A HREF="javascript:popUp('03fig01.gif')"><B>Figure 3.1.</B></A><B> </B><I>The
SQL Select Form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT1.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.4, and save the form as SELECT1.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.4. Objects and properties for the Simple SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>PROPERTY</I></B></TD>
		<TD ALIGN="LEFT"><B><I>SETTING</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.1 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Default</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstTitles</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordSource</TT></TD>
		<TD ALIGN="LEFT"><TT>SELECT [Company Name] FROM [Publishers] WHERE STATE = `NY' ORDER BY [Company
			Name]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Visible</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DBList</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dlstPublishers</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RowSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>ListField</TT></TD>
		<TD ALIGN="LEFT"><TT>Company Name</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of Form1. Ensure
	that your BIBLIO_PATH constant points to the location of your copy of BIBLIO.MDB,
	shipped with Visual Basic.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
<TT>`Change the following to point to your copy of BIBLIO.MDB.</TT>
<TT>Private Const BIBLIO_PATH = _</TT>
<TT>&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>3. </B>Add the following code to the <TT>Load</TT> event of <TT>Form1</TT>.
	The <TT>Form_Load</TT> event will set the <TT>dtaData</TT> Data control's <TT>DatabaseName</TT>
	property, allowing it to retrieve data. Then, a snapshot-type <TT>Recordset</TT>
	object containing records from the Titles table where the <TT>[Years Published]</TT>
	field is equal to <TT>1993</TT> or <TT>1994</TT> is created, and the titles are added
	to the <TT>lstTitles</TT> list box. More detail about types of recordsets is provided
	in Chapter 2, &quot;Accessing a Database with Data Access Objects.&quot;
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>PPrivate Sub Form_Load()</TT>
<TT>    Dim dbfBiblio As Database, recSelect As Recordset</TT>
<TT>    Dim strSQL As String</TT>
<TT>    `Set up the error handler.</TT>
    On Error GoTo FormLoadError
        `Get the database name and open the database.
        dtaData.DatabaseName = BIBLIO_PATH
        dtaData.Refresh
        Set dbfBiblio = _
DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
        `Open a snapshot-type recordset on the [Titles] table,
        ` selecting only those titles published in 1993 or 1994,
        ` sorting by the ISBN number. Note the use of the line
        ` continuation character (_), used throughout the
        ` examples, to make code more readable. &quot; &amp; _
        strSQL = &quot;SELECT [Title], [ISBN] FROM [Titles] &quot; &amp; _
            &quot;WHERE [Year Published] = 1993&quot;
 Or [Year Published] = 1994 &quot; &amp; _
            &quot;ORDER BY [ISBN]&quot;
        `Create the recordset.
        Set recSelect = dbfBiblio.OpenRecordset(strSQL, _
            dbOpenSnapshot)
        `Iterate through the recordset until the end of the file
        `(EOF) is reached.  Display each record in the unbound
        `list box lstTitles.
        If recSelect.RecordCount &gt; 0 Then
            recSelect.MoveFirst
            Do Until recSelect.EOF
                lstTitles.AddItem recSelect![ISBN] &amp; &quot;:  &quot; &amp; _
                recSelect![Title]
                recSelect.MoveNext
            Loop
        End If
    Exit Sub
FormLoadError:
    `If an error occurs, display it with a MsgBox command.
    MsgBox Err.Description, vbExclamation
    Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4.</B> Add the following code to the Click event of cmdClose. The code in
	the cmdClose_Click event will end the application.
	<P>
</DL>



<BLOCKQUOTE>
	<P>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
<TT>    End</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>This How-To displays two lists, each showing the records in a recordset generated
by a SQL <TT>SELECT</TT> statement. The top list is a <TT>DBList</TT> control bound
to the Data control <TT>dtaData</TT>. The SQL statement that generates the recordset
is supplied as the <TT>RecordSource</TT> property of the Data control. The bottom
list is an unbound <TT>ListBox</TT>. Its recordset is generated by the <TT>OpenRecordset</TT>
method called from the <TT>Form_Load</TT> event.</P>
<P><B>Comments</B></P>
<P>As basic as the code for this example might seem, it becomes the foundation for
data access in Visual Basic using SQL. No matter which method you use (Data controls,
Data Access Objects, or some of the other methods this book explores), SQL is the
foundation on which these methods stand.</P>
<P>
<H2>3.2 How do I...</H2>
<H3><A NAME="Select unique field values in a  SQL query?"></A><B>Select unique field
values in a SQL query?</B></H3>
<P><B>Problem</B></P>
<P>I know that records in my table contain duplicate values in a particular field.
How can I create a list of the unique values in the field?</P>
<P><B>Technique</B></P>
<P>By default, a SQL statement returns one row for each row in the table that meets
the criteria specified in the statement's <TT>WHERE</TT> clause. If this action results
in duplicate rows, these duplications are reproduced in the output recordset. For
example, assume that your company provides products in several colors but uses the
same product number for all colors of an otherwise identical product. You might have
a [Products] table with this structure:</P>


<BLOCKQUOTE>
	<PRE><TT>Product Number       Color</TT>
<TT>AGD44523             Green</TT>
<TT>AGD44523             Red</TT>
<TT>AGD44527             Red</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>You have two records with the <TT>[Product Number]</TT> field equal to <TT>AGD44523</TT>,
each with a different entry in <TT>[Color]</TT>. Query the table with this SQL statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Product Number] FROM [Products]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Included in your resulting recordset will be two identical rows, each with the
value <TT>AGD44523</TT>.</P>
<P>Perhaps you want a list of unique product numbers, with no duplication. You can
tell the Jet engine to filter duplicates out of the resulting recordset by inserting
the keyword <TT>DISTINCT</TT> immediately after the word <TT>SELECT</TT>. You would
rewrite your SQL statement like this:</P>
<P>
<PRE><TT>SELECT DISTINCT [Product Number] FROM [Products]</TT>
</PRE>
<P>That statement would result in a recordset with just one occurrence of the value
<TT>AGD44523</TT>.</P>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>WHICH IS FASTER: SQL OR PROCEDURAL?</STRONG></B> </P>

	<P>The question &quot;Is SQL or the procedural approach faster when interfacing with
	the database?&quot; is a complex one. In most cases, SQL methods will be faster than
	traditional procedural approaches. If an operation is time critical, it will probably
	be profitable to benchmark both the SQL approach and the procedural approach before
	making a decision on which to use in your production code.<BR>
	<BR>
	An important class of exceptions to the generalization that &quot;SQL is usually
	faster&quot; is random access into an indexed table using the <TT>Seek</TT> method
	when each <TT>Seek</TT> operation is followed by operations on a small number of
	records. This code fragment provides an example:</P>
	<PRE><TT>Set recSelect = dbfTest.OpenRecordset(&quot;MyTable&quot;, dbOpenTable)</TT>
<TT>recSelect.Index = &quot;MyIndex&quot;</TT>
<TT>recSelect.Seek &quot;=&quot;, intSomeValue</TT>
<TT>If Not recSelect.NoMatch Then</TT>
<TT>    ` Perform an action on the record sought</TT>
<TT>End If</TT>
<TT>` If needed, perform another Seek, or close the recordset and </TT>
<TT>` move on.</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>


<BLOCKQUOTE>
	<P>In such cases, the traditional procedural methods are usually faster than SQL
	statements. 
<HR>


</BLOCKQUOTE>

<P><B>Steps</B></P>
<P>The BIBLIO.MDB database (supplied with Visual Basic) contains multiple publishers
from the same state. Open the project SELECT2.VBP and run it. Initially, the list
box on the form is blank. Click the Show All button, and the form then appears as
shown in Figure 3.2; notice the occurrence of multiple CA entries. Click the Show
Unique button, and the form appears as shown in Figure 3.3, with only one entry for
each state.</P>
<P><A HREF="javascript:popUp('03fig02.gif')"><B>Figure 3.2.</B></A><B> </B><I>The
SQL Select Unique form after the Show All button is clicked.</I></P>
<P><A HREF="javascript:popUp('03fig03.gif')"><B>Figure 3.3.</B></A><B> </B><I>The
SQL Select Unique form after the Show Unique button is clicked.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT2.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.5, and save the form as SELECT2.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.5. Objects and properties for the Distinct SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>PROPERTY</I></B></TD>
		<TD ALIGN="LEFT"><B><I>SETTING</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.2 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close Form</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdShowUnique</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Show &amp;Unique</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdShowAll</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Show &amp;All</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DBList</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dlstData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>State</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RowSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
<TT>`Ensure that the following points to your copy of BIBLIO.MDB.</TT>
<TT>Private Const BIBLIO_PATH = _</TT>
<TT>&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>


<BLOCKQUOTE>
	<P><B>3. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdShowAll</TT>.
	This code builds a SQL statement that creates a recordset with one record for every
	[Publishers] table row with a non-<TT>NULL</TT> <TT>[State]</TT> field and passes
	the SQL statement to the <TT>RefreshControls</TT> subroutine.

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdShowAll_Click()</TT>
<TT>    Dim strSQL As String</TT>
<TT>    `Perform the simple SELECT query.  Note the lack of the</TT>
<TT>    `DISTINCT keyword (see the cmdShowUnique_Click event</TT>
<TT>    `for more info.)</TT>
<TT>    strSQL = &quot;SELECT [State] FROM [Publishers] &quot; &amp; _</TT>
<TT>        &quot;WHERE [State] IS NOT NULL &quot; &amp; _</TT>
<TT>        &quot;ORDER BY [State]&quot;</TT>
<TT>    `Set the RecordSource and refresh the Data control and </TT>
<TT>    `DBList control</TT>
<TT>    RefreshControls strSQL</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdShowUnique</TT>.
	This code builds a SQL statement that creates a recordset with one record for every
	unique value in the <TT>[State]</TT> field of the [Publishers] table and passes the
	SQL statement to the <TT>RefreshControls</TT> subroutine.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdShowUnique_Click()</TT>
<TT>Dim strSQL As String</TT>
<TT>    `Perform the SELECT DISTINCT query.  </TT>
<TT>    `Since the DISTINCT keyword is present, only </TT>
<TT>    `the first instance of a given [State] value is represented </TT>
<TT>    `in the result set.</TT>
<TT>    strSQL = &quot;SELECT DISTINCT [State] FROM [Publishers] &quot; &amp; _</TT>
<TT>        &quot;WHERE [State] IS NOT NULL &quot; &amp; _</TT>
<TT>        &quot;ORDER BY [State]&quot;</TT>
<TT>    `Set the RecordSource and refresh the Data control and </TT>
<TT>    `DBList control</TT>
<TT>    RefreshControls strSQL</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>5. </B>Create the <TT>RefreshControls</TT> subroutine by entering the following
	code into <TT>Form1</TT>. This routine assigns the SQL statement received as the
	argument to the <TT>RecordSource</TT> property of the Data control. It then refreshes
	the Data control and the bound list box.
	<P>
</DL>

<PRE></PRE>


<BLOCKQUOTE>
	<PRE><TT>Private Sub RefreshControls(strSQL as string)</TT>
<TT>    dtaData.RecordSource = strSQL</TT>
<TT>    dtaData.Refresh</TT>
<TT>    dlstData.Refresh</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>6. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
<TT>    End</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>The <TT>RecordSource</TT> property of the Data control <TT>dtaData</TT> is set
to an empty string in the Properties window. At form load, therefore, the <TT>Recordset</TT>
object of <TT>dtaData</TT> will be empty, and it will remain empty until the <TT>RecordSource</TT>
property is set to something that will return a valid recordset and the Data control
is refreshed. Because the <TT>DBList</TT> control is bound to the Data control, it
will be empty while the Data control remains empty.</P>
<P>The <TT>Click</TT> routines of <TT>cmdShowAll</TT> and <TT>cmdShowUnique</TT>
both perform the same basic function: They build a SQL statement to select the <TT>[State]</TT>
field from the [Publishers] table and then pass the SQL statement to the <TT>RefreshControls</TT>
subroutine. The difference in the <TT>Click</TT> routines is that <TT>cmdShowUnique</TT>
includes the <TT>DISTINCT</TT> keyword in its <TT>SELECT</TT> statement and, therefore,
returns only one record for each unique <TT>[State]</TT> value in the table.</P>
<P><B>Comments</B></P>
<P>In addition to the <TT>DISTINCT</TT> keyword described in this How-To, the Jet
database engine also supports <TT>DISTINCTROW</TT> operations. When you use <TT>DISTINCTROW</TT>
rather than <TT>DISTINCT</TT>, the database engine looks not only at the fields you've
specified in your query but at entire rows in the table specified by the query. It
returns one record in the dynaset for each unique row in the table, whether or not
the output recordset row is unique.</P>
<P>Here's a simple example to illustrate the difference. Assume that the table <TT>[Cities]</TT>
consists of these records:</P>


<BLOCKQUOTE>
	<PRE><TT>CITY           STATE</TT>
<TT>Chicago        IL</TT>
<TT>Rockford       IL</TT>
<TT>Madison        WI</TT>
<TT>Madison        WI</TT>
<TT>Dubuque        IA</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Here are two SQL queries:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT DISTINCT [State] FROM [Cities]</TT>
<TT>SELECT DISTINCTROW [State] FROM [Cities]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The first SQL statement would return the following recordset. The <TT>DISTINCT</TT>
statement ensures that each row in the output recordset is unique.</P>


<BLOCKQUOTE>
	<PRE><TT>IL</TT>
<TT>WI</TT>
<TT>IA</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The second SQL statement would return the following recordset. The <TT>IL</TT>
entry appears twice because there are two unique records in the underlying table
with a value of <TT>IL</TT> in the <TT>[State]</TT> field. The <TT>WI</TT> entry,
on the other hand, appears only once because there is only one unique record in the
underlying table.</P>


<BLOCKQUOTE>
	<PRE><TT>IL</TT>
<TT>IL</TT>
<TT>WI</TT>
<TT>IA</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>In a well-designed database, a table will have no duplicate records because each
record will have a primary key, and primary keys are by definition unique. If you
have primary keys on all your tables, therefore, you have no need for <TT>DISTINCTROW</TT>.</P>
<P>
<H2>3.3 How do I...</H2>
<H3><A NAME="Use variables and Visual Basic functions in a SQL query?"></A><B>Use
variables and Visual Basic functions in a SQL query?</B></H3>
<P><B>Problem</B></P>
<P>SQL <TT>SELECT</TT> statements are useful tools. But if I have to hard-code the
criteria into the statement, it limits my flexibility because I can't change the
criteria at runtime. I'd like to be able to use variables in the criteria clauses
of my <TT>SELECT</TT> statements or--even better--use Visual Basic functions that
return values. How can I accomplish this?</P>
<P><B>Technique</B></P>
<P>The SQL statement that you pass to the <TT>OpenRecordset</TT> method of the <TT>Database</TT>
object or that you assign as the <TT>RecordSource</TT> property of a Data control
is a string. Because it is a string, you can insert the values of variables into
it using Visual Basic's concatenation operator. You can use the same technique to
insert the value returned by a call to a function (a built-in Visual Basic function
or one you write yourself) into the string.</P>
<P><B>Steps</B></P>
<P>Open the project SELECT3.VBP and run the project. The form shown in Figure 3.4
appears. Scroll the top list to see the publishers in the database. Click on a publisher,
and the titles for that publisher appear in the bottom list. Enter a year in the
Year Published box, and click on a publisher to restrict the display to titles published
by a specific publisher in a specific year.</P>
<P><A HREF="javascript:popUp('03fig04.gif')"><B>Figure 3.4.</B></A><B> </B><I>The
Variable SELECTer form at startup.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT3.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.6, and save the form as SELECT3.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.6. Options and properties for the Variable SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>PROPERTY</I></B></TD>
		<TD WIDTH="168" ALIGN="LEFT"><B><I>SETTING</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>Chapter 3.3 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Default</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>lstTitles</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordsetType</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>Snapshot</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordSource</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>SELECT [Company Name] FROM [Publishers] ORDER BY [Company Name]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Visible</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DBList</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>dlstPublishers</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RowSource</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>ListField</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>Company Name</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>lblYearPublished</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>Year Published:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>txtYearPublished</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Text</TT></TD>
		<TD WIDTH="168" ALIGN="LEFT"><TT>&quot;&quot;</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
<TT>Private Const BIBLIO_PATH = _</TT>
<TT>&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</TT>
<TT>Dim dbfBiblio As Database</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>3. </B>Add the following code to the <TT>Load</TT> event of <TT>Form1</TT>:
	<P>
</DL>

<PRE></PRE>


<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
<TT>On Error GoTo FormLoadError</TT>
<TT>        `Set the Data control and load the Database object </TT>
<TT>        `dbfBiblio.</TT>
<TT>        dtaData.DatabaseName = BIBLIO_PATH</TT>
<TT>        dtaData.Refresh</TT>
<TT>        Set dbfBiblio = DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)</TT>
<TT>    On Error GoTo 0</TT>
<TT>Exit Sub</TT>
<TT>FormLoadError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Exit Sub</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the following code to the <TT>Click</TT> event of <TT>dlstPublishers</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub dlstPublishers_Click()</TT>
<TT>Dim recSelect As Recordset</TT>
<TT>    Dim strSQL As String</TT>
<TT>    Dim intYearPublished As Integer</TT>
<TT>    On Error GoTo PublishersClickError</TT>
<TT>        `Clear the list box</TT>
<TT>        lstTitles.Clear</TT>
<TT>        `Confirm that the year is numeric; if so, set the</TT>
<TT>        `intYearPublished variable to its numeric value.</TT>
<TT>        If IsNumeric(txtYearPublished) Then intYearPublished = _</TT>
<TT>            Val(txtYearPublished)</TT>
<TT>        `Build the SQL statement</TT>
<TT>        strSQL = &quot;SELECT [Title], [ISBN] FROM [Titles] &quot; &amp; _</TT>
<TT>            &quot;WHERE [PubID] = &quot; &amp; GetPubID()</TT>
<TT>        `If the year published selection is greater than zero, </TT>
<TT>        `modify the SQL to search for it.</TT>
<TT>        If intYearPublished &gt; 0 Then</TT>
<TT>            strSQL = strSQL &amp; &quot; AND [Year Published] = &quot; &amp; _</TT>
<TT>                     intYearPublished</TT>
<TT>        End If</TT>
<TT>        `Sort the results by the ISBN number.</TT>
<TT>        strSQL = strSQL &amp; &quot; ORDER BY [ISBN]&quot;</TT>
<TT>        `Get the recordset from our SQL statement.</TT>
<TT>        Set recSelect = dbfBiblio.OpenRecordset(strSQL, _</TT>
<TT>                        dbOpenSnapshot)</TT>
<TT>        `If we have obtained results, add the ISBN </TT>
<TT>        `and Title fields to the list box.</TT>
<TT>        If recSelect.RecordCount &gt; 0 Then</TT>
<TT>            recSelect.MoveFirst</TT>
<TT>            Do Until recSelect.EOF</TT>
<TT>                lstTitles.AddItem recSelect![ISBN] &amp; &quot;: &quot; _</TT>
<TT>                &amp; recSelect![Title]</TT>
<TT>                recSelect.MoveNext</TT>
<TT>            Loop</TT>
<TT>        End If</TT>
<TT>    On Error GoTo 0</TT>
<TT>Exit Sub</TT>
<TT>PublishersClickError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Exit Sub</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD>When the user clicks on a publisher name, this subroutine opens a snapshot-type
	<TT>Recordset</TT> object created from the Titles table, selecting only those titles
	published by the selected publishing company and, if the user has entered a publication
	year in <TT>txtYearPublished</TT>, in the designated year. It sorts the records in
	the snapshot by the ISBN number.
	<P>
	<DT></DT>
	<DD>The <TT>WHERE</TT> clause in the SQL statement includes the value returned from
	the function <TT>GetPubID</TT>. <TT>GetPubID</TT> returns a numeric value corresponding
	to the Publishers table's <TT>PubID</TT> field for the currently selected publisher
	in <TT>dlstPublishers</TT>. Its value can be inserted into the SQL string by concatenating
	the function call to the string.
	<P>
	<DT></DT>
	<DD>If the user has entered a publication year into <TT>txtYearPublished</TT>, its
	value is assigned to the numeric variable <TT>yrPublished</TT> and then inserted
	into the SQL string by concatenating the variable <TT>yrPublished</TT> to the string.
	Note that both values added to the string (the return value of <TT>GetPubID</TT>
	and the value of <TT>yrPublished</TT>) represent numeric fields in the database.
	Therefore, neither value is delimited by quotation marks in the SQL statement.
	<P>
	<DT></DT>
	<DD><B>5. </B>Create the following function in <TT>Form1</TT>. This function creates
	a recordset consisting of the <TT>PubID</TT> field of the record from the Publishers
	table with the company name value of the current selection in the <TT>dlstPublishers</TT>
	list. (This code assumes that each record in Publishers has a unique company name.)
	It then returns the value of that <TT>PubID</TT> field. In the SQL statement, the
	value <TT>dblPublishers.Text</TT> is used as the criterion of the <TT>WHERE</TT>
	clause. Because this value is a string (text) value, it must be delimited by quotation
	marks in the SQL statement. A single pair of double quotation marks--one at the beginning
	of the variable name and one at the end--won't do because the entire SQL statement
	is in quotation marks. You could use single quotation marks, like this:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>strSQL = strSQL &amp; &quot; WHERE [Company Name] = `&quot; &amp; dblPublishers.Text _</TT>
<TT>       &amp; &quot;`&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD>This would work if you could be sure that the value <TT>dblPublishers.Text</TT>
	would never include an apostrophe. But because you can't be sure of that (in fact,
	BIBLIO.MDB does contain one publisher, O'Reilly &amp; Associates, with an apostrophe),
	a double quotation mark is the safest course.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Function GetPubID() As Long</TT>
<TT>Dim recPubID As Recordset</TT>
<TT>    Dim strSQL As String</TT>
<TT>    `This subquery, once constructed, selects the publisher ID</TT>
<TT>    `given a company name.</TT>
<TT>    strSQL = &quot;SELECT [PubID] FROM [Publishers] &quot; &amp; _</TT>
<TT>        &quot;WHERE [Company Name] = &quot;&quot;&quot; &amp; dblPublishers.Text &amp; &quot;&quot;&quot;&quot;</TT>
<TT>    `Construct the recordset from our SQL statement.</TT>
<TT>    Set recPubID = dbfBiblio.OpenRecordset(strSQL, dbOpenSnapshot)</TT>
<TT>    `If we have a record, get the ID.  If not, return zero.</TT>
<TT>    If recPubID.RecordCount &gt; 0 Then</TT>
<TT>        GetPubID = recPubID![PubID]</TT>
<TT>    Else</TT>
<TT>        GetPubID = 0</TT>
<TT>    End If</TT>
<TT>End Function</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>6. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
<TT>    End</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>When the form loads, it opens the database by setting the value of the <TT>Database</TT>
object variable <TT>dbfBiblio</TT> to BIBLIO.MDB. The <TT>Publishers</TT> list is
a bound list and is filled on startup by the records specified in the <TT>RecordSource</TT>
property of <TT>Data1</TT> (see How-To 3.1 for a discussion of this bound list and
Data control). The <TT>Titles</TT> list is initially empty, and it remains so until
the user clicks on the name of a publisher. Then the <TT>dlstPublisher_Click</TT>
event code fills the <TT>Titles</TT> list with the titles published by the selected
publisher. It does this by building a SQL statement that includes the <TT>PubID</TT>
of the selected publisher. If the user enters a year in the Year Published text box,
its value is appended to the <TT>WHERE</TT> clause as an additional criterion.</P>
<P>Because the <TT>dlstPublishers</TT> list does not include the <TT>PubID</TT> field,
its <TT>Click</TT> event needs to retrieve the value of the <TT>PubID</TT> field
for the selected record. It does this by a call to the <TT>GetPubID</TT> function.
<TT>GetPubID</TT> returns a numeric value, which is inserted directly into the SQL
string.</P>
<P><B>Comments</B></P>
<P>You can also use built-in Visual Basic functions in your SQL statement. The functions
are evaluated at runtime and their return values inserted into the SQL statement
passed to the Jet engine. For example, if you have an integer variable named <TT>intIndex</TT>,
you could use the built-in <TT>Choose</TT> function to build a SQL statement like
this:</P>


<BLOCKQUOTE>
	<PRE><TT>strSQL = SELECT * FROM Orders WHERE [Delivery Service] = `&quot; &amp; _</TT>
<TT>Choose(intIndex, &quot;Speedy&quot;, &quot;Rapid&quot;, &quot;Quick&quot;, &quot;Rabbit&quot;, &quot;Tortoise&quot;) &amp; &quot;`&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<H2>3.4 How do I...</H2>
<H3><A NAME="Use wildcards and ranges of values in a SQL query?"></A><B>Use wildcards
and ranges of values in a SQL query?</B></H3>
<P><B>Problem</B></P>
<P>I need to create recordsets where the records returned fall within a range of
values or contain certain text strings. How can I do this with SQL?</P>
<P><B>Technique</B></P>
<P>You might need to create recordsets that consist of records that fall within a
range of values. Or perhaps you need to create recordsets consisting of records in
which a given field contains a certain text string. You can accomplish both of these
tasks with SQL.</P>
<P><B>Finding Records Within Criteria Ranges</B></P>
<P>You can use the standard comparison operators to find records that have a field
value within a range of values. For example, to find all records in the Invoices
table with <TT>Invoice Date</TT> values between January 1, 1996, and January 15,
1996, you can use this statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT * FROM [Invoices]</TT>
<TT>WHERE [Invoice Date] &gt;= #1/1/1996# AND [Invoice Date] &lt;= #1/15/1996#</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>As an alternative, you can use the SQL <TT>Between</TT> operator. This statement
returns the same recordset as the preceding one:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT * FROM [Invoices]</TT>
<TT>WHERE [Invoice Date] Between #1/1/1996# AND #1/15/1996#</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Using Wildcards in String Criteria</B></P>
<P>You can find records containing designated strings of text within text fields
by using the wildcard characters <TT>*</TT> and <TT>?</TT> with the SQL <TT>Like</TT>
operator. The asterisk matches any combination of characters. The question mark matches
a single character.</P>
<P>This statement retrieves all records that have the <TT>Company</TT> field beginning
with <TT>mcgraw:</TT></P>


<BLOCKQUOTE>
	<PRE><TT>SELECT * FROM [Publishers] WHERE [Company] LIKE &quot;mcgraw*&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>This statement retrieves all records with the last name <TT>Hansen</TT> or <TT>Hanson</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT * FROM [Authors] WHERE [Last Name] LIKE &quot;hans?n&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>You can use more than one wildcard character in a string. This statement retrieves
all the records in which the <TT>[Company Name]</TT> field includes the word <TT>hill</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT * FROM [Publishers] WHERE [Company Name] LIKE &quot;*hill*&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>Open and run the project SELECT4.VBP. The form shown in Figure 3.5 appears. Enter
<TT>*visual basic*</TT> in the text box labeled Title Includes Text, and click the
Look Up button. Enter <TT>1992</TT> and <TT>1993</TT> in the Published Between boxes,
and click Look Up again. Delete the values from the Published Between boxes; then
change the entry in the Title Includes Text box to <TT>visual basic*</TT> and click
Look Up. Change the text in the Title Includes Text box to <TT>*visual basic</TT>
and click Look Up.</P>
<P><A HREF="javascript:popUp('03fig05.gif')"><B>Figure 3.5.</B></A><B> </B><I>The
Wildcard SELECTer form on startup.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT4.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.7, and save the form as SELECT4.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.7. Options and properties for the Wildcard SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>PROPERTY</I></B></TD>
		<TD ALIGN="LEFT"><B><I>SETTING</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.4 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstTitles</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtPartialTitle</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtStartYear</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtEndYear</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblPartialTitle</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Title includes text:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblStartYear</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Published between:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblEndYear</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>and</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdLookup</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Look Up</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Default</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
<TT>Private Const BIBLIO_PATH = &quot;D:\Program Files\Microsoft Visual Studio\</TT>
&Acirc;<TT>VB6\Biblio.MDB&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>3. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdLookup</TT>.
	This sets the values of the three variables to be inserted into the SQL statement
	to <BR>
	the contents of the three text boxes. It uses the <TT>IIf</TT> function to set the
	variables to default values if a text box is blank or if one of the Year text boxes
	contains a nonnumeric value. It then builds the SQL statement, inserting the variable
	values into the <TT>WHERE</TT> clause, opens the recordset, and fills the list with
	the recordset contents. (See How-To 3.3 for a discussion of using Visual Basic variables
	in SQL statements.)
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdLookup_Click()</TT>
<TT>Dim dbfBiblio As Database, recSelect As Recordset</TT>
<TT>    Dim strName As String, strSQL As String</TT>
<TT>    Dim strTitleText As String, strStartYear As String, strEndYear As String</TT>
<TT>    On Error GoTo LookupError</TT>
<TT>        `Clear the list box</TT>
<TT>        lstTitles.Clear</TT>
<TT>        `Construct the search strings, using wildcards where </TT>
<TT>        `appropriate. For example, if the txtPartialTitle field is </TT>
<TT>        `blank, the * wildcard is substituted.</TT>
<TT>        strTitleText = IIf(txtPartialTitle &lt;&gt; &quot;&quot;, _</TT>
<TT>                       txtPartialTitle, &quot;*&quot;)</TT>
<TT>        strStartYear = IIf(IsNumeric(txtStartYear), _</TT>
<TT>                       txtStartYear, &quot;1&quot;)</TT>
<TT>        strEndYear = IIf(IsNumeric(txtEndYear), _</TT>
<TT>                     txtEndYear, &quot;9999&quot;)</TT>
<TT>        `Open the database</TT>
<TT>        Set dbfBiblio = _</TT>
<TT>            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)</TT>
<TT>        `Build the SQL statement, substituting our search strings, </TT>
<TT>        `built above, in the appropriate locations.</TT>
<TT>        strSQL = &quot;SELECT [Title] FROM [Titles] &quot; &amp; _</TT>
<TT>            &quot;WHERE [Title] LIKE `*&quot; &amp; strTitleText &amp; &quot;*' &quot; &amp; _</TT>
<TT>            &quot;AND [Year Published] BETWEEN &quot; &amp; strStartYear &amp; _</TT>
<TT>            &quot; AND &quot; &amp; strEndYear &amp; _</TT>
<TT>            &quot; ORDER BY [Title]&quot;</TT>
<TT>        `Construct the SQL statement.</TT>
<TT>        Set recSelect = _</TT>
<TT>            dbfBiblio.OpenRecordset(strSQL, dbOpenSnapshot)</TT>
<TT>        `If we get results, load the Title field of each record </TT>
<TT>        `into the list box.</TT>
<TT>        If recSelect.RecordCount &gt; 0 Then</TT>
<TT>            recSelect.MoveFirst</TT>
<TT>            Do Until recSelect.EOF</TT>
<TT>                lstTitles.AddItem recSelect![Title]</TT>
<TT>                recSelect.MoveNext</TT>
<TT>            Loop</TT>
<TT>        End If</TT>
<TT>    On Error GoTo 0</TT>
<TT>Exit Sub</TT>
<TT>LookupError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Exit Sub</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
<TT>    End</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>The true action of this sample application occurs in the <TT>cmdLookup_Click</TT>
event. After clearing the contents of the <TT>lstTitles</TT> list box, the code uses
the values supplied in the text boxes to construct a SQL statement to run against
the <TT>dbfBiblio Database</TT> object. If records were retrieved after the statement
was run with the <TT>OpenRecordset</TT> method, the <TT>lstTitles</TT> list box would
be populated with the contents of the <TT>[Title]</TT> field from each record.</P>
<P><B>Comments</B></P>
<P>A Visual Basic database stores a date field as a number. In the <TT>WHERE</TT>
clause of a SQL statement, you can treat it like a number; using the <TT>Between</TT>
operator or comparison operators like <TT>&gt;=</TT> or <TT>&lt;=</TT> returns the
results you would expect.</P>
<P>However, you can treat the date field like text in the <TT>WHERE</TT> clause of
a SQL statement. This method enables you to use wildcard characters for any of the
three values in a standard date.</P>
<P>For example, this <TT>WHERE</TT> clause returns all records with an invoice date
in January 1996:</P>


<BLOCKQUOTE>
	<PRE><TT>WHERE [Invoice Date] LIKE &quot;1/*/1996&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The following <TT>WHERE</TT> clause returns all records with an invoice date in
1996:</P>


<BLOCKQUOTE>
	<PRE><TT>WHERE [Invoice Date] LIKE &quot;*/*/1996&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Notice that when you use the <TT>Like</TT> operator and wildcard characters, you
delimit the date with quotation marks--not pound signs. Quotation marks tell the
Jet database engine, &quot;Treat this date like a string.&quot; The pound signs tell
it, &quot;Treat this date like a number.&quot;</P>
<P>
<H2>3.5 How do I...</H2>
<H3><A NAME="Define and use a parameter query?"></A><B>Define and use a parameter
query?</B></H3>
<P><B>Problem</B></P>
<P>I need to create recordsets with search criteria based on a parameter that will
change often and reload quickly each time the parameter changes.</P>
<P><B>Technique</B></P>
<P>Normally, when using SQL to search for a specific value or values, you would specify
which values you wanted in the statement. For example, to retrieve names and telephone
numbers from the [Publishers] table in which the <TT>[State]</TT> field was equal
to <TT>&quot;NY&quot;</TT>, you would use this SQL statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [Name], [Telephone] FROM [Publishers] WHERE [State] = &quot;NY&quot; _</TT>
<TT>       ORDER BY [Name]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>But this limits you. If you wanted all the names and telephone numbers from a
different state, you would create a new query. There is, however, a faster way. A
<I>parameter query</I> is a special SQL query in which replaceable parameters are
used. Think of a parameter in SQL as a variable in Visual Basic. This allows your
query to be flexible, and it also allows an increase in performance because the SQL
precompiler doesn't have to completely build a new query every time you change a
parameter.</P>
<P>To use a parameter in your SQL statement, you first have to specify the parameter--like
declaring a variable in Visual Basic. You do this in the <TT>PARAMETERS</TT> section
of your query, which usually precedes the <TT>SELECT</TT> statement. The declaration,
as in Visual Basic, consists of a name and a data type, although the data types vary
slightly from the names you might be accustomed to in Visual Basic. The <TT>PARAMETERS</TT>
section is separated from the <TT>SELECT</TT> section by a semicolon (<TT>;</TT>)
so that the SQL precompiler can tell the difference between the two sections.</P>
<P>To rewrite the preceding query for use with parameters, you might use something
like this:</P>


<BLOCKQUOTE>
	<PRE><TT>PARAMETERS prmState String; SELECT [Name], [Telephone] FROM [Publishers] _</TT>
</PRE>
	<PRE><TT>     WHERE [State] = [prmState] ORDER BY [Name]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The parameter is substituted for the search value but in all other respects does
not alter the SQL statement.</P>
<P><B>Steps</B></P>
<P>Open and run the project SELECT5.VBP. The form shown in Figure 3.6 appears. Enter
<TT>NY</TT> in the State Abbreviation text box and click Search. Enter any other
value in the State Abbreviation text box and click Search again.</P>
<P><A HREF="javascript:popUp('03fig06.gif')"><B>Figure 3.6.</B></A><B> </B><I>The
SQL Parameter Query form on startup.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1.</B> Create a new project called SELECT5.VBP. Use Form1 to create the objects
	and properties listed in Table 3.8, and save the form as SELECT5.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.8. Options and properties for the Parameter SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>PROPERTY</I></B></TD>
		<TD ALIGN="LEFT"><B><I>SETTING</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.5 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblParameter</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>State abbreviation:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtParameter</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblResults</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Results:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstResults</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdSearch</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Search</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
<TT>Private Const BIBLIO_PATH = _</TT>
<TT>        &quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</TT>
<TT>Private mdbfBiblio As Database, mrecSelect As Recordset, _</TT>
<TT>        mqdfTemp As QueryDef</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>3. </B>Add the following code to the <TT>Load</TT> method of <TT>Form1</TT>.
	The <TT>CreateQueryDef</TT> method is used on the database to create a <TT>QueryDef</TT>
	object, which will hold the parameter query. Later, the <TT>QueryDef</TT> will be
	used to create a recordset for display.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
<TT>    `Open a Database object first - the familiar BIBLIO.MDB</TT>
<TT>        Set mdbfBiblio = </TT>
<TT>            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)</TT>
<TT>    `Use the CreateQueryDef method to create a temporary QueryDef </TT>
<TT>    `object that will store our parameter query.  The best way to </TT>
<TT>    `use a parameter query in DAO is with the QueryDef object.</TT>
<TT>    Set mqdfTemp = mdbfBiblio.CreateQueryDef(&quot;&quot;)</TT>
<TT>    `Set the SQL property to our parameter query SQL statement.</TT>
<TT>    mqdfTemp.SQL = &quot;PARAMETERS pstrState String;SELECT &quot; &amp; _</TT>
<TT>        &quot;[Name],[Telephone] &quot; &amp; _</TT>
<TT>        &quot;FROM [Publishers] WHERE [State] = [pstrState] &quot; &amp; _</TT>
<TT>        &quot;ORDER By [Name]&quot;</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdSearch</TT>.
	Now that you have a possible value for your parameter, you reference the <TT>pstrState</TT>
	parameter of the <TT>QueryDef</TT> object you created in the <TT>Form_Load</TT> routine.
	Then, using the <TT>QueryDef</TT>, you create a recordset. Now, the best part of
	this is when you change the parameter; instead of recreating the recordset, you use
	the <TT>Requery</TT> method provided by the <TT>Recordset</TT> object. Using this
	method is much faster because the recordset has an existing connection to the database
	and has its SQL already defined; you're just changing a parameter.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdSearch_Click()</TT>
<TT>    Dim lstrTemp As String</TT>
<TT>    `Set the parameter to the contents of our text box</TT>
<TT>    mqdfTemp![pstrState] = txtParameter.Text</TT>
<TT>    `If we haven't run this query yet, we'll need to</TT>
<TT>    `create it.  If we have, we don't need to create it,</TT>
<TT>    `just to requery it.</TT>
<TT>    If mrecSelect Is Nothing Then</TT>
<TT>        Set mrecSelect = mqdfTemp.OpenRecordset()</TT>
<TT>    Else</TT>
<TT>        mrecSelect.Requery mqdfTemp</TT>
<TT>    End If</TT>
<TT>    `Clear the list box</TT>
<TT>    lstResults.Clear</TT>
<TT>    `Populate the list box with names &amp; phone numbers</TT>
<TT>    If mrecSelect.RecordCount &gt; 0 Then</TT>
<TT>        mrecSelect.MoveFirst</TT>
<TT>        Do Until mrecSelect.EOF</TT>
<TT>            lstResults.AddItem mrecSelect![Name] &amp; &quot;  (Phone: &quot; _</TT>
<TT>                &amp; mrecSelect![Telephone] &amp; &quot;)&quot;</TT>
<TT>            mrecSelect.MoveNext</TT>
<TT>        Loop</TT>
<TT>    End If</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>5. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
<TT>    End</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>When the application is started, <TT>Form1</TT> loads. The <TT>Form_Load</TT>
event creates a <TT>Database</TT> object instance and then uses object's <TT>CreateQueryDef</TT>
method to create a temporary <TT>QueryDef</TT> object. At this point, your parameter
query is created by placing the SQL statement for the query into the SQL property
of the newly created <TT>QueryDef</TT> object.</P>
<P>When the <TT>cmdSearch_Click</TT> event is triggered, you first populate the <TT>QueryDef</TT>'s
<TT>Parameter</TT> object with information from the <TT>txtParameter</TT> field.
Then the routine checks whether the <TT>Recordset</TT> object it's about to populate
is set to <TT>Nothing</TT>. If so, the query hasn't been run yet, so the routine
constructs a <TT>Recordset</TT> object by running the <TT>OpenRecordset</TT> method
from the <TT>QueryDef</TT> object. If not, it uses the <TT>Requery</TT> method, which
simply re-executes the query without having to make a new connection to the database,
compile the SQL, and so on.</P>
<P>After it does so, if the query has returned records, the <TT>lstResults</TT> list
box is populated with the information.</P>
<P><B>Comments</B></P>
<P>One of the benefits of using a parameter query is the <TT>Requery</TT> method.
The <TT>Requery</TT> method allows you to re-issue a query with different parameters;
Microsoft Access will actually reuse the existing connection, running the query faster.
Also, the optimization engine built into Jet works best on static SQL (that is, SQL
stored in the database, as opposed to the SQL statements stored in code), so you
can get even more benefit from the use of a parameter query that is saved to a Microsoft
Access database. For more information on how to use a stored parameter query, examine
How-To 5.7 in Chapter 5, &quot;Microsoft Access Database.&quot;</P>
<P>
<H2>3.6 How do I...</H2>
<H3><A NAME="Create recordsets by joining fields from multiple tables?"></A><B>Create
recordsets by joining fields from multiple tables?</B></H3>
<P><B>Problem</B></P>
<P>I've designed my database using good relational database design principles, which
means that I have data in multiple tables that are related through key fields. How
can I use SQL to return recordsets with data from multiple tables in each recordset
record?</P>
<P><B>Technique</B></P>
<P>In BIBLIO.MDB, the Publishers table contains information about publishers, and
the Titles table contains information about titles. Each publisher is assigned a
unique publisher ID, which appears in the <TT>PubID</TT> field in the Publishers
table. In the Titles table, the publisher is indicated by the publisher number as
well as in a field named <TT>PubID</TT>. Figure 3.7 shows this relationship. If you
were using procedural coding and wanted to find the name of the publisher of a given
title, you would find the title in the Titles table, store the value of the <TT>PubID</TT>
for that title, and then find the matching <TT>PubID</TT> in the Publishers table.</P>
<P>This job is a lot easier with SQL. When you have a link like the one in Figure
3.7, you can use the keywords <TT>INNER JOIN</TT> in the <TT>FROM</TT> clause of
a SQL <TT>SELECT</TT> statement to create a single recordset with fields from both
tables. To continue the example, you could create a recordset with the <TT>Title</TT>
field from the Titles table and the <TT>Name</TT> field from the Publishers table
with this SQL statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT Titles.Title, Publishers.Name</TT>
<TT>FROM Publishers INNER JOIN Titles ON Publishers.PubID = Titles.PubID</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>In a single-table <TT>SELECT</TT> statement, the <TT>FROM</TT> clause is simple--it
just gives the name of the table. A multitable statement <TT>FROM</TT> clause consists
of one (or more) subclauses, each based on an <TT>INNER JOIN</TT>. The syntax of
each <TT>INNER JOIN</TT> is as follows:</P>


<BLOCKQUOTE>
	<PRE><TT>&lt;table 1 name&gt; INNER JOIN &lt;table 2 name&gt;</TT>
<TT>ON &lt;table 1 linking field name&gt; = &lt;table 2 linking field name&gt;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><A HREF="javascript:popUp('03fig07.gif')"><B>Figure 3.7.</B></A><B> </B><I>The
BIBLIO.MDB Publishers and Titles table relationship.</I></P>
<P>Note that the field names in both the <TT>SELECT</TT> clause and the <TT>FROM</TT>
clause are fully qualified with their table names, with the period operator separating
the table name from the field name. Strictly speaking, this is necessary only when
both tables have fields with identical names. In the example, the table names are
required in the <TT>FROM</TT> clause because both tables have a field named <TT>PubID</TT>;
they are optional in the <TT>SELECT</TT> clause because only the Titles table has
a field named <TT>Title</TT> and only the Publishers table has a field named <TT>Name</TT>.
It's good practice, however, to fully qualify all field names in multitable SQL statements.
This not only makes the code easier to interpret but also makes it less likely that
your code will be broken by subsequent changes to the structure of the database.</P>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>MULTIFIELD JOINS</STRONG></B> </P>

	<P>It's quite common to have relationships based on multiple fields within each table.
	For example, assume that you have an Employees table and an Hours Worked table. You
	identify each employee by two fields, <TT>[Last Name]</TT> and <TT>[First Name]</TT>.
	These two fields appear in each table and are used to link Employee records to Hours
	Worked records.<BR>
	Code these multifield joins by creating an <TT>INNER JOIN</TT> subclause, with multiple
	<TT>ON</TT> expressions tied together with the <TT>AND</TT> keyword. Each <TT>ON</TT>
	expression links one pair of common fields. The <TT>FROM</TT> clause you'd use to
	link the tables in the example would be this: 
<HR>
</P>
	<PRE><TT>FROM Employees INNER JOIN [Hours Worked]</TT>
<TT>ON Employees.[Last Name] = [Hours Worked].[Last Name]</TT>
AND Employees.[First Name] = [Hours Worked].[First Name]</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>Steps</B></P>
<P>Open the project SELECT6.VBP. The form shown in Figure 3.8 appears. Use the Data
control's record navigation buttons to page through the records in the recordset.</P>
<P><A HREF="javascript:popUp('03fig08.gif')"><B>Figure 3.8.</B></A><B> </B><I>The
SQL Inner Join form on startup.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT6.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.9.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.9. Options and properties for the INNER JOINer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>PROPERTY</I></B></TD>
		<TD ALIGN="LEFT"><B><I>SETTING</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.6 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtYearPublished</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>Year Published</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtPublisher</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtTitle</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>Title</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordSource</TT></TD>
		<TD ALIGN="LEFT"><TT>SELECT DISTINCTROW Titles.Title, Publishers.Name, Titles.[Year Published] FROM
			Publishers INNER JOIN Titles ON Publishers.PubID = Titles.PubID ORDER BY Titles.Title</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblYearPublished</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Year Published:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblPublisher</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Publisher:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblTitle</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>CAPTION</TT></TD>
		<TD ALIGN="LEFT"><TT>TITLE:</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
<TT>Private Const BIBLIO_PATH = _</TT>
<TT>&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>3. </B>Add the following code as the <TT>Load</TT> event of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
<TT>    `Set the DatabaseName for the Data control.</TT>
<TT>    dtaData.DatabaseName = BIBLIO_PATH</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
<TT>    End</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>This program makes use of the innate capabilities of bound controls (discussed
in more detail in Chapter 1, &quot;Accessing a Database with Bound Controls&quot;)
to illustrate the use of an <TT>INNER JOIN</TT>. When the program is started, the
<TT>Form_Load</TT> event will set the <TT>DatabaseName</TT> property of the <TT>dtaData</TT>
Data control to the location of BIBLIO.MDB. At this point, the <TT>dtaData</TT> Data
control will run the SQL statement stored in its <TT>RecordSource</TT> property.
The Data control will then handle the rest.</P>
<P><B>Comments</B></P>
<P>The <TT>INNER JOIN</TT> can be extremely useful in databases, but don't go &quot;whole
hog&quot; with it. The more tables you add to a <TT>JOIN</TT>, no matter what type,
the slower the SQL statement will execute. Consider this a database developer's maxim:
Retrieve only the data you need; if you don't need it, don't include it. That goes
for <TT>JOIN</TT>s as well. If you don't need the table, don't <TT>JOIN</TT> it.</P>
<P>
<H2>3.7 How do I...</H2>
<H3><A NAME="Find records in a table without corresponding entries in a related table?"></A><B>Find
records in a table without corresponding entries in a related table?</B></H3>
<P><B>Problem</B></P>
<P>I have an Orders table and a Customers table, related on the <TT>Customer</TT>
<TT>Number</TT> field. I'd like to find all the customers who have not placed an
order in the past six months. How can I do this?</P>
<P><B>Technique</B></P>
<P>The <TT>INNER JOIN</TT>, discussed in the preceding How-To, allows you to find
all the records in a table that have matching records in another table, when the
two tables are related on a key field and when &quot;matching&quot; means that values
in the key fields match. SQL also provides an outer join, which lets you list all
the records in one of the related tables whether or not they have matching records
in the other table.</P>
<P>For example, assume that you have two tables, Customers and Invoices, with these
entries:</P>


<BLOCKQUOTE>
	<PRE><TT>Customers Table                     Invoices Table</TT>
<TT> Customer Number  Customer Name Customer Number  Invoice Date Invoice Amount</TT>
<TT>        100       ABC Company         102        12/12/1996   $589.31</TT>
<TT>        101       MNO Company         100        12/15/1996   $134.76</TT>
<TT>        102       XYZ Company         102        12/22/1996   $792.13</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Create a recordset using the following SQL statement with an <TT>INNER JOIN</TT>
in the <TT>FROM</TT> clause:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT Customers.[Customer Name], Customers.[Customer Number], </TT>
<TT>    Invoices.[Customer Number], Invoices.[Invoice Date], </TT>
<TT>    Invoices.[Invoice Amount]</TT>
<TT>FROM Customers INNER JOIN Invoices</TT>
<TT>ON Customers.[Customer Number] = Invoices.[Customer Number]</TT>
<TT>ORDER BY Customers.[Customer Number], Invoices.[Invoice Date]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Executing that statement returns this recordset:</P>


<BLOCKQUOTE>
	<PRE><TT>           Customers                Invoices</TT>
<TT>Customer Name  Customer Number  Customer Number  Invoice Date Invoice Amount</TT>
<TT>ABC Company          100              100        12/15/1996   $134.76</TT>
<TT>XYZ Company          102              102        12/12/1996   $589.31</TT>
<TT>XYZ Company          102              102        12/22/1996   $792.13</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>MNO Company, customer number 101, would not appear at all in the recordset because
there are no records in the Invoices table for customer number 101, and an <TT>INNER
JOIN</TT> returns only records with matching key field values in both tables. But
see what happens when you change the join type in the <TT>FROM</TT> to a <TT>LEFT
JOIN</TT>, one of the two types of outer joins:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT Customers.[Customer Name], Customers.[Customer Number], </TT>
<TT>    Invoices.[Customer Number], Invoices.[Invoice Date], </TT>
<TT>    Invoices.[Invoice Amount]</TT>
<TT>FROM Customers LEFT JOIN Invoices</TT>
<TT>ON Customers.[Customer Number] = Invoices.[Customer Number]</TT>
<TT>ORDER BY Customers.[Customer Number], Invoices.[Invoice Date]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Executing this SQL statement returns this recordset:</P>


<BLOCKQUOTE>
	<PRE><TT>            Customers              Invoices</TT>
<TT>Customer Name  Customer Number Customer Number  Invoice Date  Invoice Amount</TT>
<TT>ABC Company          100             100        12/15/1996    $134.76</TT>
<TT>MNO Company          101</TT>
<TT>XYZ Company          102             102        12/12/1996    $589.31</TT>
<TT>XYZ Company          102             102        12/22/1996    $792.13</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The recordset consists of all the records that the <TT>INNER JOIN</TT> version
produced, and one additional record for each record in the table on the left side
of the <TT>FROM</TT> clause that has no matching records in the table on the right
side of the <TT>FROM</TT> clause.</P>


<BLOCKQUOTE>
	<P>
<HR>
<B><TT><STRONG>LEFT JOIN</STRONG></TT><STRONG>S AND <TT>RIGHT JOIN</TT>S</STRONG></B>
	</P>

	<P>There are two outer joins: <TT>LEFT JOIN</TT> and <TT>RIGHT JOIN</TT>. The <I>direction</I>
	of the join refers to the relative position of the table names in the <TT>FROM</TT>
	clause of the SQL statement. A <TT>LEFT JOIN</TT> returns a record from the table
	on the left side of the <TT>FROM</TT> clause, whether or not a matching record exists
	on the right side. A <TT>RIGHT JOIN</TT> returns a record from the table on the right
	side of the <TT>FROM</TT> clause, whether or not a matching record exists on the
	left side. These two <TT>FROM</TT> clauses, therefore, have identical results: 
<HR>
</P>
	<PRE><TT>FROM Customers LEFT JOIN Invoices</TT>
ON Customers.[Customer Number] = Invoices.[Customer Number]
FROM Invoices RIGHT JOIN Customers
ON Invoices.[Customer Number] = Customers.[Customer Number]</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>The &quot;missing&quot; fields on the right side of the recordset all have the
value <TT>NULL</TT>. You can use this fact to modify the SQL statement to select
only the records from the left table that do not have matching records in the right
table:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT Customers.[Customer Name], Customers.[Customer Number], </TT>
<TT>    Invoices.[Customer Number], Invoices.[Invoice Date], </TT>
<TT>    Invoices.[Invoice Amount]</TT>
<TT>FROM Customers LEFT JOIN Invoices</TT>
<TT>ON Customers.[Customer Number] = Invoices.[Customer Number]</TT>
<TT>WHERE Invoice.[Customer Number] IS NULL</TT>
<TT>ORDER BY Customers.[Customer Number], Invoices.[Invoice Date]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>This statement returns the following recordset:</P>


<BLOCKQUOTE>
	<PRE><TT>             Customers              Invoices</TT>
<TT>Customer Name  Customer Number  Customer Number  Invoice Date Invoice Amount</TT>
<TT>MNO Company          101</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The field used in the <TT>WHERE</TT> clause can be any field from the right-side
table because all right-side fields will be <TT>NULL</TT> when there is no record
to match a left-side table record.</P>
<P><B>Steps</B></P>
<P>Open the project SELECT7.VBP. The form shown in Figure 3.9 appears. The list shows
all the publishers in the Publishers table that do not have entries in the Publisher
Comments table.</P>
<P><A HREF="javascript:popUp('03fig09.gif')"><B>Figure 3.9.</B></A><B> </B><I>The
SQL Left Join form on startup.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT7.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.10.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.10. Options and properties for the Outer JOINer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD WIDTH="232" ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>Chapter 3.7 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordSource</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>SELECT Publishers.[Company Name] FROM Publishers LEFT JOIN [Publisher Comments]
			ON Publishers.PubID = [Publisher Comments].PubID WHERE [Publisher Comments].PubID
			IS NULL ORDER BY [Company Name]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Visible</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DBList</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>dlstAuthors</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RowSource</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>ListField</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>Author</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>lblAuthors</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD WIDTH="232" ALIGN="LEFT"><TT>Authors without Title records:</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following code to the <TT>Load</TT> event of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    `Set the DatabaseName of the Data control.
    dtaData.DatabaseName = BIBLIO_PATH
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
</PRE>
	<P><TT>End Sub</TT></P>

</BLOCKQUOTE>

<P><B>How It Works</B></P>
<P>The <TT>dtaData</TT> recordset is built by the following SQL statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT Publishers.[Company Name]</TT>
<TT>FROM Publishers LEFT JOIN [Publisher Comments]</TT>
<TT>ON Publishers.PubID = [Publisher Comments].PubID</TT>
<TT>WHERE [Publisher Comments].PubID IS NULL</TT>
<TT>ORDER BY [Company Name]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The <TT>WHERE</TT> clause of that SQL statement creates a <TT>LEFT JOIN</TT> between
the left-side table (Publishers) and the right-side table (Publisher Comments). Ignoring
the <TT>WHERE</TT> clause for a moment, this <TT>LEFT JOIN</TT> would create a snapshot
with one record for each record in the Publisher Comments table, plus one record
for every record in the Publishers table that does not have a matching record in
Publisher Comments.</P>
<P>The <TT>WHERE</TT> clause eliminates from the snapshot all records in which there
is a Publisher Comment, because the <TT>[Publisher Comments].PubID</TT> field will
not be <TT>NULL</TT> where there is a record in Publisher Comments. For snapshot
records created by records in Publishers without matching records in Publisher Comments,
<TT>[Publisher Comments].PubID</TT> is <TT>NULL</TT>; the <TT>WHERE</TT> clause causes
these records to be included in the output snapshot.</P>
<P><B>Comments</B></P>
<P>Like the <TT>INNER JOIN</TT>, explained in the preceding How-To, this can be a
powerful tool if used well. You should experiment with the behavior of all sorts
of joins--you might be surprised at what you get. Use this How-To's code as a basic
example, and go from there, trying out different SQL joins to get a feel for what
to expect with other SQL queries involving <TT>JOIN</TT> statements.</P>
<P>
<H2>3.8 How do I...</H2>
<H3><A NAME="Retrieve information such as counts, averages, and sums and display it by binding it to a Data control?"></A><B>Retrieve
information such as counts, averages, and sums and display it by binding it to a
Data control?</B></H3>
<P><B>Problem</B></P>
<P>I'd like to extract descriptive statistics about the data in a table (for example,
averages and sums or numeric fields, minimum and maximum values, and counts of records
that meet certain criteria). How can I use SQL to accomplish this task?</P>
<P><B>Technique</B></P>
<P>SQL includes a rich set of aggregate functions--functions you can embed in SQL
statements to return descriptive statistics about the data in your database. Table
3.11 lists the aggregate functions available and shows what each function returns.
Note that all functions ignore <TT>NULL</TT> values in the recordset.</P>
<P>
<H4>Table 3.11. SQL aggregate functions.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>AGGREGATE FUNCTION</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Returns</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Sum</TT></TD>
		<TD ALIGN="LEFT">Sum of the values in a designated numeric field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Avg</TT></TD>
		<TD ALIGN="LEFT">Average of the non-<TT>NULL</TT> values in a designated numeric field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Count</TT></TD>
		<TD ALIGN="LEFT">Count of non-<TT>NULL</TT> values in one or more designated fields</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Min</TT></TD>
		<TD ALIGN="LEFT">Minimum value in a designated numeric or text field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Max</TT></TD>
		<TD ALIGN="LEFT">Maximum value in a designated numeric or text field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>First</TT></TD>
		<TD ALIGN="LEFT">Value of a designated field in the first record in the recordset</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Last</TT></TD>
		<TD ALIGN="LEFT">Value of a designated field in the last record in the recordset</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>StDev</TT></TD>
		<TD ALIGN="LEFT">Sample standard deviation of the non-<TT>NULL</TT> values in a designated field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>StDevP</TT></TD>
		<TD ALIGN="LEFT">Population standard deviation of the non-<TT>NULL</TT> values in a designated field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Var</TT></TD>
		<TD ALIGN="LEFT">Sample variance of the non-<TT>NULL</TT> values in a designated field</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>VarP</TT></TD>
		<TD ALIGN="LEFT">Population variance of the non-<TT>NULL</TT> values in a designated field</TD>
	</TR>
</TABLE>
</P>
<P>The syntax for using these functions in the <TT>SELECT</TT> clause of a SQL statement
is the same for all functions:</P>


<BLOCKQUOTE>
	<PRE><TT>&lt;<I>functionname</I>&gt;(&lt;<I>fieldname</I>&gt;) AS &lt;<I>outputfieldname</I>&gt;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The <TT>&lt;<I>fieldname</I>&gt;</TT> is the name of the field in the table whose
records you are examining. The <TT>&lt;<I>outputfieldname</I>&gt;</TT> is the name
you give to the result column in the recordset created by the SQL statement. The
two field names must be different, and the <TT>&lt;<I>outputfieldname</I>&gt;</TT>
cannot duplicate the name of a field in any table referenced in the SQL statement.</P>
<P>For example, assume that you want to get a total of the <TT>Invoice Amount</TT>
field for all Invoice Table records with <TT>Invoice Dates</TT> between January 1,
1996, and January 31, 1996. Your SQL statement could be this:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT SUM([Invoice Amount]) AS SumOfInvoices</TT>
<TT>FROM Invoices</TT>
</PRE>
	<PRE><TT>WHERE [Invoice Date] BETWEEN #1/1/1996# AND #1/31/1996#</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>That statement would return a recordset consisting of one record with one field,
with a field name of <TT>SumOfInvoices</TT>. The field's value would be the total
of all the invoices between the specified dates.</P>
<P>You can include more than one aggregate function in a SQL statement. The following
statement would return a single record with two fields, <TT>SumOfInvoices</TT> and
<TT>AverageInvoice</TT>. <TT>SumOfInvoices</TT> would be the sum of all invoices
for the designated customer. <TT>AverageInvoice</TT> would be the average invoice
amount for that customer (disregarding any fields for which the <TT>Invoice Amount</TT>
is <TT>NULL</TT>).</P>


<BLOCKQUOTE>
	<P>
	<PRE><TT>SELECT SUM([Invoice Amount]) AS SumOfInvoices, AVG([Invoice Number])</TT>
<TT>        as AverageInvoice</TT>
<TT>FROM Invoices</TT>
<TT>WHERE [Customer Number] = 12345</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>Open the project SELECT8.VBP. The form shown in Figure 3.10 appears. The labels
on the form show several statistics about the authors in the Authors table of BIBLIO.MDB.</P>
<P><A HREF="javascript:popUp('03fig10.gif')"><B>Figure 3.10.</B></A><B> </B><I>The
SQL Aggregate form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT8.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.12. Save the form as SELECT8.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.12. Options and properties for the Author Statistics form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.8 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordSource</TT></TD>
		<TD ALIGN="LEFT"><TT>SELECT Count(*) AS CountOfAuthor, Avg([Year Born]) AS [AvgOfYear Born], Min([Year
			Born]) AS [MinOfYear Born], Max([Year Born]) AS [MaxOfYear Born] FROM Authors</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Visible</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>RecordsetType</TT></TD>
		<TD ALIGN="LEFT"><TT>Snapshot</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cancel</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Default</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dlblCount</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>Fixed Single</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>CountOfAuthor</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dlblMin</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>Fixed Single</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>MinOfYear Born</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dlblMax</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>Fixed Single</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>MaxOfYear Born</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dlblAvg</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>Fixed Single</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataField</TT></TD>
		<TD ALIGN="LEFT"><TT>AvgOfYear Born</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSource</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblCount</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Number of authors:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblMin</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Earliest year born:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblMax</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Latest year born:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblAvg</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AutoSize</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	</TABLE>


</BLOCKQUOTE>

<P><TT> <B>CAPTION</B></TT><B> <TT>AVERAGE YEAR BORN:</TT></B> 

<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following code to the <TT>Load</TT> event of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
<TT>    `Set the DatabaseName of the Data control.</TT>
    dtaData.DatabaseName = BIBLIO_PATH
End Sub
</PRE>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>4. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>The Data control creates a one-record recordset with this SQL statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT Count(*) AS CountOfAuthor, Avg([Year Born]) AS [AvgOfYear Born],</TT>
<TT>Min([Year Born]) AS [MinOfYear Born], Max([Year Born]) AS [MaxOfYear Born]</TT>
<TT>FROM Authors</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The single record contains four fields, each reporting one statistic about the
records in the Authors table. The four bound labels on the form are each bound to
one of the recordset fields.</P>
<P><B>Comments</B></P>
<P>The SQL statement used in the example for this How-To included this expression
in its <TT>SELECT</TT> clause:</P>


<BLOCKQUOTE>
	<PRE><TT>Count(*) as CountOfAuthor</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Using the wildcard character <TT>*</TT> as the argument to the <TT>Count</TT>
aggregate function indicates that you want the count of all the records in the table.
You can achieve the same thing by using a field that you know to be non-<TT>NULL</TT>
in every record (for example, the primary key of the table, which must by definition
be non-<TT>NULL</TT>):</P>


<BLOCKQUOTE>
	<PRE><TT>Count ([AuthorID]) as CountOfAuthor</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>However, it's better to use the wildcard character <TT>*</TT>, because the Jet
database engine is optimized to perform <TT>Count</TT> queries with the wildcard.
You get the same answer either way, but you get it faster with the wildcard.</P>
<P>
<H2>3.9 How do I...</H2>
<H3><A NAME="Create a recordset consisting of records with duplicate values?"></A><B>Create
a recordset consisting of records with duplicate values?</B></H3>
<P><B>Problem</B></P>
<P>I need to create a recordset that shows records with duplicate values. How can
I do this with SQL?</P>
<P><B>TECHNIQUE</B><BR>
Three features of SQL--the <TT>GROUP BY</TT> clause, the <TT>HAVING</TT> clause,
and SQL <TT>IN</TT> subqueries--facilitate the identification of duplicate values
in a table.</P>
<P><B>The </B><TT>GROUP BY</TT><B> Clause</B></P>
<P>SQL provides the <TT>GROUP BY</TT> clause, which combines records with identical
values into a single record. If you include a SQL aggregate function (such as <TT>COUNT</TT>)
in the <TT>SELECT</TT> statement, the <TT>GROUP BY</TT> clause applies that function
to each group of records to create a summary value.</P>
<P>For example, to return a recordset with one record for each unique state/city
pair from the Publishers table in BIBLIO.MDB, you can use this SQL statement:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT State, City, COUNT(*) AS CountByCityAndState FROM Publishers</TT>
<TT>GROUP BY State, City</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>The </B><TT>HAVING</TT><B> Clause</B></P>
<P>The <TT>HAVING</TT> clause is similar to the <TT>WHERE</TT> clause, but you use
<TT>HAVING</TT> with <TT>GROUP BY</TT>. The argument to <TT>HAVING</TT> specifies
which grouped records created by <TT>GROUP BY</TT> should be included in the output
recordset. For example, this SQL statement returns one record for each unique state/city
pair from the Publishers table in BIBLIO.MDB, restricting the records to those in
which the state is <TT>CA</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [State],[City] FROM [Publishers]</TT>
<TT>GROUP BY [State],[City]</TT>
<TT>HAVING [State] = `CA'</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>You can use <TT>HAVING</TT> with the aggregate <TT>COUNT</TT> function (see the
preceding How-To for information on aggregate functions) to restrict the output recordset
to records in which the values grouped by the <TT>GROUP BY</TT> clause have a specified
range of occurrences. This example selects only city/state pairs that occur more
than once in the table:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [State],[City] FROM [Publishers]</TT>
<TT>GROUP BY [State],[City]</TT>
<TT>HAVING COUNT(*) &gt; 1</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The <TT>SELECT</TT> and <TT>GROUP BY</TT> clauses in this example create a recordset
to which the <TT>HAVING</TT> clause applies the <TT>COUNT</TT> aggregate function.
The <TT>HAVING COUNT(*) &gt; 1</TT> clause eliminates from the final output recordset
record groups that occur only once.</P>
<P>You can use multiple criteria with the <TT>HAVING</TT> clause. This example selects
only city/state pairs that occur more than once in the table where the state is <TT>CA</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [State],[City] FROM [Publishers]</TT>
<TT>GROUP BY [State],[City]</TT>
<TT>HAVING COUNT(*) &gt; 1 AND [State] = `CA'</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>SQL </B><TT>IN</TT><B> Subqueries</B></P>
<P>An <TT>IN</TT> subquery is a <TT>SELECT</TT> statement nested inside the <TT>WHERE</TT>
clause of another <TT>SELECT</TT> statement. The subquery returns a set of records,
each consisting of a single field. The <TT>WHERE</TT> clause then compares a field
from the &quot;main&quot; <TT>SELECT</TT> statement to the field returned by the
subquery. The resultant recordset consists of those records from the main recordset
where the main field equals the subquery field.</P>
<P>Consider this simple <TT>SELECT</TT> query:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [City], [Company Name] FROM [Publishers]</TT>
<TT>ORDER BY [City]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>This query creates a recordset consisting of one record for every record in the
[Publishers] table, sorted by <TT>[City]</TT>. Now add a <TT>WHERE</TT> clause containing
an <TT>IN</TT> subquery:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [City], [Company Name] FROM [Publishers]</TT>
<TT>WHERE [City] IN</TT>
<TT>        (SELECT [City] FROM [Publishers]</TT>
<TT>         GROUP BY [City]</TT>
<TT>         HAVING COUNT(*) &gt; 1)</TT>
<TT>ORDER BY [City]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The subquery in the example is parenthesized and indented. (The parentheses are
required; the indenting is not.) The subquery returns one record for every <TT>[City]</TT>
value that occurs more than one time in the [Publishers] table. If a <TT>[City]</TT>
value occurs only once, it is not included in the subquery output.</P>
<P>The <TT>WHERE</TT> clause of the main query compares the <TT>[City]</TT> field
of every record in the table to the set of <TT>[City]</TT> values returned by the
subquery. If there is a match, the record is included in the main query's output
recordset. If there is no match, the record is excluded from the output recordset.
Because the subquery <TT>[City]</TT> values include only those occurring more than
once in the table, the <TT>WHERE</TT> clause includes in the output recordset only
those records with a <TT>[City]</TT> value that occurs more than once.</P>
<P>If you need a recordset based on a single duplicated field, the last illustration
is sufficient. If you need to compare multiple fields to find duplicate values, additional
steps are required. For example, your [Publishers] table contains records in which
the <TT>[City]</TT> field is duplicated but in which the <TT>[State]</TT> field differs,
as in the following table:</P>


<BLOCKQUOTE>
	<PRE><TT>CITY                  STATE</TT>
<TT>Springfield           IL</TT>
<TT>Springfield           MA</TT>
<TT>Springfield           OH</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>(The BIBLIO.MDB database supplied with Visual Basic does not have any records
in which this condition exists, but a real-life example might.)</P>
<P>Finding the true duplicates here requires additions to the subquery. The additions
to the original subquery are shown here in bold:</P>


<BLOCKQUOTE>
	<PRE><TT>(SELECT [City] FROM [Publishers] AS Tmp</TT>
<TT>GROUP BY [City], [State]</TT>
<TT>HAVING COUNT(*) &gt; 1 <B>AND [State] = Publishers.[State]</B>)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>The addition of the <TT>State</TT> field to the <TT>GROUP BY</TT> clause creates
a record for every unique combination of <TT>City</TT> and <TT>State</TT>; the three
Springfields will now each appear in the recordset returned by the <TT>GROUP</TT>
<TT>BY</TT>. The additional criterion, <TT>State = Publishers.State,</TT> in the
<TT>HAVING</TT> clause compares the <TT>State</TT> field in each <TT>GROUP BY</TT>
record output to the <TT>State</TT> field in the original Publishers table and selects
only those in which the fields are equal; note that the table name on the right side
of the equal sign is mandatory. Because of the additional criterion in the <TT>HAVING</TT>
clause, it is necessary to assign the output of the subquery to a temporary variable--arbitrarily
called <TT>Tmp</TT>--but any legal name that does not duplicate an existing field
name will do.</P>
<P>You can use up to 10 criteria in a subquery. For additional criteria, simply append
them to the <TT>GROUP BY</TT> clause with a comma and to the <TT>HAVING</TT> clause
with the <TT>AND</TT> keyword.</P>
<P><B>Steps</B></P>
<P>Open and run the project SELECT9.VBP. The form shown in Figure 3.11 appears. The
grid control on the form shows records from the Publishers table for which the city
and state appear more than once in the table.</P>
<P><A HREF="javascript:popUp('03fig11.gif')"><B>Figure 3.11.</B></A><B> </B><I>The
duplicate SELECTer form on startup.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT9.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.13, and save the form as SELECT9.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.13. Objects and properties for the Duplicate SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.9 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblCount</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Alignment</TT></TD>
		<TD ALIGN="LEFT"><TT>2 - Center</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>1 - Fixed Single</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblDupValues</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Duplicated values:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Grid</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>grdValues</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cols</TT></TD>
		<TD ALIGN="LEFT"><TT>3</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>FixedCols</TT></TD>
		<TD ALIGN="LEFT"><TT>0</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Scrollbars</TT></TD>
		<TD ALIGN="LEFT"><TT>2 - Vertical</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cancel</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Enter the following code as the <TT>Load</TT> event for <TT>Form1</TT>.
	For the <TT>Form_Load</TT> event, the routine first creates a <TT>Database</TT> object.
	Then it starts creating the SQL statement from the inside out by first creating the
	subquery in the <TT>strSubQuery</TT> string and then &quot;wrapping&quot; the rest
	of the query around it inside the <TT>strSQL</TT> string. After execution, if records
	are present, the <TT>grdValues</TT> grid is configured and populated with the contents
	of the <TT>[State]</TT>, <TT>[City]</TT>, and <TT>[Company Name]</TT> fields.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    Dim dbfBiblio As Database, recSelect As Recordset
    Dim strSQL As String, strSubQuery As String
    Dim intCount As Integer, intGridRow As Integer
   ` Get the database name and open the database.
    Set dbfBiblio = DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
    ` Build the subquery, starting with its SELECT statement.
    strSubQuery = &quot;SELECT City FROM Publishers AS Tmp &quot; &amp; _
        &quot;GROUP BY City, State &quot; &amp; _
        &quot;HAVING COUNT(*) &gt; 1 AND State = Publishers.State &quot;
    ` Build the SQL statement
    ` Start by designating the fields to be included in the 
    ` recordset and the WHERE IN clause
    strSQL = &quot;SELECT City, State, [Company Name]&quot; &amp; _ 
        &quot;FROM Publishers &quot; 
        &quot;WHERE City IN (&quot; &amp; strSubQuery &amp; &quot;) &quot; &amp; _
        &quot;ORDER BY State, City&quot;
    ` Run the query.
    Set recSelect = dbfBiblio.OpenRecordset(strSQL, _
        dbOpenSnapshot)
    ` Make sure the query returned at least one record
    If recSelect.RecordCount &gt; 0 Then
        ` Get a count of records in the recordset and display it 
        ` on the form.
        recSelect.MoveLast
        intCount = recSelect.RecordCount
        lblCount.Caption = intCount
        ` Initialize the grid
        With grdValues
            .Rows = intCount + 1
            .ColWidth(0) = 700: .ColWidth(1) = 2000: 
                         .ColWidth(2) = 4000
            .Row = 0: .Col = 0: .Text = &quot;State&quot;
            .Col = 1: .Text = &quot;City&quot;
            .Col = 2: .Text = &quot;Publisher&quot;
        End With
        `Populate the grid
        recSelect.MoveFirst
        For intGridRow = 1 To intCount
            With grdValues
                .Row = intGridRow
                .Col = 0: .Text = recSelect![State]
                .Col = 1: .Text = recSelect![City]
                .Col = 2: .Text = recSelect![Company Name]
            End With
            recSelect.MoveNext
        Next intGridRow
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Enter the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>.
	This event ends the application.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>The <TT>Form_Load()</TT> event subroutine creates a SQL statement, first by building
the subquery and then by creating the main query with the inserted subquery. (Refer
to the &quot;Technique&quot; section for an explanation of the syntax of the SQL
statement.) The subroutine then executes the query and creates a <TT>Recordset</TT>
object. If the recordset contains at least one record, the subroutine initializes
the grid control and inserts each record into the grid.</P>
<P><B>Comments</B></P>
<P>If you insert the word <TT>NOT</TT> in front of the word <TT>IN</TT>, a <TT>SELECT</TT>
statement containing an <TT>IN</TT> subquery returns a recordset consisting of records
that do not meet the criteria of the subquery. Assume that you changed the query
in the example by inserting the word <TT>NOT</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>SELECT [City], [Company Name] FROM [Publishers]</TT>
<TT>WHERE [City] NOT IN</TT>
<TT>       (SELECT [City] FROM [Publishers] AS Tmp</TT>
<TT>        GROUP BY [City], [State]</TT>
<TT>        HAVING COUNT(*) &gt; 1 AND [State] = Publishers.[State])</TT>
<TT>ORDER BY [City]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>This query would produce a recordset consisting of records with a city/state combination
that occur only once in the table.</P>
<P>complexity</P>
<P>
<H2>3.10 How do I...</H2>
<H3><A NAME="Use Visual Basic functions within a SQL statement?"></A><B>Use Visual
Basic functions within a SQL statement?</B></H3>
<P><B>Problem</B></P>
<P>I need to create a recordset with special formatting based on the contents of
a field, but I can't find any standard SQL function to use for the formatting.</P>
<P><B>Technique</B></P>
<P>One of the benefits of using the Jet database engine and Data Access Objects is
the capability of embedding Visual Basic for Applications (VBA) functions in Access
SQL for various tasks that SQL by itself could not accomplish easily.</P>
<P><B>Steps</B></P>
<P>Open and run the project SELECT10.VBP. The form shown in Figure 3.12 appears.
The grid control on the form shows records from the Publishers table, before and
after the execution of the <TT>LCase()</TT> function to convert the case from uppercase
to lowercase.</P>
<P><A HREF="javascript:popUp('03fig12.gif')"><B>Figure 3.12.</B></A><B> </B><I>The
Visual Basic code with SQL form, showing Publishers data.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called SELECT10.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.14, and save the form as SELECT10.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.14. Objects and properties for the Duplicate SELECTer form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.10 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblPublishers</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Publisher Names</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>MSFlexGrid</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>grdValues</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cols</TT></TD>
		<TD ALIGN="LEFT"><TT>3</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>FixedCols</TT></TD>
		<TD ALIGN="LEFT"><TT>1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>AllowUserResizing</TT></TD>
		<TD ALIGN="LEFT"><TT>1 - flexResizeColumns</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Scrollbars</TT></TD>
		<TD ALIGN="LEFT"><TT>2 - Vertical</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Width</TT></TD>
		<TD ALIGN="LEFT"><TT>5655</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cancel</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following statements to the declarations section of <TT>Form1</TT>.
	Ensure that the <TT>BIBLIO_PATH</TT> constant is set to the location of BIBLIO.MDB
	on your workstation.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Enter the following code as the <TT>Load</TT> event for <TT>Form1</TT>.
	As with the preceding How-To, the event starts by creating a <TT>Database</TT> object,
	opening BIBLIO.MDB for use. Then a SQL statement is created, using the VBA function
	<TT>LCase</TT> to convert the string to lowercase, as denoted by the second parameter
	in the command. (For more information on the <TT>LCase</TT> command, search for <TT>LCase</TT>
	in the Visual Basic Help Index.) Note that the constant for the second parameter,
	<TT>vbProperCase</TT>, was not used here--some constants might not be accessible
	by the SQL precompiler used by the DAO library.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    Dim dbfBiblio As Database, recSelect As Recordset
    Dim strSQL As String
    Dim intCount As Integer, intGridRow As Integer
    Set dbfBiblio = DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
    ` Build the query, starting with its SELECT statement.
    ` Note the LCase() function; a VBA function, NOT a SQL 
    ` function.
    strSQL = &quot;SELECT Publishers.PubID, Publishers.Name, &quot; &amp; _
             &quot;LCase([Publishers].[Name],3) AS CheckedName &quot; &amp; _
             &quot;FROM Publishers;&quot;
    ` Run the query to create the recordset.
    Set recSelect = _
        dbfBiblio.OpenRecordset(strSQL, dbOpenSnapshot)
    ` Make sure the query returned at least one record
    If recSelect.RecordCount &gt; 0 Then
        `Get the record count &amp; display it on the form
        recSelect.MoveLast
        intCount = recSelect.RecordCount
        lblPublishers.Caption = &quot;Publisher Names (&quot; &amp; _
CStr(intCount) &amp; &quot;records)&quot;
        `Initialize the grid
        With grdValues
            .Rows = intCount + 1
            .ColWidth(0) = 700: .ColWidth(1) = 2000: 
            .ColWidth(2) = 4000
            .Row = 0: .Col = 0: .Text = &quot;Pub ID&quot;
            .Col = 1: .Text = &quot;Name&quot;
            .Col = 2: .Text = &quot;Name After LCase()&quot;
        End With
        `Populate the grid
        recSelect.MoveFirst
        For intGridRow = 1 To intCount
            With grdValues
               .Row = intGridRow
               .Col = 0: .Text = recSelect![PubID]
               .Col = 1: .Text = recSelect![Name]
               .Col = 2: .Text = recSelect![CheckedName]
            End With
            recSelect.MoveNext
        Next intGridRow
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Enter the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>The <TT>Form_Load()</TT> event creates a SQL statement, showing both the raw data
in the <TT>[Name]</TT> field and the same data after processing by the <TT>LCase()</TT>
VBA function to &quot;scrub&quot; the raw data. The recordset data is placed directly
into the grid with no further processing.</P>
<P><B>Comments</B></P>
<P>VBA functionality can expand DAO query power enormously, allowing for everything
from math functions to string processing within the SQL. Rather than the tedious
and time-consuming process of performing the same action by looping through a recordset
and using the same VBA function to modify the data field by field, the ease of using
a single SQL statement should strongly encourage you to experiment with VBA functions
in Access SQL.</P>
<P>
<H2>3.11 How do I...</H2>
<H3><A NAME="Make bulk updates to database records?"></A><B>Make bulk updates to
database records?</B></H3>
<P><B>Problem</B></P>
<P>I need to make an identical change to a number of records that meet certain criteria.
How can I accomplish this task with a single SQL statement?</P>
<P><B>TECHNIQUE</B><BR>
In addition to <TT>SELECT</TT> queries, which create recordsets based on criteria
you specify, SQL provides a group of action query statements. One type of action
query is the <TT>UPDATE</TT> query, which makes specified changes to a set of records
that meet designated criteria.</P>
<P>An <TT>UPDATE</TT> query contains the clauses shown in Table 3.15. The example
shown in Table 3.15 increases the <TT>[Price Each]</TT> field by 3% for each record
in the [Parts List] table that has a <TT>[Part Number]</TT> beginning with the string
<TT>&quot;XYZ7&quot;</TT>.</P>
<P>
<H4>Table 3.15. The UPDATE statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>UPDATE</TT></TD>
		<TD ALIGN="LEFT">Names the table</TD>
		<TD ALIGN="LEFT"><TT>UPDATE [Parts List]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>SET</TT></TD>
		<TD ALIGN="LEFT">Designates the fields to be updated and their new values</TD>
		<TD ALIGN="LEFT"><TT>SET [Price Each] = [Price Each] * 1.03</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>WHERE</TT></TD>
		<TD ALIGN="LEFT">Specifies the records to be updated</TD>
		<TD ALIGN="LEFT"><TT>WHERE [Part Number] LIKE &quot;XYZ7*&quot;</TT></TD>
	</TR>
</TABLE>
</P>
<P>You run a SQL action query statement using the <TT>Execute</TT> method of the
<TT>Database</TT> object. Assuming that you have a <TT>Database</TT> object <TT>db</TT>,
you would run the query shown in the table using this Visual Basic code (the entire
statement would normally appear on one line):</P>


<BLOCKQUOTE>
	<PRE><TT>db.Execute(&quot;UPDATE [Parts List] SET [Price Each] = &quot; &amp; _</TT>
<TT>    &quot;[Price Each] * 1.03 WHERE [Part Number] LIKE `XYZ7'&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>The BIBLIO.MDB file distributed with Visual Basic contains outdated information
about four publishers. These publishers were formerly located on College Ave. in
Carmel, IN. They have moved to an address in Indianapolis. The UPDATE.VBP project
updates all four publishers' records to show their new address. It also provides
the capability to restore the firms' original Carmel address.</P>
<P>Open the project UPDATE.VBP and run the project. Click the Update button and the
form appears as shown in Figure 3.13. Click the Restore button, and the addresses
change to show the Carmel address.</P>
<P><A HREF="javascript:popUp('03fig13.gif')"><B>Figure 3.13.</B></A><B> </B><I>The
SQL Update form after the update.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called UPDATE.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.16, and save the form as UPDATE.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.16. Objects and properties for the UPDATEr form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>UPDATEr</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cancel</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdRestore</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Restore</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdUpdate</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Update</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstData</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following statements to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;
Private dbfBiblio As Database</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdUpdate</TT>.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdUpdate_Click()</TT>
Dim strSQL As String
    On Error GoTo UpdateError
        `Build the UPDATE statement.
        strSQL = &quot;UPDATE Publishers &quot; &amp; _
            &quot;SET City = `Indianapolis', &quot; &amp; _
                 Address = `201 W. 103rd St.', &quot; &amp; _
            &quot;Zip = `46290' &quot; &amp; _
            &quot;WHERE ([City] = `Carmel') AND &quot; &amp; _
                   (Address LIKE `*11711*College*')&quot;
        `Execute the update query.
        dbfBiblio.Execute strSQL
        ListRecords &quot;Indianapolis&quot;
    On Error GoTo 0
Exit Sub
UpdateError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD>This procedure builds a SQL <TT>UPDATE</TT> statement that changes the contents
	of the <TT>[City]</TT>, <TT>[Address]</TT>, and <TT>[Zip]</TT> fields for each record
	that meets the criteria. The criteria are the city being equal to <TT>&quot;Carmel&quot;</TT>
	and the address containing the strings <TT>&quot;11711&quot;</TT> and <TT>&quot;College&quot;</TT>.
	The <TT>LIKE</TT> clause in the address is necessary because BIBLIO.MDB, as supplied,
	uses a different form of the same address for each of the four publishers at 11711
	N. College Ave.
	<P>
	<DT></DT>
	<DD>The procedure executes the SQL statement, using the <TT>Execute</TT> method of
	the <TT>Database</TT> object. It then calls the <TT>ListRecords</TT> subroutine to
	display the records.
	<P>
	<DT></DT>
	<DD><B>4. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdRestore</TT>.
	The <TT>cmdRestore</TT> routine reverses the action of <TT>cmdUpdate</TT>, using
	the same methodology.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdRestore_Click()</TT>
Dim strSQL As String
    On Error GoTo RestoreError
        `Build the UPDATE statement.
        strSQL = &quot;UPDATE Publishers &quot; &amp; _
            &quot;SET City = `Carmel', &quot; &amp; _
                        &quot;Address = `11711 N. College Ave.', &quot; &amp; _
            &quot;Zip = `46032' &quot; &amp; _
            &quot; WHERE ([City] = `Indianapolis') AND &quot; &amp; _
                    &quot;(Address = `201 W. 103rd St.')&quot;
        `Execute the update query.
        dbfBiblio.Execute strSQL
        ListRecords &quot;Carmel&quot;
    On Error GoTo 0
Exit Sub
RestoreError:
    MsgBox Error$, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>5. </B>Create the subroutine <TT>ListRecords</TT> by entering the following
	code. <TT>ListRecords</TT> builds a SQL <TT>SELECT</TT> statement that selects records,
	based on the city name passed as the parameter, and then lists these records in the
	list box on the form.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub ListRecords(cityName As String)</TT>
    Dim recSelect As Recordset
    Dim strSQL As String, strAddress As String
    On Error GoTo ListError
        ` Set the correct street address based on the city name.
        strAddress = IIf(strCity = &quot;Indianapolis&quot;, _
                     &quot;201 W. 103rd St.&quot;, _
                     &quot;11711 N. College Ave.&quot;)
        ` Create the recordset for the list box.
        strSQL = &quot;SELECT [Company Name], [Address], [City], &quot; &amp; _
            &quot;[State], [Zip] &quot; &amp; _
            &quot;FROM Publishers &quot; &amp; _
            &quot;WHERE [City] = `&quot; &amp; strCity &amp; &quot;`&quot; &amp; _
                   &quot;AND [Address] = `&quot; &amp; _
            strAddress &amp; &quot;`&quot;
        `Construct the recordset.
        Set recSelect = _
                   dbfBiblio.OpenRecordset(strSQL, dbOpenSnapshot)
        `Clear the list box
        lstData.Clear
        `Show each record in the list box.
        If recSelect.RecordCount &gt; 0 Then
            recSelect.MoveFirst
            Do
                lstData.AddItem 
                    Left$(recSelect![Company Name], 10) _
                    &amp; &quot;, &quot; &amp; recSelect![Address] &amp; &quot;, &quot; &amp; _
                             recSelect![City] _
                    &amp; &quot;, &quot; &amp; recSelect![State] &amp; &quot; &quot; &amp; _
                             recSelect![Zip]
                recSelect.MoveNext
            Loop While Not recSelect.EOF
        End If
    On Error GoTo 0
Exit Sub
ListError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>6. </B>Add the following code as the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>Until the user clicks either the Update or the Restore button, the form just lies
in wait. If the user clicks the Update button, the form executes a SQL statement,
modifying any record the statement finds with specific <TT>[City]</TT> and <TT>[Address]</TT>
field contents, changing the <TT>[City]</TT>, <TT>[Address]</TT>, and <TT>[Zip]</TT>
fields. The Restore performs exactly the same action but reverses the actions taken
by the Update button, searching for the newly altered records and restoring them
to their previous values.</P>
<P><B>Comments</B></P>
<P>This method is usually the best way to make bulk updates to records in any database;
it gets the database to do the work rather than the calling application, usually
in a more efficient fashion. But, as with any powerful tool, this method can be misused.
Ensure that your <TT>WHERE</TT> clause incorporates <I>only</I> those records to
be changed. Have too &quot;loose&quot; a selection, and records might be mistakenly
altered; this might happen much too quickly for the error to be stopped. Be cautious,
and your caution will serve you well.</P>
<P>
<H2>3.12 How do I...</H2>
<H3><A NAME="Create and delete tables?"></A><B>Create and delete tables?</B></H3>
<P><B>Problem</B></P>
<P>I need to create a temporary table, use it for a while, and then get rid of it.
How can I accomplish this using SQL?</P>
<P><B>Technique</B></P>
<P>SQL provides two statements that allow you to create and delete tables. <TT>CREATE
TABLE</TT> creates a new table, using a name and field list that you specify. <TT>DROP
TABLE</TT> deletes a named table.</P>
<P>To create a table with <TT>CREATE TABLE</TT>, you need to pass it two arguments:
the name of the table to be created and a field list, with the field list enclosed
in parentheses. The field list consists of a set of field descriptions separated
by commas. Each field description has two parts: a field name and a data type. The
field name and data type are separated by a space.</P>
<P>Execute the <TT>CREATE TABLE</TT> statement by passing it as the parameter of
the <TT>Execute</TT> method of the <TT>Database</TT> object. The following Visual
Basic statement creates a new table in the database represented by the <TT>Database</TT>
object variable <TT>dbfTest</TT>. The new table is named My Parts and has two fields:
<TT>[Part Name]</TT>, which is a text field, and <TT>[Quantity]</TT>, which is a
long integer.</P>
<P>
<PRE><TT>dbfTest.Execute(&quot;CREATE TABLE [My Parts] ([Part Name] TEXT, &quot; &amp; _</TT>
<TT>      &quot;[Quantity] LONG)&quot;)</TT>
</PRE>
<P>As with any table or field name, the brackets are required if the name contains
a space, and they are optional if there is no space. The convention is to capitalize
the data type, but this capitalization is not required.</P>
<P>The data type names used by the Jet database engine do not exactly match the names
required by SQL. Table 3.17 shows the SQL data types and the corresponding Jet data
type for each.</P>


<BLOCKQUOTE>
	<H4>Table 3.17. SQL data types used by CREATE TABLE and their corresponding Jet database
	engine data types.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>SQL DATA TYPE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Equivalent Jet Data Type</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>BINARY</TT></TD>
		<TD ALIGN="LEFT">N/A--for queries on attached tables that define a <TT>BINARY</TT> data type</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>BIT</TT></TD>
		<TD ALIGN="LEFT">Yes/No</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>BYTE</TT></TD>
		<TD ALIGN="LEFT">Numeric--Byte</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>COUNTER</TT></TD>
		<TD ALIGN="LEFT">Counter</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CURRENCY</TT></TD>
		<TD ALIGN="LEFT">Currency</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DATETIME</TT></TD>
		<TD ALIGN="LEFT">Date/Time</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>SINGLE</TT></TD>
		<TD ALIGN="LEFT">Numeric--Single</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DOUBLE</TT></TD>
		<TD ALIGN="LEFT">Numeric--Double</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>SHORT</TT></TD>
		<TD ALIGN="LEFT">Numeric--Integer</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>LONG</TT></TD>
		<TD ALIGN="LEFT">Numeric--Long</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>LONGTEXT</TT></TD>
		<TD ALIGN="LEFT">Memo</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>LONGBINARY</TT></TD>
		<TD ALIGN="LEFT">OLE objects</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TEXT</TT></TD>
		<TD ALIGN="LEFT">Text</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>

<P>The <TT>DROP TABLE</TT> requires just one argument--the name of the table to be
removed from the database. Like <TT>CREATE TABLE</TT>, the <TT>DROP TABLE</TT> statement
is executed through the <TT>Execute</TT> method of the <TT>Database</TT> object.
The following Visual Basic statement deletes the table My Parts from the database
represented by <TT>dbfTest:</TT></P>


<BLOCKQUOTE>
	<PRE><TT>dbfTest.Execute(&quot;DROP TABLE [My Parts]&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>The NEWTABLE.VBP project lets you create tables in BIBLIO.MDB and assign the table's
fields using any data type. Open the project NEWTABLE.VBP and run the project. The
form shown in Figure 3.14 appears.</P>
<P><A HREF="javascript:popUp('03fig14.gif')"><B>Figure 3.14.</B></A><B> </B><I>The
SQL Create Table form at startup.</I></P>
<P>Click the List Tables button, and the form shown in Figure 3.15 appears. This
form lists the tables currently in BIBLIO.MDB. Click Close to return to the Table
Creator form.</P>
<P>In the Table Name text box, type any legal table name. In the Field Name text
box, type a field name; then select a field type from the drop-down list. Click Add
Field to create the field. Create several additional fields; for each field, type
a field name, select a field type, and click Add Field. When you have several fields
defined, the form will appear as shown in Figure 3.16. Click Create Table to add
the table to BIBLIO.MDB. The table name and field names will disappear to prepare
the Table Creator form to create another table. You can click List Tables to see
your table BIBLIO.MDB.</P>
<P>After you've created several tables, click List Tables. Select one of the tables
you created and click Delete. (The program will not let you delete a table with data
in it, so you will not be able to delete any of the original BIBLIO.MDB tables.)
The table disappears from the table list.</P>
<P><A HREF="javascript:popUp('03fig15.gif')"><B>Figure 3.15.</B></A><B> </B><I>The
Table List form, showing table names.</I></P>
<P><A HREF="javascript:popUp('03fig16.gif')"><B>Figure 3.16.</B></A><B> </B><I>The
SQL Create Table form, with new fields added.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called NEWTABLE.VBP. Rename <TT>Form1</TT> to
	<TT>frmMain</TT>, create the objects and properties listed in Table 3.18, and save
	the form as NEWTABLE.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.18. Objects and properties for the Table Creator form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>frmMain</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.12 Example - Table Creator</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdListTables</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;List Tables</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdCreateTable</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Create &amp;Table</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdRemoveField</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Remove Field</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdAddField</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Add Field</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Default</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Cancel</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ComboBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cboFieldTypes</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Style</TT></TD>
		<TD ALIGN="LEFT"><TT>2 - Dropdown List</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstFields</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtFieldName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtTableName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblTableName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Table Name:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblFieldName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Field Name:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblFieldType</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Field T&amp;ype:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblFieldList</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Field Li&amp;st:</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Insert a new form into the project. Rename it <TT>frmTableList</TT>,
	create the objects and properties listed in Table 3.19, and save the form as TABLIST.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.19. Objects and properties for the Current Tables form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>frmTableList</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>3 - Fixed Dialog</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.12 Example - Table List</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>MaxButton</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>MinButton</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdDelete</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Delete</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstTables</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Sorted</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following statements to the declarations section of <TT>frmMain</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const IllegalCharacters = &quot;[].!'&quot;
Private Const FIELDNAME = 1
Private Const TABLENAME = 2
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Enter the following code for the <TT>Form_Load</TT> event for <TT>frmMain</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    `Fill the Field Type combo box.
    FillTypeList
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>5. </B>Create the <TT>FillTypeList</TT> subroutine in <TT>frmMain</TT> with
	the following code. This procedure fills the drop-down list with the available data
	types, using the Jet database engine names.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Sub FillTypeList()</TT>
`Fill the Field Type combo box with types of available fields
    With cboFieldTypes
        .AddItem &quot;Counter&quot;
        .AddItem &quot;Currency&quot;
        .AddItem &quot;Date/Time&quot;
        .AddItem &quot;Memo&quot;
        .AddItem &quot;Number: Byte&quot;
        .AddItem &quot;Number: Integer&quot;
        .AddItem &quot;Number: Long&quot;
        .AddItem &quot;Number: Single&quot;
        .AddItem &quot;Number: Double&quot;
        .AddItem &quot;OLE Object&quot;
        .AddItem &quot;Text&quot;
        .AddItem &quot;Yes/No&quot;
    End With
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>6. </B>Enter the following code as the <TT>Click</TT> event of <TT>frmMain</TT>'s
	<TT>cmdListTables</TT>. This subroutine displays the <TT>List Tables</TT> form modally.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdListTables_Click()</TT>
    ` Display the Table List form modally.
    frmTableList.Show vbModal
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>7. </B>Enter the following code as the <TT>Click</TT> event of <TT>frmMain</TT>'s
	<TT>cmdAddField</TT>. The <TT>cmdAddField</TT> routine first calls the <TT>LegalName</TT>
	function to verify that the user has entered a legal field name and verifies that
	the user has selected a field type. It then translates the data type shown in the
	drop-down list from the Jet name to the SQL name. It formats the field name and data
	type and adds it to the field list. It then clears the field name and field type
	for entry of the next field.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdAddField_Click()</TT>
Dim strFieldType As String
    `Check first if the Field Name text box contains a legal name
    If LegalName(FIELDNAME) Then
        `If it does, check if the Field Type has been selected.
        If cboFieldTypes.ListIndex &gt; -1 Then
            `If both criteria are satisfied, store the SQL field 
            `type in the strFieldType string.
            Select Case cboFieldTypes.Text
                Case &quot;Counter&quot;
                    strFieldType = &quot;COUNTER&quot;
                Case &quot;Currency&quot;
                    strFieldType = &quot;CURRENCY&quot;
                Case &quot;Date/Time&quot;
                    strFieldType = &quot;DATETIME&quot;
                Case &quot;Memo&quot;
                    strFieldType = &quot;LONGTEXT&quot;
                Case &quot;Number: Byte&quot;
                    strFieldType = &quot;BYTE&quot;
                Case &quot;Number: Integer&quot;
                    strFieldType = &quot;SHORT&quot;
                Case &quot;Number: Long&quot;
                    strFieldType = &quot;LONG&quot;
                Case &quot;Number: Single&quot;
                    strFieldType = &quot;SINGLE&quot;
                Case &quot;Number: Double&quot;
                    strFieldType = &quot;DOUBLE&quot;
                Case &quot;OLE Object&quot;
                    strFieldType = &quot;LONGBINARY&quot;
                Case &quot;Text&quot;
                    strFieldType = &quot;TEXT&quot;
                Case &quot;Yes/No&quot;
                    strFieldType = &quot;BIT&quot;
            End Select
            `Add the new field to the Field List list box.
            lstFields.AddItem &quot;[&quot; &amp; txtFieldName &amp; &quot;] &quot; &amp; _
                              strFieldType
            `Reset the Field Name and Field Type controls.
            txtFieldName = &quot;&quot;
            cboFieldTypes.ListIndex = -1
        Else
            MsgBox &quot;You must select a field type.&quot;, vbExclamation
        End If
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>8. </B>Create the <TT>LegalName</TT> function in <TT>frmMain</TT> by entering
	the following code. The function performs a number of checks to verify that the name
	entered by the user as a table name or field name is acceptable to the Jet engine.
	For each check, it generates a user-defined error if the name fails the test. The
	error-handling code displays a message that explains to the user what the problem
	is and then returns <TT>False</TT> to the calling routine. If the name passes all
	the tests, the error-handling code is never called, and the function returns <TT>True</TT>.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Function LegalName(intNameType As Integer) As Boolean</TT>
    Dim i As Integer
    Dim strObjectName As String
    Dim dbfBiblio As Database, tdfNewTable As TableDef
    On Error GoTo IllegalName
        `Depending on the type of name being checked, store either 
        `the field or table name text box contents.
        If intNameType = FIELDNAME Then
            strObjectName = txtFieldName
        Else
            strObjectName = txtTableName
        End If
        `If blank, raise an error.
        If Len(strObjectName) = 0 Then Err.Raise 32767
        `If it has a leading space, raise an error.
        If Left$(strObjectName, 1) = &quot; &quot; Then Err.Raise 32766
        `If it contains any of the characters in the 
        `IllegalCharacters constant, raise an error
        For i = 1 To Len(IllegalCharacters)
            If InStr(strObjectName, Mid(IllegalCharacters, 
              i, 1)) &gt; 0 Then Err.Raise 32765
        Next i
        `If it contains any ANSI character from Chr$(0) to 
        `Chr$(31), (you guessed it) raise an error.
        For i = 0 To 31
            If InStr(strObjectName, Chr(i)) &gt; 0 _
               Then Err.Raise 32764
        Next i
        `Check if the field or table name already exists.  If so,
        `raise an error.
        If intNameType = FIELDNAME Then
            For i = 0 To lstFields.ListCount - 1
                If strObjectName = lstFields.List(i) _
                   Then Err.Raise 32763
            Next i
        ElseIf intNameType = TABLENAME Then
            Set dbfBiblio = 
                DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
            For Each tdfNewTable In dbfBiblio.TableDefs
                If tdfNewTable.Name = strObjectName _
                   Then Err.Raise 32762
            Next
        End If
        `If they've managed to get through all that validation, 
        `the function should be True, to indicate success.
        LegalName = True
    On Error GoTo 0
Exit Function
IllegalName:
    Dim strErrDesc As String, context As String
    `Note the use of an IIf statement to reduce code size.
    context = IIf(intNameType = FIELDNAME, &quot;field name&quot;, _
              &quot;table name&quot;)
    `Build an error message based on the user-defined error that 
    `occurred.
    Select Case Err.Number
        Case 32767
            strErrDesc = &quot;You must enter a &quot; &amp; context &amp; &quot;.&quot;
        Case 32766
            strErrDesc = &quot;The &quot; &amp; context &amp; _
                         &quot; cannot begin with a space.&quot;
        Case 32765
            strErrDesc = &quot;The &quot; &amp; context &amp; _
                &quot; contains the illegal character &quot; &amp; _
                Mid(IllegalCharacters, i, 1) &amp; &quot;.&quot;
        Case 32764
            strErrDesc = &quot;The &quot; &amp; context &amp; _
                &quot; contains the control character &quot; &amp; _
                &quot;with the ANSI value&quot; &amp; Str$(i) &amp; &quot;.&quot;
        Case 32763
            strErrDesc = &quot;The field name &quot; &amp; strObjectName &amp; _
                &quot; already exists in the field name list.&quot;
        Case 32762
            strErrDesc = &quot;The table name &quot; &amp; strObjectName &amp; _
                &quot; already exists in the database &quot; &amp; _
                  BIBLIO_PATH &amp; &quot;.&quot;
        Case Else
            ` Visual Basic's default error message.
            strErrDesc = Err.Description
    End Select
    MsgBox strErrDesc, vbExclamation
    `The function indicates False, or failure.
    LegalName = False
Exit Function
End Function</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P><B>9. </B>Enter the following code as the <TT>Click</TT> event of <TT>frmMain</TT>'s
	<TT>cmdRemoveField</TT>. This procedure deletes the field selected by the user.</P>
	<PRE><TT>Private Sub cmdRemoveField_Click()</TT>
    ` If the user has selected a field, remove it from the list.
    ` Otherwise, just ignore the click.
    If lstFields.ListIndex &gt; -1 Then lstFields.RemoveItem _
       lstFields.ListIndex
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>10. </B>Enter the following code as the <TT>Click</TT> event of <TT>frmMain</TT>'s
	<TT>cmdCreateTable</TT>. This procedure calls <TT>LegalName</TT> to verify that the
	table name is acceptable and verifies that the user has defined at least one field.
	It creates the field list for the SQL statement by reading through the data in <TT>lstFields</TT>
	and building a comma-delimited string from the entries in that list box. It then
	builds the SQL statement and uses the <TT>Execute</TT> method of the <TT>Database</TT>
	object to create the table.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdCreateTable_Click()</TT>
    Dim strSQL As String, strFieldList As String
    Dim i As Integer
    Dim dbfBiblio As Database
    On Error GoTo CreateTableError
        Screen.MousePointer = vbHourglass
        If LegalName(TABLENAME) Then
            If lstFields.ListCount &gt; 0 Then
                strFieldList = &quot; (&quot; &amp; lstFields.List(0)
                For i = 1 To lstFields.ListCount - 1
                    strFieldList = strFieldList &amp; &quot;, &quot; &amp; _
                                   lstFields.List(i)
                Next i
                strFieldList = strFieldList &amp; &quot;) &quot;
                strSQL = &quot;CREATE TABLE [&quot; &amp; txtTableName &amp; &quot;]&quot; _
                       &amp; strFieldList
                Set dbfBiblio = DBEngine.Workspaces(0). _
                       OpenDatabase(BIBLIO_PATH)
                dbfBiblio.Execute (strSQL)
                Screen.MousePointer = vbDefault
                MsgBox &quot;Table created successfully.&quot;
                txtTableName = &quot;&quot;
                lstFields.Clear
            Else
                Screen.MousePointer = vbDefault
                MsgBox &quot;You must define at least one field.&quot;, _
                       vbExclamation
            End If
        End If
    On Error GoTo 0
Exit Sub
CreateTableError:
    Screen.MousePointer = vbDefault
    MsgBox Error$, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>11. </B>Enter the following code as the <TT>Click</TT> event of <TT>frmMain</TT>'s
	<TT>cmdClose</TT>. Unlike most of the <TT>cmdClose_Click</TT> events in previous
	How-To's, this one has a bit more to it. If the user has entered a partial table
	definition (as determined by a table name or one or more created fields), a message
	box appears, asking the user whether to abandon the current creation, and it requires
	a Yes or No answer. If the user answers Yes, the program ends. If there is no partial
	table definition, the program ends without showing the message box.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    Dim strErrDesc As String
    ` If the user has entered a partial table definition, make 
    ` sure that the user wants to abandon it. If so, end the 
    ` program.
    If txtTableName &lt;&gt; &quot;&quot; Or lstFields.ListCount &gt; 0 Then
        strErrDesc = &quot;Do you want to abandon operations on &quot; &amp; _
                     &quot;the current table?&quot;
        If MsgBox(strErrDesc, vbQuestion + vbYesNo + 
           vbDefaultButton2) = vbYes Then
            End
        End If
    Else
        ` No partial table definition, so just end the program
        End
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>12. </B>Switch to <TT>frmTableList</TT>. Enter the following code into the
	declarations section of <TT>frmTableList</TT>, modifying the path in the <TT>Const</TT>
	statement to point to your copy of BIBLIO.MDB.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>13. </B>Enter the following code as <TT>frmTableList</TT>'s <TT>Form_Load</TT>
	event. This calls the <TT>ListTables</TT> subroutine, explained in the next step,
	to fill the <TT>lstTables</TT> list box with the database's tables.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    ` Fill the list box with the current non-system tables in 
    ` BIBLIO.MDB.
    ListTables
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>14. </B>Create the <TT>ListTables</TT> subroutine in <TT>frmTableList</TT>
	by entering the following code. <TT>ListTables</TT> is called when the form loads
	and when the user deletes a table. It uses the <TT>TableDefs</TT> collection of the
	<TT>Database</TT> object to build a list of tables in the BIBLIO.MDB database. The
	<TT>TableDefs</TT> collection contains one record for each table in the database,
	including the (normally hidden) system tables. Because the <TT>Name</TT> property
	of all system table <TT>TableDef</TT> objects begins with the string <TT>&quot;MSys&quot;</TT>,
	this procedure assumes that any table starting with that string is a system table
	and ignores it. The names of all other tables get added to the <TT>lstTables</TT>
	list box.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub ListTables()</TT>
Dim dbfBiblio As Database, tdfTableList As TableDef
    On Error GoTo ListError
        Screen.MousePointer = vbHourglass
        `Clear the list box, then open the database.
        lstTables.Clear
        Set dbfBiblio = _
            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
        ` Cycle through the table definitions in BIBLIO_PATH.
        ` If the table is a system table (name begins with MSys), 
        ` ignore it. Otherwise, add it to the list.
        For Each tdfTableList In dbfBiblio.TableDefs
            If Left$(tdfTableList.Name, 4) &lt;&gt; &quot;MSys&quot; Then _
               lstTables.AddItem tdfTableList.Name
        Next
        Screen.MousePointer = vbDefault
    On Error GoTo 0
Exit Sub
ListError:
    Screen.MousePointer = vbDefault
    MsgBox Err.Description, vbExclamation
    Unload frmTableList
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>15. </B>Enter the following code as the <TT>Click</TT> event <TT>frmTableList</TT>'s
	<TT>cmdDelete</TT>. <TT>DROP TABLE</TT> deletes a table whether or not the table
	contains data. Because you do not want to delete any tables with data, this procedure
	checks to make sure that the table is empty and then deletes it.
	<P>
</DL>



<BLOCKQUOTE>
	<P>
	<PRE><TT>Private Sub cmdDelete_Click()</TT>
Dim dbfBiblio As Database
    On Error GoTo DeleteError
        Screen.MousePointer = vbHourglass
        `If a table is selected, then continue
        If lstTables.ListIndex &gt; -1 Then
            `Confirm that the table has no records
            If TableIsEmpty() Then
                ` Delete the selected table from BIBLIO_PATH.
                Set dbfBiblio = DBEngine.Workspaces(0). _
                    OpenDatabase(BIBLIO_PATH)
                dbfBiblio.Execute (&quot;DROP TABLE [&quot; &amp; _
                                  lstTables.Text &amp; &quot;]&quot;)
                ` Display the modified list of tables.
                ListTables
                Screen.MousePointer = vbDefault
            Else
                `The table has records, so inform the user.
                Screen.MousePointer = vbDefault
                MsgBox lstTables.Text &amp; &quot; is not empty.&quot;, _
                       vbExclamation
            End If
        Else
            `No table has been chosen, so inform the user.
            Screen.MousePointer = vbDefault
            MsgBox &quot;You have not selected a table to delete.&quot;, _
                   vbExclamation
        End If
    On Error GoTo 0
Exit Sub
</PRE>
	<P>
	<PRE><TT>DeleteError:</TT>
    Screen.MousePointer = vbDefault
    MsgBox Err.Description, vbExclamation
    Unload frmTableList
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>16. </B>Create the <TT>TableIsEmpty</TT> function by entering the following
	code into <TT>frmTableList</TT>. This function returns <TT>True</TT> if the table
	currently selected in <TT>lstTables</TT> is empty.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Function TableIsEmpty() As Boolean</TT>
Dim dbfBiblio As Database, tdfTableList As TableDef
    On Error GoTo TableIsEmptyError
        Set dbfBiblio = 
            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
        ` Cycle through the table definitions in BIBLIO_PATH.
        ` When the table currently selected in lstTables is found, 
        ` check to see whether it has records. If it does not, 
        ` return True; otherwise, return False.
        For Each tdfTableList In dbfBiblio.TableDefs
            If tdfTableList.Name = lstTables.Text Then
                TableIsEmpty = IIf(tdfTableList.RecordCount = 0, _
                     True, False)
                Exit For
            End If
        Next
    On Error GoTo 0
Exit Function
TableIsEmptyError:
    MsgBox Err.Description, vbExclamation
    Unload frmTableList
Exit Function
End Function</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>17. </B>Enter the following code as the <TT>Click</TT> event of <TT>frmTableList</TT>'s
	<TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    Unload frmTableList
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>The <TT>frmMain</TT> form essentially builds a <TT>CREATE TABLE</TT> SQL statement
by using the table name listed in the <TT>lstTables</TT> control, with the fields
listed in the <TT>lstFields</TT> list box. This might seem greatly simplified, but
it guides all the reasoning behind the code added in this How-To.</P>
<P>The main action occurs in the <TT>cmdCreateTable_Click</TT> event of <TT>frmMain</TT>.
Here, based on the choices the user made regarding the name of the table and the
name and type of the fields to be added, the <TT>CREATE TABLE</TT> SQL statement
is concatenated and executed. Clicking the <TT>cmdListTables</TT> button displays
a list of existing tables in the Access database in case the user wants to rewrite
an existing empty table. (The <TT>TableIsEmpty</TT> function is used to ensure that
valu-able data is not overwritten; the program will destroy only an empty table.)
The <TT>cboFieldTypes</TT> combo box allows the program to filter the various field
types in a manner accessible to the user.</P>
<P><B>Comments</B></P>
<P>One of the key items to remember in this How-To is the destructive behavior of
the <TT>CREATE TABLE</TT> statement, as mentioned in step 15. If a <TT>CREATE TABLE</TT>
statement is issued defining a table with the same name as one that already exists
in the Access database, it destroys the existing table. Although this behavior is
not true across all database platforms, it's usually better to be safe than sorry
and include a routine similar to the <TT>TableIsEmpty</TT> function in this How-To.</P>
<P>
<H2>3.13 How do I...</H2>
<H3><A NAME="Append and delete records?"></A><B>Append and delete records?</B></H3>
<P><B>Problem</B></P>
<P>I have a table to which I'd like to add records that are built from records in
other tables. I'd also like to delete records based on criteria I specify. How can
I accomplish these tasks with SQL?</P>
<P><B>Technique</B></P>
<P>SQL provides two statements, the <TT>INSERT INTO</TT> and <TT>DELETE</TT> statements,
that append records to a table and delete records from a table, respectively.</P>
<P><B>THE </B><TT>INSERT INTO</TT><B> STATEMENT</B><BR>
SQL's <TT>INSERT INTO</TT> statement is used to append records to an existing table.
The <TT>INSERT INTO</TT> statement has three clauses, shown in Table 3.20.</P>
<P>
<H4>Table 3.20. The syntax of the INSERT INTO statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD WIDTH="150" ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>INSERT INTO</TT></TD>
		<TD WIDTH="150" ALIGN="LEFT">Names the table and fields into which data are to be inserted</TD>
		<TD ALIGN="LEFT"><TT>INSERT INTO [Publisher Titles] ([Name], [Title])</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>SELECT</TT></TD>
		<TD WIDTH="150" ALIGN="LEFT">Names the fields from which data are to be taken</TD>
		<TD ALIGN="LEFT"><TT>SELECT Publishers.Name, Titles.Title</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>FROM</TT></TD>
		<TD WIDTH="150" ALIGN="LEFT">Names the table or other source of the data</TD>
		<TD ALIGN="LEFT"><TT>FROM Publishers INNER JOIN Titles ON Publishers.PubID</TT> <TT>= Titles.PubID</TT></TD>
	</TR>
</TABLE>
</P>
<P>The <TT>INSERT INTO</TT> clause takes two parameters, the table name ([Publisher
Titles] in the example) and the field names into which data are to be inserted. The
field names are enclosed in parentheses and delimited by commas.</P>
<P>The <TT>SELECT</TT> clause statement consists of a list of fields from which the
data to be inserted into the fields named in the <TT>INSERT INTO</TT> clause will
be drawn. There must be a one-to-one correspondence between the fields in the <TT>INSERT
INTO</TT> clause and the fields in the <TT>SELECT</TT> clause. If you have more <TT>INSERT
INTO</TT> fields than <TT>SELECT</TT> fields, or vice versa, an error will result.
If the field names are from multiple tables--as in the example--and if the names
are ambiguous (that is, both tables have fields with the same names), they must be
qualified with the table names.</P>
<P>The <TT>FROM</TT> clause statement names the table or other source of the fields
named in the <TT>SELECT</TT> clause. In the example, the <TT>FROM</TT> clause names
not a single table but a pair of tables linked by an <TT>INNER JOIN</TT>. (See How-To
3.6 for details on <TT>INNER JOIN</TT>s.)</P>
<P>As with other SQL action queries, you run the <TT>INSERT INTO</TT> clause by using
it as the argument for the <TT>Execute</TT> method of the <TT>Database</TT> object.
To execute the query shown in the table against a database object represented by
the variable <TT>dbfTest</TT>, you would create the following Visual Basic statement
(note the continuation character):</P>


<BLOCKQUOTE>
	<PRE><TT>dbfTest.Execute(&quot;INSERT INTO [Publisher Titles] ([Name], &quot; &amp; _</TT>
<TT>    &quot;[Title]) SELECT Publishers.Name, &quot; &amp; _</TT>
<TT>    &quot;Titles.Title FROM Publishers INNER JOIN Titles ON &quot; &amp; _</TT>
<TT>    &quot;Publishers.PubID = Titles.PubID&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>The </B><TT>DELETE</TT><B> Statement</B></P>
<P>Use the SQL <TT>DELETE</TT> statement to delete records from a table, based on
criteria you specify in the <TT>DELETE</TT> statement. The <TT>DELETE</TT> statement
has the syntax shown in Table 3.21.</P>
<P>
<H4>Table 3.21. The syntax of the DELETE statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DELETE FROM</TT></TD>
		<TD ALIGN="LEFT">Names the table from which records are to be deleted</TD>
		<TD ALIGN="LEFT"><TT>DELETE FROM [Publisher Titles]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>WHERE</TT></TD>
		<TD ALIGN="LEFT">Criteria that select records for deletion</TD>
		<TD ALIGN="LEFT"><TT>WHERE [Publication Date]</TT></TD>
	</TR>
</TABLE>
</P>
<P>Execute the <TT>DELETE</TT> statement by passing it as the parameter to the <TT>Execute</TT>
method statement of the <TT>Database</TT> object. If you have a <TT>Database</TT>
object variable named <TT>dbfTest</TT>, this Visual Basic statement executes the
SQL shown in the table:</P>


<BLOCKQUOTE>
	<PRE><TT>dbfTest.Execute(&quot;DELETE FROM [Publisher Titles] WHERE [Publication Date] &lt;= 1990&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>Open and run the project UPDATE.VBP. Click the Create Table button and then the
Append Records button. These two actions create a table named [Publisher Titles],
fill it with records, and display the records in the form, as shown in Figure 3.17.
Notice the titles from Addison-Wesley on your screen. (You might need to scroll down
to see them.)</P>
<P><A HREF="javascript:popUp('03fig17.gif')"><B>Figure 3.17.</B></A><B> </B><I>The
SQL Insert Into form, showing appended records.</I></P>
<P>Click the Delete Records button. The Select Publisher form shown in Figure 3.18
appears. Select Addison-Wesley and click OK. The previous form reappears with the
list refreshed to show the records currently in the [Publisher Titles] table. Notice
that the Addison-Wesley titles are missing.</P>
<P><A HREF="javascript:popUp('03fig18.gif')"><B>Figure 3.18.</B></A><B> </B><I>The
Publisher List form, showing publisher names.</I></P>


<BLOCKQUOTE>
	<P><B>1. </B>Create a new project called APPEND.VBP. Rename <TT>Form1</TT> to <TT>frmMain</TT>,
	create the objects and properties listed in Table 3.22, and save the form as APPEND.FRM.
	<H4>Table 3.22. Objects and properties for the Append and Delete form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>frmMain</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.13 - Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Sorted</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdDeleteRecords</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Delete Records</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdDropTable</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>D&amp;rop Table</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdAppendRecords</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Append Records</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdCreateTable</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Create &amp;Table</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Insert a new form into the project. Rename it to <TT>frmSelectPublisher</TT>,
	create the objects and properties listed in Table 3.23, and save the form as PublisherSelect.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.23. Objects and properties for the Select Publisher form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>frmSelectPublisher</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>BorderStyle</TT></TD>
		<TD ALIGN="LEFT"><TT>3 - Fixed Dialog</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.13 - Publisher List</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>MaxButton</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>MinButton</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdOK</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;OK</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Default</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdCancel</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Cancel</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CheckBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>chkDeleteAll</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Delete All</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstPublishers</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Sorted</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following statements to the declarations section of <TT>frmMain</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;
Private strPublisherToDelete As String
Private dbfBiblio As Database</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Enter the following code as in the <TT>Load</TT> event of <TT>frmMain</TT>.
	The <TT>Form_Load</TT> code checks to see whether the [Publisher Titles] table exists
	in the database and, if it exists, whether it has any records. It then enables and
	disables the appropriate command buttons.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
Dim tdfTable As TableDef
    Dim blnTableFound As Boolean
    On Error GoTo LoadError
        blnTableFound = False
        `Open the database.
        Set dbfBiblio = 
            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
        `Iterate through the TableDefs collection.  If the table 
        `&quot;Publisher Titles&quot; is found, configure the 
        `form's buttons appropriately.
        For Each tdfTable In dbfBiblio.TableDefs
            If tdfTable.Name = &quot;Publisher Titles&quot; Then
                blnTableFound = True
                cmdDropTable.Enabled = True
                cmdCreateTable.Enabled = False
                If tdfTable.RecordCount &gt; 0 Then
                    cmdDeleteRecords.Enabled = True
                    cmdAppendRecords.Enabled = False
                    FillList
                Else
                    cmdDeleteRecords.Enabled = False
                    cmdAppendRecords.Enabled = True
                End If
                Exit For
            End If
        Next
        `If the table is not found, configure the form's buttons
        `appropriately.
        If blnTableFound = False Then
            cmdDropTable.Enabled = False
            cmdCreateTable.Enabled = True
            cmdAppendRecords.Enabled = False
            cmdDeleteRecords.Enabled = False
        End If
    On Error GoTo 0
Exit Sub
LoadError:
    MsgBox Err.Description, vbExclamation
    Unload Me
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>5. </B>Create the <TT>FillList</TT> subroutine in <TT>frmMain</TT> by entering
	the following code. The <TT>FillList</TT> routine fills the list box <TT>lstData</TT>
	with the records from the [Publisher Titles] table.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Sub FillList()</TT>
Dim recSelect As Recordset
    Dim strSQL As String
    On Error GoTo FillListError
        `Clear the list box.
        lstData.Clear
        `Get all the records from the Publisher Titles table.
        Set recSelect = dbfBiblio.OpenRecordset( _
           &quot;SELECT * FROM &quot; &amp; _
           &quot;[Publisher Titles]&quot;, _
            dbOpenSnapshot)
        `Put the records into the list box.
        If recSelect.RecordCount &gt; 0 Then
            recSelect.MoveFirst
            Do Until recSelect.EOF
                lstData.AddItem recSelect![Name] &amp; &quot;: &quot; &amp; _
                                recSelect![Title]
                recSelect.MoveNext
            Loop
        End If
    On Error GoTo 0
Exit Sub
FillListError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>6. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmMain</TT>'s
	<TT>cmdCreateTable</TT>. This code creates the [Publisher Titles] table. Refer to
	the preceding How-To for information on the <TT>CREATE TABLE</TT> statement.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdCreateTable_Click()</TT>
    Dim strSQL As String
</PRE>
	<P>
	<PRE><TT>    On Error GoTo CreateTableError</TT>
        `Build the CREATE TABLE statement.
        strSQL = &quot;CREATE TABLE [Publisher Titles] &quot; &amp; _
            &quot;([Name] TEXT, [Title] TEXT)&quot;
        `Execute the statement.  Since it's an action query,
        `you don't use the OpenRecordset command.  It would
        `fail, since an action query does not return a recordset.
        dbfBiblio.Execute (strSQL)
        `Configure the form's buttons appropriately.
        cmdCreateTable.Enabled = False
        cmdDropTable.Enabled = True
        cmdAppendRecords.Enabled = True
    On Error GoTo 0
Exit Sub
CreateTableError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>7. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmMain</TT>'s
	<TT>cmdDropTable</TT>. This code deletes the [Publisher Titles] table. Refer to the
	preceding How-To for information on the <TT>DROP TABLE</TT> statement.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdDropTable_Click()</TT>
Dim dbName As String
    On Error GoTo DropTableError
        `Build &amp; execute the DROP TABLE statement.
        dbfBiblio.Execute (&quot;DROP TABLE [Publisher Titles]&quot;)
        `Configure the form's buttons appropriately.
        cmdDropTable.Enabled = False
        cmdCreateTable.Enabled = True
        cmdAppendRecords.Enabled = False
        cmdDeleteRecords.Enabled = False
        `Clear the list box.
        lstData.Clear
    On Error GoTo 0
Exit Sub
DropTableError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>8. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmMain</TT>'s
	<TT>cmdAppendRecords</TT>. This command builds the SQL statement that will append
	the records to the database and then executes the statement. The SQL statement is
	identical to that shown in Table 3.20.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdAppendRecords_Click()</TT>
    Dim strSQL As String
    On Error GoTo AppendRecordsError
        Screen.MousePointer = vbHourglass
        `Build the INSERT INTO statement
        strSQL = _
            &quot;INSERT INTO [Publisher Titles] ( [Name], Title ) &quot; &amp; _
            &quot;SELECT Publishers.Name, Titles.Title &quot; &amp; _
            &quot;FROM Publishers INNER JOIN Titles &quot; &amp; _
            &quot;ON Publishers.PubID = Titles.PubID&quot;
        `Execute the statement.
        dbfBiblio.Execute (strSQL)
        `Fill the list box via the FillList subroutine.
        FillList
        `Configure the form's buttons appropriately.
        cmdDeleteRecords.Enabled = True
        cmdAppendRecords.Enabled = False
        Screen.MousePointer = vbDefault
    On Error GoTo 0
Exit Sub
AppendRecordsError:
    Screen.MousePointer = vbDefault
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P><B>9. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmMain</TT>'s
	<TT>cmdDeleteRecords</TT>. This procedure deletes the designated records from the
	database. It calls the <TT>GetPublisher</TT> function of <TT>frmSelectPublisher</TT>,
	returning a value to be placed in <TT>strPublisherToDelete</TT>. Then it examines
	the public variable <TT>strPublisherToDelete</TT>; if <TT>strPublisherToDelete</TT>
	is an empty string, it indicates that the user wants to cancel the deletion, so no
	records are deleted. If <TT>strPublisherToDelete</TT> is <TT>&quot;*&quot;</TT>,
	the user wants to delete all the records. Otherwise, <TT>frmSelectPublisher</TT>
	contains the name of the publisher whose titles the user wants to delete. The procedure
	builds the appropriate <TT>SQL DELETE</TT> statement and then executes the statement.</P>
	<PRE><TT>Private Sub cmdDeleteRecords_Click()</TT>
    Dim strSQL As String
    On Error GoTo DeleteRecordsError
    `Use the GetPublisher function on frmSelectPublisher to return
    `a publisher to delete.
    strPublisherToDelete = frmSelectPublisher.GetPublisher
    `If one is selected, then delete it.
    If strPublisherToDelete &lt;&gt; &quot;&quot; Then
        `Build the DELETE statement.
        strSQL = &quot;DELETE FROM [Publisher Titles]&quot;
        `If the publisher to delete isn't the * wildcard, then
        `modify the SQL to choose the selected publisher(s).
        If strPublisherToDelete &lt;&gt; &quot;*&quot; Then
            strSQL = strSQL &amp; _
                     &quot; WHERE [Publisher Titles].[Name] = &quot; &amp; _
                &quot;&quot;&quot;&quot; &amp; strPublisherToDelete &amp; &quot;&quot;&quot;&quot;
        End If
        `Execute the statement.
        dbfBiblio.Execute (strSQL)
        `Fill the list box.
        FillList
    End If
    cmdAppendRecords.Enabled = (lstData.ListCount = 0)
    cmdDeleteRecords.Enabled = (lstData.ListCount &gt; 0)
Exit Sub
DeleteRecordsError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>10. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmMain</TT>'s
	<TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>11. </B>Switch to <TT>frmPublisherSelect</TT> and enter the following code
	into the declarations section. Modify the path in the <TT>Const</TT> statement to
	point to your copy of BIBLIO.MDB.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
        &quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;
Private strPublisherToDelete As String</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>12. </B>Enter the following code as the <TT>Load</TT> event for <TT>frmSelectPublisher</TT>.
	On loading, the form builds a recordset of publisher names in the [Publisher Titles]
	table through a SQL <TT>SELECT</TT> statement with the <TT>DISTINCT</TT> keyword.
	(See How-To 3.2 for information on the <TT>DISTINCT</TT> keyword.) It uses that recordset
	to fill the <TT>lstPublishers</TT> list box.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    Dim dbfBiblio As Database, recSelect As Recordset
    Dim strSQL As String
    On Error GoTo LoadError
        Set dbfBiblio = _
            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
        strSQL = &quot;SELECT DISTINCT [Name] FROM [Publisher Titles]&quot;
        Set recSelect = dbfBiblio.OpenRecordset(strSQL)
        If recSelect.RecordCount &gt; 0 Then
            recSelect.MoveFirst
            Do Until recSelect.EOF
                lstPublishers.AddItem recSelect![Name]
                recSelect.MoveNext
            Loop
        End If
    On Error GoTo 0
Exit Sub
LoadError:
    MsgBox Err.Description, vbExclamation
    strPublisherToDelete = &quot;&quot;
    Me.Hide
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>13. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmSelectPublisher</TT>'s
	<TT>cmdOK</TT>. This procedure sets the public variable <TT>strPublisherToDelete</TT>.
	If the user has clicked the Delete All button, <TT>strPublisherToDelete</TT> is set
	to the string <TT>&quot;*&quot;</TT>. Otherwise, <TT>strPublisherToDelete</TT> is
	set to the name of the selected publisher.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdOK_Click()</TT>
If chkDeleteAll Then
        strPublisherToDelete = &quot;*&quot;
        Me.Hide
    ElseIf lstPublishers.ListIndex &gt; -1 Then
        strPublisherToDelete = lstPublishers.Text
        Me.Hide
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>14. </B>Enter the following code as the <TT>DblClick</TT> event for <TT>frmSelectPublisher</TT>'s
	<TT>lstPublishers</TT>. This allows the program to call the <TT>cmdOK_Click</TT>
	event, preventing duplication of code. A double-click of the Publishers list brings
	about exactly the same result as if the user had selected a publisher with a single
	left-click and then clicked the OK button.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub lstPublishers_DblClick()</TT>
<TT>    cmdOK_Click</TT>
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>15. </B>Enter the following code as the <TT>Click</TT> event for <TT>frmSelectPublisher</TT>'s
	<TT>cmdCancel</TT>. This code ensures that the <TT>strPublisherToDelete</TT> string
	is blank, preventing the calling form's code from inadvertently deleting a publisher.
	Note that the form is hidden (as opposed to unloaded) here. This form is called by
	the <TT>GetPublisher</TT> public function and is unloaded by that function.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdCancel_Click()</TT>
    strPublisherToDelete = &quot;&quot;
    Me.Hide
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>16. </B>Enter the following code to create the <TT>GetPublisher</TT> method
	for <TT>frmSelectPublisher</TT>. This is a public function, allowing you to use this
	form like a dialog box, resulting in this function being sent back to the calling
	form. You will find that this method for using forms is preferable to the &quot;one
	use&quot; form in many situations, especially when a &quot;generic&quot; form is
	used for multiple purposes.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Public Function GetPublisher() As String</TT>
    Me.Show vbModal
    GetPublisher = strPublisherToDelete
    Unload Me
End Function</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>When the user clicks the <TT>cmdCreateTable</TT> button, a <TT>CREATE TABLE</TT>
statement is executed (for more information on the <TT>CREATE TABLE</TT> statement,
see the preceding How-To) to create an empty table in BIBLIO.MDB. The <TT>cmdAppendRecords</TT>
button, when clicked, fills that empty table by executing the <TT>INSERT...INTO</TT>
statement, creating the information from a <TT>SELECT</TT> query run on two other
tables in the database. When the table is fully populated, the list box <TT>lstTitles</TT>
fills from the new table's data via the <TT>FillList</TT> subroutine. The <TT>cmdDeleteRecords</TT>
button, which deletes the newly created records, first calls the <TT>GetPublisher</TT>
public function on the <TT>frmSelectPublisher</TT> form. The form presents a dialog
box with options to delete records from either a single publisher or all publishers
in the table. Based on this selection, the <TT>GetPublisher</TT> function returns
either a publisher's name or the asterisk wildcard character. Using this information,
the <TT>cmdDeleteRecords</TT> button builds and executes a <TT>DELETE</TT> statement.
Last, but not least, the <TT>cmdDropTable</TT> button simply executes a <TT>DROP
TABLE</TT> statement on the new table.</P>
<P><B>Comments</B></P>
<P>One of the more interesting capabilities of Visual Basic is its capacity for public
functions and subroutines on forms. This allows for a wide degree of flexibility
in the way you can use forms, including your ability to use a form in a manner similar
to that of, say, a common dialog, by calling a public function on the form. This
functionality serves well in this How-To because it makes the selection process for
deletion of a group of records much easier and cleaner in terms of design and user
interface.</P>
<P>The <TT>INSERT...INTO</TT> and <TT>DELETE</TT> statements are useful for creating
and emptying temporary tables. Temporary tables, although not always the most efficient
way to go, do have their purposes, and these two new tools in your arsenal should
go a long way toward their proper and efficient management.</P>
<P>
<H2>3.14 How do I...</H2>
<H3><A NAME="Create a new table with data from existing tables?"></A><B>Create a
new table with data from existing tables?</B></H3>
<P><B>Problem</B></P>
<P>I know I can use <TT>CREATE TABLE</TT> and <TT>INSERT INTO</TT> to create a table
and add records to it. But in my application, I do this many times, and I'd like
to accomplish it all with a single SQL operation. How can I do this?</P>
<P><B>Technique</B></P>
<P>The <TT>SELECT...INTO</TT> statement lets you create a new table with data from
existing tables in a single operation. Table 3.24 shows its syntax. Similar to <TT>INSERT...INTO</TT>
and <TT>DELETE</TT> statements, both covered in the preceding How-To, this tool provides
an excellent way to work with temporary tables.</P>
<P>
<H4>Table 3.24. The syntax of the SELECT...INTO statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>SELECT</TT></TD>
		<TD ALIGN="LEFT">Names the fields in the existing table that will be re-created in the new table</TD>
		<TD ALIGN="LEFT"><TT>SELECT Publishers.Name, Titles.Title</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>INTO</TT></TD>
		<TD ALIGN="LEFT">Names the new table</TD>
		<TD ALIGN="LEFT"><TT>INTO [Publisher Titles]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>FROM</TT></TD>
		<TD ALIGN="LEFT">Names the table (or other source) of the data</TD>
		<TD ALIGN="LEFT"><TT>FROM Publishers INNER</TT> <TT>JOIN Titles ON Publishers.PubID =</TT> <TT>Titles.PubID</TT></TD>
	</TR>
</TABLE>
</P>
<P>To run the <TT>SELECT...INTO</TT> query, use the <TT>Execute</TT> method of the
<TT>Database</TT> object. The following Visual Basic statement (on one line) executes
the query shown in the table on the database represented by the variable <TT>dbfTest</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>dbfTest.Execute(&quot;SELECT Publishers.Name, &quot; &amp; _</TT>
<TT>    &quot;Titles.Title INTO [Publisher Titles]&quot; &amp; _</TT>
<TT>    &quot; FROM Publishers INNER JOIN Titles ON Publishers.PubID = Titles.PubID&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>With the example presented previously, a new table, titled [Publisher Titles],
is created in the database, constructed from information gleaned from two other tables,
connected by an <TT>INNER JOIN</TT>. The difference between the <TT>SELECT...INTO</TT>
command and the <TT>INSERT...INTO</TT> command is simple: the <TT>INSERT...INTO</TT>
command creates new records and performs an <TT>INSERT</TT> on the existing recipient
table, whereas the <TT>SELECT...INTO</TT> creates a new recipient table before performing
an <TT>INSERT</TT>. The <TT>SELECT...INTO</TT> statement, because of this behavior,
is the ideal method of creating a temporary table in one step. In the preceding How-To,
you needed two steps--one to create the table and one to add the records. <TT>SELECT...INTO</TT>
combines these two steps into one, making it simpler to use and simpler to debug
if problems arise. Note that the behavior on some databases differs as to exactly
what happens when a <TT>SELECT...INTO</TT> statement is executed, with the recipient
table having the same name as an existing table in the database. In a Microsoft Access
database, the <TT>SELECT...INTO</TT> command deletes the existing table first. Some
databases, however, might trigger an error in performing this action. To examine
this behavior, you should create a sample table with data, execute a <TT>SELECT...INTO</TT>
statement with that sample table as recipient, and note the results.</P>
<P><B>Steps</B></P>
<P>Open and run the project MAKETABL.VBP. Click the Create Table button; the list
box fills with the records added to the newly created table (see Figure 3.19). Click
the Drop Table button to delete the table.</P>
<P><A HREF="javascript:popUp('03fig19.gif')"><B>Figure 3.19.</B></A><B> </B><I>The
SQL Select Into form, with new table and records.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called MAKETABL.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.25, and save the form as MAKETABL.FRM.
	<P>
</DL>

<H4>Table 3.25. Objects and properties for the Table Maker form.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.14 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Sorted</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdDropTable</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>D&amp;rop Table</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdCreateTable</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Create &amp;Table</TT></TD>
	</TR>
</TABLE>
</P>

<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following statements to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
</PRE>
	<P>
	<PRE><TT>Private Const BIBLIO_PATH = _</TT>
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;
Private dbfBiblio As Database</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Enter the following code as the <TT>Load</TT> event for <TT>Form1</TT>.
	On loading, this procedure looks for the [Publisher Titles] table in the database.
	If it finds the table, it fills the list box with the table's data and enables the
	Drop Table button. If it does not find the table, it enables the Create Table button.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
Dim tdfTable As TableDef
    Dim blnTableFound As Boolean
    On Error GoTo LoadError
        blnTableFound = False
        `Open the database
        Set dbfBiblio = _
            DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
        `Check each table in the TableDefs collection; 
        `if the name matches, then allow the user to drop the 
        `table, and populate the list box.
        For Each tdfTable In dbfBiblio.TableDefs
            If tdfTable.Name = &quot;Publisher Titles&quot; Then
                blnTableFound = True
                cmdDropTable.Enabled = True
                cmdCreateTable.Enabled = False
                FillList
                Exit For
            End If
        Next
        `If no table was found, allow the user to create the 
        `table.
        If blnTableFound = False Then
            cmdDropTable.Enabled = False
            cmdCreateTable.Enabled = True
        End If
    On Error GoTo 0
Exit Sub
LoadError:
    MsgBox Err.Description, vbExclamation
    Unload Me
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Create the <TT>FillList</TT> subroutine by entering the following code
	into <TT>Form1</TT>. This subroutine fills the list box with the contents of the
	[Publisher Titles] table.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Sub FillList()</TT>
Dim recSelect As Recordset
    Dim strSQL As String
    On Error GoTo FillListError
        `Clear the list box
        lstData.Clear
        `Get the [Publisher Titles] table in a recordset
        Set recSelect = dbfBiblio.OpenRecordset( _
            &quot;SELECT * FROM &quot; &amp; _
            &quot;[Publisher Titles]&quot;, dbOpenSnapshot)
        `If there are any records, fill the list box
        If recSelect.RecordCount &gt; 0 Then
            recSelect.MoveFirst
            Do Until recSelect.EOF
                lstData.AddItem recSelect![Name] &amp; &quot;: &quot; &amp; _
                                recSelect![Title]
                recSelect.MoveNext
            Loop
        End If
    On Error GoTo 0
Exit Sub
FillListError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>5. </B>Enter the following code as the <TT>Click</TT> event for <TT>cmdCreateTable</TT>.
	This procedure builds the <TT>SELECT...INTO</TT> SQL statement, building the [Publisher
	Titles] table from the combination of the <TT>[Name]</TT> field from the [Publishers]
	table and the <TT>[Title]</TT> field from the [Titles] table, as described in the
	&quot;Technique&quot; section of this How-To. When built, it then executes the statement
	and calls the <TT>FillList</TT> subroutine to fill the list box on the form. Finally,
	this step enables the Delete Records button, because (you hope) you now have records
	to delete.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdCreateTable_Click()</TT>
Dim strSQL As String
    On Error GoTo CreateTableError
        Screen.MousePointer = vbHourglass
        `Build the SELECT INTO statement.
        strSQL = &quot;SELECT Publishers.Name, Titles.Title &quot; &amp; _
            &quot;INTO [Publisher Titles] &quot; &amp; _
            &quot;FROM Publishers INNER JOIN Titles &quot; &amp; _
            &quot;ON Publishers.PubID = Titles.PubID&quot;
        `Create the new table by executing the SQL statement.
        dbfBiblio.Execute (strSQL)
        `Fill the list box with records.
        FillList
        `Set the command buttons.
        cmdCreateTable.Enabled = False
        cmdDropTable.Enabled = True
        Screen.MousePointer = vbDefault
    On Error GoTo 0
Exit Sub
CreateTableError:
    Screen.MousePointer = vbDefault
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>6. </B>Enter the following code as the <TT>Click</TT> event for <TT>cmdDropTable</TT>.
	The routine executes a <TT>DROP TABLE</TT> statement against the newly created [Publisher
	Titles] table and reenables the Create Table button.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdDropTable_Click()</TT>
On Error GoTo DropTableError
        `Execute the DROP TABLE statement
        dbfBiblio.Execute (&quot;DROP TABLE [Publisher Titles]&quot;)
        `Set the command buttons
        cmdDropTable.Enabled = False
        cmdCreateTable.Enabled = True
        `Clear the list box.
        lstData.Clear
    On Error GoTo 0
Exit Sub
DropTableError:
    MsgBox Err.Description, vbExclamation
Exit Sub
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>7. </B>Enter the following code as the <TT>Click</TT> event for <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>When <TT>Form1</TT> loads, it first attempts to find the [Publisher Titles] table.
If it finds the table, it loads the table's information into the list box by calling
the <TT>FillList</TT> subroutine, disables the Create Table button, and then enables
the Drop Table buttons. If it doesn't find the table, it enables the Create Table
button and disables the Drop Table button.</P>
<P>If the Create Table button is enabled, when clicked, it constructs and executes
a <TT>SELECT...INTO</TT> statement, creating the [Publisher Titles] table and pulling
in information from both the [Publishers] and the [Titles] table to populate it in
one step. When complete, it loads the data into the list box by using the <TT>FillList</TT>
subroutine.</P>
<P>The Drop Table button, if enabled, issues a <TT>DROP TABLE</TT> statement when
clicked, destroying your [Publisher Titles] table in one fell swoop.</P>
<P><B>Comments</B></P>
<P>When you use <TT>SELECT...INTO</TT> to create the table, the fields in the new
table inherit only the data type and field size of the corresponding fields in the
query's source table. No other field or table properties are picked up from the existing
table.</P>
<P>
<H2>3.15 How do I...</H2>
<H3><A NAME="Modify a table's structure?"></A>Modify a table's structure?</H3>
<P><B>Problem</B></P>
<P>I need to be able to add or drop columns from a table without having to use Access
or go through the lengthy process of working with <TT>TableDef</TT> and <TT>Field</TT>
objects. Can I do this with a simple SQL statement?</P>
<P><B>Technique</B></P>
<P>The <TT>ALTER TABLE</TT> statement lets you add or drop columns or indexes as
needed, with a single SQL operation. The syntax is explained in Table 3.26, with
a sample statement.</P>
<P>
<H4>Table 3.26. The syntax of the ALTER TABLE statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ALTER TABLE</TT></TD>
		<TD ALIGN="LEFT">Selects the table to be altered</TD>
		<TD ALIGN="LEFT"><TT>ALTER TABLE [Publisher Titles]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ADD COLUMN</TT></TD>
		<TD ALIGN="LEFT">Adds a column, defining its data type at the same time</TD>
		<TD ALIGN="LEFT"><TT>ADD COLUMN [Notes] MEMO NOT NULL</TT></TD>
	</TR>
</TABLE>
</P>
<P>The <TT>ALTER TABLE</TT> statement uses several other keywords, as listed in Table
3.27.</P>
<P>
<H4>Table 3.27. Additional syntax for the ALTER TABLE statement.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DROP COLUMN</TT></TD>
		<TD ALIGN="LEFT">Removes a column</TD>
		<TD ALIGN="LEFT"><TT>DROP COLUMN [Notes]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ADD CONSTRAINT</TT></TD>
		<TD ALIGN="LEFT">Adds an index to the table</TD>
		<TD ALIGN="LEFT"><TT>ADD CONSTRAINT [Key1] [Notes]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>DROP CONSTRAINT</TT></TD>
		<TD ALIGN="LEFT">Removes an index statement</TD>
		<TD ALIGN="LEFT"><TT>DROP CONSTRAINT [Key1]</TT></TD>
	</TR>
</TABLE>
</P>
<P>The <TT>Execute</TT> method is used on a <TT>Database</TT> object to perform an
<TT>ALTER TABLE</TT> statement. The following example executes the queries shown
in Table 3.26 on the database represented by the variable <TT>dbfTest</TT>:</P>


<BLOCKQUOTE>
	<PRE><TT>dbfTest.Execute(&quot;ALTER TABLE [Publisher Titles] ADD COLUMN [Notes]</TT>
<TT>                MEMO NOT NULL&quot;)</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Steps</B></P>
<P>Open and run the project ADDFIELD.VBP. Type a valid field name into the Field
Name text box. Select a field type from the Field Type drop-down list and then click
the Add Field button; the list box fills with the fields added to the newly created
table (see Figure 3.20). Highlight one of the newly created fields and click the
Remove Field button to delete the field. Note that this example is similar in appearance
to the example in How-To 3.12.</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Create a new project called ADDFIELD.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.28, and save the form as MAKETABL.FRM.
	<P>
</DL>

<P><A HREF="javascript:popUp('03fig20.gif')"><B>Figure 3.20.</B></A><B> </B><I>The
SQL Alter Table form on startup.</I></P>


<BLOCKQUOTE>
	<H4>Table 3.28. Objects and properties for the Table Maker form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.14 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ListBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lstFields</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Sorted</TT></TD>
		<TD ALIGN="LEFT"><TT>True</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblTableName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Table &amp;Name:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblFieldName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Field Name:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblFieldType</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Field T&amp;ype:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblFieldList</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Field Li&amp;st:</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtTableName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Enabled</TT></TD>
		<TD ALIGN="LEFT"><TT>False</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TextBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>txtFieldName</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>ComboBox</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cboFieldType</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Style</TT></TD>
		<TD ALIGN="LEFT"><TT>2 - Dropdown List</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdAddField</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Add Field</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdRemoveField</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Remove Field</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following statements to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;
Private Const IllegalCharacters = &quot;[].!'&quot;
Private dbfBiblio As Database</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following statements to the <TT>Load</TT> event of <TT>Form1</TT>.
	The <TT>FillTypeList</TT> and <TT>FillFieldList</TT> routines, detailed next, are
	called to prepare the form for use.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    `Open the database
    Set dbfBiblio = _
        DBEngine.Workspaces(0).OpenDatabase(BIBLIO_PATH)
    `Set the txtTableName control to the table that will be 
    `edited.
    txtTableName = &quot;Title Author&quot;
    `Fill the Field Type combo box
    FillTypeList
    `Fill the Field List list box
    FillFieldList
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Create the following subroutine in <TT>Form1</TT>. The <TT>FillFieldList</TT>
	subroutine will iterate through the <TT>Fields</TT> collection of the [Title Author]
	table, including the names and data types in the <TT>lstFields</TT> list box.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Sub FillFieldList()</TT>
    Dim tbfTemp As TableDef, fldTemp As Field
    Dim strFieldType As String
    `Iterate through the TableDefs collection of the database, 
    `searching for the table name specified in the txtTableName 
    `edit control.
    For Each tbfTemp In dbfBiblio.TableDefs
        `If we find the table, iterate through the Fields 
        `collection, adding each field and its field type to the 
        `Field List list box
        If tbfTemp.Name = txtTableName.Text Then
            For Each fldTemp In tbfTemp.Fields
                Select Case fldTemp.Type
                    Case dbBigInt
                        strFieldType = &quot;BIGINT&quot;
                    Case dbBinary
                        strFieldType = &quot;BINARY&quot;
                    Case dbBoolean
                        strFieldType = &quot;BOOLEAN&quot;
                    Case dbByte
                        strFieldType = &quot;BYTE&quot;
                    Case dbChar
                        strFieldType = &quot;CHAR(&quot; _
                                       &amp; fldTemp.FieldSize &amp; &quot;)&quot;
                    Case dbCurrency
                        strFieldType = &quot;CURRENCY&quot;
                    Case dbDate
                        strFieldType = &quot;DATE&quot;
                    Case dbDecimal
                        strFieldType = &quot;DECIMAL&quot;
                    Case dbDouble
                        strFieldType = &quot;DOUBLE&quot;
                    Case dbFloat
                        strFieldType = &quot;FLOAT&quot;
                    Case dbGUID
                        strFieldType = &quot;GUID&quot;
                    Case dbInteger
                        strFieldType = &quot;INTEGER&quot;
                    Case dbLong
                        strFieldType = &quot;LONG&quot;
                    Case dbLongBinary
                        strFieldType = &quot;LONGBINARY&quot;
                    Case dbMemo
                        strFieldType = &quot;LONGTEXT&quot;
                    Case dbNumeric
                        strFieldType = &quot;NUMERIC&quot;
                    Case dbSingle
                        strFieldType = &quot;SINGLE&quot;
                    Case dbText
                        strFieldType = &quot;TEXT&quot;
                    Case dbTime
                        strFieldType = &quot;TIME&quot;
                    Case dbTimeStamp
                        strFieldType = &quot;TIMESTAMP&quot;
                    Case dbVarBinary
                        strFieldType = &quot;VARBINARY&quot;
                End Select
                lstFields.AddItem fldTemp.Name &amp; _
                                  &quot; [&quot; &amp; strFieldType &amp; &quot;]&quot;
            Next
        Exit For
        End If
    Next
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>5. </B>Create the following subroutine in <TT>Form1</TT>. The <TT>FillTypeList</TT>
	subroutine adds the various data types to the <TT>cboFieldType</TT> drop-down combo
	box.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Sub FillTypeList()</TT>
    `Fill the Field Type combo box with types of available fields
    With cboFieldTypes
        .AddItem &quot;Counter&quot;
        .AddItem &quot;Currency&quot;
        .AddItem &quot;Date/Time&quot;
        .AddItem &quot;Memo&quot;
        .AddItem &quot;Number: Byte&quot;
        .AddItem &quot;Number: Integer&quot;
        .AddItem &quot;Number: Long&quot;
        .AddItem &quot;Number: Single&quot;
        .AddItem &quot;Number: Double&quot;
        .AddItem &quot;OLE Object&quot;
        .AddItem &quot;Text&quot;
        .AddItem &quot;Yes/No&quot;
    End With
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>6. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdAddField</TT>.
	The routine checks for a field name, ensures that the name is legal (no invalid characters,
	no leading spaces, and so on), determines its data type from the Field Type combo
	box, and finally builds the SQL needed to send the <TT>ALTER TABLE</TT> command to
	the database.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdAddField_Click()</TT>
    Dim strFieldType As String, strSQL As String
    `Check first if the Field Name text box contains a legal name
    If LegalName(True) Then
        On Error GoTo BadAdd
            `If it does, check if the Field Type has been 
            `selected.
            If cboFieldTypes.ListIndex &gt; -1 Then
                `If both criteria are satisfied, store the SQL 
                `field type in the strFieldType string.
                Select Case cboFieldTypes.Text
                    Case &quot;Counter&quot;
                        strFieldType = &quot;COUNTER&quot;
                    Case &quot;Currency&quot;
                        strFieldType = &quot;CURRENCY&quot;
                    Case &quot;Date/Time&quot;
                        strFieldType = &quot;DATETIME&quot;
                    Case &quot;Memo&quot;
                        strFieldType = &quot;LONGTEXT&quot;
                    Case &quot;Number: Byte&quot;
                        strFieldType = &quot;BYTE&quot;
                    Case &quot;Number: Integer&quot;
                        strFieldType = &quot;SHORT&quot;
                    Case &quot;Number: Long&quot;
                        strFieldType = &quot;LONG&quot;
                    Case &quot;Number: Single&quot;
                        strFieldType = &quot;SINGLE&quot;
                    Case &quot;Number: Double&quot;
                        strFieldType = &quot;DOUBLE&quot;
                    Case &quot;OLE Object&quot;
                        strFieldType = &quot;LONGBINARY&quot;
                    Case &quot;Text (25 chars)&quot;
                        strFieldType = &quot;TEXT(25)&quot;
                    Case &quot;Yes/No&quot;
                        strFieldType = &quot;BIT&quot;
                End Select
                `Crate the ALTER TABLE statement
                strSQL = &quot;ALTER TABLE [&quot; &amp; txtTableName.Text &amp; _
                    &quot;] ADD COLUMN &quot; _
                    &amp; &quot;[&quot; &amp; txtFieldName &amp; &quot;] &quot; &amp; strFieldType
                `Execute the SQL
                dbfBiblio.Execute (strSQL)
                `Add the new field to the Field List list box.
                lstFields.AddItem txtFieldName &amp; &quot; [&quot; &amp; _
                                  strFieldType &amp; &quot;]&quot;
                `Reset the Field Name and Field Type controls.
                txtFieldName = &quot;&quot;
                cboFieldTypes.ListIndex = -1
            Else
                MsgBox &quot;You must select a field type.&quot;, _
                       vbExclamation
            End If
        On Error GoTo 0
    End If
Exit Sub
BadAdd:
    MsgBox Err.Description, vbExclamation
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>7. </B>Create the <TT>LegalName</TT> function in <TT>Form1</TT> with the following
	code. This function checks for a valid field name containing at least one character,
	without trailing spaces, that doesn't contain an illegal character. If it passes
	all that, it performs one more check, depending on the value of <TT>intAction</TT>.
	If <TT>intAction</TT> is <TT>True</TT>, indicating that the field is to be added,
	the function checks whether a field already exists. If <TT>intAction</TT> is <TT>False</TT>,
	indicating that the field is to be deleted, it ensures that there is no data in the
	field anywhere in the table.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Function LegalName(intAction As Boolean) As Boolean</TT>
    Dim i As Integer
    Dim recNameCheck As Recordset
    On Error GoTo IllegalName
        `If blank, raise an error.
        If Len(txtFieldName.Text) = 0 Then Err.Raise 32767
        `If it has a leading space, raise an error.
        If Left$(txtFieldName.Text, 1) = &quot; &quot; Then Err.Raise 32766
        `If it contains any of the characters in the 
        `IllegalCharacters constant, raise an error
        For i = 1 To Len(IllegalCharacters)
            If InStr(txtFieldName.Text, Mid(IllegalCharacters, _
               i, 1)) _
                &gt; 0 Then Err.Raise 32765
        Next i
        `If it contains any ANSI character from Chr$(0) to 
        `Chr$(31), (you guessed it) raise an error.
        For i = 0 To 31
            If InStr(txtFieldName.Text, Chr(i)) &gt; 0 _
               Then Err.Raise 32764
        Next i
        If intAction Then
            `It's an add field; ensure that the name doesn't 
            `already exist. If so, raise an error.
            For i = 0 To lstFields.ListCount - 1
                If txtFieldName.Text = lstFields.List(i) _
                   Then Err.Raise 32763
            Next i
        Else
            `It's a drop field; ensure that the field being erased 
            `contains no data. If so, raise an error
            Set recNameCheck = dbfBiblio.OpenRecordset( _
                &quot;SELECT [&quot; &amp; _
                txtFieldName.Text &amp; &quot;] FROM [&quot; _
                                  &amp; txtTableName.Text &amp; _
                &quot;] WHERE [&quot; &amp; txtFieldName.Text &amp; &quot;] IS NOT NULL&quot;)
            If recNameCheck.RecordCount Then Err.Raise 32762
        End If
</PRE>
	<P>
	<PRE><TT>        `If they've managed to get through all that validation, </TT>
        `the function should be True, to indicate success.
        LegalName = True
    On Error GoTo 0
Exit Function
IllegalName:
    Dim strErrDesc As String
    `Build an error message based on the user-defined error that 
    `occurred.
    Select Case Err.Number
        Case 32767
           strErrDesc = &quot;You must enter a field name.&quot;
        Case 32766
           strErrDesc = _
              &quot;The field name cannot begin with a space.&quot;
        Case 32765
           strErrDesc = _
              &quot;The field name contains the illegal character &quot; &amp; _
                Mid(IllegalCharacters, i, 1) &amp; &quot;.&quot;
        Case 32764
           strErrDesc = _
              &quot;The field name contains the control character &quot; &amp; _
                &quot;with the ANSI value&quot; &amp; Str$(i) &amp; &quot;.&quot;
        Case 32763
           strErrDesc = &quot;The field name &quot; &amp; txtFieldName.Text &amp; _
                &quot; already exists in the field name list.&quot;
        Case 32762
           strErrDesc = &quot;The field name &quot; &amp; txtFieldName.Text &amp; _
                &quot; has data; it cannot be deleted.&quot;
        Case Else
           ` Visual Basic's default error message.
           strErrDesc = Err.Description
    End Select
    MsgBox strErrDesc, vbExclamation
    `The function indicates False, or failure.
    LegalName = False
Exit Function
End Function</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>8. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdRemoveField</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdRemoveField_Click()</TT>
    Dim strSQL As String, strTemp As String
    ` If the user has selected a field, remove it from the list.
    ` Otherwise, just ignore the click.
    If lstFields.ListIndex &gt; -1 Then
        `Call the lstFields_Click event, to ensure that 
        `txtFieldName is still populated. The user might have 
        `erased it after selecting a
        `field to delete.
        Call lstFields_Click
        If LegalName(False) Then
            `Build the ALTER TABLE statement
            strSQL = &quot;ALTER TABLE [&quot; &amp; txtTableName.Text &amp; _
                &quot;] DROP COLUMN [&quot; &amp; _
                txtFieldName.Text &amp; &quot;]&quot;
            `Execute the SQL
            dbfBiblio.Execute (strSQL)
            `Delete the field from the Field List
            lstFields.RemoveItem lstFields.ListIndex
        End If
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>9. </B>Add the following code to the <TT>Click</TT> event of <TT>lstFields</TT>.
	This code extracts the name of the field selected in <TT>lstFields</TT> and passes
	it to the <TT>txtFieldName</TT> text box.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub lstFields_Click()</TT>
    Dim strTemp As String
    `If a field has been selected, extract the field's name from
    `the list entry and display it in the txtFieldName control.
    If lstFields.ListIndex &gt; -1 Then
        strTemp = lstFields.List(lstFields.ListIndex)
        strTemp = Left(strTemp, InStr(strTemp, &quot;[&quot;) - 2)
        txtFieldName.Text = strTemp
    End If
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>10. </B>Add the following code to the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>When you load <TT>Form1</TT>, it prepares for use by running the <TT>FillTypeList</TT>
routine, which loads the <TT>cboFieldTypes</TT> combo box with the various field
types allowed by Visual Basic, and the <TT>FillFieldList</TT> routine, which loads
all the field information from a given table into the <TT>lstFields</TT> list box.
The <TT>Form_Load</TT> event defaults the table name for this routine to the [Title
Author] table.</P>
<P>Each time the user adds a field to the table, an <TT>ALTER TABLE</TT> statement
is concatenated in the <TT>cmdAddField_Click</TT> routine. Several steps are performed
to ensure that the entered field is valid and meets the criteria for the statement.
The routine uses the <TT>LegalName</TT> function to determine whether the field name
specified is legal for use--doesn't have any illegal characters, has at least one
character, and doesn't start with a space (ASCII 32). After that step, the routine
fetches the field's type from the <TT>cboFieldTypes</TT> combo box and translates
the English-readable selection into a valid SQL data type. After the translation
is complete, it builds and executes the <TT>ALTER TABLE</TT> statement, using the
<TT>ADD COLUMN</TT> keywords to create the field. If run successfully, it adds the
newly created field to the <TT>lstFields</TT> list box.</P>
<P>Removing a field, however, is much less involved. Given the selected field name
from the <TT>lstFields</TT> list box, and after the <TT>LegalName</TT> function is
called to ensure that the selected field contains no data, another <TT>ALTER TABLE</TT>
statement is issued, this time utilizing the <TT>DROP COLUMN</TT> keywords to remove
the field from the table. After execution is complete, the field is then removed
from the <TT>lstFields</TT> list box.</P>
<P><B>Comments</B></P>
<P>The <TT>ALTER TABLE</TT> has different behaviors depending on the database platform.
Microsoft SQL Server, for example, won't allow a field-level constraint (for example,
restricting a field's data to a certain range of values) to be added to an already
existing field. As with the <TT>SELECT...INTO</TT> statement (covered previously
in How-To 3.14), the best way to ensure that you get a complete understanding of
how the database reacts to the <TT>ALTER TABLE</TT> statement is to experiment and
observe the results.</P>
<P>
<H2>3.16 How do I...</H2>
<H3><A NAME="Create a crosstab query?"></A><B>Create a crosstab query?</B></H3>
<P><B>Problem</B></P>
<P>I need to be able to supply a worksheet-style query showing cross-referenced information
easily. How do I do this?</P>
<P><B>Technique</B></P>
<P>The new features of the Microsoft Jet (3.5 and above) engines include the capability
to create <I>crosstab</I>, or cross-tabulated, queries. Think of a crosstab query
as a spreadsheet, with the information provided by the query read by referencing
the row and column of the spreadsheet. For example, using your old familiar friend
BIBLIO.MDB, you need to get a count of all the titles published since 1975, year
by year, listed by publisher. Normally, this job would take a couple of queries,
but the crosstab query allows you to use some SQL &quot;sleight of hand&quot; in
performing this action by adding a couple of new SQL keywords to your arsenal.</P>
<P>In the following sample query, notice the <TT>TRANSFORM</TT> and <TT>PIVOT</TT>
keywords. These new additions allow Jet to construct a crosstab query.</P>


<BLOCKQUOTE>
	<PRE><TT>TRANSFORM Count(Titles.Title) AS [TitlesCount] </TT>
<TT>    SELECT Publishers.Name FROM Publishers INNER JOIN Titles ON </TT>
<TT>    (Titles.PubID = Publishers.PubID) WHERE Titles.[Year Published] </TT>
<TT>    &gt; 1975 GROUP BY Publishers.Name</TT>
<TT>PIVOT Titles.[Year Published]</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P>Table 3.29 lists the <TT>TRANSFORM</TT> and <TT>PIVOT</TT> keywords, used to create
a crosstab query.</P>
<P>
<H4>Table 3.29. The syntax of the crosstab query.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CLAUSE</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Purpose</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>TRANSFORM</TT></TD>
		<TD ALIGN="LEFT">Selects the data to be shown in the body of the query</TD>
		<TD ALIGN="LEFT"><TT>TRANSFORM Count(Titles.Title) AS [TitlesCount]</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>SELECT</TT></TD>
		<TD ALIGN="LEFT">Chooses the row information for the query, in a crosstab query</TD>
		<TD ALIGN="LEFT"><TT>SELECT Publishers.Name FROM Publishers INNER JOIN Titles ON( Titles.PubID = Publishers.PubID)
			WHERE Titles.[Year Published]</TT> <TT>&gt; 1975</TT></TD>
	</TR>
</TABLE>
<BR>
<TT><BR>
PIVOT</TT> SELECTS THE COLUMN INFORMATION FOR THE QUERY <TT>PIVOT TITLES.[YEAR PUBLISHED]</TT><BR>
To better understand the results of this query, visualize the results as a spreadsheet.
The <TT>SELECT</TT> creates the rows of the spreadsheet; in the preceding example,
a row is created for each publisher with a title published after 1975. The <TT>PIVOT</TT>
creates the columns of the spreadsheet--a column for each year a title was published
after 1975. The <TT>TRANSFORM</TT> statement creates the information on the spreadsheet
where each row and column intersect--in the preceding query, a count of titles.</P>
<P><B>Steps</B></P>
<P>Open and run the project CROSSTAB.VBP. When the form appears, a grid displays
the count of all the titles published after 1975, listed by publisher, as shown in
Figure 3.21.</P>
<P><A HREF="javascript:popUp('03fig21.gif')"><B>Figure 3.21.</B></A><B> </B><I>The
SQL Transform form, displaying crosstab data.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called CROSSTAB.VBP. Use <TT>Form1</TT> to create
	the objects and properties listed in Table 3.30, and save the form as CROSSTAB.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 3.30. Objects and properties for the Crosstab form.</H4>
	<P>
	<TABLE BORDER="1" WIDTH="330">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Form</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>Form1</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Chapter 3.16 Example</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Data</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>MSFlexGrid</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>grdCrossTab</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>DataSourcw</TT></TD>
		<TD ALIGN="LEFT"><TT>dtaData</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>Label</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>lblCrossTab</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>Titles per year published after 1975, sorted by Publisher ID</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><TT>CommandButton</TT></TD>
		<TD ALIGN="LEFT"><TT>Name</TT></TD>
		<TD ALIGN="LEFT"><TT>cmdClose</TT></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"><TT>Caption</TT></TD>
		<TD ALIGN="LEFT"><TT>&amp;Close</TT></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the following statements to the declarations section of <TT>Form1</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Option Explicit</TT>
Private Const BIBLIO_PATH = _
&quot;D:\Program Files\Microsoft Visual Studio\VB6\Biblio.MDB&quot;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following statements to the <TT>Load</TT> event of <TT>Form1</TT>.
	At this point, the event constructs the SQL statement used for the crosstab query
	(explained earlier in this How-To) and places it in the <TT>RecordSource</TT> property
	of the <TT>dtaData</TT> Data control. After it's added, the Data control is refreshed
	to execute the query and return the needed records, which will automatically display
	in the bound <TT>MSFlexGrid</TT> control, <TT>grdCrossTab</TT>.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub Form_Load()</TT>
    Dim strSQL As String
    `Construct the crosstab query statement.  Note the use of 
    `several new SQL keywords, including TRANSFORM and PIVOT.  
    `These two keywords are the building blocks of the crosstab 
    `query.
    strSQL = &quot;TRANSFORM Count(Titles.Title) AS [TitlesCount] &quot; &amp; _
        &quot;SELECT Publishers.Name FROM Publishers &quot;&amp; _
                INNER JOIN Titles &quot; &amp; _
        &quot;ON (Titles.PubID &quot; &amp; _
        &quot;= Publishers.PubID) &quot; &amp; _
           WHERE Titles.[Year Published] &gt; 1975 &quot; &amp; _
        &quot;GROUP BY Publishers.Name &quot; &amp; _
        &quot;PIVOT Titles.[Year Published]&quot;
    `Set up the Data control
    With dtaData
        .DatabaseName = BIBLIO_PATH
        .RecordSource = strSQL
        .Refresh
    End With
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Add the following statements to the <TT>Click</TT> event of <TT>cmdClose</TT>:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdClose_Click()</TT>
    End
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P><B>How It Works</B></P>
<P>When <TT>Form1</TT> loads, it constructs the sample crosstab query detailed earlier
in the How-To. It then uses the <TT>dtaData</TT> Data control to execute it and retrieve
the records for display in <TT>grCrossTab</TT>.</P>
<P><B>Comments</B></P>
<P>The crosstab query is a powerful tool for generating tabular data, especially
aggregate or arithmetically derived information such as counts or statistical data,
for a quick summary. Normally, without the <TT>TRANSFORM</TT> or <TT>PIVOT</TT> keywords,
performing a query like the one you used would require two or three queries and possibly
a temporary table, making it a complex task not only to execute but also to maintain.
A crosstab query takes all that work and hands it to the database to perform, making
the tedious job of cross-indexing information that much faster and easier.</P>
<CENTER>
<P>
<HR>
<A HREF="ch02.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch02/ch02.htm"><IMG SRC="previous.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch04.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch04/ch04.htm"><IMG
SRC="next.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index-21.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/index.htm"><IMG SRC="contents.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> </P>

<P>&copy; <A HREF="copy.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/copy.htm">Copyright</A>, Macmillan Computer Publishing. All
rights reserved.
</CENTER>

</BODY>

</HTML>
