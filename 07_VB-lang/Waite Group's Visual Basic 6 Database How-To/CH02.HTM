<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<SCRIPT LANGUAGE="JavaScript">

<!--

function popUp(pPage) {
 var fullURL = document.location;
 var textURL = fullURL.toString();
 var URLlen = textURL.length;
 var lenMinusPage = textURL.lastIndexOf("/");
 lenMinusPage += 1;
 var fullPath = textURL.substring(0,lenMinusPage);
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '</head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + fullPath + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 window.popUpWin.document.write(zhtm);
 window.popUpWin.document.close();
 // Johnny Jackson 4/28/98
 }

//-->
                                                                
</SCRIPT>
<link rel="stylesheet" href="ebooks.css" tppabs="http://pbs.mcp.com/includes/stylesheets/ebooks.css">

	<META NAME="GENERATOR" Content="Symantec Visual Page Mac 1.1.1">
	<TITLE>Visual Basic 6 Database How-To -- Ch 2 -- Accessing a Data-base with Data Access Objects</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><IMG SRC="sams.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/sams.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM"
BORDER="0"></H1>

<H1 ALIGN="CENTER">Visual Basic 6 Database How-To</H1>
<CENTER>
<P><A HREF="ch01.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch01/ch01.htm"><IMG SRC="previous.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch03.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch03/ch03.htm"><IMG
SRC="next.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index-21.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/index.htm"><IMG SRC="contents.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> 
<HR>

</CENTER>
<H1></H1>
<H1 ALIGN="CENTER">- 2 -<BR>
Accessing a Data-base with Data Access Objects</H1>
<H2></H2>

<UL>
	<LI>How do I...
	<UL>
		<LI><A HREF="#Browse and update records by using Data Access Objects?">2.1 Browse
		and update a recordset with Data Access Objects?</A>
		<LI><A HREF="#Validate data entered into Data Access Objects?">2.2 Validate data
		entered into Data Access Objects?</A>
		<LI><A HREF="#Allow users to undo changes they've made in Data Access Objects?">2.3
		Allow users to undo changes they've made in Data Access Objects?</A>
		<LI><A HREF="#Add and delete records by using Data Access Objects?">2.Add and delete
		records by using Data Access Objects?</A>
		<LI><A HREF="#Use unbound controls to update fields in Data Access Objects?">2.5
		Use unbound controls to update fields in Data Access Objects?</A>
		<LI><A HREF="#Find records by using index values in Data Access Objects?">2.6 Find
		records by using index values in Data Access Objects?</A>
		<LI><A HREF="#Determine how many records are in a dynaset-or snapshot-type recordset?">2.7
		Determine how many records are in a dynaset- or snapshot-type recordset?</A>
		<LI><A HREF="#Handle Data Access Object errors?">2.8 Handle Data Access Object errors?</A>
		<LI><A HREF="#Access Excel worksheets by using Data Access Objects?">2.9 Access Excel
		worksheets by using Data Access Objects?</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<H3></H3>
<P>The Data control provides a means of quickly developing database applications
with little or no code, but it limits your access to the underlying database. The
Microsoft Jet database engine exposes another method of working with data-bases:
Data Access Objects (DAO). Although using DAO requires more coding than using the
Data control, it offers complete programmatic access to every-thing in the database,
as well as significantly greater flexibility. This chapter shows you how to use Jet
Data Access Objects to perform common database operations.</P>
<P>All the examples in this chapter use Microsoft Access (.MDB) database files. The
Jet engine can also access other PC-based databases such as dBASE, FoxPro, Paradox,
and Btrieve, as well as Open Database Connectivity (ODBC) data sources. The techniques
shown can be used with any database that Visual Basic can access through Jet. Chapter
6, &quot;Connecting to an ODBC Server,&quot; and Chapter 7, &quot;SQL Server Databases
and Remote Data Objects,&quot; show how to access ODBC and SQL Server databases.</P>
<P>
<H4>2.1 Browse and Update a Recordset with Data Access Objects</H4>
<P>Browsing and updating records are two of the most basic database operations. In
this How-To, you will use unbound controls and Data Access Objects to browse and
update a recordset.</P>
<P>
<H4>2.2 Validate Data Entered into Data Access Objects</H4>
<P>Users make data entry errors, and robust applications anticipate and trap those
errors. This How-To shows how to trap and respond to user errors when you're using
Data Access Objects.</P>
<P>
<H4>2.3 Allow Users to Undo Changes They've Made in Data Access Objects</H4>
<P>Users expect to be able to undo changes they make while they are working. In this
How-To, using Data Access Objects and unbound controls, you will learn how to enable
users to undo changes.</P>
<P>
<H4>2.Add and Delete Records by Using Data Access Objects</H4>
<P>Inserting and deleting records are common database activities. In this How-To,
you will learn to use Data Access Objects to add and delete records.</P>
<P>
<H4>2.5 Use Unbound Controls to Update Fields in Data Access Objects</H4>
<P>Simple text boxes are not the only user interface tools available when you're
using unbound controls. In this How-To, you will build a generic form that can run
an ad hoc query, display the results, and enable the user to select a record.</P>
<P>
<H4>2.6 Find Records by Using Index Values in Data Access Objects</H4>
<P>Indexes can substantially speed up access to records. This How-To shows how you
can leverage indexes for performance.</P>
<P>
<H4>2.7 Determine How Many Records Are in a Dynaset- or Snapshot-Type Recordset</H4>
<P>If you need to know how many records are in your recordset, this How-To will show
you how to get that number.</P>
<P>
<H4>2.8 Handle Data Access Object Errors</H4>
<P>Although Jet is a robust database engine, many things can go wrong when working
with a database. This How-To shows you how to handle Data Access Object errors gracefully.</P>
<P>
<H4>2.9 Access Excel Worksheets by Using Data Access Objects</H4>
<P>An interesting capability of the Microsoft Jet engine is used to access Excel
worksheets. In this How-To, we view and manipulate an Excel worksheet as if it were
an ordinary database file.</P>
<P>
<H2><A NAME="Heading11"></A>2.1 How do I...</H2>
<H3><A NAME="Browse and update records by using Data Access Objects?"></A><B>Browse
and update records by using Data Access Objects?</B></H3>
<P><B>PROBLEM</B><BR>
<BR>
Bound recordsets with Data controls are fine for many purposes, but the Data control
has significant limitations. I can't use indexes with bound controls, and I can't
refer to the Data control's recordset if the Data control's form is not loaded. How
can I browse a recordset without using bound controls?</P>
<P><B>Technique</B></P>
<P>Visual Basic and the Microsoft Jet database engine provide a rich set of Data
Access Objects that give you complete control over your database and provide capabilities
beyond what you can accomplish with bound controls.</P>
<P>If you've worked with other databases, and in particular Structured Query Language
(SQL), you might be accustomed to dividing the database programming language into
Data Definition Language (DDL) and Data Manipulation Language (DML). Although Jet
provides programmatic access to both structure and data, DAO makes no clear distinction
between the two. Some objects, such as the Recordset, are used strictly for data
manipulation, whereas others, such as the TableDef object, act in both data definition
and data manipulation roles. Figure 2.1 shows the DAO hierarchy.</P>
<P><A HREF="javascript:popUp('02fig01.gif')"><B>Figure 2.1.</B></A><B> </B><I>The
Data Access Object hierarchy.</I></P>
<P>In most cases, you will be using DAO to manage data. There are four general types
of data operations:</P>

<UL>
	<LI>Retrieve records
	<P>
	<LI>Insert new records
	<P>
	<LI>Update existing records
	<P>
	<LI>Delete records
</UL>

<P>DAO provides the recordset object for retrieving records and both the recordset
object and the Execute method for inserting, updating, and deleting records.</P>
<P>Before you can do anything useful with DAO, you must open a database. In most
cases, this is as simple as using the OpenDatabase method of the default workspace.
The following code fragment shows some typical code used to open an Access .MDB file
and create a recordset:</P>


<BLOCKQUOTE>
	<PRE>` Declare database variable
Dim db As Database
Dim rs As Recordset
` Open a database file and assign it to db
Set db = DBEngine.Workspaces(0).OpenDatabase(App.Path &amp; &quot;\MyDB.MDB&quot;)
` Create a recordset
Set rs = db.OpenRecordset(&quot;MyQuery&quot;, dbOpenDynaset, , dbOptimistic)</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>If you are working with a secured database, you will need to take a few extra
steps to provide a valid username and password to the database engine so that a secured
workspace object can be created. Refer to Chapter 11, &quot;The Windows Registry
and State Information,&quot; for more information.</P>
<P><B>Moving Within an Unbound Recordset</B></P>
<P>When you use the Data control on a bound form, you rarely have to code in order
to move operations. The user clicks on the navigational buttons, and the Data control
executes a move internally. Only in the case of a delete do you need to code a move
operation (see How-To 1.4).</P>
<P>When you use unbound controls, you must refresh the data displayed on the form
with your code. The recordset object provides four methods to facilitate this task:
MoveFirst, MovePrevious, MoveNext, and MoveLast.</P>
<P>When you use MovePrevious, you should always check to make sure that the movement
has not placed the record pointer before the first record in the recordset. Do this
by checking the value of the recordset's BOF property. If BOF is True, you're not
on a valid record. The usual solution is to use MoveFirst to position the pointer
on the first record. Similarly, when you use MoveNext, you should check to make sure
that you're not past the last record in the recordset by checking the EOF property.
If EOF is True, use MoveLast to move to a valid record. It's also a good idea to
ensure that the recordset has at least one record by making sure that the value of
the recordset's RecordCount property is greater than zero.</P>
<P><B>Updating Records</B></P>
<P>You can update the values in table-type or dynaset-type recordsets. Updating records
in a recordset is a four-step procedure:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Position the record pointer to the record you want to update.
	<P>
	<DT></DT>
	<DD><B>2. </B>Copy the record's values to an area of memory known as the copy buffer
	by invoking the recordset object's Edit method.
	<P>
	<DT></DT>
	<DD><B>3. </B>Change the desired fields by assigning values to the Field objects.
	<P>
	<DT></DT>
	<DD><B>4. </B>Transfer the contents of the copy buffer to the database by invoking
	the recordset object's Update method.
	<P>
</DL>

<P><B>Steps</B></P>
<P>Open and run the project HT201.VBP. The form shown in Figure 2.2 appears. Use
the navigation buttons at the bottom of the form to browse through the records in
the recordset. You can change the data by typing over the existing values.</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Create a new project called HT201.VBP. Use Form1 to create the objects
	and properties listed in Table 2.1, and save the form as HT201.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.1. Objects and properties for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Form</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Form1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Unbound Browser</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdMove</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">|&lt;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">0</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdMove</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&lt;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdMove</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&gt;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">2</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdMove</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&gt;|</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">3</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">TextBox</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txt</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">0</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">TextBox</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txt</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">TextBox</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txt</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">2</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">TextBox</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txt</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">3</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Title</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label2</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Year Published</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label3</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;ISBN</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label4</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Publisher ID</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Create the menu shown in Table 2.2.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.2. Menu specifications for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CAPTION</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Name</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Shortcut Key</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;File</TD>
		<TD ALIGN="LEFT">mnuFile</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----E&amp;xit</TD>
		<TD ALIGN="LEFT">mnuFileExit</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;Data</TD>
		<TD ALIGN="LEFT">mnuData</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----&amp;Save Record</TD>
		<TD ALIGN="LEFT">mnuDataSaveRecord</TD>
		<TD ALIGN="LEFT">Ctrl+S</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>

<P><A HREF="javascript:popUp('02fig02.gif')"><B>Figure 2.2.</B></A><I> The Unbound
Browser form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>3. </B>Add READINI.bas to your project. READINI.bas looks for a file named
	VBDBHT.ini in the Windows directory with the following text:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>[Data Files]
<TT>BIBLIO=&lt;path to biblio directory&gt;</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD>The path should point to the Chapter 2 subdirectory of the directory where you
	installed the files from the CD setup program. The standard module uses the GetPrivateProfileString
	API function to obtain the path to the sample database.
	<P>
	<DT></DT>
	<DD>You can also use the copy of Biblio.mdb that was installed with Visual Basic,
	although it is possible that there are differences in the file. If your copy has
	the same database structure, you can update the .ini file to point to your existing
	copy and delete the copy in the Chapter 2 subdirectory.
	<P>
	<DT></DT>
	<DD><B>4. </B>Add a class module to the project, name it CTitles, and save the file
	as HT201.CLS.
	<P>
	<DT></DT>
	<DD><B>5. </B>Add the following code to the declarations section of CTitles. Several
	private variables are declared, including database and recordset object variables,
	a flag to track changes to the record, strings to hold the property values, and public
	enumerations for record movement and class errors.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` The CTitles class provides a light wrapper</TT>
<TT>` around the database and record for the</TT>
<TT>` Titles table in the Biblio database</TT>
<TT>` Note: It's up to the client to save</TT>
<TT>` Database and recordset objects</TT>
<TT>Private mdb As Database</TT>
<TT>Private mrs As Recordset</TT>
<TT>` Flags</TT>
<TT>` dirty flag</TT>
<TT>Private mblnIsDirty As Boolean</TT>
<TT>` Fields</TT>
<TT>` title</TT>
<TT>Private mstrTitle As String</TT>
<TT>` year - note use of string for</TT>
<TT>` assignment to text box</TT>
<TT>Private mstrYearPublished As String</TT>
<TT>` ISBN number</TT>
<TT>Private mstrISBN As String</TT>
<TT>` PubID - also a string</TT>
<TT>Private mstrPubID As String</TT>
<TT>` Move method constants</TT>
<TT>Public Enum CTitlesMove</TT>
<TT>    FirstRecord = 1</TT>
<TT>    LastRecord = 2</TT>
<TT>    NextRecord = 3</TT>
<TT>    PreviousRecord = 4</TT>
<TT>End Enum</TT>
<TT>` Error constants</TT>
<TT>` Note: RaiseClassError method provides the strings</TT>
<TT>` because you cannot assign a string to an Enum</TT>
<TT>Public Enum CTitlesError</TT>
<TT>    ErrInvalidMoveType = vbObjectError + 1000 + 11</TT>
<TT>    ErrNoRecords = vbObjectError + 1000 + 12</TT>
<TT>End Enum</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>ENUMERATIONS</STRONG></B> </P>

	<P>Enumerations are a feature in Visual Basic that enables you to define publicly
	available constants within a class module. If you did any work with class modules
	in Visual Basic 4.0 or earlier, you might have been frustrated by the need to provide
	a standard &quot;helper&quot; module for any class that used public constants. This
	type of workaround has been replaced with public enumerations. Note, however, that
	you can assign only long integer values in an enumeration. No means exist for making
	strings or other types of constants public in classes. 
<HR>


</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>6. </B>Add the following code to the Class_Initialize and Class_Terminate
	event procedures in CTitles. Class_Initialize opens the database and creates a recordset,
	generating an error if no records exist. Class_Terminate closes the object variables
	opened by Class_Initialize.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Class_Initialize()
<TT>    ` open the database and recordset</TT>
<TT>    Dim strDBName As String</TT>
<TT>    ` Get the database name and open the database.</TT>
<TT>    ` BiblioPath is a function in READINI.BAS</TT>
<TT>    strDBName = BiblioPath()</TT>
<TT>    Set mdb = DBEngine.Workspaces(0).OpenDatabase(strDBName)</TT>
<TT>    ` Open the recordset.</TT>
<TT>    Set mrs = mdb.OpenRecordset( _</TT>
<TT>        &quot;Titles&quot;, dbOpenDynaset, dbSeeChanges, dbOptimistic)</TT>
<TT>    ` Raise an error if there is no data</TT>
<TT>    If mrs.BOF Then</TT>
<TT>        RaiseClassError ErrNoRecords</TT>
<TT>    End If</TT>
<TT>    ` fetch the first record to the properties</TT>
<TT>    GetCurrentRecord</TT>
<TT>End Sub</TT>
<TT>Private Sub Class_Terminate()</TT>
<TT>` cleanup - note that since a Class_Terminate error</TT>
<TT>` is fatal to the app, this proc simply traps and</TT>
<TT>` ignores any shutdown errors</TT>
<TT>` that's not a great solution, but there's not much</TT>
<TT>` else that can be done at this point</TT>
<TT>` in a production app, it might be helpful to log</TT>
<TT>` these errors</TT>
<TT>    ` close and release the recordset object</TT>
<TT>    mrs.Close</TT>
<TT>    Set mrs = Nothing</TT>
<TT>    ` close and release the database object</TT>
<TT>    mdb.Close</TT>
<TT>    Set mdb = Nothing</TT>
</PRE>
	<H4>End Sub</H4>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>7. </B>Add the private RaiseClassError method to CTitles. This is a simple
	switch that sets the Description and Source properties for errors raised by the class.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub RaiseClassError(lngErrorNumber As CTitlesError)
<TT>` Note: DAO errors are passed out as-is</TT>
<TT>    Dim strDescription As String</TT>
<TT>    Dim strSource As String</TT>
<TT>    ` assign the description for the error</TT>
<TT>    Select Case lngErrorNumber</TT>
<TT>        Case ErrInvalidMoveType</TT>
<TT>            strDescription = &quot;Invalid move operation.&quot;</TT>
<TT>        Case ErrNoRecords</TT>
<TT>            strDescription = _</TT>
<TT>                &quot;There are no records in the Titles table.&quot;</TT>
<TT>        Case Else</TT>
<TT>            ` If this executes, it's a coding error in</TT>
<TT>            ` the class module, but having the case is</TT>
<TT>            ` useful for debugging.</TT>
<TT>            strDescription = _</TT>
<TT>                &quot;There is no message for this error.&quot;</TT>
<TT>    End Select</TT>
<TT>    ` build the Source property for the error</TT>
<TT>    strSource = App.EXEName &amp; &quot;.CTitles&quot;</TT>
<TT>    ` raise it</TT>
<TT>    Err.Raise lngErrorNumber, strSource, strDescription</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>8. </B>Add the GetCurrentRecord method. This procedure fetches the data from
	the recordset and writes the values to the private module-level variables used by
	the property procedures.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub GetCurrentRecord()
<TT>` Get current values from the recordset</TT>
<TT>    ` a zero length string is appended to</TT>
<TT>    ` each variable to avoid the Invalid use of Null</TT>
<TT>    ` error if a field is null</TT>
    ` although current rules don't allow nulls, there
<TT>    ` may be legacy data that doesn't conform to</TT>
<TT>    ` existing rules</TT>
<TT>    mstrISBN = mrs![ISBN] &amp; &quot;&quot;</TT>
<TT>    mstrTitle = mrs![Title] &amp; &quot;&quot;</TT>
<TT>    mstrYearPublished = mrs![Year Published] &amp; &quot;&quot;</TT>
<TT>    mstrPubID = mrs![PubID] &amp; &quot;&quot;</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>9. </B>Add the private UpdateRecord method. This procedure writes the module-level
	variables to the recordset. The error handler in this procedure clears any changes
	that were made to the field values.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub UpdateRecord()
<TT>` DAO Edit/Update</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    ` inform DAO we will edit</TT>
<TT>    mrs.Edit</TT>
<TT>    mrs![ISBN] = mstrISBN</TT>
<TT>    mrs![Title] = mstrTitle</TT>
<TT>    mrs![Year Published] = mstrYearPublished</TT>
<TT>    mrs![PubID] = mstrPubID</TT>
<TT>    ` commit changes</TT>
<TT>    mrs.Update</TT>
<TT>    ` clear dirty flag</TT>
<TT>    mblnIsDirty = False</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    ` clear the values that were assigned</TT>
<TT>    ` and cancel the edit method by</TT>
<TT>    ` executing a moveprevious/movenext</TT>
<TT>    mrs.MovePrevious</TT>
<TT>    mrs.MoveNext</TT>
<TT>    ` raise the error again</TT>
<TT>    Err.Raise Err.Number, Err.Source, Err.Description, _</TT>
<TT>        Err.HelpFile, Err.HelpContext</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>10. </B>Add the Property Let and Property Get procedures for the Title, YearPublished,
	ISBN, and PubID properties of the class. The Property Get procedures simply return
	the values of the module-level variables. The Property Let procedures assign the
	new values to the module level variables and set the mblnIsDirty flag.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Property Get Title() As String
<TT>    Title = mstrTitle</TT>
<TT>End Property</TT>
<TT>Public Property Let Title(strTitle As String)</TT>
<TT>    mstrTitle = strTitle</TT>
<TT>    ` set the dirty flag</TT>
<TT>    mblnIsDirty = True</TT>
<TT>End Property</TT>
<TT>Public Property Get YearPublished() As String</TT>
<TT>    YearPublished = mstrYearPublished</TT>
<TT>End Property</TT>
<TT>Public Property Let YearPublished(strYearPublished As String)</TT>
<TT>    mstrYearPublished = strYearPublished</TT>
<TT>    ` set the dirty flag</TT>
<TT>    mblnIsDirty = True</TT>
<TT>End Property</TT>
<TT>Public Property Get ISBN() As String</TT>
<TT>    ISBN = mstrISBN</TT>
<TT>End Property</TT>
<TT>Public Property Let ISBN(strISBN As String)</TT>
<TT>    mstrISBN = strISBN</TT>
<TT>    ` set the dirty flag</TT>
<TT>    mblnIsDirty = True</TT>
<TT>End Property</TT>
<TT>Public Property Get PubID() As String</TT>
<TT>    PubID = mstrPubID</TT>
<TT>End Property</TT>
<TT>Public Property Let PubID(strPubID As String)</TT>
<TT>    mstrPubID = strPubID</TT>
<TT>    ` set the dirty flag</TT>
<TT>    mblnIsDirty = True</TT>
<TT>End Property </TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>11. </B>Add the IsDirty Property Get procedure. This property returns the
	current value of the mblnIsDirty flag. Note that this is a read-only property. There
	is no corresponding Property Let procedure.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Property Get IsDirty() As Boolean
<TT>` pass out the dirty flag</TT>
<TT>    IsDirty = mblnIsDirty</TT>
<TT>End Property</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>12. </B>Add the Move method. This method moves the current pointer for the
	recordset based on the lngMoveType parameter. The values for lngMoveType are defined
	by the CTitlesMove enumeration in the header section. This method is a simple wrapper
	around the various move methods of the underlying recordset object.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub Move(lngMoveType As CTitlesMove)
<TT>` Move and refresh properties</TT>
<TT>    Select Case lngMoveType</TT>
<TT>        Case FirstRecord</TT>
<TT>            mrs.MoveFirst</TT>
<TT>        Case LastRecord</TT>
<TT>            mrs.MoveLast</TT>
<TT>        Case NextRecord</TT>
<TT>            mrs.MoveNext</TT>
<TT>            ` check for EOF</TT>
<TT>            If mrs.EOF Then</TT>
<TT>                mrs.MoveLast</TT>
<TT>            End If</TT>
<TT>        Case PreviousRecord</TT>
<TT>            mrs.MovePrevious</TT>
<TT>            ` check for BOF</TT>
<TT>            If mrs.BOF Then</TT>
<TT>                mrs.MoveFirst</TT>
<TT>            End If</TT>
<TT>        Case Else</TT>
<TT>            ` bad parameter, raise an error</TT>
<TT>            RaiseClassError ErrInvalidMoveType</TT>
<TT>    End Select</TT>
<TT>    GetCurrentRecord</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DD>
<HR>
<B><STRONG>More on Enumerations</STRONG></B> 

	<P>Declaring the lngMoveType parameter as CTitlesMove instead of as a long integer
	illustrates another benefit of using enumerations. If a variable is declared as the
	type of a named enumeration, the code editor provides a drop-down list of available
	constants wherever the variable is used. 
<HR>

	<DT></DT>
	<DD><B>13. </B>Add the SaveRecord method. This method tests the mblnIsDirty flag
	and updates the current record if necessary.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub SaveRecord()
<TT>` save current changes</TT>
<TT>    ` test dirty flag</TT>
<TT>    If mblnIsDirty Then</TT>
<TT>        ` update it</TT>
<TT>        UpdateRecord</TT>
<TT>    Else</TT>
<TT>        ` record is already clean</TT>
<TT>    End If</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>14. </B>Add the following code to the declarations section of Form1. A private
	object variable is created for the CTitles class, as well as constants for the control
	arrays and a status flag used to prevent the txt_Change events from writing the property
	values in the class during a refresh of the data.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` CTitles object</TT>
<TT>Private mclsTitles As CTitles</TT>
<TT>` These constants are used for the various control arrays</TT>
<TT>` command button constants</TT>
<TT>Const cmdMoveFirst = 0</TT>
<TT>Const cmdMovePrevious = 1</TT>
<TT>Const cmdMoveNext = 2</TT>
<TT>Const cmdMoveLast = 3</TT>
<TT>` text box index constants</TT>
<TT>Const txtTitle = 0</TT>
<TT>Const txtYearPublished = 1</TT>
<TT>Const txtISBN = 2</TT>
<TT>Const txtPubID = 3</TT>
<TT>` refresh flag</TT>
<TT>Private mblnInRefresh As Boolean</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>15. </B>Add the Form_Load event procedure. Form_Load creates the mclsTitles
	object and loads the first record. If an error occurs, the error handler displays
	a message and unloads the form, which terminates the application.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Form_Load()
<TT>` create the mclsTitles object and display the first record</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Dim strDBName As String</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` create the CTitles object</TT>
<TT>    Set mclsTitles = New CTitles</TT>
<TT>    ` fetch and display the current record</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    ` An error was generated by Visual Basic or CTitles.</TT>
<TT>    ` Display the error message and terminate gracefully.</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Unload Me</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>16. </B>Add the Query_Unload event procedure. This saves the current record
	before unloading the form. If an error occurs, the error handler gives the user the
	option of continuing (with loss of data) or returning to the form.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save the current record</TT>
<TT>    mclsTitles.SaveRecord</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    ` an error here means the record won't be saved</TT>
<TT>    ` let the user decide what to do</TT>
<TT>    Dim strMsg As String</TT>
<TT>    strMsg = &quot;The following error occurred while _</TT>
<TT>             &quot;attempting to save:&quot;</TT>
<TT>strMsg = strMsg &amp; vbCrLf &amp; Err.Description &amp; vbCrLf</TT>
<TT>    strMsg = strMsg &amp; &quot;If you continue the current operation, &quot; _</TT>
<TT>    strMsg = strMsg &amp; &quot;changes to your data will be lost.&quot;</TT>
<TT>    strMsg = strMsg &amp; vbCrLf</TT>
<TT>    strMsg = strMsg &amp; &quot;Do you want to continue anyway?&quot;</TT>
<TT>    If MsgBox(strMsg, _</TT>
<TT>        vbQuestion Or vbYesNo Or vbDefaultButton2) = vbNo Then</TT>
<TT>        Cancel = True</TT>
<TT>    End If</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>17. </B>Add the cmdMove_Click event procedure. This event saves the current
	record, requests the record indicated by the Index parameter from the mclsTitles
	object, and refreshes the form.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdMove_Click(Index As Integer)
<TT>` move to the desired record, saving first</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save the record</TT>
<TT>    mclsTitles.SaveRecord</TT>
<TT>    ` move to the indicated record</TT>
<TT>    Select Case Index</TT>
<TT>        Case cmdMoveFirst</TT>
<TT>            mclsTitles.Move FirstRecord</TT>
<TT>        Case cmdMoveLast</TT>
<TT>            mclsTitles.Move LastRecord</TT>
<TT>        Case cmdMoveNext</TT>
<TT>            mclsTitles.Move NextRecord</TT>
<TT>        Case cmdMovePrevious</TT>
<TT>            mclsTitles.Move PreviousRecord</TT>
<TT>    End Select</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>18. </B>Add the txt_Change event procedure. This event writes the control
	values to the properties unless the mblnInRefresh flag is set. The flag tells the
	event procedure that the form is being refreshed and that the property values in
	mclsTitles do not need to be set.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub txt_Change(Index As Integer)
<TT>` update property values if required</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Dim strValue As String</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` fetch the value from the control</TT>
<TT>    strValue = txt(Index).Text</TT>
<TT>    ` check first to see if we're in a GetData call</TT>
<TT>    ` assigning the property values while refreshing</TT>
<TT>    ` will reset the dirty flag again so the data will</TT>
<TT>    ` never appear to have been saved</TT>
<TT>    If Not mblnInRefresh Then</TT>
<TT>        ` update the clsTitles properties</TT>
<TT>        Select Case Index</TT>
<TT>            Case txtTitle</TT>
<TT>                mclsTitles.Title = strValue</TT>
<TT>            Case txtYearPublished</TT>
<TT>                mclsTitles.YearPublished = strValue</TT>
<TT>            Case txtISBN</TT>
<TT>                mclsTitles.ISBN = strValue</TT>
<TT>            Case txtPubID</TT>
<TT>                mclsTitles.PubID = strValue</TT>
<TT>        End Select</TT>
<TT>    End If</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>19. </B>Add the mnuFileExit_Click event. This procedure unloads the form.
	The rest of the unload logic is contained in the QueryUnload event procedure.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuFileExit_Click()
<TT>    ` shut down</TT>
<TT>    ` work is handled by the Query_Unload event</TT>
<TT>    Unload Me</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>20. </B>Add the mnuData_Click and mnuDataSaveRecord_Click event pro-cedures.
	The mnuData_Click event toggles the enabled flag for the mnuDataSaveRecord menu control
	based on the IsDirty flag of the mclsTitles object. The mnuDataSaveRecord_Click procedure
	saves <BR>
	the current record.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuData_Click()
<TT>` set enabled/disabled flags for menu commands</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save enabled only when dirty</TT>
<TT>    mnuDataSaveRecord.Enabled = mclsTitles.IsDirty</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT>
<TT>Private Sub mnuDataSaveRecord_Click()</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save it</TT>
<TT>    mclsTitles.SaveRecord</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub </TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>21. </B>Add the private GetData procedure. GetData is used to refresh the
	controls based on the property values in mclsTitles and sets the mblnInRefresh flag
	so that the properties aren't changed again by txt_Change.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub GetData()
<TT>` display the current record</TT>
<TT>    ` set the mblnInRefresh flag so that the txt_Change event</TT>
<TT>    ` doesn't write the property values again</TT>
<TT>    mblnInRefresh = True</TT>
<TT>    ` assign the values to the controls from the properties</TT>
<TT>    txt(txtTitle).Text = mclsTitles.Title</TT>
<TT>    txt(txtYearPublished).Text = mclsTitles.YearPublished</TT>
<TT>    txt(txtISBN).Text = mclsTitles.ISBN</TT>
<TT>    txt(txtPubID).Text = mclsTitles.PubID</TT>
<TT>    ` clear the refresh flag</TT>
<TT>    mblnInRefresh = False</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>When the form loads, it creates the object variable for the CTitles class and
displays the first record. The user can navigate among the records by clicking the
move buttons, and the logic in the form and the CTitles class saves changes if the
record is dirty.</P>
<P>With placement of the data management logic in the class module and the user interface
logic in the form, a level of independence between the database and the user interface
is created. Several different forms can be created that all use the same class without
duplicating any of the data management logic. Additionally, changes made to the underlying
database can be incorporated into the class without requiring changes to the forms
based on it.</P>
<P><B>Comments</B></P>
<P>The beauty of encapsulating all the data access code in a class module isn't fully
revealed until you have an application that enables the user to edit the same data
using more than one interface. If, for example, you display a summary of detail records
in a grid and also provide a regular form for working with the same data, most of
the code for managing that data will be shared in the class modules. Each form that
presents the data will only need to have code that controls its own interface.</P>
<P>
<H2><A NAME="Heading13"></A>2.2 How do I...</H2>
<H3><A NAME="Validate data entered into Data Access Objects?"></A><B>Validate data
entered into Data Access Objects?</B></H3>
<P><B>Problem</B></P>
<P>I need to verify that data entered is valid before I update the database. How
can I do this with Data Access Objects and unbound controls?</P>
<P><B>Technique</B></P>
<P>Databases, tables, and fields often have various business rules that apply to
the data. You can apply rules by writing code to check the values of the data in
unbound controls before you write the changes to the underlying tables.</P>
<P>Class modules are most often used to handle the data-management logic for unbound
data--adding a layer of separation between the database schema and the user interface
logic. Normally, class modules should not handle any user interaction (unless, of
course, the class is specifically designed to encapsulate user interface components),
so instead of generating messages, classes raise errors if a validation rule is violated.
The error is trapped by the user interface and handled in whatever manner is appropriate.</P>
<P><B>Steps</B></P>
<P>Open and run HT202.VBP. Tab to the Year Published text box, delete the year, and
attempt to save the record. Because the Year Published is required, an error message
is displayed, as shown in Figure 2.3. Experiment with some of the other fields to
examine other rules and the messages that are displayed.</P>
<P><A HREF="javascript:popUp('02fig03.gif')"><B>Figure 2.3</B><I>.</I></A><I> The
Validating Browser form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT202.VBP. This project adds to the project
	developed for How-To 2.1 by adding validation code to the CTitles class module. The
	form and the READINI.bas module for this project are unchanged from the previous
	How-To, with the exception of the form caption, which was changed to Validating Browser.
	Changes to the class module are shown in the steps that follow.
	<P>
	<DT></DT>
	<DD><B>2. </B>Add the following code to the declarations section of the class module.
	The modified enumeration, shown in bold, defines the errors that can be raised by
	the class. The rest of the declarations section is unchanged from the previous How-To.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` The CTitles class provides a light wrapper</TT>
<TT>` around the database and record for the</TT>
<TT>` Titles table in the Biblio database</TT>
<TT>` Database and recordset objects</TT>
<TT>Private mdb As Database</TT>
<TT>Private mrs As Recordset</TT>
<TT>` Flags</TT>
<TT>` dirty flag</TT>
<TT>Private mblnIsDirty As Boolean</TT>
<TT>` Fields</TT>
<TT>` title</TT>
<TT>Private mstrTitle As String</TT>
<TT>` year - note use of string for</TT>
<TT>` assignment to text box</TT>
<TT>Private mstrYearPublished As String</TT>
<TT>` ISBN number</TT>
<TT>Private mstrISBN As String</TT>
<TT>` PubID - also a string</TT>
<TT>Private mstrPubID As String</TT>
<TT>` Move method constants</TT>
<TT>Public Enum CTitlesMove</TT>
<TT>    FirstRecord = 1</TT>
<TT>    LastRecord = 2</TT>
<TT>    NextRecord = 3</TT>
<TT>    PreviousRecord = 4</TT>
<TT>End Enum</TT>
<TT>` Error constants</TT>
<TT>` Note: RaiseClassError method provides the strings</TT>
<TT>` because you cannot assign a string to an Enum</TT>
<TT>Public Enum CTitlesError</TT>
<TT>    ErrMissingTitle = vbObjectError + 1000 + 1</TT>
<TT>    ErrMissingYear = vbObjectError + 1000 + 2</TT>
<TT>    ErrMissingISBN = vbObjectError + 1000 + 3</TT>
<TT>    ErrInvalidYear = vbObjectError + 1000 + 4</TT>
<TT>    ErrMissingPubID = vbObjectError + 1000 + 5</TT>
<TT>    ErrNonNumericPubID = vbObjectError + 1000 + 6</TT>
<TT>    ErrRecordNotFound = vbObjectError + 1000 + 10</TT>
<TT>    ErrInvalidMoveType = vbObjectError + 1000 + 11</TT>
<TT>    ErrNoRecords = vbObjectError + 1000 + 12</TT>
<TT>End Enum</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>3. </B>Modify the RaiseClassError procedure, as shown. This is a simple switch
	that sets the Description and Source properties for errors raised by the class. Several
	new cases in the Select Case block are dedicated to assigning descriptions to validation
	errors.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub RaiseClassError(lngErrorNumber As CTitlesError)
<TT>` Note: DAO errors are passed out as-is</TT>
<TT>    Dim strDescription As String</TT>
<TT>    Dim strSource As String</TT>
<TT>    ` assign the description for the error</TT>
<TT>    Select Case lngErrorNumber</TT>
<TT>        Case ErrMissingTitle</TT>
<TT>            strDescription = &quot;The Title is required.&quot;</TT>
<TT>        Case ErrMissingYear</TT>
<TT>            strDescription = &quot;The Year Published is required.&quot;</TT>
<TT>        Case ErrMissingISBN</TT>
<TT>            strDescription = &quot;The ISBN number is required.&quot;</TT>
<TT>        Case ErrInvalidYear</TT>
<TT>            strDescription = &quot;Not a valid year.&quot;</TT>
<TT>        Case ErrMissingPubID</TT>
<TT>            strDescription = &quot;The Publisher ID is required.&quot;</TT>
<TT>        Case ErrNonNumericPubID</TT>
<TT>            strDescription = &quot;The Publisher ID must be numeric.&quot;</TT>
<TT>        Case ErrRecordNotFound</TT>
<TT>            strDescription = &quot;The record was not found.&quot;</TT>
<TT>        Case ErrInvalidMoveType</TT>
<TT>            strDescription = &quot;Invalid move operation.&quot;</TT>
<TT>        Case ErrNoRecords</TT>
<TT>            strDescription = _</TT>
<TT>                &quot;There are no records in the Titles table.&quot;</TT>
<TT>        Case Else</TT>
<TT>            ` If this executes, it's a coding error in</TT>
<TT>            ` the class module, but having the case is</TT>
<TT>            ` useful for debugging.</TT>
<TT>            strDescription = &quot;There is no message for this error.&quot;</TT>
<TT>    End Select</TT>
<TT>    ` build the Source property for the error</TT>
<TT>    strSource = App.EXEName &amp; &quot;.CTitles&quot;</TT>
<TT>    ` raise it</TT>
<TT>    Err.Raise lngErrorNumber, strSource, strDescription</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the IsValid property. This property takes an optional argument,
	blnRaiseError, which defaults to False and controls the procedure logic. If the flag
	is True, an error is generated when a validation rule is violated. Code within the
	class sets the flag to True so that errors are raised when rules are violated. Forms
	would normally ignore this optional parameter and simply test for a True or False
	value in the property.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Property Get IsValid _
<TT>  (Optional blnRaiseError As Boolean = False) As Boolean</TT>
<TT>` test the data against our rules</TT>
<TT>` the optional blnRaiseError flag can be used to have the</TT>
<TT>` procedure raise an error if a validation rule is</TT>
<TT>` violated.</TT>
<TT>    Dim lngError As CTitlesError</TT>
<TT>    If mstrISBN = &quot;&quot; Then</TT>
<TT>        lngError = ErrMissingISBN</TT>
<TT>    ElseIf mstrTitle = &quot;&quot; Then</TT>
<TT>        lngError = ErrMissingTitle</TT>
<TT>    ElseIf mstrYearPublished = &quot;&quot; Then</TT>
<TT>        lngError = ErrMissingYear</TT>
<TT>    ElseIf Not IsNumeric(mstrYearPublished) Then</TT>
<TT>        lngError = ErrInvalidYear</TT>
<TT>    ElseIf mstrPubID = &quot;&quot; Then</TT>
<TT>        lngError = ErrMissingPubID</TT>
<TT>    ElseIf Not IsNumeric(mstrPubID) Then</TT>
<TT>        lngError = ErrNonNumericPubID</TT>
<TT>    End If</TT>
<TT>    If lngError &lt;&gt; 0 Then</TT>
<TT>        If blnRaiseError Then</TT>
<TT>            RaiseClassError lngError</TT>
<TT>        Else</TT>
<TT>            IsValid = False</TT>
<TT>        End If</TT>
<TT>    Else</TT>
<TT>        IsValid = True</TT>
<TT>    End If</TT>
<TT>End Property</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>5. </B>Modify the SaveRecord method to call IsValid. This method tests the
	mblnIsDirty flag and updates the current record if necessary. Before UpdateRecord
	is called, the procedure calls the IsValid procedure, setting the blnRaiseError parameter
	to True so that any rule violations are raised as errors in the form. The only difference
	between this version of SaveRecord and the version shown in How-To 2.1 is the call
	to IsValid and the relocation of the call to UpdateRecord so that it is called only
	if IsValid returns True.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub SaveRecord()
<TT>` save current changes</TT>
<TT>    ` test dirty flag</TT>
<TT>    If mblnIsDirty Then</TT>
<TT>        ` validate, raise an error</TT>
<TT>        ` if rules are violated</TT>
<TT>        If IsValid(True) Then</TT>
<TT>            ` update it</TT>
<TT>            UpdateRecord</TT>
<TT>        End If</TT>
<TT>    Else</TT>
<TT>        ` record is already clean</TT>
<TT>    End If</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>Data validation logic is handled entirely within the CTitles class--no special
coding is required in the form beyond the normal error handlers that trap errors
and display a simple message about the error. The rules applied for validation can
be as simple or as complex as the application requires.</P>
<P>Only minor modifications to the class were required to implement data validation.
The error enumeration and the corresponding RaiseClassError procedure were expanded
to include validation errors, the IsValid procedure was added to perform the validation
tests, and a few lines of code were changed in the SaveRecord procedure.</P>
<P><B>Comments</B></P>
<P>Not all database rules require you to write code to perform data validation. The
Jet database engine can enforce some--or possibly all--of your rules for using the
properties of tables and fields or relational constraints. How-To 4.5 shows you how
to use these objects and properties to supplement or replace validation code.</P>
<P>
<H2><A NAME="Heading14"></A>2.3 How do I...</H2>
<H3><A NAME="Allow users to undo changes they've made in Data Access Objects?"></A><B>Allow
users to undo changes they've made in Data Access Objects?</B></H3>
<P><B>Problem</B></P>
<P>Users sometimes make data entry errors while working. How can I allow users to
undo changes they've made to data in unbound controls using Data Access Objects?</P>
<P><B>Technique</B></P>
<P>A few additional lines of code in the class module handling data management for
your database can implement an undo feature. Because data is not updated in bound
controls until you explicitly update it with your code, you can restore the original
values by reloading them from the underlying recordset. The class module handles
restoring the original values from the recordset and assigning them to the property
values. The form only needs to read the data from the property procedures and write
the property values to the controls.</P>
<P><B>Steps</B></P>
<P>Open and run the project HT203.VBP and the form shown in Figure 2.4 appears. Change
the data in any control on the form, and use the Undo command on the Edit menu to
restore the original value.</P>
<P><A HREF="javascript:popUp('02fig04.gif')"><B>Figure 2.4.</B></A><I> The Undo Browser
form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT203 .VBP. This project is based on the
	example developed for How-To 2.1 and also includes the READINI.bas module and CTitles.cls
	module. Menu controls and supporting code have been added to the form developed for
	How-To 2.1 to support the undo operation, and a public method has been added to the
	class module. If you have worked through How-To 2.1, you can copy or modify your
	existing files. If not, refer to the steps in that example to create the foundation
	for this project.
	<P>
	<DT></DT>
	<DD><B>2. </B>Change the caption of Form1 to Undo Browser, and add the menu shown
	in Table 2.3.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.3. Menu specifications for the Edit menu.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CAPTION</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Name</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Shortcut Key</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;Edit</TD>
		<TD ALIGN="LEFT">mnuEdit</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----&amp;Undo</TD>
		<TD ALIGN="LEFT">mnuEditUndo</TD>
		<TD ALIGN="LEFT">Ctrl+Z</TD>
	</TR>
	</TABLE>
<BR>
	
<HR>
<B><STRONG>NOTE</STRONG></B> By convention, the Edit menu is placed to the immediate
	right of the File menu. 
<HR>


</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>3. </B>Add the mnuEdit_Click and mnuEditUndo_Click events to Form1. <BR>
	The mnuEdit_Click event checks the current record state and toggles the enabled property
	of the mnuEditUndo control based on the value of the IsDirty property of mclsTitles.
	The mnuEditUndo_Click procedure calls the UndoRecord method of the mclsTitles object
	and refreshes the form. This is the only new code in the form.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuEdit_Click()
<TT>` enable/disable undo command based on current dirty flag</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` toggle based on dirty flag</TT>
<TT>    mnuEditUndo.Enabled = mclsTitles.IsDirty</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT>
<TT>Private Sub mnuEditUndo_Click()</TT>
<TT>` undo changes</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` undo changes</TT>
<TT>    mclsTitles.UndoRecord</TT>
<TT>    ` refresh the display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the UndoRecordmethod to the CTitles class. UndoRecord clears the
	mblnIsDirty flag and restores the original values from the recordset to <BR>
	the private variables used for the property procedures by calling the GetCurrentRecord
	procedure.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub UndoRecord()
<TT>` clear changes and refresh properties</TT>
<TT>    ` clear dirty flag</TT>
<TT>    ` but do not clear new flag</TT>
<TT>    mblnIsDirty = False</TT>
<TT>    ` refresh the current values from the recordset</TT>
<TT>    GetCurrentRecord</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>Each of the property procedures that represent fields in the CTitles class sets
the module-level mblnIsDirty flag. This flag is then used to toggle the enabled property
of the Undo command on the Edit menu. When the user selects Undo, the form calls
the UndoRecord method of the class and refreshes the controls on the form. The UndoRecord
method needs only to restore the private module-level variables with the data that
is still unchanged in the recordset.</P>
<P><B>Comments</B></P>
<P>The standard TextBox control supports a field level undo capability with the built-in
context menu. By adding some code, you could also implement a field-level undo command
for any field you display, regardless of the type of control that is used.</P>
<P>
<H2><A NAME="Heading15"></A>2.How do I...</H2>
<H3><A NAME="Add and delete records by using Data Access Objects?"></A><B>Add and
delete records by using Data Access Objects?</B></H3>
<P><B>Problem</B></P>
<P>Viewing and editing existing records are only half of the jobs my users need to
do. How do I add and delete records using unbound controls and Data Access Objects?</P>
<P><B>Technique</B></P>
<P>The recordset object provides the AddNew and Delete methods for inserting and
deleting records. When you are using unbound controls on a form, adding a record
is a five-step process:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Clear (and if necessary save) the current record so that the user can
	enter data for the new record.
	<P>
	<DT></DT>
	<DD><B>2. </B>Call the AddNew method of the recordset.
	<P>
	<DT></DT>
	<DD><B>3. </B>Write the values from the controls to the Fields.
	<P>
	<DT></DT>
	<DD><B>4. </B>Call the Update method of the recordset.
	<P>
	<DT></DT>
	<DD><B>5. </B>Restore the record pointer to the newly added record.
	<P>
</DL>

<P>Deleting a record is a two-step process:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Call the Delete method of the recordset.
	<P>
	<DT></DT>
	<DD><B>2. </B>Move to a valid record and display it.
	<P>
</DL>



<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>ADD AND DELETE USER INTERFACES</STRONG></B> </P>

	<P>Microsoft Access and (if properly configured) the Data control enable users to
	add new records by navigating to the end of the recordset and clicking the Next Record
	button. Although this two-step procedure might seem obvious to most programmers and
	database developers, it is not at all obvious to most users. Users will be looking
	for something clearly labeled as a command that will give them a new record with
	which to work. Rather than emulate this confusing idiom, this example uses a New
	Record command on the Data menu.<BR>
	<BR>
	The same reasoning applies to deleting records. Provide a clearly labeled menu command
	or button the user can click to perform a delete.<BR>
	In short, don't aggravate your users by burying common operations with obscure procedures
	in the interface. 
<HR>


</BLOCKQUOTE>

<P><B>Steps</B></P>
<P>Open and run the project HT204 .VBP. To add a new record, select the Data | New
Record menu command, as shown in Figure 2.5. To delete a record, choose the Delete
Record command.</P>
<P><A HREF="javascript:popUp('02fig05.gif')"><B>Figure 2.5.</B></A><I> The Add and
Delete form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT204.VBP. This project is based on the
	example developed for How-To 2.1. Only the changes to that project are described
	here. Refer to the steps in the original project for the complete details of creating
	the form, the CTitles class module, and the READINI.bas module.
	<P>
	<DT></DT>
	<DD><B>2. </B>Change the caption of Form1 to Add and Delete, and add the New Record
	and Delete Record commands (shown in bold) to the Data menu, as shown in Table 2.4.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.4. Menu specifications for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CAPTION</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Name</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Shortcut Key</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;File</TD>
		<TD ALIGN="LEFT">mnuFile</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----E&amp;xit</TD>
		<TD ALIGN="LEFT">mnuFileExit</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;Data</TD>
		<TD ALIGN="LEFT">mnuData</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>----&amp;New Record</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataNewRecord</B></TD>
		<TD ALIGN="LEFT"><B>Ctrl+N</B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----&amp;Save Record</TD>
		<TD ALIGN="LEFT">mnuDataSaveRecord</TD>
		<TD ALIGN="LEFT">Ctrl+S</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>----&amp;Delete Record</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataDeleteRecord</B></TD>
		<TD ALIGN="LEFT"><B>Ctrl+X</B></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>3. </B>Modify the Form_Load event procedure to enable the user to create a
	new record if the table is empty when the form is initially loaded. Only the code
	in the error handler has changed.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Form_Load()
<TT>` create the mclsTitles object and display the first record</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Dim strDBName As String</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` create the CTitles object</TT>
<TT>    Set mclsTitles = New CTitles</TT>
<TT>    ` fetch and display the current record</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    ` An error was generated by Visual Basic or CTitles.</TT>
<TT>    ` Check for the &quot;No Records&quot; error and if so</TT>
<TT>    ` just provide a new record.</TT>
<TT>    Select Case Err.Number</TT>
<TT>        Case ErrNoRecords</TT>
<TT>            mclsTitles.NewRecord</TT>
<TT>            Resume Next</TT>
<TT>        Case Else</TT>
<TT>            ` Some other error</TT>
<TT>            ` Display the error message and terminate gracefully.</TT>
<TT>            MsgBox Err.Description, vbExclamation</TT>
<TT>            Unload Me</TT>
<TT>            Resume ProcExit</TT>
<TT>    End Select</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Add the event procedures for mnuData_Click and its submenu items mnuDataNewRecord_Click,
	mnuDataSaveRecord_Click, and mnuDataDeleteRecord_Click. The mnuData_Click event toggles
	the enabled flag for the mnuDataSaveRecord menu control based on the IsDirty flag
	of the mclsTitles object. The mnuDataNewRecord_Click event calls the NewRecord method
	of the mclsTitles object. The mnuDataSaveRecord_Click procedure saves the current
	record by calling the mclsTitles.SaveRecord method. The DeleteRecord method of mclsTitles
	is called by mnuDataDeleteRecord_Click. A special trap is used in the error handler.
	If the delete leaves the recordset empty, a new record is created.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuData_Click()
<TT>` set enabled/disabled flags for menu commands</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save enabled only when dirty</TT>
<TT>    mnuDataSaveRecord.Enabled = mclsTitles.IsDirty</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD>The mnuData_Click event procedure is unchanged from the example in How-To 2.1.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuDataNewRecord_Click()
<TT>` set up a new record</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save existing first</TT>
<TT>    mclsTitles.SaveRecord</TT>
<TT>    ` get a new record</TT>
<TT>    mclsTitles.NewRecord</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT>
<TT>Private Sub mnuDataSaveRecord_Click()</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` save it</TT>
<TT>    mclsTitles.SaveRecord</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT>
<TT>Private Sub mnuDataDeleteRecord_Click()</TT>
<TT>` delete the current record</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    mclsTitles.DeleteRecord</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    Select Case Err.Number</TT>
<TT>        Case ErrNoRecords</TT>
<TT>            ` last record was deleted</TT>
<TT>            ` Create a new record</TT>
<TT>            mclsTitles.NewRecord</TT>
<TT>            Resume Next</TT>
<TT>        Case Else</TT>
<TT>            ` inform</TT>
<TT>            MsgBox Err.Description, vbExclamation</TT>
<TT>            Resume ProcExit</TT>
<TT>    End Select</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>5. </B>Revise the declarations section of CTitles to include the new mblnIsNew
	flag, shown in bold in the following listing. This flag is True if the current data
	is a new record and False if it is an existing record.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` The CTitles class provides a light wrapper</TT>
<TT>` around the database and record for the</TT>
<TT>` Titles table in the Biblio database</TT>
<TT>` Note: It's up to the client to save</TT>
<TT>` Database and recordset objects</TT>
<TT>Private mdb As Database</TT>
<TT>Private mrs As Recordset</TT>
<TT>` Flags</TT>
<TT>` dirty flag</TT>
<TT>Private mblnIsDirty As Boolean</TT>
<B><TT>` new record flag</TT></B>
<B><TT>Private mblnIsNew As Boolean</TT></B>
<TT>` Fields</TT>
<TT>` title</TT>
<TT>Private mstrTitle As String</TT>
<TT>` year - note use of string for</TT>
<TT>` assignment to text box</TT>
<TT>Private mstrYearPublished As String</TT>
<TT>` ISBN number</TT>
<TT>Private mstrISBN As String</TT>
<TT>` PubID - also a string</TT>
<TT>Private mstrPubID As String</TT>
<TT>` Move method constants</TT>
<TT>Public Enum CTitlesMove</TT>
<TT>    FirstRecord = 1</TT>
<TT>    LastRecord = 2</TT>
<TT>    NextRecord = 3</TT>
<TT>    PreviousRecord = 4</TT>
<TT>End Enum</TT>
<TT>` Error constants</TT>
<TT>` Note: RaiseClassError method provides the strings</TT>
<TT>` because you cannot assign a string to an Enum</TT>
<TT>Public Enum CTitlesError</TT>
<TT>    ErrInvalidMoveType = vbObjectError + 1000 + 11</TT>
<TT>    ErrNoRecords = vbObjectError + 1000 + 12</TT>
<TT>End Enum</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>6. </B>Create the AddNewRecord method. This sub does the real work of inserting
	the record into the database. First the AddNew method is called, then the values
	from the properties are written to the fields, and finally the Update method is called
	to commit the changes. After a record is inserted using AddNew and Update, the current
	record is undefined. Setting the recordset's Bookmark property to the special LastModified
	bookmark restores the current record pointer to the new record.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub AddNewRecord()
<TT>` DAO AddNew/Update</TT>
<TT>    ` inform DAO we are going to insert</TT>
<TT>    mrs.AddNew</TT>
<TT>    ` write the current values</TT>
<TT>    mrs![ISBN] = mstrISBN</TT>
<TT>    mrs![Title] = mstrTitle</TT>
<TT>    mrs![Year Published] = mstrYearPublished</TT>
<TT>    mrs![PubID] = mstrPubID</TT>
<TT>    ` update the record</TT>
<TT>    mrs.Update</TT>
<TT>    ` return to the new record</TT>
<TT>    mrs.Bookmark = mrs.LastModified</TT>
<TT>    ` clear new flag</TT>
<TT>    mblnIsNew = False</TT>
<TT>    ` clear dirty flag</TT>
<TT>    mblnIsDirty = False</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>7. </B>Add the IsNew property. This flag indicates whether the current record
	is a new record (one that has not been added to the recordset) by returning the value
	of the private mblnIsNew flag.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Property Get IsNew() As Boolean
<TT>` pass out the new flag</TT>
<TT>    IsNew = mblnIsNew</TT>
<TT>End Property</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>8. </B>Add the NewRecord method. This method clears the current values of
	the private variables used for the field properties and sets the mblnIsNew flag used
	by the IsNew property.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub NewRecord()
<TT>` clear the current values for an insert</TT>
<TT>` NOTE: the flags work so that if a new</TT>
<TT>` record is added but not changed, you</TT>
<TT>` can move off of it or close with no</TT>
<TT>` prompt to save</TT>
<TT>    ` assign zero-length strings to the properties</TT>
<TT>    mstrISBN = &quot;&quot;</TT>
<TT>    mstrTitle = &quot;&quot;</TT>
<TT>    mstrYearPublished = &quot;&quot;</TT>
<TT>    mstrPubID = &quot;&quot;</TT>
<TT>    ` set the new flag</TT>
<TT>    mblnIsNew = True</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>9. </B>Add the DeleteRecord method. DeleteRecord calls the Delete method of
	the recordset object and then uses the MovePrevious method to reset the current record
	to a valid record pointer. If MovePrevious takes the recordset to BOF (before the
	first record) a MoveFirst is executed.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub DeleteRecord()
<TT>` DAO delete</TT>
<TT>    ` delete the record</TT>
<TT>    mrs.Delete</TT>
<TT>    ` clear new and dirty flags</TT>
<TT>    mblnIsDirty = False</TT>
<TT>    mblnIsNew = False</TT>
<TT>    ` reposition to a valid record</TT>
<TT>    mrs.MovePrevious</TT>
<TT>    ` check for BOF</TT>
<TT>    If mrs.BOF Then</TT>
<TT>        ` could be empty, check EOF</TT>
<TT>        If Not mrs.EOF Then</TT>
<TT>            mrs.MoveFirst</TT>
<TT>        Else</TT>
<TT>            ` empty recordset, raise error</TT>
<TT>            ` the client must decide how to</TT>
<TT>            ` handle this situation</TT>
<TT>            RaiseClassError ErrNoRecords</TT>
<TT>        End If</TT>
<TT>    End If</TT>
<TT>    GetCurrentRecord</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>10. </B>Add the SaveRecord method. This method tests the mblnIsDirty flag
	and updates the current record, if necessary. If the record is new, the data is committed
	to the table using the AddNewRecord procedure. Existing records are updated using
	the UpdateRecord procedure.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub SaveRecord()
<TT>` save current changes</TT>
<TT>    ` test dirty flag</TT>
<TT>    If mblnIsDirty Then</TT>
<TT>        ` test new flag</TT>
<TT>        If mblnIsNew Then</TT>
<TT>            ` add it</TT>
<TT>            AddNewRecord</TT>
<TT>        Else</TT>
<TT>            ` update it</TT>
<TT>            UpdateRecord</TT>
<TT>        End If</TT>
<TT>    Else</TT>
<TT>        ` record is already clean</TT>
<TT>    End If</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>The CTitles class handles all the data processing with the database engine and
provides a lightweight wrapper around the AddNew, Update, and Delete methods of the
Recordset object. The form exposes these features in the user interface by providing
menu commands for each data operation and handling save and error trapping logic.</P>
<P>Encapsulating all the recordset management logic in the class module means that
all that code can be easily reused in other forms based on the same data.</P>
<P><B>Comments</B></P>
<P>A complete application might not necessarily have a one-to-one correspondence
between tables and class modules. The classes should reflect the object model for
the application and its data, not the database schema itself. The database underlying
a complex application might have tables that are not reflected in the object model,
such as tables used only for supplying lookup values to lists, or tables that are
not directly represented, such as junction tables in many-to-many relationships.</P>
<P>
<H2><A NAME="Heading16"></A>2.5 How do I...</H2>
<H3><A NAME="Use unbound controls to update fields in Data Access Objects?"></A><B>Use
unbound controls to update fields in Data Access Objects?</B></H3>
<P><B>Problem</B></P>
<P>Using Data Access Objects to build data entry forms with unbound controls works
well in most situations, but sometimes the data is difficult for the user to work
with. I need to extend the user interface of my application to provide alternative
methods of finding and choosing records.</P>
<H4><B>TECHNIQUE</B></H4>
<P>The nature of database applications is that users must often deal with less-than-obvious
values, such as foreign keys and coded data. Instead of forcing the user to remember
arbitrary key values and data codes, you can alter the user interface to provide
lists of values rather than simple text boxes.</P>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>NOTE</STRONG></B><STRONG> </STRONG>Chapter 4, &quot;Designing and Implementing
	a Database,&quot; discusses foreign keys and table relationships. 
<HR>


</BLOCKQUOTE>

<P>Foreign key values can represent a special problem because the lookup tables for
the keys are often quite large. Populating a list with all the available values can
seriously damage the performance of the application. Additionally, because this is
such a common operation, a generic tool for working with this type of data saves
significant coding effort.</P>
<P>Using a simple form and a ListView control, you can build a generic tool that
can display the results of an ad hoc query and return a key value for the record
selected by the user.</P>
<P><B>Steps</B></P>
<P>Open and run the project HT205.VBP. Select Data|Find Publisher and enter SAMs.
Click OK to display the results. The form shown in Figure 2.6 appears.</P>
<P><A HREF="javascript:popUp('02fig06.gif')"><B>Figure 2.6.</B></A><I> The Lookup
Browser form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT205 .VBP. This example extends the project
	developed for How-To 2.1 to provide a means for the user to search for an identifier
	value for a publisher. Refer to the steps in How-To 2.1 for complete details on building
	the base application. Only the changes to the original project are shown in the steps
	that follow.
	<P>
	<DT></DT>
	<DD><B>2. </B>Change the caption of Form1 to Lookup Browser. Modify the Data menu
	as shown in Table 2.5, adding the Find Publisher command (shown in bold).
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.5. Menu specifications for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CAPTION</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Name</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Shortcut Key</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;File</TD>
		<TD ALIGN="LEFT">mnuFile</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----E&amp;xit</TD>
		<TD ALIGN="LEFT">mnuFileExit</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;Data</TD>
		<TD ALIGN="LEFT">mnuData</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----&amp;Save Record</TD>
		<TD ALIGN="LEFT">mnuDataSaveRecord</TD>
		<TD ALIGN="LEFT">Ctrl+S</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>----&amp;Find Publisher</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataFindPublisher</B></TD>
		<TD ALIGN="LEFT"><B>Ctrl+F</B></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>3. </B>Add the following code to Form1 as the mnuDataFindPublisher_Click event.
	This event uses an input box and the FSearchResults form to build and display the
	results of an ad hoc query. The user is prompted <BR>
	to enter all or part of the name of a publisher. The value entered is used to build
	a SQL statement that is passed to the FSearchResults form. The FSearchResults form
	handles the balance of the selection process and sets its KeyValue property before
	it returns control to the mnuDataFindPublisher_Click event.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuDataFindPublisher_Click()
<TT>` Use the FSearchResults form to find a pub id</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Dim strPrompt As String</TT>
<TT>    Dim strInput As String</TT>
<TT>    Dim strSQL As String</TT>
<TT>    Dim fSearch As FSearchResults</TT>
<TT>    strPrompt = &quot;Enter all or the beginning of _</TT>
<TT>                &quot;the publisher name:&quot;</TT>
<TT>    strInput = InputBox$(strPrompt, &quot;Search for Publishers&quot;)</TT>
<TT>    If strInput &lt;&gt; &quot;&quot; Then</TT>
<TT>        ` search</TT>
<TT>        strSQL = &quot;SELECT * FROM Publishers &quot; &amp; _</TT>
<TT>            &quot;WHERE Name LIKE `&quot; &amp; strInput &amp; &quot;*';&quot;</TT>
<TT>        Set fSearch = New FSearchResults</TT>
<TT>        ` Note: Search method does not return</TT>
<TT>        ` until the user dismisses the form</TT>
<TT>        fSearch.Search &quot;PubID&quot;, strSQL, Me</TT>
<TT>        If Not fSearch.Cancelled Then</TT>
<TT>            txt(txtPubID).Text = fSearch.KeyValue</TT>
<TT>        End If</TT>
<TT>    End If</TT>
<TT>ProcExit:</TT>
<TT>    ` release the search form reference</TT>
<TT>    Set fSearch = Nothing</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
</PRE>
	<H4>End Sub</H4>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>4. </B>Create a new form, name it FSearchResults, and save the form. Table
	2.6 shows the objects and properties for the form.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.6. Objects and properties for the FSearchResults form.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Value</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">ListView</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lvwResults</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">View</TD>
		<TD ALIGN="LEFT">3 - lvwReport</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">LabelEdit</TD>
		<TD ALIGN="LEFT">1 - lvwManual</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmd</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">0</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">OK</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Default</TD>
		<TD ALIGN="LEFT">True</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmd</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Index</TD>
		<TD ALIGN="LEFT">1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Cancel</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Cancel</TD>
		<TD ALIGN="LEFT">True</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>5. </B>Add the following code to the declarations section of FSearchResults.
	The two constants are used for the index to the CommandButton control array. The
	mblnCancelled flag is used to indicate that the user chose the Cancel button. The
	mvntKeyValue holds the value (typically the primary key field, but any field can
	be specified when the Search method is called) for the key field. The mintItemIdx
	holds the index into the SubItems collection of the ListView control for the key
	value.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` This form will run an ad hoc query and</TT>
<TT>` display the results in the list view control</TT>
<TT>` command button array constants</TT>
<TT>Const cmdOK = 0</TT>
<TT>Const cmdCancel = 1</TT>
<TT>` cancel property</TT>
<TT>Private mblnCancelled As Boolean</TT>
<TT>` selected key value</TT>
<TT>Private mvntKeyValue As Variant</TT>
<TT>` subitem index for key value</TT>
<TT>Private mintItemIdx As Integer</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>6. </B>Add the cmd_Click event procedure for the CommandButton control array.
	This event procedure sets the private flag indicating whether the user chose OK or
	Cancel and hides the form. Because the form is displayed modally, control returns
	to whatever procedure created the form after this procedure exits.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmd_Click(Index As Integer)
<TT>    If Index = cmdOK Then</TT>
<TT>        mblnCancelled = False</TT>
<TT>    Else</TT>
<TT>        mblnCancelled = True</TT>
<TT>    End If</TT>
<TT>    Me.Hide</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>7. </B>Add the lvwResults_ItemClick event procedure. When Visual Basic fires
	the ItemClick event for a ListView control, it passes the clicked ListItem object
	as a parameter. The mintItemIdx variable set by the Search method is used to retrieve
	the value of the key field from the SubItems collection and assign it to the mvntKeyValue
	variable, where it can be read by the KeyValue property procedure.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub lvwResults_ItemClick(ByVal Item As ComctlLib.ListItem)
<TT>On Error GoTo ProcError</TT>
<TT>    mvntKeyValue = Item.SubItems(mintItemIdx)</TT>
<TT>ProcExit:</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>8. </B>Add the Cancelled and KeyValue property procedures. Each procedure
	returns the values assigned to the module-level variables. These properties are checked
	by the procedure that created the instance of the form to see what button the user
	chose and the key value of the record selected.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Property Get Cancelled()
<TT>    Cancelled = mblnCancelled</TT>
<TT>End Property</TT>
<TT>Public Property Get KeyValue() As Variant</TT>
<TT>    KeyValue = mvntKeyValue</TT>
<TT>End Property</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>9. </B>Add the following code to FSearchResults as the Search method. The
	method takes three parameters: a key field name used to return a value in the KeyValue
	property, a SQL statement used to create the list of results, and a parent form reference
	used by the Show method. The method builds the results list by first creating a recordset
	object based on the SQL statement provided. If there are records to display, it iterates
	the Fields collection of the recordset to generate a set of column headers for lvwResults
	(determining the index of the key field in the process). After the column headers
	for the list have been created, the method enters a Do loop and iterates the records
	in the recordset. For each record, the fields are iterated and their values are placed
	into the appropriate SubItem of the ListView. In addition to the list of fields,
	the lvwResults ListView control shows the ordinal position in the results for each
	record.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub Search( _
<TT>    strKeyField As String, _</TT>
<TT>    strSQLStatement As String, _</TT>
<TT>    frmParent As Form)</TT>
<TT>` run the specified query and populate the</TT>
<TT>` listview with the results</TT>
<TT>    Dim strDBName As String</TT>
<TT>    Dim lngOrdRecPos As Long</TT>
<TT>    Dim db As Database</TT>
<TT>    Dim rs As Recordset</TT>
<TT>    Dim fld As Field</TT>
<TT>    strDBName = BiblioPath()</TT>
<TT>    Set db = DBEngine(0).OpenDatabase(strDBName)</TT>
<TT>    Set rs = db.OpenRecordset(strSQLStatement, _</TT>
<TT>        dbOpenDynaset, dbReadOnly)</TT>
<TT>    ` test for no records</TT>
<TT>    If Not rs.EOF Then</TT>
<TT>        ` create the ordinal position column</TT>
<TT>        lvwResults.ColumnHeaders.Add , &quot;Ordinal&quot;, &quot;Record&quot;</TT>
<TT>        ` set width</TT>
<TT>        lvwResults.ColumnHeaders(&quot;Ordinal&quot;).Width = 600</TT>
<TT>        ` create the columns in the listview</TT>
<TT>        For Each fld In rs.Fields</TT>
<TT>            lvwResults.ColumnHeaders.Add , fld.Name, fld.Name</TT>
<TT>            ` best guess column width</TT>
<TT>            lvwResults.ColumnHeaders(fld.Name).Width _</TT>
<TT>                = 150 * Len(fld.Name)</TT>
<TT>            If fld.Name = strKeyField Then</TT>
<TT>                ` mark the item index for later retrieval</TT>
<TT>                mintItemIdx = fld.OrdinalPosition + 1</TT>
<TT>            End If</TT>
<TT>        Next    ` field</TT>
<TT>        ` populate the list</TT>
<TT>        Do</TT>
<TT>            ` increment the ordinal position counter</TT>
<TT>            lngOrdRecPos = lngOrdRecPos + 1</TT>
<TT>            ` add the item</TT>
<TT>            lvwResults.ListItems.Add _</TT>
<TT>                lngOrdRecPos, , CStr(lngOrdRecPos)</TT>
<TT>            ` add the fields to the rest of the columns</TT>
<TT>            For Each fld In rs.Fields</TT>
<TT>                lvwResults.ListItems(lngOrdRecPos). _</TT>
<TT>                SubItems(fld.OrdinalPosition + 1) = _</TT>
<TT>                fld.Value &amp; &quot;&quot;</TT>
<TT>            Next    ` field</TT>
<TT>            ` go to next record</TT>
<TT>            rs.MoveNext</TT>
<TT>        Loop While Not rs.EOF</TT>
<TT>        ` clean up</TT>
<TT>        rs.Close</TT>
<TT>        Set rs = Nothing</TT>
<TT>        db.Close</TT>
<TT>        Set db = Nothing</TT>
<TT>        ` show modally</TT>
<TT>        Me.Show vbModal, frmParent</TT>
<TT>    Else</TT>
<TT>        ` no data, treat as a cancel</TT>
<TT>        mblnCancelled = True</TT>
<TT>        MsgBox &quot;No matching records found.&quot;, vbInformation</TT>
<TT>        Me.Hide</TT>
<TT>    End If</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>The FSearchResults form provides a generic tool for running an ad hoc query, displaying
its results, and returning a key value selected by the user. The benefit of using
a generic search form is that the form can be easily reused in any situation in which
this type of lookup is required. This form can be added with minimal impact on the
original design or performance of the main data entry form, but it still provides
the user with a more advanced method of entering the PubID foreign key field.</P>
<P>The form works by filling a ListView control using a completely generic population
routine in the Search method. When the user selects a record and dismisses the form
by clicking OK, a private module-level variable retains the selected item, which
can then be read from the KeyValue property.</P>
<P><B>Comments</B></P>
<P>Over time, you might build a significant library of generic components such as
this lookup form. If the tools are properly designed and not coupled too tightly
to any particular application or database, you might be able to bundle them together
in an ActiveX DLL, which can then be included in future applications without having
to return to the source code.</P>
<P>
<H2><A NAME="Heading17"></A>2.6 How do I...</H2>
<H3><A NAME="Find records by using index values in Data Access Objects?"></A><B>Find
records by using index values in Data Access Objects?</B></H3>
<P><B>Problem</B></P>
<P>I know that indexes can be used to speed up database operations. How can I take
advantage of indexes in my application?</P>
<P><B>Technique</B></P>
<P>When a table-type recordset has a current index (either the primary key or another
index you have designated), you can use the Seek method to find records based on
the indexed values. To use the Seek method, provide it with an argument that matches
each field in the index. When the Seek method executes, if it finds at least one
record matching the index values, it positions the record pointer to the first matching
record and sets the NoMatch property of the recordset to False. If Seek does not
find a matching record, it sets the NoMatch property to True; the current record
is then undefined, which means that you can't be sure where the record pointer is
pointing.</P>
<P>When you use Seek, specify not only the values for the key index fields but also
the comparison criterion that Seek is to use. You provide the comparison criterion
as the first argument to the Seek method, and you provide it as a string value. In
the majority of cases, you will specify that Seek is to match the index value exactly;
you do this by specifying a comparison criterion of =. You can also specify &lt;
&gt; for not equal, &gt; for greater than, &lt; for less than, &gt;= for greater
than or equal to, or &lt;= for less than or equal to.</P>
<P><B>Steps</B></P>
<P>Open and run the project HT206.VBP. Use the Index command on the Data menu to
select the ISBN index. Browse forward in the recordset a few records, and copy the
ISBN number from the form to the clipboard. Using the MoveFirst button, return to
the first record; then select Data|Seek to display the input box shown in Figure
2.7. Paste the value you copied into the input box, and click OK. The record with
the matching ISBN number is displayed.</P>
<P><A HREF="javascript:popUp('02fig07.gif')"><B>Figure 2.7.</B></A><I> The Seek form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT206 .VBP. This example adds the capability
	to find records using the Seek method to the basic browser application developed
	in How-To 2.1. The form and class module contain minor changes and some added code
	to support the Seek operation. The READINI.bas module is unchanged. Only the code
	that has been added or modified for this project is shown in the steps that follow.
	<P>
	<DT></DT>
	<DD><B>2. </B>Change the caption of Form1 to Seek, and modify the Data menu as shown
	in Table 2.7. The Index command, its submenu items, and the Seek command (all shown
	in bold) are new in this project.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.7. Menu specifications for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>CAPTION</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Name</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Shortcut Key</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;File</TD>
		<TD ALIGN="LEFT">mnuFile</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----E&amp;xit</TD>
		<TD ALIGN="LEFT">mnuFileExit</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&amp;Data</TD>
		<TD ALIGN="LEFT">mnuData</TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">----&amp;Save Record</TD>
		<TD ALIGN="LEFT">mnuDataSaveRecord</TD>
		<TD ALIGN="LEFT">Ctrl+S</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>----&amp;Index</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataIndex</B></TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>--------&amp;ISBN</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataIndexName</B></TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>--------&amp;Title</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataIndexName</B></TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B>----S&amp;eek</B></TD>
		<TD ALIGN="LEFT"><B>mnuDataSeek</B></TD>
		<TD ALIGN="LEFT"></TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>3. </B>Modify the declarations section of Form1 as shown. Index constants
	have been added for the mnuDataIndexName control array.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` CTitles object</TT>
<TT>Private mclsTitles As CTitles</TT>
<TT>` These constants are used for the various control arrays</TT>
<TT>` command button constants</TT>
<TT>Const cmdMoveFirst = 0</TT>
<TT>Const cmdMovePrevious = 1</TT>
<TT>Const cmdMoveNext = 2</TT>
<TT>Const cmdMoveLast = 3</TT>
<TT>` text box index constants</TT>
<TT>Const txtTitle = 0</TT>
<TT>Const txtYearPublished = 1</TT>
<TT>Const txtISBN = 2</TT>
<TT>Const txtPubID = 3</TT>
<B><TT>` index constants</TT></B>
<B><TT>Const idxISBN = 0</TT></B>
<B><TT>Const idxTitle = 1</TT></B>
<TT>` refresh flag</TT>
<TT>Private mblnInRefresh As Boolean</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Modify the mnuData_Click event procedure to toggle the enabled flag
	for the mnuDataSeek menu control if an index has been chosen.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuData_Click()
<TT>` set enabled/disabled flags for menu commands</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<B><TT>    ` seek enabled only if index is set</TT></B>
<B><TT>    If Len(mclsTitles.IndexName) Then</TT></B>
<B><TT>        mnuDataSeek.Enabled = True</TT></B>
<B><TT>    Else</TT></B>
<B><TT>        mnuDataSeek.Enabled = False</TT></B>
<B><TT>    End If</TT></B>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>5. </B>Add the following code to Form1 as the mnuDataIndexName_Click and mnuDataSeek_Click
	events. The mnuDataIndexName_Click procedure assigns the index to use for the Seek
	operation and manages the check marks on the menu. The mnuDataSeek_Click procedure
	prompts the user for search criteria and attempts to locate the value provided by
	calling the Seek method of mclsTitles.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub mnuDataIndexName_Click(Index As Integer)
<TT>` set the current index</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` set the index</TT>
<TT>    Select Case Index</TT>
<TT>        Case idxISBN</TT>
<TT>            ` assign the index</TT>
<TT>            mclsTitles.Index = IndexISBN</TT>
<TT>            ` set up menu check marks</TT>
<TT>            mnuDataIndexName(idxTitle).Checked = False</TT>
<TT>            mnuDataIndexName(idxISBN).Checked = True</TT>
<TT>        Case idxTitle</TT>
<TT>            ` assign the index</TT>
<TT>            mclsTitles.Index = IndexTitle</TT>
<TT>            ` set up menu check marks</TT>
<TT>            mnuDataIndexName(idxTitle).Checked = True</TT>
<TT>            mnuDataIndexName(idxISBN).Checked = False</TT>
<TT>    End Select</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT>
<TT>Private Sub mnuDataSeek_Click()</TT>
<TT>` seek a record</TT>
<TT>On Error GoTo ProcError</TT>
<TT>    Dim strMsg As String</TT>
<TT>    Dim strResult As String</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    ` prompt for a value</TT>
<TT>    strMsg = &quot;Enter a value to search for:&quot;</TT>
<TT>    strResult = InputBox$(strMsg)</TT>
<TT>    ` seek for the record</TT>
<TT>    mclsTitles.SeekRecord strResult</TT>
<TT>    ` refresh display</TT>
<TT>    GetData</TT>
<TT>ProcExit:</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description, vbExclamation</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>6. </B>Modify the declarations section of the CTitles class to include the
	new enumeration for the index and to modify the error enumeration for new error messages.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` The CTitles class provides a light wrapper</TT>
<TT>` around the database and record for the</TT>
<TT>` Titles table in the Biblio database</TT>
<TT>` Database and recordset objects</TT>
<TT>Private mdb As Database</TT>
<TT>Private mrs As Recordset</TT>
<TT>` Fields</TT>
<TT>` title</TT>
<TT>Private mstrTitle As String</TT>
<TT>` year - note use of string for</TT>
<TT>` assignment to text box</TT>
<TT>Private mstrYearPublished As String</TT>
<TT>` ISBN number</TT>
<TT>Private mstrISBN As String</TT>
<TT>` PubID - also a string</TT>
<TT>Private mstrPubID As String</TT>
<TT>` Move method constants</TT>
<TT>Public Enum CTitlesMove</TT>
<TT>    FirstRecord = 1</TT>
<TT>    LastRecord = 2</TT>
<TT>    NextRecord = 3</TT>
<TT>    PreviousRecord = 4</TT>
<TT>End Enum</TT>
<B><TT>` Index constants</TT></B>
<B><TT>Public Enum CTitlesIndex</TT></B>
<B><TT>    IndexISBN = 0</TT></B>
<B><TT>    IndexTitle = 1</TT></B>
<B><TT>End Enum</TT></B>
<TT>` Error constants</TT>
<TT>` Note: RaiseClassError method provides the strings</TT>
<TT>` because you cannot assign a string to an Enum</TT>
<B><TT>Public Enum CTitlesError</TT></B>
<B><TT>    ErrRecordNotFound = vbObjectError + 1000 + 10</TT></B>
<B><TT>    ErrInvalidMoveType = vbObjectError + 1000 + 11</TT></B>
<B><TT>    ErrNoRecords = vbObjectError + 1000 + 12</TT></B>
<B><TT>    ErrInvalidIndex = vbObjectError + 1000 + 13</TT></B>
<B><TT>End Enum</TT></B></PRE>

</BLOCKQUOTE>

<PRE><B><TT></TT></B></PRE>

<DL>
	<DT><B><TT></TT></B></DT>
	<DD><B>7. </B>Change the Class_Initialize procedure so that a table-type recordset
	is created rather than a dynaset-type recordset. Only the table-type recordset supports
	the Seek method. The only thing required to change to a table-type recordset is to
	change the dbOpenDynaset constant to dbOpenTable.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Class_Initialize()
<TT>    ` open the database and recordset</TT>
<TT>    Dim strDBName As String</TT>
<TT>    ` Get the database name and open the database.</TT>
<TT>    ` BiblioPath is a function in READINI.BAS</TT>
<TT>    strDBName = BiblioPath()</TT>
<TT>    Set mdb = DBEngine.Workspaces(0).OpenDatabase(strDBName)</TT>
<TT>    ` Open the recordset.</TT>
<B><TT>    Set mrs = mdb.OpenRecordset( _</TT></B>
<B><TT>        &quot;Titles&quot;, dbOpenTable, dbSeeChanges, dbOptimistic)</TT></B>
<TT>    ` Raise an error if there is no data</TT>
<TT>    If mrs.BOF Then</TT>
<TT>        RaiseClassError ErrNoRecords</TT>
<TT>    End If</TT>
<TT>    ` fetch the first record to the properties</TT>
<TT>    GetCurrentRecord</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>8. </B>The RaiseClassError procedure has had new sections added to the Select...Case
	block for the newly added errors.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub RaiseClassError(lngErrorNumber As CTitlesError)
<TT>` Note: DAO errors are passed out as-is</TT>
<TT>    Dim strDescription As String</TT>
<TT>    Dim strSource As String</TT>
<TT>    ` assign the description for the error</TT>
<B><TT>    Select Case lngErrorNumber</TT></B>
<B><TT>        Case ErrRecordNotFound</TT></B>
<B><TT>            strDescription = &quot;The record was not found.&quot;</TT></B>
<B><TT>        Case ErrInvalidMoveType</TT></B>
<B><TT>            strDescription = &quot;Invalid move operation.&quot;</TT></B>
<B><TT>        Case ErrNoRecords</TT></B>
<B><TT>            strDescription = &quot;There are no records &quot; _</TT></B>
<B><TT>                &amp; &quot;in the Titles table.&quot;</TT></B>
<B><TT>        Case ErrInvalidIndex</TT></B>
<B><TT>            strDescription = &quot;Invalid Index Name.&quot;</TT></B>
<B><TT>        Case Else</TT></B>
<B><TT>            ` If this executes, it's a coding error in</TT></B>
<B><TT>            ` the class module, but having the case is</TT></B>
<B><TT>            ` useful for debugging.</TT></B>
<B><TT>            strDescription = &quot;There is no message for this error.&quot;</TT></B>
<B><TT>    End Select</TT></B>
<TT>    ` build the Source property for the error</TT>
<TT>    strSource = App.EXEName &amp; &quot;.CTitles&quot;</TT>
<TT>    ` raise it</TT>
<TT>    Err.Raise lngErrorNumber, strSource, strDescription</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>9. </B>Add the IndexName and Index properties. The IndexName property is used
	to determine the current index for the recordset. The Index property changes the
	index based on the value provided in the lngIndex parameter.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Property Get IndexName() As String
<TT>    IndexName = mrs.Index</TT>
<TT>End Property</TT>
<TT>Public Property Let Index(lngIndex As CTitlesIndex)</TT>
<TT>` unlike the field values, this is validated when assigned</TT>
<TT>    Dim vntBookmark As Variant</TT>
<TT>    ` save a bookmark</TT>
<TT>    vntBookmark = mrs.Bookmark</TT>
<TT>    ` assign the index</TT>
<TT>    Select Case lngIndex</TT>
<TT>        Case IndexISBN</TT>
<TT>            mrs.Index = &quot;PrimaryKey&quot;</TT>
<TT>        Case IndexTitle</TT>
<TT>            mrs.Index = &quot;Title&quot;</TT>
<TT>        Case Else</TT>
<TT>            ` invalid, raise an error</TT>
<TT>            RaiseClassError ErrInvalidIndex</TT>
<TT>    End Select</TT>
<TT>    ` return to old record</TT>
<TT>    mrs.Bookmark = vntBookmark</TT>
<TT>End Property</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>10. </B>Add the SeekRecord method. This method stores a bookmark and seeks
	for the value passed in the strValue parameter. If a matching record is found, it
	is fetched. If no matching record is found, the saved bookmark is used to restore
	the record pointer to the original position.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Public Sub SeekRecord(strValue As String)
<TT>` seek to the indicated record based on the current index</TT>
<TT>    Dim vntBookmark As Variant</TT>
<TT>    ` mark the current record</TT>
<TT>    vntBookmark = mrs.Bookmark</TT>
<TT>    ` seek, the first operator is the comparison,</TT>
<TT>    ` the following represent the field(s) in the index</TT>
<TT>    mrs.Seek &quot;=&quot;, strValue</TT>
<TT>    ` check for match</TT>
<TT>    If Not mrs.NoMatch Then</TT>
<TT>        ` found it, now fetch it</TT>
<TT>        GetCurrentRecord</TT>
<TT>    Else</TT>
<TT>        ` not found, return to prior location</TT>
<TT>        mrs.Bookmark = vntBookmark</TT>
<TT>        ` raise the not found error</TT>
<TT>        RaiseClassError ErrRecordNotFound</TT>
<TT>    End If</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>The Seek method takes two or more parameters. The first parameter specifies the
comparison operator (normally =), and the following parameters are the values for
the fields in the index. The Index Property Let procedure in the CTitles class enables
you to assign the current index for the recordset, and SeekRecord searches for a
value. Both procedures use bookmarks to store records and, if necessary, return to
the original record.</P>
<P><B>Comments</B></P>
<P>You cannot set indexes or use the Seek method with dynaset- or snapshot-type Recordset
objects. To find a record in a dynaset or snapshot recordset, use one of the Find
methods: FindFirst, FindNext, FindPrevious, or FindLast. Because these methods do
not use indexes, they are much slower than Seek operations with table-type recordsets.
You also cannot use Seek on remote server tables because these cannot be opened as
table-type recordsets.</P>
<P>In most cases, it is much faster to create a new dynaset- or snapshot-type recordset
than to use either a Find or the Seek method. You do this by building a SQL statement
that includes a WHERE clause specifying the records you want to retrieve. If the
database engine can find a useful index for the query, it uses that index to speed
up the query.</P>
<P>See Chapter 3, &quot;Creating Queries with SQL,&quot; for details on creating
SQL statements, and Chapter 4, &quot;Designing and Implementing a Database,&quot;
for more information on choosing and defining indexes.</P>
<P>
<H2><A NAME="Heading18"></A>2.7 How do I...</H2>
<H3><A NAME="Determine how many records are in a dynaset-or snapshot-type recordset?"></A><B>Determine
how many records are in a dynaset- or snapshot-type recordset?</B></H3>
<P><B>Problem</B></P>
<P>I need to know how many records are in a recordset I've created. For table-type
recordsets, this is easy--I just use the value of the RecordCount property. But when
I try this with a dynaset- or snapshot-type recordset, I can't predict what value
will be returned. Sometimes it's the correct count, while other times it's not. How
can I reliably determine the number of records in a dynaset- or snapshot-type recordset?</P>
<P><B>Technique</B></P>
<P>The system tables in a Microsoft Access database include information about the
number of records in every table in the database. As records are added or deleted,
the table is continuously updated by the Jet engine. You can determine the number
of records in the table at any time by checking the RecordCount property of the TableDef.
Unlike a table, dynaset- and snapshot-type recordsets are temporary recordsets. You
can't obtain a record count by checking a TableDef.</P>
<P>You can retrieve the RecordCount property of a dynaset- or snapshot-type recordset,
but the value it returns depends on several factors in addition to the number of
records actually in the recordset. The only way the Jet engine can determine how
many records are in a dynaset- or snapshot-type recordset is by counting them. To
count them, the Jet engine has to move through the records, one by one, until it
reaches the end of the recordset. When the Jet engine creates a dynaset- or snapshot-type
recordset, however, it does not automatically count the records because counting
the records in a large recordset could take a long time. If you retrieve the RecordCount
property immediately after you create a dynaset- or snapshot-type recordset, therefore,
you're guaranteed to get back one of two values: 0 if the recordset is empty or 1
if the recordset has at least one record.</P>
<P>To get an accurate count, your code must tell the Jet engine to count the records.
Do this by executing the recordset's MoveLast method. After a MoveLast, you can retrieve
the RecordCount with the confidence that the value is accurate. In the case of a
dynaset-type recordset, if you add or delete records, the Jet engine keeps track
of them for you, and any subsequent looks at RecordCount will give you the correct
current count.</P>
<P><B>Steps</B></P>
<P>Open and run the project HT207.VBP. You will see the form shown in Figure 2.8.
This form shows the number of records in the BIBLIO.MDB Authors table. The first
box reports the number of records reported immediately after Authors is opened as
a table-type recordset. The second box shows the number of records reported immediately
after a dynaset is opened with the SQL statement SELECT Au_ID FROM Authors--a statement
that returns a dynaset consisting of the entire table, the same set of records that
are in the table-type recordset reported in the first box. The third box shows the
record count from the dynaset after its MoveLast method has been used. Note that
the first and third boxes have the same number (which might be different on your
system). The second box, reporting the dynaset record count before the MoveLast,
shows a count <BR>
of 1.</P>
<P><A HREF="javascript:popUp('02fig08.gif')"><B>Figure 2.8.</B></A><I> The Record
Counts form.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT207 .VBP. Create the objects and properties
	listed in Table 2.8, and save the form as HT207.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.8. Objects and properties for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Form</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Form1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Record Counter</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CommandButton</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdExit</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Cancel</TD>
		<TD ALIGN="LEFT">True</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Default</TD>
		<TD ALIGN="LEFT">True</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Exit</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblTable</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Alignment</TD>
		<TD ALIGN="LEFT">2 (Center)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">BorderStyle</TD>
		<TD ALIGN="LEFT">1 (Fixed Single)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblDynasetCreate</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Alignment</TD>
		<TD ALIGN="LEFT">2 (Center)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">BorderStyle</TD>
		<TD ALIGN="LEFT">1 (Fixed Single)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblDynasetMoved</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Alignment</TD>
		<TD ALIGN="LEFT">2 (Center)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">BorderStyle</TD>
		<TD ALIGN="LEFT">1 (Fixed Single)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Records reported in the</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">BIBLIO.MDB Authors table</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">recordset:</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label2</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Records in the BIBLIO.MDB SELECT</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Au_ID FROM Authors dynaset immediately after creation.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Label3</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Records in the BIBLIO.MDB SELECT</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Au_ID FROM Authors dynaset after using the MoveLast method.</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add READINI.BAS to your project.
	<P>
	<DT></DT>
	<DD><B>3. </B>Add the Form_Load event procedure. Form_Load opens the database, opens
	table and dynaset recordsets, and gets record counts for both recordsets. It then
	uses MoveLast to go to the end of the dynaset and gets the record count again. Finally,
	Form Load inserts each of the record counts into Label controls on the form.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Form_Load()
<TT>On Error GoTo ProcError</TT>
<TT>    Dim strDBName As String</TT>
<TT>    Dim strSQL As String</TT>
<TT>    Dim db As Database</TT>
<TT>    Dim rsTable As Recordset</TT>
<TT>    Dim rsDynaset As Recordset</TT>
<TT>    ` Get the database name and open the database.</TT>
<TT>    ` BiblioPath is a function in READINI.BAS</TT>
<TT>    strDBName = BiblioPath()</TT>
<TT>    Set db = DBEngine.Workspaces(0).OpenDatabase(strDBName)</TT>
<TT>    Set rsTable = db.OpenRecordset(&quot;Authors&quot;, dbOpenTable)</TT>
<TT>    lblTable = rsTable.RecordCount</TT>
<TT>    strSQL = &quot;SELECT Au_ID FROM Authors&quot;</TT>
<TT>    Set rsDynaset = db.OpenRecordset(strSQL, dbOpenDynaset)</TT>
<TT>    lblDynasetCreate = rsDynaset.RecordCount</TT>
<TT>    rsDynaset.MoveLast</TT>
<TT>    lblDynasetMoved = rsDynaset.RecordCount</TT>
<TT>ProcExit:</TT>
<TT>    On Error Resume Next</TT>
<TT>    ` clean up</TT>
<TT>    rsDynaset.Close</TT>
<TT>    rsTable.Close</TT>
<TT>    db.Close</TT>
<TT>    Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox Err.Description</TT>
<TT>    Resume ProcExit</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>4. </B>Insert the following code as the Click event of cmdExit:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdExit_Click()
<TT>    Unload Me</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>The table-type recordset enables you to check the RecordCount property immediately
after it is created, but with a snapshot- or dynaset-type recordset, you must first
access all the records before you can obtain an accurate count. This is typically
done via the MoveLast method.</P>
<P><B>Comments</B></P>
<P>One common reason for wanting an accurate record count is to use the count as
the control for a For...Next loop to cycle through the entire recordset, as in this
code fragment:</P>


<BLOCKQUOTE>
	<PRE>myRecordset.MoveLast
n = myRecordset.RecordCount
myRecordset.MoveFirst
for i = 1 to n
    ` do something
    myRecordset.MoveNext
next i</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>The difficulties with getting and keeping accurate record counts make it inadvisable
to use code like this--especially in shared data environments where the record count
of a table can change the instant after you retrieve it. This fragment illustrates
a more reliable way to accomplish the same goal:</P>


<BLOCKQUOTE>
	<PRE>myRecordset.MoveFirst
Do While Not myRecordset.EOF
    ` do something
    myRecordset.MoveNext
Loop</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>This loop executes until the last record in the recordset has been processed (when
myRecordset.EOF becomes True), and it does not depend on a potentially unstable record
count.</P>
<P>
<H2><A NAME="Heading19"></A>2.8 How do I...</H2>
<H3><A NAME="Handle Data Access Object errors?"></A><B>Handle Data Access Object
errors?</B></H3>
<P><B>Problem</B></P>
<P>When I access a database through Visual Basic, I have limited control over the
environment. A user might move a database file, or another program might have made
unexpected changes to the database. I need my programs to be able to detect errors
that occur and handle them in the context of the program. How do I accomplish this
task with Visual Basic?</P>
<P><B>Technique</B></P>
<P>When an error occurs in a Visual Basic program, control passes to error-handling
logic. Unless you have enabled an error handler, Visual Basic uses its default handler,
which displays a message about the error--one that is sometimes useful, but often
not--and terminates the application.</P>
<P>Clearly, the default handling is not acceptable. Fortunately, Visual Basic provides
tools that you can use to build your own error traps and handlers. Although any Visual
Basic application should trap and handle runtime errors, it is especially important
in database applications in which many error conditions can be expected to occur.
Visual Basic error-trapping is enabled with the On Error statement. The On Error
statement takes two basic forms:</P>


<BLOCKQUOTE>
	<PRE>On Error Goto <I>label</I>
On Error Resume Next</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>In the first form, when a runtime error occurs, Visual Basic transfers control
of the application to the location specified by <I>label</I>. In the second form,
Visual Basic continues execution with the line following the line in which the error
occurred. When an error trap is enabled and an error occurs, Visual Basic performs
the action indicated by the most recent On Error statement in the execution path.
Listing 2.1 shows a hypothetical call tree and several variations of how error handlers
are enabled and activated.</P>
<P>
<H4>Listing 2.1. Trapping errors.</H4>
<PRE>Sub SubA()
    ...<I>other code</I>
    SubB
End Sub
Sub SubB()
On Error Goto ProcError
  SubC
ProcExit:
    Exit Sub
ProcError:
    MsgBox &quot;Error: &quot; &amp; Err.Number &amp; vbCrLf &amp; Err.Description
    Resume ProcExit
End Sub
SubC
    ...<I>other code</I>
    SubD
End Sub
SubD()
On Error Resume Next
    ...<I>code</I>
End Sub
</PRE>
<P>Understanding the path of execution in this code fragment is important to comprehending
how error handlers are activated:</P>

<UL>
	<LI>In SubA no error handler exists. If an error occurs before the call to SubB,
	Visual Basic's default handler displays a message and terminates the application.
	<P>
	<LI>SubB uses the On Error Goto form. If an error occurs in this routine, control
	is transferred to the statement following the ProcError label.
	<P>
	<LI>SubC has no error handler. However, when it is called from SubB, the error handler
	in SubB is still enabled, so an error in SubC also transfers control to the statement
	following the ProcError label in SubB.
	<P>
	<LI>SubD uses the On Error Resume Next form. If an error occurs in this procedure,
	code within the procedure needs to detect and handle the error.
</UL>



<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>WARNING</STRONG></B> Errors in Class_Terminate events and most form and
	control events are fatal to your application if untrapped, so it is especially important
	that you include error-handling logic in these procedures. 
<HR>


</BLOCKQUOTE>

<P>Errors generated by Visual Basic and by components of an application--including
the Jet database engine--are associated with error numbers. You can obtain the error
number, which tells you the nature of the error, by reading the Number property of
the Err object. You can read additional information about the error from the Description
property. After you know the type of error, you can take appropriate action to handle
it. This is typically done with a Select Case block.</P>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>NOTE</STRONG></B> For backward compatibility, Visual Basic still supports
	the outdated Err and Error statements and functions. However, any new code should
	use the Err object. 
<HR>
</P>

</BLOCKQUOTE>

<P>The code fragment in Listing 2.2 illustrates how you might handle some common
errors that occur in a multiuser environment. (See Chapter 11, &quot;The Windows
Registry and State Information,&quot; for a complete discussion of working with a
multiuser database application.)</P>
<P>
<H4>Listing 2.2. Error handling.</H4>
<PRE>Sub DAOCode()
On Error Goto ProcError
    ...<I>code</I>
ProcExit:
    Exit Sub
ProcError
    Dim strMsg As String
    Select Case Err.Number
        Case 3197
            ` Another user changed the data since the last time
            ` the recordset was updated
            strMsg = &quot;The data in this record was changed by &quot; &amp; _
                  &quot;another user.&quot; &amp; _
                  vbCrLf &amp; &quot;Do you want to overwrite those changes?&quot;
            If MsgBox(strMsg, vbYesNo or vbQuestion or vbDefaultButton2) _
                  = vbYes Then
                ` VB only generates the error on the first attempt
                ` Resume re-executes the line that caused the error
                Resume
            Else
                ` refresh the existing data
                rs.Requery
                DisplayData
                Resume ProcExit
            End If
        Case 3260
            ` locked by another user
            strMsg = &quot;The record is currently locked by another user.&quot;
            ` control continues at end of block
        Case Else
            ` default
            strMsg = &quot;Error: &quot; &amp; Err.Number &amp; vbCrLf &amp; Err.Description
    End Select
    MsgBox strMsg, vbExclamation
    Resume ProcExit
End Sub
</PRE>
<P>An error handler must execute a statement that clears the error. Table 2.9 list
the methods of clearing an error.</P>
<P>
<H4>Table 2.9. Statements that clear an error.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>STATEMENT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Effect</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Resume</TD>
		<TD ALIGN="LEFT">Re-executes the line that generated the error</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Resume Next</TD>
		<TD ALIGN="LEFT">Resumes execution at the line that follows the line that generated the error</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Resume label</TD>
		<TD ALIGN="LEFT">Resumes execution at the line following the named label</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Resume number</TD>
		<TD ALIGN="LEFT">Resumes execution at the line with the indicated number</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Exit Sub</TD>
		<TD ALIGN="LEFT">Exits immediately from the current subroutine</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Exit Function</TD>
		<TD ALIGN="LEFT">Exits immediately from the current function</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Exit Property</TD>
		<TD ALIGN="LEFT">Exits immediately from the current property</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">On Error</TD>
		<TD ALIGN="LEFT">Resets error-handling logic</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Err.Clear</TD>
		<TD ALIGN="LEFT">Clears the error without otherwise affecting program execution</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">End</TD>
		<TD ALIGN="LEFT">Terminates execution of the program</TD>
	</TR>
</TABLE>



<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>ERRORS IN CLASS MODULES</STRONG></B><STRONG> </STRONG></P>

	<P>It is good programming practice to separate data management code in class modules
	from user interface code in forms. To maintain this separation, it is important that
	you do not simply display a message if an error occurs in a class module. Two types
	of error situations can occur in a class module.<BR>
	<BR>
	A class can detect an error condition (such as the violation of a validation rule).
	In this case, the class module should call the Raise method of the Err object and
	set the Number, Description, Source, and--if a help file is available--the appropriate
	help properties.<BR>
	<BR>
	A class can also trap errors raised by the database engine. These can be much more
	difficult to handle. The sheer number of possible errors makes it impractical in
	most applications to reassign and describe these errors, so most applications simply
	regenerate them. 
<HR>


</BLOCKQUOTE>

<P>In either case, the code in the class module should, if possible, attempt to correct
the error before raising it.</P>
<P><B>Steps</B></P>
<P>Open and run the project HT208.VBP. Three errors will occur in succession. For
each, the message reporting the error gives you the error number, error description,
and line number where the error occurred. Figure 2.9 shows the first of these errors.</P>
<P><A HREF="javascript:popUp('02fig09.gif')"><B>Figure 2.9.</B></A><I> The HT208
error message.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>Create a new project called HT208.VBP. Use Form1 to create the objects
	and properties listed in Table 2.10, and save the form as HT208.FRM.
	<P>
</DL>



<BLOCKQUOTE>
	<H4>Table 2.10. Objects and properties for Form1.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Form</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">Form1</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Errors</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>2. </B>Add the file READINI.BAS to your project.
	<P>
	<DT></DT>
	<DD><B>3. </B>Add the following code as the Load event of Form1. This code generates
	three errors. Line 20 generates an error because there is no such table as No Such
	Table. Line 40 generates an error because there is no such field as No Such Field.
	Line 60 generates an error because the Year Published field requires a numeric value.
	Each error causes execution to branch to the label LoadError. The code beginning
	with LoadError displays an informative message and then executes a Resume Next. The
	Resume Next transfers execution back to the line following the line that caused the
	error.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Form_Load()
<TT>On Error GoTo ProcError</TT>
<TT>    Dim db As Database</TT>
<TT>    Dim dbName As String</TT>
<TT>    Dim rs As Recordset</TT>
<TT>    Dim s As String</TT>
<TT>    ` Get the database name and open the database.</TT>
<TT>    ` BiblioPath is a function in READINI.BAS</TT>
<TT>5   dbName = BiblioPath()</TT>
<TT>10  Set db = DBEngine.Workspaces(0).OpenDatabase(dbName)</TT>
<TT>20  Set rs = db.OpenRecordset(&quot;No Such Table&quot;, dbOpenTable)</TT>
<TT>30  Set rs = db.OpenRecordset(&quot;Titles&quot;, dbOpenTable)</TT>
<TT>40  s = rs![No Such Field]</TT>
<TT>50  rs.Edit</TT>
<TT>60  rs![Year Published] = &quot;XYZ&quot;</TT>
<TT>70  rs.Update</TT>
<TT>80  End</TT>
<TT>Exit Sub</TT>
<TT>ProcError:</TT>
<TT>    MsgBox &quot;Error: &quot; &amp; Err.Number &amp; vbCrLf &amp; _</TT>
<TT>        &quot;Line: &quot; &amp; Erl &amp; vbCrLf &amp; _</TT>
<TT>        Err.Description, vbExclamation</TT>
<TT>Resume Next</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>NOTE</STRONG></B> Line numbers are used here to help illustrate the error
	handler. Few programmers actually use them in production code, although they can
	be helpful for debugging. 
<HR>


</BLOCKQUOTE>

<P><B>How It Works</B></P>
<P>When Visual Basic encounters a runtime error, it transfers control of the application
to the error-handling code you specify by using the On Error statement. You have
a choice of inline handling using On Error Resume Next or centralized handling using
On Error Goto. Either way, it's up to you to determine the type of error generated
and the appropriate action to take for that error.</P>


<BLOCKQUOTE>
	<P>
<HR>
<B><STRONG>ERRORS COLLECTION</STRONG></B><STRONG> </STRONG></P>

	<P>It is possible for a single statement in DAO code to generate several errors.
	You can examine these errors by iterating the DAO Errors collection, as shown in
	the following code fragment: 
<HR>
</P>
	<PRE>For Each Error In Errors
<TT>    Debug.Print Err.Number &amp; &quot; - &quot; &amp; Err.Description</TT>
<TT>Next ` Error</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>Comments</B></P>
<P>Hundreds of potential runtime errors can occur in a Visual Basic application,
and you are unlikely to be able to anticipate all of them. With experience and careful
coding, you can be prepared for the most common problems, but you should expect that
from time to time your application will encounter a situation for which you did not
explicitly plan. In this situation it is important for your general error-handling
code to offer as much information as possible to the user and to provide the opportunity
to correct the problem.</P>
<P>You might also find it useful to write errors to a log file. Examining an error
log provides you with information you can use to build more robust error-handling
procedures.</P>
<P>
<H2><A NAME="Heading20"></A>2.9 How do I...</H2>
<H3><A NAME="Access Excel worksheets by using Data Access Objects?"></A><B>Access
Excel worksheets by using Data Access Objects?</B></H3>
<P><B>Problem</B></P>
<P>I have Excel worksheets that my company created. I need to incorporate this data
into my own applications. I want to both display and manipulate the data from these
Excel worksheets. How do I work with these Excel files in my Visual Basic projects?</P>
<P><B>Technique</B></P>
<P>By using the Microsoft Jet engine, you can access Excel worksheets as if they
were actually Access databases. As with accessing other types of ISAM files with
the Jet engine, there are a few restrictions with accessing Excel worksheets:</P>

<UL>
	<LI>You cannot delete rows.
	<P>
	<LI>You cannot delete or modify cells that contain formulas.
	<P>
	<LI>You cannot create indexes.
	<P>
	<LI>You cannot read encrypted Excel files, even when using the correct password (PWD
	parameter) in the Connect string.
</UL>

<P>You can add records to a worksheet or edit standard cells (those without formulas).</P>
<P>When opening an ISAM database with the OpenDatabase method, you must provide a
valid ISAM type. In addition to this, if you want to use the first row of the Excel
document as field names, you can specify a parameter HDR equal to Yes. (HDR stands
for header.) If you set HDR to No, the first row of the Excel worksheet is included
as a record in the recordset, as in this example:</P>


<BLOCKQUOTE>
	<PRE>Set db = DBEngine.Workspaces(0).OpenDatabase(&quot;C:\VB6DBHT\&quot; &amp; _
                                  &quot;CHAPTER02\HowTo09\WidgetOrders.XLS&quot;, _
                                  False, False, &quot;Excel 8.0; HDR=NO;&quot;)</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>Notice that when accessing Excel worksheets, unlike with other ISAM formats, you
must specify the filename in the OpenDatabase method.</P>
<P>When opening a recordset from an Excel ISAM, you must specify the sheet name as
the recordset name, followed by a dollar sign ($), as in this example:</P>


<BLOCKQUOTE>
	<PRE>WorkSheetName = &quot;Sheet1&quot;
Set rs = db.OpenRecordset(WorkSheetName &amp; &quot;$&quot;, dbOpenTable)</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>Here, rs is a recordset variable.</P>
<P><B>Steps</B></P>
<P>Open and run the ExcelDAO project. You should see a form that looks like the one
shown in Figure 2.10. This application enables you to view a Microsoft Excel worksheet
file in a ListView control. If you click the Add or Edit buttons, the form expands
so that you can edit the contents. Clicking OK or Cancel when editing a record either
saves or discards your changes, respectively. By clicking the View in Excel button,
you can view the worksheet in Microsoft Excel (assuming that you have Microsoft Excel;
it is not included on the distribution CD-ROM with this book). If you make changes
in Excel and click the Refresh button on the form, the ListView control repopulates
with the updates.</P>
<P><A HREF="javascript:popUp('02fig10.gif')"><B>Figure 2.10.</B></A><I> The ExcelDAO
project.</I></P>

<DL>
	<DT><I></I></DT>
	<DD><B>1. </B>If you have not already installed the Excel IISAM, reinstall Visual
	Basic with the Custom Setup option, and specify the Excel IISAM in setup.
	<P>
	<DT></DT>
	<DD><B>2. </B>Create a new project and call it ExcelDAO.
	<P>
	<DT></DT>
	<DD><B>3. </B>Go to the Project|Components menu item in Visual Basic, and select
	Microsoft Windows Common Controls 6.0 from the list. This selection enables you to
	use the ListView common control that comes with Windows 95.
	<P>
	<DT></DT>
	<DD><B>4. </B>Add the appropriate controls so that the form looks like that shown
	in Figure 2.11.
	<P>
	<DT></DT>
	<DD><B>5. </B>Edit the objects and properties of Form1, as shown in Table 2.11, and
	then save it as frmWidgetOrders.
	<P>
</DL>

<P><A HREF="javascript:popUp('02fig11.gif')"><B>Figure 2.11.</B></A><I> The ExcelDAO
form in design mode.</I></P>


<BLOCKQUOTE>
	<H4>Table 2.11. Objects and properties for the Widget Orders project.</H4>
	<P>
	<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>OBJECT</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Property</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Setting</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Form</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">frmWidgetOrders</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Widget Orders</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Height</TD>
		<TD ALIGN="LEFT">3390</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">List view</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lstvWidgetOrders</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">View</TD>
		<TD ALIGN="LEFT">3 `vwReport</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdAdd</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Add</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdEdit</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Edit</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdView</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;View in Excel</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdRefresh</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Refresh</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdClose</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Close</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Cancel</TD>
		<TD ALIGN="LEFT">True</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Default</TD>
		<TD ALIGN="LEFT">True</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdOk</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Ok</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Command button</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">cmdCancel</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">&amp;Cancel</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Text box</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txtOrderNum</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Text box</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txtProductID</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Text box</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txtProductDesc</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Text box</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txtQuantity</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Text box</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">txtUnitPrice</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblOrderNum</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Order Num</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblProductID</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Product ID</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblProductDesc</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Product Description</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblQuantity</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Quantity</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Label</TD>
		<TD ALIGN="LEFT">Name</TD>
		<TD ALIGN="LEFT">lblUnitPrice</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"></TD>
		<TD ALIGN="LEFT">Caption</TD>
		<TD ALIGN="LEFT">Unit Price</TD>
	</TR>
	</TABLE>
</P>

</BLOCKQUOTE>


<DL>
	<DT></DT>
	<DD><B>6. </B>Enter the following code in the declarations section of your project.
	The variables and constants included here are form level and can be accessed by any
	code within this form. The integer, m_nState, holds the value of one of the two constants
	defined. This variable states whether the user has selected to add a new record or
	edit the current one. The m_oSelItem object variable of type ComctlLib.ListItem is
	an object that holds the value of a selected item in the list view. The last two
	variables hold the path, filename, and worksheet name of the Excel file to be used
	in this project.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Option Explicit
<TT>` form-level variables used to hold the database and recordset</TT>
<TT>Private db As Database</TT>
<TT>Private rs As Recordset</TT>
<TT>` form-level constant values used to indicate the current state</TT>
<TT>Private Const ADD_RECORD = 0</TT>
<TT>Private Const EDIT_RECORD = 1</TT>
<TT>` form-level variables used to save the current state, and </TT>
<TT>` selected list item</TT>
<TT>Private m_nState As Integer</TT>
<TT>Private m_oSelItem As ComctlLib.ListItem</TT>
<TT>` form-level variables used to store the file path and sheet name</TT>
<TT>` of the Excel file used in the app</TT>
<TT>Private m_sFilePath As String</TT>
<TT>Private m_sSheetName As String</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>7. </B>Add the following code to the Form_Activate event to get the path and
	filename of the Excel XLS file to be used. This information is stored in the form-level
	variable m_sFilePath. The worksheet name is stored in the m_sSheetName form-level
	variable. Finally, the PopulateListView routine is called. The file is opened and
	read here.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub Form_Activate()
<TT>    ` allow app to paint screen</TT>
<TT>    DoEvents</TT>
<TT>    ` get paths and names of files used in app</TT>
<TT>    m_sFilePath = DataPath &amp; &quot;\Chapter02\WidgetOrders.xls&quot;</TT>
<TT>    m_sSheetName = &quot;Sheet1$&quot;</TT>
<TT>    ` populate the list view control</TT>
<TT>    PopulateListView</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>8. </B>Add the following code to clear the text boxes and display the lower
	portion of the form for editing, or in this case, adding a new record. The last line
	of code sets the m_nState variable to ADD_RECORD, indicating that the user is adding
	a new record.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdAdd_Click()
<TT>    ` clear all the text boxes</TT>
<TT>    txtOrderNum = &quot;&quot;</TT>
<TT>    txtProductID = &quot;&quot;</TT>
<TT>    txtProductDesc = &quot;&quot;</TT>
<TT>    txtQuantity = &quot;&quot;</TT>
<TT>    txtUnitPrice = &quot;&quot;</TT>
<TT>    ` show the bottom of the form and set the state to add so we </TT>
<TT>    ` know how to save the record later</TT>
<TT>    ShowBottomForm</TT>
<TT>    m_nState = ADD_RECORD</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>9. </B>The cmdEdit_Click event is used when the user wants to edit the current
	record. The database will already be open from the PopulateListView routine. This
	event walks through each record in the recordset until the selected item's order
	number matches the record's order number. After the record is found, the text boxes
	on the lower portion of the form are populated with the values in the corresponding
	fields. The Total Price field is left out because we will calculate it ourselves
	from the given information. After the text boxes are populated, the form is lengthened
	by the call to ShowBottomForm, and the m_nState variable is set to EDIT_RECORD, indicating
	that the user has chosen to edit the current record.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdEdit_Click()
<TT>    ` we cannot use indexes with Excel files, so we must </TT>
<TT>    ` transverse the recordset until the record matches the </TT>
<TT>    ` selected item, then populate the text boxes with the records </TT>
<TT>    ` values</TT>
<TT>    With rs</TT>
<TT>        .MoveFirst</TT>
<TT>        While (.Fields(&quot;Order Number&quot;) &lt;&gt; m_oSelItem.Text)</TT>
<TT>            .MoveNext</TT>
<TT>        Wend</TT>
<TT>        txtOrderNum = .Fields(&quot;Order Number&quot;)</TT>
<TT>        txtProductID = .Fields(&quot;Product ID&quot;)</TT>
<TT>        txtProductDesc = .Fields(&quot;Product Description&quot;)</TT>
<TT>        txtQuantity = .Fields(&quot;Quantity&quot;)</TT>
<TT>        txtUnitPrice = .Fields(&quot;Unit Price&quot;)</TT>
<TT>    End With</TT>
<TT>    ` show the bottom of the form and set the state to editing so </TT>
<TT>    ` we know how to save the record later</TT>
<TT>    ShowBottomForm</TT>
<TT>    m_nState = EDIT_RECORD</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>10. </B>With the cmdView command button, the user can view the worksheet used
	in this project in Excel. To enable the user to view the file in Excel, the database
	must be closed first. This is done by setting the rs and db objects to nothing. The
	Shell command then calls Excel with the m_sFilePath variable, which holds the path
	and filename of the Excel worksheet. The ExcelPath function is included in the ReadINIFile
	module installed from the distribution CD-ROM.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdView_Click()
<TT>    ` set the recordset and database to nothing because Excel will </TT>
<TT>    ` not be able to successfully open the file if not</TT>
<TT>    Set rs = Nothing</TT>
<TT>    Set db = Nothing</TT>
<TT>    ` open Excel with the file</TT>
<TT>    Shell ExcelPath &amp; &quot; &quot;&quot;&quot; &amp; m_sFilePath &amp; &quot;&quot;&quot;&quot;, vbNormalFocus</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>11. </B>If the user edits the worksheet in Excel while the Widget Orders project
	is open, the changes will not be apparent in the application. Use the Refresh button
	to repopulate the information from the worksheet. Enter the code for cmdRefresh_Click:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdRefresh_Click()
<TT>    ` force a repopulation of the list view (use when the user has </TT>
<TT>    ` made changes in Excel to the file)</TT>
<TT>    PopulateListView</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>12. </B>Now enter the following code for the Close button and the Form_Unload
	event to successfully end the application:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdClose_Click()
<TT>    ` always use Unload Me instead of End</TT>
<TT>    Unload Me</TT>
<TT>End Sub</TT>
<TT>Private Sub Form_Unload(Cancel As Integer)</TT>
<TT>    ` it is good practice to set all objects to nothing</TT>
<TT>    Set m_oSelItem = Nothing</TT>
<TT>    ` this is equivalent to closing the recordset and the database</TT>
<TT>    Set db = Nothing</TT>
<TT>    Set rs = Nothing</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>13. </B>The OK button is used to save the information after a user has edited
	the current record or added a new one. The event can determine the proper recordset
	method to use from the m_nState variable, either AddNew or Edit. The information
	for each field is saved, and the Total Price field is calculated from the Unit Price
	and the Quantity. After the save, the list view is repopulated, and the bottom of
	the form is hidden from the user. The code for the button is as follows:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub cmdOk_Click()
<TT>    ` edit or add new is confirmed, save the values of the text </TT>
<TT>    ` boxes this would be a good place to code validation for each </TT>
<TT>    ` field</TT>
<TT>    With rs</TT>
<TT>        If (m_nState = ADD_RECORD) Then</TT>
<TT>            .AddNew</TT>
<TT>        Else</TT>
<TT>            .Edit</TT>
<TT>        End If</TT>
<TT>        .Fields(&quot;Order Number&quot;) = txtOrderNum</TT>
<TT>        .Fields(&quot;Product ID&quot;) = txtProductID</TT>
<TT>        .Fields(&quot;Product Description&quot;) = txtProductDesc</TT>
<TT>        .Fields(&quot;Quantity&quot;) = txtQuantity</TT>
<TT>        .Fields(&quot;Unit Price&quot;) = txtUnitPrice</TT>
<TT>        .Fields(&quot;Total Price&quot;) = txtUnitPrice * txtQuantity</TT>
<TT>        .Update</TT>
<TT>    End With</TT>
<TT>    ` repopulate the listview with the changes; then hide the </TT>
<TT>    ` bottom of the form</TT>
<TT>    PopulateListView</TT>
<TT>    HideBottomForm</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>14. </B>The cmdCancel_Click event simply hides the bottom half of the form
	so that the user cannot edit the record. Because the recordset has not been set to
	AddNew or Edit yet, we need do nothing further.
	<P>
</DL>



<BLOCKQUOTE>
	<PRE><TT>Private Sub cmdCancel_Click()</TT>
    ` edit or add new was canceled, hide the bottom of the form
    HideBottomForm
End Sub</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>15. </B>The following routines show the bottom of the form, hide the bottom
	of the form, and set the Enabled property of all input controls but the ListView
	to the appropriate state:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub ShowBottomForm()
<TT>    ` lengthen the height of the form and enable the proper </TT>
<TT>    ` controls</TT>
<TT>    Me.Height = 4350</TT>
<TT>    SetObjects False</TT>
<TT>End Sub</TT>
<TT>Private Sub HideBottomForm()</TT>
<TT>    ` shorten the height of the form and enable the proper </TT>
<TT>    ` controls</TT>
<TT>    Me.Height = 3390</TT>
<TT>    SetObjects True</TT>
<TT>End Sub</TT>
<TT>Private Sub SetObjects(StateIn As Boolean)</TT>
<TT>    ` set Enabled property for controls on top of form</TT>
<TT>    cmdAdd.Enabled = StateIn</TT>
<TT>    cmdEdit.Enabled = StateIn</TT>
<TT>    cmdRefresh.Enabled = StateIn</TT>
<TT>    cmdView.Enabled = StateIn</TT>
<TT>    cmdClose.Enabled = StateIn</TT>
<TT>    ` set Enabled property for controls on bottom of form</TT>
<TT>    txtOrderNum.Enabled = Not StateIn</TT>
<TT>    txtProductID.Enabled = Not StateIn</TT>
<TT>    txtProductDesc.Enabled = Not StateIn</TT>
<TT>    txtQuantity.Enabled = Not StateIn</TT>
<TT>    txtUnitPrice.Enabled = Not StateIn</TT>
<TT>    cmdOk.Enabled = Not StateIn</TT>
<TT>    cmdCancel.Enabled = Not StateIn</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>

<DL>
	<DT><TT></TT></DT>
	<DD><B>16. </B>The PopulateListView routine is the core of this project because it
	opens the database and sets the worksheet to a recordset. This routine also reads
	the database TableDefs collection to define the column headers for the list view,
	as well as populate the entire list view with the recordset. This first part of the
	routine adds a column for each field in the TableDefs(m_sSheetName).Fields collection.
	The second part of the routine steps through each record in the recordset and adds
	a list item for each record. Enter the code for the PopulateListView routine:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Private Sub PopulateListView()
<TT>    Dim oField As Field</TT>
<TT>    Dim nFieldCount As Integer</TT>
<TT>    Dim nFieldAlign As Integer</TT>
<TT>    Dim nFieldWidth As Single</TT>
<TT>    Dim oRecItem As ListItem</TT>
<TT>    Dim sValFormat As String</TT>
<TT>    ` this might take a noticeable amount of time, so before we do </TT>
<TT>    ` anything change the mouse pointer to an hourglass and then </TT>
<TT>    ` hide the bottom of the form</TT>
<TT>    Screen.MousePointer = vbHourglass</TT>
<TT>    HideBottomForm</TT>
<TT>    ` open the database (this might already be open; however, if </TT>
<TT>    ` the user has just started the app or selected the `View in </TT>
<TT>    ` Excel' button, then the database and recordset would be set </TT>
<TT>    ` to nothing</TT>
<TT>    Set db = OpenDatabase(m_sFilePath, False, False, _</TT>
<TT>        &quot;Excel 8.0;HDR=YES;&quot;)</TT>
<TT>    Set rs = db.OpenRecordset(m_sSheetName)</TT>
<TT>    With lstvWidgetOrders</TT>
<TT>        ` clear the list view box in case this is a refresh of the </TT>
<TT>        ` records</TT>
<TT>        .ListItems.Clear</TT>
<TT>        .ColumnHeaders.Clear</TT>
<TT>        ` using the For Each statement as compared to the For To </TT>
<TT>        ` statement is technically faster, as well as being </TT>
<TT>        ` easier to understand and use</TT>
<TT>        For Each oField In db.TableDefs(m_sSheetName).Fields</TT>
<TT>            ` align currency fields to the right, all others to </TT>
<TT>            ` the left</TT>
<TT>            nFieldAlign = IIf((oField.Type = dbCurrency), _</TT>
<TT>                              vbRightJustify, vbLeftJustify)</TT>
<TT>            ` our product description field is text, and the </TT>
<TT>            ` values in this field are generally longer than their </TT>
<TT>            ` field name, so increase the width of the column</TT>
<TT>            nFieldWidth = TextWidth(oField.Name) _</TT>
<TT>                         + IIf(oField.Type = dbText, 500, 0)</TT>
<TT>            ` add the column with the correct settings</TT>
<TT>            .ColumnHeaders.Add , , oField.Name, _</TT>
<TT>                                   nFieldWidth, _</TT>
<TT>                                   nFieldAlign</TT>
<TT>        Next oField</TT>
<TT>    End With</TT>
<TT>    ` add the records</TT>
<TT>    With rs</TT>
<TT>        .MoveFirst</TT>
<TT>        While (Not .EOF)</TT>
<TT>            ` set the new list item with the first field in the </TT>
<TT>            ` record</TT>
<TT>            Set oRecItem = lstvWidgetOrders.ListItems.Add(, , _</TT>
<TT>                CStr(.Fields(0)))</TT>
<TT>            ` now add the rest of the fields as subitems of the </TT>
<TT>            ` list item</TT>
<TT>            For nFieldCount = 1 To .Fields.Count - 1</TT>
<TT>                ` set a currency format for fields that are </TT>
<TT>                ` dbCurrency type</TT>
<TT>                sValFormat = IIf(.Fields(nFieldCount).Type = </TT>
<TT>                             dbCurrency, _</TT>
<TT>                                  &quot;$#,##0.00&quot;, _</TT>
<TT>                                  &quot;&quot;)</TT>
<TT>                ` set the subitem</TT>
<TT>                oRecItem.SubItems(nFieldCount) = _</TT>
<TT>                            Format$(&quot;&quot; &amp; .Fields(nFieldCount), _</TT>
<TT>                            sValFormat)</TT>
<TT>            Next nFieldCount</TT>
<TT>            .MoveNext</TT>
<TT>        Wend</TT>
<TT>    End With</TT>
<TT>    ` by setting the last record item to the selected record item </TT>
<TT>    ` form variable, we can assure ourselves that a record </TT>
<TT>    ` is selected for editing later</TT>
<TT>    Set m_oSelItem = oRecItem</TT>
<TT>    ` remember to set object variables to nothing when you are </TT>
<TT>    ` done</TT>
<TT>    Set oRecItem = Nothing</TT>
<TT>    Set oRecItem = Nothing</TT>
<TT>    Screen.MousePointer = vbDefault</TT>
<TT>End Sub</TT></PRE>

</BLOCKQUOTE>

<PRE><TT></TT></PRE>
<P><B>How It Works</B></P>
<P>In this project, an Excel worksheet file is opened and used to create a recordset
object to populate a ListView control. The code for accessing the recordset is the
same as that of accessing Microsoft Access databases, using AddNew and Edit to alter
the underlying ISAM data file. However, Excel worksheet rows cannot be deleted; therefore,
the Delete method of a recordset is unavailable.</P>
<P>In the PopulateListView routine, the project uses the TableDef object of the database
object to access the table definition of the Excel worksheet. Within this object,
there is a collection of fields through which the project loops, adding a column
header for each, using the fields' Name, Width, and Align properties.</P>
<P>After the column header collection of the list view is populated with the field
names in the Excel worksheet, the ListView control is populated with the records.
Accessing these records is the same as accessing other Jet database records. A list
item is set for each record with the first field of the record. After this, the subitems
of the list item are populated with the remaining fields in the current record.</P>
<P>This application also uses a trick to gain more space when necessary. The form
is elongated when either the Add button or the Edit button is clicked, allowing room
for a record editing area. After the record is saved or canceled, the form resumes
its normal size.</P>
<P>Another feature of this project is that the user can view the worksheet in Excel
by using the Shell method to start another application. By using this option, the
user can load a worksheet, edit its changes, and then switch to Excel to see the
results. Even if the user changes the worksheet within Excel while the project is
still running (as long as the file is saved and the user clicks the Refresh button),
the ListView control will be repopulated with the correct, up-to-date information.</P>
<P><B>Comments</B></P>
<P>It is possible to open ranges of an Excel worksheet using the Microsoft Jet Engine.
To do this, replace the worksheet name in the OpenRecordset method with the range
of cells you want returned, as in this example:</P>


<BLOCKQUOTE>
	<PRE>Set rs = db.OpenRecordset(<I>&quot;B1:H12&quot;</I>)</PRE>

</BLOCKQUOTE>

<PRE></PRE>
<P>In this example, &quot;<I>B1:H12</I>&quot; is the range on which you want to create
a recordset, from the specified Excel worksheet.</P>
<CENTER>
<P>
<HR>
<A HREF="ch01.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch01/ch01.htm"><IMG SRC="previous.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch03.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/ch03/ch03.htm"><IMG
SRC="next.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index-21.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/index.htm"><IMG SRC="contents.gif" tppabs="http://pbs.mcp.com/ebooks/1571691529/button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> </P>

<P>&copy; <A HREF="copy.htm" tppabs="http://pbs.mcp.com/ebooks/1571691529/copy.htm">Copyright</A>, Macmillan Computer Publishing. All
rights reserved.
</CENTER>

</BODY>

</HTML>
