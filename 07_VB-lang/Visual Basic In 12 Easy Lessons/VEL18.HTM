<HTML>

<HEAD>

<TITLE>Visual Basic in 12 Easy Lessons vel18.htm </TITLE>

<LINK REL="ToC" HREF="index.htm">

<LINK REL="Index" HREF="htindex.htm">

<LINK REL="Next" HREF="velp09.htm">

<LINK REL="Previous" HREF="vel17.htm"></HEAD>

<BODY BGCOLOR="#FFFFFF" 
TEXT="#000000" LINK="#0000FF" VLINK="#800080">

<A NAME="I0"></A>

<H2>Visual Basic in 12 Easy Lessons vel18.htm</H2>

<P ALIGN=LEFT>

<A HREF="vel17.htm" TARGET="_self"><IMG SRC="purprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A 
HREF="index.htm" TARGET="_self"><IMG SRC="purtoc.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="velp09.htm" TARGET="_self"><IMG SRC="purnext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>


<HR ALIGN=CENTER>

<P>

<UL>

<UL>

<UL>

<LI>

<A HREF="#E68E132" >What You'll Learn</A>

<LI>

<A HREF="#E68E133" >Disk File Background</A>

<LI>

<A 
HREF="#E68E134" >Opening Files</A>

<LI>

<A HREF="#E68E135" >Clean Up with Close</A>

<LI>

<A HREF="#E68E136" >Writing to Files With Write</A>

<LI>

<A HREF="#E68E137" >Inputting from Files with Input#</A>

<LI>

<A HREF="#E68E138" >Line Input# Really 
Makes it Easy</A>

<LI>

<A HREF="#E68E139" >Homework</A>

<UL>

<LI>

<A HREF="#E69E122" >General Knowledge</A>

<LI>

<A HREF="#E69E123" >What's the Output?</A>

<LI>

<A HREF="#E69E124" >Find the Bug</A>

<LI>

<A HREF="#E69E125" >Write Code That...</A>


<LI>

<A HREF="#E69E126" >Extra Credit</A></UL></UL></UL></UL>

<HR ALIGN=CENTER>

<A NAME="E66E26"></A>

<H1 ALIGN=CENTER>

<CENTER>

<FONT SIZE=6 COLOR="#FF0000"><B>Lesson 9, Unit 18</B></FONT></CENTER></H1>

<BR>

<A NAME="E67E29"></A>

<H2 
ALIGN=CENTER>

<CENTER>

<FONT SIZE=6 COLOR="#FF0000"><B>Simple File I/O</B></FONT></CENTER></H2>

<BR>

<BR>

<A NAME="E68E132"></A>

<H3 ALIGN=CENTER>

<CENTER>

<FONT SIZE=5 COLOR="#FF0000"><B>What You'll Learn</B></FONT></CENTER></H3>

<BR>

<UL>


<LI>Creating the disk file background

<BR>

<BR>

<LI>Opening files

<BR>

<BR>

<LI>Cleaning up with Close

<BR>

<BR>

<LI>Writing to files with Write

<BR>

<BR>

<LI>Inputting from files with Input#

<BR>

<BR>

<LI>Making it really easy with Line 
Input#

<BR>

<BR>

</UL>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><I>Definition: I/O</I> means input and output.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>This lesson explains how you can use Visual Basic code to 
manage disk file I/O. If you've collected data from the user and stored that data in variables and arrays, you can save the data to the disk for later retrieval. Also, you can access disk files 
from within Visual Basic for product inventory codes, 
amounts, customer balances, and whatever else your program needs from the long-term data file storage.

<BR>

<P>As you master Visual Basic and upgrade to other Visual Basic products, you'll add additional controls to your Toolbox window. There are several 
database access controls that read and write the data you've put in databases using products such as 
Microsoft Access and Paradox. Even though these controls provide more power and ease than you can get by programming alone, you'll still need the 
fundamentals of disk access. This unit explains a little on the background of disk access and teaches some of 
the most important disk commands and functions that you need to work with data files.

<BR>

<BR>

<A NAME="E68E133"></A>

<H3 ALIGN=CENTER>


<CENTER>

<FONT SIZE=5 COLOR="#FF0000"><B>Disk File Background</B></FONT></CENTER></H3>

<BR>

<P><FONT COLOR="#FF8000"><B><I>Concept: </I></B></FONT>A file is a collection of related data as well as programs that you buy and write, and documents from your 
word processor. Generally, you'll use Visual Basic to access data and text files stored on the 
disk.

<BR>

<P>There are all kinds of files on your computer's disks. Every file is stored under a unique filename to its directory and disk drive. Therefore, 
there can't be two or more files with the same filename unless the files reside in different directories or 
on different disks.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><I>Definition: </I>A <I>data file</I> holds data on the 
disk.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>This unit is concerned with data files. Data files can take on all kinds of formats. Generally, newcomers to Visual Basic should stick with data files that are textual in nature. Text 
files are readable by virtually any kind of program, and virtually 
any program can produce text files. Sometimes, text files are called ASCII files because text files consist of strings of ASCII characters.

<BR>

<P>Before Visual Basic can access a file, 
you or the user will have to direct Visual Basic to the exact location on the exact disk where the file is stored. If your user is selecting a file, you'll want to use the file selection frame described in the 
previous unit to give the user the ability to 
change drives, directories, and filenames easily. When your program accesses a file that the user doesn't know about, your program will have to supply the drive, directory, and filename.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>


<NOTE><B>Note: </B>The project at the end of this lesson contains an application that combines the file dialog frame that you mastered in the previous unit with the file I/O commands and functions described here to build a complete file access and display 

program.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P><FONT COLOR="#FF8000"><B><I>Review: </I></B></FONT>This unit teaches you how to access text data files stored on the disk. You'll need to supply Visual Basic with the filename, 
directory, and disk drive of any file with which Visual Basic works.

<BR>

<BR>

<A NAME="E68E134"></A>

<H3 ALIGN=CENTER>

<CENTER>

<FONT SIZE=5 COLOR="#FF0000"><B>Opening Files</B></FONT></CENTER></H3>

<BR>

<P><FONT COLOR="#FF8000"><B><I>Concept: 
</I></B></FONT>The Open statement opens files. Before Visual Basic can access a data file, Visual Basic has to open the file first. Think of the Open statement as doing for Visual Basic what an open file drawer does 
for you when you want to retrieve a 
file from a filing cabinet. The Open statement locates the file and makes the file available to Visual Basic.

<BR>

<P>The Open statement performs various tasks such as locating a file, making sure that the file exists if needed, and creating some 
directory entries that manage the file while the file is open. A Visual Basic program always has to open a file, using Open, 
before the program can read or write data to the file.

<BR>

<P>Here is the format of Open:

<BR>

<BR>

<PRE>

<FONT 
COLOR="#000080">Open FileNameStr [For mode] As [#]FileNumber</FONT></PRE>

<P>The <I>FileNameStr</I> must be a string value or variable that holds a filename. The filename must reside on the default drive or directory unless you specify the full path to 
the file. Generally, you won't have easy access to the user's current Windows 
default drive and directory, so you'll almost always specify the full drive and pathname inside the <I>FileNameStr</I> portion of the Open statement.

<BR>

<P>The <I>mode</I> 
must be a named value from Table 18.1. There are additional <I>mode</I> values, but this book won't cover the more advanced or the esoteric <I>mode</I> values. The <I>mode</I> tells Visual Basic exactly what your program expects to do 
with the file once 
Visual Basic opens the file.

<BR>

<BR>

<P ALIGN=CENTER>

<CENTER>

<FONT COLOR="#000080"><B>Table 18.1. Possible </B><FONT COLOR="#FF8000"><B><I>mode</I></B></FONT><B> values for the </B><B>Open</B><B> statement.</B></FONT></CENTER>

<BR>



<TABLE  
BORDERCOLOR=#000040 BORDER=1 CELLSPACING=2 WIDTH="100%" CELLPADDING=2 >

<TR>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

<I>Mode</I>

</FONT>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

<I>Description</I></FONT>

<TR>

<TD 
VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

Append

</FONT>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

Tells Visual Basic that your program needs to write to the end of the file if the file already exists. If the file doesn't exist, 
Visual Basic creates the file so that your program can write data to the file.</FONT>

<TR>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

Input

</FONT>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

Tells Visual Basic that your program 
needs to read from the file. If the file doesn't exist, Visual Basic issues an error message. As long as you use a file selection frame properly, Visual Basic will never issue an error, because the file selection frame 
forces the user to select a file or 
cancel the selection operation.</FONT>

<TR>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

Output

</FONT>

<TD VALIGN=top  BGCOLOR=#80FFFF ><FONT COLOR=#000080>

Tells Visual Basic that your program needs to write to the file. If the file 
doesn't exist, Visual Basic creates the file. If the file does exist, Visual Basic first erases the existing file and creates a new one under the same name, thereby replacing the 
original one.</FONT>

</TABLE><P>The pound sign, #, is optional, although 
most Visual Basic programmers do specify the pound sign out of habit (some previous versions of the BASIC language required the pound sign). The <I>FileNumber</I> represents a number from 1 to 255 and 
associates the open file with that number. After you 
open a file successfully (assuming that there are no errors such as a disk drive door being left open), the rest of the program uses file I/O commands and functions to access the file. The file number 
stays with the file until you issue a Close command 
(see the next section) that releases the <I>FileNumber</I> and makes the number available to other files.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><B>Note: </B>As with all DOS and Windows file descriptions, you can specify the 
drive, directory, and filename using uppercase or lowercase characters.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>You can open more than one file simultaneously within a single program. Each command that accesses one of the files 
directs its activity towards a specific file using that file's <I>FileNumber</I>.

<BR>

<P>The following Open statement creates and opens a data file on the disk drive and associates the file to the file number 1:

<BR>

<BR>

<PRE>

<FONT 
COLOR="#000080">Open &quot;d:\data\myfile.dat&quot; For Output As #1</FONT></PRE>

<P>If you knew that the file already existed and you needed to add to the file, you could use the Append <I>mode</I> to add to the file after this Open statement:

<BR>


<BR>

<PRE>

<FONT COLOR="#000080">Open &quot;d:\data\myfile.dat&quot; For Append As #1</FONT></PRE>

<P>One Visual Basic program can have more than one file open at the same time. There is an advanced FILES option in your computer's CONFIG.SYS file that 
determines the maximum number of files that can be open at one time. If the #1 <I>FileNumber</I> was in 
use by another file that you opened earlier in the application, you could assign the open file to a different number like this:

<BR>

<BR>

<PRE>


<FONT COLOR="#000080">Open &quot;d:\data\myfile.dat&quot; For Append As #5</FONT></PRE>

<P>Any currently unused <I>FileNumber</I> works; you can't associate more than one file at a time to the same <I>FileNumber</I> value.

<BR>

<P>The following Open 
would open the same file for input in a different program:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Open &quot;d:\data\myfile.dat&quot; For Input As #2</FONT></PRE>

<P>Visual Basic supplies a helpful built-in function named FreeFile() that accepts no 
arguments. FreeFile() returns the next available file number value. For example, if you've used #1 and #2 for open files, the next value returned from FreeFile() will be 
3. FreeFile() is most helpful when you write general-purpose subroutine and function 
procedures that need to open files, and the procedures may be called from more than one place in an application. At each calling location, there is a different number of 
files open at the time. The procedure can store the value of the next available file 
number like this:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">fNum = FreeFile()</FONT></PRE>

<P>and use the variable fNum in subsequent Open, I/O, and Close statements. No matter how many files are open, the procedure will always use the next file number in 
line to open its file.

<BR>

<P><FONT COLOR="#FF8000"><B><I>Review: </I></B></FONT>The Open command associates files using file numbers with which the rest of the program will access the file. The three <I>mode</I> values determine how Visual Basic uses 
the file. If you want to write 
to a file, you can't use the Input mode, and if you want to read from a file, you can't use Output or Append.

<BR>

<BR>

<A NAME="E68E135"></A>

<H3 ALIGN=CENTER>

<CENTER>

<FONT SIZE=5 COLOR="#FF0000"><B>Clean Up with 
</B><B>Close</B></FONT></CENTER></H3>

<BR>

<P><FONT COLOR="#FF8000"><B><I>Concept: </I></B></FONT>The Close statement performs the opposite job from Open. Close closes the file by writing any final data to the file, releasing the file to other 
applications, and giving the file's number back to your 
application in case you want to use that number in a subsequent Open statement.

<BR>

<P>Eventually, every program that opens files should close those files. The Close statement closes files. These 
are the two formats of Close:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Close [[#]<I>FileNumber</I>] [, ..., [#]<I>FileNumber</I>]</FONT></PRE>

<P>and

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Close</FONT></PRE>

<P>The first format closes one or more 
open files, specifying the files by their open file numbers. The pound sign is optional in front of any of the file numbers. The second form of Close closes all files that are currently open. Close closes any open 
file no matter what mode you used to open 
the file.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><B>Tip: </B>If you create a file by opening the file with the Output <I>mode</I>, and then close the file, you can reopen the same file in the same program in the Input <I>mode</I> 
to read the file.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>The following statement closes the two open files that were opened and attached to the 1 and 3 file numbers:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Close 1, 3</FONT></PRE>


<P>The following statement closes <I>all</I> files no matter how many are open:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Close ' Closes ALL files</FONT></PRE>

<P><FONT COLOR="#FF8000"><B><I>Review: </I></B></FONT>Use the Close statement to close all open 
files before your program ends. Closing files provides extra safety, so close any and all open files when you're through accessing those files. If a power 
failure occurs during your program's execution, your closed files will be safely stored on the disk, 
but any files that are open at the time of the power failure could lose data.

<BR>

<BR>

<A NAME="E68E136"></A>

<H3 ALIGN=CENTER>

<CENTER>

<FONT SIZE=5 COLOR="#FF0000"><B>Writing to Files With </B><B>Write</B></FONT></CENTER></H3>

<BR>

<P><FONT 
COLOR="#FF8000"><B><I>Concept: </I></B></FONT>The Write# command is perhaps the easier command to use for writing data to a file. Write# writes data of any data type to a file. Using corresponding input statements that you'll learn in the next 
section, 
you'll be able to read data that you sent to a file with the Write# command.

<BR>

<P>The Write# statement enables you to write data of any format to any disk file opened in the Output or Append mode. Write# writes strings, numbers, constants, variables, 
in any and all combinations to a disk file.

<BR>

<P>Here is the format of Write#:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Write #FileNumber [, ExpressionList]</FONT></PRE>

<P>The <I>FileNumber</I> must be a file number associated to a file opened with 
Output. If you don't specify variables or values to write, Write# writes a carriage return and line feed character (an ASCII 13 followed by an ASCII 10) to the file, putting a 
blank line in the file. If you specify more than one value in the 
<I>ExpressionList</I>, Visual Basic writes that data to the file using the following considerations:

<BR>

<UL>

<LI>Write# separates multiple items on the same line by adding commas between values

<BR>

<BR>

<LI>Write# always adds a carriage return and 
line feed character to the end of each line written.

<BR>

<BR>

<LI>Write# adds quotation marks around all strings in the file. The quotation marks make for easy reading of the strings later.

<BR>

<BR>

<LI>Write# write date and time values using the 
following format:

<BR>#yyyy-mm-dd hh:mm:ss#

<BR>

<BR>

<LI>Write# writes the value of #NULL# to the file if the data is null (a VarType of 1).

<BR>

<BR>

<LI>Write# writes nothing when the data value is empty (a VarType of 0), but does separate even 
empty values with commas if you write more than one value on a single line.

<BR>

<BR>

</UL>

<P>The code in Listing 18.1 writes a famous first century poem to a disk file named ODE.TXT. A command button named cmdWrite triggers the code's execution with 
its Click event when the user clicks the command button. The file appears on your C: drive's 
root directory.

<BR>

<P>

<FONT COLOR="#000080"><B>Listing 18.1. Writing four string values to a file named ODE.TXT.</B></FONT>

<BR>

<PRE>

<FONT 
COLOR="#000080">1: Sub cmdWrite_Click ()

2: ' Creates a text file and

3: ' writes a poem to the file

4: Open &quot;c:\ode.txt&quot; For Output As #1

5: 

6: ' Write the poem

7: Write #1, &quot;Visual Basic, Visual Basic,&quot;

8: Write #1, &quot;oh 
how I long to see...&quot;

9: Write #1, &quot;A working application that&quot;

10: Write #1, &quot;means so much to me.&quot;

11: 

12: ' Always close any open file

13: ' when done with the file

14: Close #1

15: End Sub</FONT></PRE>

<P>When Visual 
Basic closes the file in line 14, there will be a file in the user's root directory with the following contents:

<BR>

<PRE>

<FONT COLOR="#000080">&quot;Visual Basic, Visual Basic,&quot;

&quot;oh how I long to see...&quot;

&quot;A working application 
that&quot;

&quot;means so much to me.&quot;</FONT></PRE>

<P>Typically, quotation marks never appear when you assign or display string values. The quotation marks are usually for the programmer to indicate the start and end of string values used in a 
program. The only exception to the appearance of quotation 
marks is that Write# always adds the quotation marks around all string data, whether the data is variable or constant, that Write# outputs to a file.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR 
ALIGN=CENTER>

<BR>

<NOTE><I>Definition: Append</I> means to add to the end of something.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>If you open a file using the Append <I>mode</I>, the Write# statement will add to the end of the 
file. The program in Listing 18.2 writes a blank line and a second stanza to the poem stored in the ODE.TXT file.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><B>Warning: </B>Remember that if you write to a file that already exists 
using the Output <I>mode</I> value, Visual Basic will erase the original contents and replace the file with the subsequent writing.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>

<FONT COLOR="#000080"><B>Listing 18.2. Code that adds to 
the end of a data file using the </B><B>Write#</B><B> statement.</B></FONT>

<BR>

<PRE>

<FONT COLOR="#000080">1: Sub cmdAddIt_Click ()

2: ' Adds to a text file already created

3: ' by writing a second verse to the file

4: Open &quot;c:\ode.txt&quot; 
For Append As #1

5:

6: ' Add to the poem

7: Write #1, ' Writes one blank line

8: Write #1, &quot;Visual Basic, to you I sing&quot;

9: Write #1, &quot;the songs a programmer knows...&quot;

10: Write #1, &quot;Listen carefully when I choose Run,&quot;


11: Write #1, &quot;or we'll surely come to blows.&quot;

12:

13: Close #1

14:

15: End Sub</FONT></PRE>

<P>I'll give you a chance to get a handkerchief before looking at the newly expanded poem. Here is the result of the Append <I>mode</I> value if you 
were to display the contents of the ODE.TXT file after running this event procedure:

<BR>

<PRE>

<FONT COLOR="#000080">&quot;Visual Basic, Visual Basic,&quot;

&quot;oh how I long to see...&quot;

&quot;A working application that&quot;

&quot;means so 
much to me.&quot;

&quot;Visual Basic, to you I sing&quot;

&quot;the songs a programmer knows...&quot;

&quot;Listen carefully when I choose Run,&quot;

&quot;or we'll surely come to blows.&quot;</FONT></PRE>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>


<BR>

<NOTE><B>Tip: </B>You may write data to files from variables as well as from controls on the form. Wherever you've got data that needs to be written, Visual Basic's Write# command will write that data to a disk file that you've opened.</NOTE>

<BR>


<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P><FONT COLOR="#FF8000"><B><I>Stop and Type: </I></B></FONT>Listing 18.3 contains a subroutine procedure that accepts four arrays of four different data types and writes that array data to a disk file named 
VALUES.DAT. Notice how a simple For loop can be 
used to write a large amount of data to a data file. The fifth argument sent to the subroutine is assumed to contain the total number of elements defined for the arrays.

<BR>

<P><FONT 
COLOR="#FF8000"><B><I>Review: </I></B></FONT>The Write# statement provides one of the easiest file output commands inside the Visual Basic language. Write# separates multiple output values with commas and encloses all string data inside quotation 
marks.


<BR>

<P>

<FONT COLOR="#000080"><B>Listing 18.3. Code that writes arrays using the </B><B>Write#</B><B> statement.</B></FONT>

<BR>

<PRE>

<FONT COLOR="#000080">1: Sub WriteData (CNames() As String, CBalc() As Currency, CDate() As Variant, CRegion() As 
Integer)

2: ' Writes array data to a file

3: Dim ctr As Integer ' For loop control

4: ' Assumes that each array has the

5: ' same number of elements defined

6: Dim MaxSub As Integer

7: MaxSub = UBound(CNames) ' The maximum subscript

8: 

9: ' Write 
MaxSub lines to the file

10: ' with four values on each line

11: Open &quot;c:\mktg.dat&quot; For Output As #1

12: For ctr = 1 To MaxSub

13: Write #1, CNames(ctr), CBalc(ctr), CDate(ctr), CRegion(ctr)

14: Next ctr

15: Close #1

16:

17: End 
Sub</FONT></PRE>

<P><FONT COLOR="#FF8000"><B><I>Output: </I></B></FONT>Here are six sample lines from the MKTG.DAT file that the program in Listing 18.3 might write:

<BR>

<PRE>

<FONT COLOR="#000080">&quot;Adams, H&quot;, 123.41, #1997-11-18 11:34:21#, 
6

&quot;Enyart, B&quot;, 602.99, #21:40:01#, 4

&quot;Powers, W&quot;, 12.17, #1996-02-09#, 7

&quot;O'Rourke, P&quot;, 8.74, #1998-05-24 14:53:10#, 0

&quot;Grady, Q&quot;, 154.75, #1997-10-30 17:23:59#, 6

&quot;McConnell, I&quot;, 9502.32, #1996-07-12 
08:00:03#, 9</FONT></PRE>

<P><FONT COLOR="#FF8000"><B><I>Review: </I></B></FONT>Line 1 defines the subroutine procedure and accepts the four passed arrays. Each array is assumed to have the same number of defined subscripts. Although not all arrays passed 
to a procedure would 
necessarily have the same number of subscripts defined, these happen to do so. Line 6 and 7 defines and initializes a value that holds the maximum number of subscripts, so the subsequent For loop can write all of the array values to 
the file names 
MKTG.DAT.

<BR>

<P>The For loop in lines 12 to 14 step through the array elements, writing a line of four array values with each iteration. Visual Basic encloses the string array data with quotation marks and encloses the variant date and 
time data with pound signs.

<BR>

<P>The pound signs around the date and time variant values help Visual Basic when you subsequently read the data values back into variant variables. As you can see, the date may have a missing time or the time may have a 
missing date. Write# still writes 
as much of the date and time as is available within that variant value.

<BR>

<P>The Close statement on line 15 closes the file and releases the file number back to the program.

<BR>

<BR>

<A NAME="E68E137"></A>

<H3 
ALIGN=CENTER>

<CENTER>

<FONT SIZE=5 COLOR="#FF0000"><B>Inputting from Files with </B><B>Input#</B></FONT></CENTER></H3>

<BR>

<P><FONT COLOR="#FF8000"><B><I>Concept: </I></B></FONT>The Input# statement reads data from files and stores the file data in 
your program's variables and controls. Input# is the mirror-image statement to the Write# statement. Use Input# to read any data 
that you send to a file with Write#.

<BR>

<P>The Input# statement reads data into a list of variables or controls. Here is 
the format of Input#:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Input #FileNumber [, ExpressionList]</FONT></PRE>

<P>Again, the bottom line to using Input# is that Input# is the mirror image of the Write# statement that produced the file data. When you 
write a program that must use data from a data file, locate the program's Write# statement that originally created 
the data file, and use that same format for the Input# statement.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><B>Tip: 
</B>Be sure to open all files that you'll read from using the Input file mode value, or Visual Basic will display an error message.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>Listing 18.4 reads and displays in a scrolling list box the 
poem stored in the ODE.TXT file that was created in earlier listings.

<BR>

<P>

<FONT COLOR="#000080"><B>Listing 18.4. Code that reads a poem using the </B><B>Input#</B><B> statement.</B></FONT>

<BR>

<PRE>

<FONT COLOR="#000080">1: Sub cmdList_Click ()


2: ' Reads a poem from a text file and

3: ' adds the poem, one line at a time,

4: ' to the list box

5: Dim ctr As Integer ' For loop control

6: Dim PoemLine As String ' Holds each poem line

7: Open &quot;c:\ode.txt&quot; For Input As #1

8: 

9: ' 
Read the poem

10: For ctr = 1 To 9

11: Input #1, PoemLine

12: lstPoem.AddItem PoemLine

13: Next ctr

14: 

15: ' Always close any open file

16: ' when done with the file

17: Close #1

18:

19: End Sub</FONT></PRE>

<P>Figure 18.1 shows the list box 
that would appear as a result of Listing 18.4's execution.

<BR>

<P><B> <A HREF="18vel01.gif">Figure 18.1. The contents of a file shown in a list box.</A></B>

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><I>Definition: </I>A 
<I>record</I> is a row in a file.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P>When reading data from a file, you can very easily cause an error by attempting to read more data than the file holds. Listing 18.4 assumed that there were 
only nine records in the poem file to read, and that happened to be the case. For data files that 
hold data such as customer balances and employee pay values, however, the number of records varies because you'll add and remove records as transactions take 
place.

<BR>

<P>The Eof() function is Visual Basic's built-in <I>end of file</I> function that senses when an input reaches the end of file. Here is the format of the Eof() function:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Eof(FileNumber)</FONT></PRE>


<P>Eof() returns True if the most recent reading of the input file just reached the end of the file and returns False if the input file still has data left to be read. Most data input programs loop until the Eof() condition is true. Perhaps the best way to 

use Eof() is with a Do Until-Loop that follows this general format:

<BR>

<PRE>

<FONT COLOR="#000080">Input #1, VariableList ' Read the first record

Do Until (Eof(FileNumer) = True)

 ' Process the record just read

 Input #1, VariableList ' Get more 
data

Loop</FONT></PRE>

<P>If there are none, one, or four hundred records in the file, this format of Do Until will keep reading, but will stop as soon as the end of file is reached. Many programmers often increment an integer counter variable inside the 
loop to count the number 
of records read. The counter is useful if you're reading the file's data into arrays.

<BR>

<BLOCKQUOTE>

<BLOCKQUOTE>

<HR ALIGN=CENTER>

<BR>

<NOTE><B>Note: </B>If you read file data into arrays, be sure to dimension more than 
enough array elements to hold the maximum number of records expected.</NOTE>

<BR>

<HR ALIGN=CENTER>

</BLOCKQUOTE></BLOCKQUOTE>

<P><FONT COLOR="#FF8000"><B><I>Stop and Type: </I></B></FONT>Listing 18.5 reads the file written earlier using a series of 
Write# statements back in Listing 18.3. The body of the code isn't shown. The code is supposed to output the file's contents to a 
printed paper report. You won't master the reporting commands until Lesson 11, so comments were used in place of the actual 
reporting commands.

<BR>

<P><FONT COLOR="#FF8000"><B><I>Review: </I></B></FONT>As long as you output to files using Write#, you'll easily read that same data back again using Input#. Input# is the mirror-image command to Write#. The combination of Write# 
and Input# makes file I/O 
simpler than possible in most programming languages.

<BR>

<P>

<FONT COLOR="#000080"><B>Listing 18.5. Reading and reporting file data using </B><B>Input#</B><B>.</B></FONT>

<BR>

<PRE>

<FONT COLOR="#000080">1: Sub ReadData ()


2: ' Reads array data from a file and reports the data

3: ' Assume that 200 values were read

4: Static CNames(200) As String, CBalc(200) As Currency

5: Static CDate(200) As Variant, CRegion(200) As Integer

6: Dim NumVals As Integer ' Count of records


7: Dim ctr As Integer ' For loop control

8: 

9: NumVals = 1 ' Start the count

10: ' Reads the file records assuming

11: ' four values on each line

12: Open &quot;c:\mktg.dat&quot; For Input As #1

13: Input #1, CNames(NumVals), CBalc(NumVals), 
CDate(NumVals), CRegion(NumVals)

14: Do Until (Eof(1) = True)

15: NumVals = NumVals + 1 ' Increment counter

16: Input #1, CNames(NumVals), CBalc(NumVals), CDate(NumVals), CRegion(NumVals)

17: Loop

18:

19: ' When loop ends, NumVals holds one too many


20: NumVals = NumVals - 1

21: 

22: ' The following loop is for reporting the data

23: For ctr = 1 To NumVals

24: ' Code goes here that outputs the array

25: ' data to the printer

26: '

27: Next ctr

28: Close #1

29:

30: End Sub</FONT></PRE>


<P><FONT COLOR="#FF8000"><B><I>Analysis: </I></B></FONT>Lines 4 and 5 define four arrays that will hold the file's data. The arrays are defined to hold, at most, 200 values. There is no error checking to be sure that the reading doesn't read more than 200 

records, but an exercise at the end of the chapter gives you the chance to add this array-checking code.

<BR>

<P>Line 9 initializes NumVals to hold the count of file records. The count begins at 1 because the first array subscript that will hold incoming 
data is 1. (As with all programs in this book, this code ignores the 0 subscript that all arrays contain unless 
you specify Option Base 1.)

<BR>

<P>Line 12 opens the file for input and associates the file to the file number 1. The first input occurs on 
line 13. The input attempts to read the first record in the file that contains four values. Line 14's relational test for an end of file condition 
will immediately be true if the file is empty. Otherwise, the body of the loop executes. Line 15 increments 
the record count once more owing to line 16's input into the next set of array elements. The loop continues until the end of file is reached and 
line 14's relational test becomes false.

<BR>

<P>Line 20 must decrement the NumVals variable by 1 because 
the last attempt at reading the file will always produce an end-of-file condition. Therefore, the final Input# was unsuccessful and the record count can't contain that unsuccessful read.

<BR>

<P>After you read all the data into the arrays, you can work 
with the array data just as you normally work with array data. You can calculate statistics based on the data, display the array using list boxes and combo boxes, or print the data to paper.

<BR>

<BR>

<A NAME="E68E138"></A>

<H3 ALIGN=CENTER>

<CENTER>


<FONT SIZE=5 COLOR="#FF0000"><B>Line Input#</B><B> Really Makes it Easy</B></FONT></CENTER></H3>

<BR>

<P><FONT COLOR="#FF8000"><B><I>Concept: </I></B></FONT>The Line Input# command reads data from open data files. Unlike Input#, Line Input# reads each 
line of data in the file into a string variable. You don't have to specify separate variable names after a 
Line Input# because Line Input# requires a single string value. Line Input# reads data from any file whose lines end with a carriage return and line 
feed sequence. (Most files do.)

<BR>

<P>The Line Input# command is simple to use for reading entire records into a single variable. Whereas Input# reads each records values individually, Line Input# reads an entire record&#151;data, commas, quotation 
marks, and everything else&#151;into a 
string or variant variable or control.

<BR>

<P>Here is the format of Line Input#:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Line Input #FileNumber, VariableName</FONT></PRE>

<P>No matter how many record values 
appear in the file associated with file number 3, the following Line Input# statement reads an image of the record into the string variable named aRecord:

<BR>

<BR>

<PRE>

<FONT COLOR="#000080">Line Input #3, aRecord</FONT></PRE>

<P><FONT 
COLOR="#FF8000"><B><I>Review: </I></B></FONT>The Line Input# command reads records from data files into string or variant variables. The Input# command reads each record's individual data values into a single variable (or control). The Line Input# 
command 
reads entire records into string or variant variables. The project at the end of this lesson uses Line Input# to read an entire file using a <I>single</I> string variable.

<BR>

<BR>

<A NAME="E68E139"></A>

<H3 ALIGN=CENTER>

<CENTER>

<FONT SIZE=5 
COLOR="#FF0000"><B>Homework</B></FONT></CENTER></H3>

<BR>

<BR>

<A NAME="E69E122"></A>

<H4 ALIGN=CENTER>

<CENTER>

<FONT SIZE=4 COLOR="#FF0000"><B>General Knowledge</B></FONT></CENTER></H4>

<BR>

<OL>

<LI>What is a file?

<BR>

<BR>

<LI>What are the 
purposes of files?

<BR>

<BR>

<LI>True or false: Your computer system can contain more than one file with the same filename.

<BR>

<BR>

<LI>What statement prepares a file for use by a program?

<BR>

<BR>

<LI>What are the three modes possible in the 
Open statement?

<BR>

<BR>

<LI>What is the purpose of the file number?

<BR>

<BR>

<LI>If a file doesn't exist and you open the file for output, what does Visual Basic do?

<BR>

<BR>

<LI>If a file does exist and you open the file for output, what does 
Visual Basic do?

<BR>

<BR>

<LI>If a file doesn't exist and you open the file for appending, what does Visual Basic do?

<BR>

<BR>

<LI>If a file does exist and you open the file for appending, what does Visual Basic do?

<BR>

<BR>

<LI>If a file 
doesn't exist and you open the file for input, what does Visual Basic do?

<BR>

<BR>

<LI>What is the range for the Open statement's file number?

<BR>

<BR>

<LI>True or false: When opening a file, you must specify the filename using lowercase letters.


<BR>

<BR>

<LI>What CONFIG.SYS command limits the number of files that you can have open at one time?

<BR>

<BR>

<LI>Which function locates the next available file number?

<BR>

<BR>

<LI>Which statement cleans up a file after you're done with the 
file?

<BR>

<BR>

<LI>Why is the Close command recommended?

<BR>

<BR>

<LI>Which open files does the following statement close?

<BR>

<BR>

<LI>  Close

<BR>

<BR>

<LI>Which statement writes data to a file?

<BR>

<BR>

<LI>What character does Write# 
use to separate values in the output?

<BR>

<BR>

<LI>What character does Write# place around date and time values?

<BR>

<BR>

<LI>What character does Write# place around string values?

<BR>

<BR>

<LI>Which statement is the mirror-image input 
statement for Write#?

<BR>

<BR>

<LI>What is a <I>record</I>?

<BR>

<BR>

<LI>Which function tests for the end of file?

<BR>

<BR>

<LI>Which statement reads an entire record into a string or variant variable?

<BR>

<BR>

</OL>

<BR>

<A 
NAME="E69E123"></A>

<H4 ALIGN=CENTER>

<CENTER>

<FONT SIZE=4 COLOR="#FF0000"><B>What's the Output?</B></FONT></CENTER></H4>

<BR>

<OL>

<LI>What does the file record look like after the following Write# completes?

<BR>Write #1, &quot;Peach&quot;, 
34.54, 1, &quot;98&quot;

<BR>

<BR>

</OL>

<BR>

<A NAME="E69E124"></A>

<H4 ALIGN=CENTER>

<CENTER>

<FONT SIZE=4 COLOR="#FF0000"><B>Find the Bug</B></FONT></CENTER></H4>

<BR>

<OL>

<LI>Rusty the programmer wants to read an entire record into a string 
variable named MyRecord, but his attempt shown as follows doesn't work. Help Rusty fix the problem.

<BR>Input #1, MyRecord

<BR>

<BR>

</OL>

<BR>

<A NAME="E69E125"></A>

<H4 ALIGN=CENTER>

<CENTER>

<FONT SIZE=4 COLOR="#FF0000"><B>Write Code 
That...</B></FONT></CENTER></H4>

<BR>

<OL>

<LI>Write a Close command that closes an input file associated with file number 3 and an output file associated with file number 19.

<BR>

<BR>

<LI>Write the Open command needed to open a file named NAMES.DAT 
for append mode. Associate the file to file number 7.

<BR>

<BR>

<LI>Change Listing 18.5 to display a message box and exit the file-reading loop if the input data file contains more than 200 records. (The arrays holding the incoming data can't hold more 
than 200 values.)

<BR>

<BR>

</OL>

<BR>

<A NAME="E69E126"></A>

<H4 ALIGN=CENTER>

<CENTER>

<FONT SIZE=4 COLOR="#FF0000"><B>Extra Credit</B></FONT></CENTER></H4>

<BR>

<P>Write a subroutine procedure that writes four records of your four best 
friends' first names, ages, weights, and IQs (remember, these are your friends, so be gentle). Write a second procedure that reads that data into string variables one record at a 
time.

<BR>

<P ALIGN=LEFT>

<A HREF="vel17.htm" TARGET="_self"><IMG 
SRC="purprev.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Previous Page"></A>

<A HREF="#I0" TARGET="_self"><IMG SRC="purtop.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Page Top"></A>

<A HREF="index.htm" TARGET="_self"><IMG SRC="purtoc.gif" WIDTH = 32 
HEIGHT = 32 BORDER = 0 ALT="TOC"></A>

<A HREF="velp09.htm" TARGET="_self"><IMG SRC="purnext.gif" WIDTH = 32 HEIGHT = 32 BORDER = 0 ALT="Next Page"></A>


</BODY></HTML>







