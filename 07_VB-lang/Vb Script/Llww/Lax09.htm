<HTML>
<HEAD>
<TITLE>lax09.htm </TITLE>
<LINK REL="ToC" HREF="httoc.htm">
<LINK REL="Index" HREF="htindex.htm">
<LINK REL="Next" HREF="lax10.htm">
<LINK REL="Previous" HREF="lax08.htm"></HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080">
<A NAME="I0"></A><P ALIGN=CENTER>
<A HREF="lax08.htm" TARGET="_self"><IMG SRC="blanprev.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="Previous Page"></A>
<A HREF="httoc.htm" TARGET="_self"><IMG SRC="blantoc.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="TOC"></A>
<A HREF="lax10.htm" TARGET="_self"><IMG SRC="blannext.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="Next Page"></A>
<A HREF="http://www.mcp.com/sams/" TARGET="_self"><IMG SRC="blanhome.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="See Page"></A>
<HR ALIGN=CENTER>
<P>
<UL>
<UL>
<UL>
<UL>
<LI>
<A HREF="#E69E71" >Subroutines</A></UL>
<LI>
<A HREF="#E68E53" ><IMG SRC="task.gif">Declaring Custom Functions</A>
<LI>
<A HREF="#E68E54" ><IMG SRC="task.gif">Declaring Custom Procedures</A>
<LI>
<A HREF="#E68E55" ><IMG SRC="task.gif">Using the ActiveX Control Pad to Create Subroutines</A>
<LI>
<A HREF="#E68E56" ><IMG SRC="task.gif">Making Decisions with If and Select</A>
<UL>
<LI>
<A HREF="#E69E72" >If...Then Else and ElseIf</A>
<LI>
<A HREF="#E69E73" >Select Case</A></UL>
<LI>
<A HREF="#E68E57" ><IMG SRC="task.gif">Looping with For and Do</A>
<UL>
<LI>
<A HREF="#E69E74" >For...Next Loops</A>
<LI>
<A HREF="#E69E75" >Do...Loop</A>
<LI>
<A HREF="#E69E76" >Workshop Wrap-Up</A>
<LI>
<A HREF="#E69E77" >Next Steps</A>
<LI>
<A HREF="#E69E78" >Q&amp;A</A></UL></UL></UL></UL>
<HR ALIGN=CENTER>
<A NAME="E66E18"></A>
<H1 ALIGN=CENTER>
<CENTER>
<FONT SIZE=6 COLOR="#FF0000"><B>- 9 -</B>
<BR><B>Making Your Program Flow</B></FONT></CENTER></H1>
<BR>
<P>In this chapter, you
<BR>
<UL>
<LI>Learn how to create custom functions and custom procedures
<BR>
<BR>
<LI>Learn how to use conditional If...Then statements
<BR>
<BR>
<LI>Learn how to branch with Select..Case
<BR>
<BR>
<LI>Learn how to use loops
<BR>
<BR>
</UL>
<P>Tasks in this chapter:
<BR>
<UL>
<LI>Declaring custom functions
<BR>
<BR>
<LI>Declaring custom procedures
<BR>
<BR>
<LI>Using the ActiveX Control Pad to create subroutines
<BR>
<BR>
<LI>Making decisions with If and Select
<BR>
<BR>
<LI>Looping with For and Do
<BR>
<BR>
</UL>
<P>To achieve more than the simplest &quot;Hello World&quot; task in any programming language, you need to get into some real programming. Just as trying to hold a conversation in French knowing only <I>Bonjour</I> can be somewhat limiting, programming in VBScript can be difficult knowing only Alert &quot;Hello World&quot;.
<BR>
<P>To write scripts or programs that achieve a goal or provide a solution, you first need to clearly define the task at hand. Because VBScript is a logical and easy to use language, you will soon see that the definition you have come up with for your problem can be translated directly into a program.
<BR>
<P>But writing modern event-driven programs with VBScript is not a straightforward, start-to-finish affair. Many times, you need the program to make decisions and, based on that decision, maybe jump to another part of the program. Or, perhaps, a calculation is required to produce a value you use regularly in the program, so your program jumps off in another direction to get that value and then comes back to continue. This is where managing program flow becomes vital.
<BR>
<P>In this chapter, you'll see the main constituents of program flow. Program flow is dictated by calls to functions and procedures, loops, and decisions&#151;parts of the program that force execution to be either diverted somewhere else in the program or held in a certain part for a given period. Before this gets too cryptic, let's move on and see this in action.
<BR>
<BR>
<A NAME="E69E71"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>Subroutines</B></FONT></CENTER></H4>
<BR>
<P>Subroutines are small, almost self-contained programs that are called by another part of the program as they are required. The term subroutine can be thought of as a general term for the individually defined sections of the overall script.
<BR>
<P>Subroutines in VBScript include the following:
<BR>
<UL>
<LI>Event handlers: The code within an event handler is executed as the result of an action acting upon the object or control to which the event is attached, as in the following example:
<BR>
<BR>
</UL>
<UL>
<UL>
<PRE>
<FONT COLOR="#000080">Sub myButton_OnClick
Alert &quot;Hello World&quot;
End Sub</FONT></PRE></UL></UL>
<UL>
<LI>Functions: A function returns a value to the part of the script that called it, as in the following example:
<BR>
<BR>
</UL>
<UL>
<UL>
<PRE>
<FONT COLOR="#000080">Function ConvertToInches(Feet)
ConvertToInches = Feet * 12
End Function</FONT></PRE></UL></UL>
<UL>
<LI>Procedures: A procedure does not return a value. It is usually a self-contained program that can be called from anywhere within the overall script.
<BR>
<BR>
</UL>
<UL>
<UL>
<PRE>
<FONT COLOR="#000080">Sub myCustomSub()
Window.Status = &quot;Hello World&quot;
End Sub</FONT></PRE></UL></UL>
<BR>
<A NAME="E68E53"></A>
<H3 ALIGN=CENTER>
<CENTER>
<FONT SIZE=5 COLOR="#FF0000"><B><IMG SRC="task.gif">Declaring Custom Functions</B></FONT></CENTER></H3>
<BR>
<P>Functions are separate subroutines that return a value&#151;simple as that. Declaring a function is very straightforward:
<BR>
<PRE>
<FONT COLOR="#000080">Function myFunctionName()
.....
End Function</FONT></PRE>
<P>You use the keyword Function, followed by the name you've given to the function. The parentheses are used to hold the variable names for any values being passed into the function from outside, which is covered later in this section. To complete the function definition, use the words End Function. The following is a quick example, with the result shown in Figure 9.1.
<BR>
<PRE>
<FONT COLOR="#000080">&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;My Function&lt;/TITLE&gt;
&lt;SCRIPT LANGUAGE=&quot;vbscript&quot;&gt;
 Sub myButton_OnClick
  myVar = Document.Form1.Input.Value
  Document.Form1.Output.Value = myFunction(myVar)
 End Sub
 Function myFunction(ByVal AnyValue)
   myFunction = AnyValue &amp; &quot; added by my function&quot;
 End Function
&lt;/SCRIPT&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR=&quot;white&quot;&gt;
&lt;CENTER&gt;
&lt;FORM NAME=&quot;Form1&quot;&gt;
Input  &amp;nbsp;&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;Input&quot;&gt;&lt;P&gt;
&lt;INPUT TYPE=&quot;button&quot; NAME=&quot;myButton&quot; VALUE=&quot;Click Me&quot;&gt;&lt;P&gt;
Output &amp;nbsp;&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;Output&quot; SIZE=40&gt;&lt;/FORM
&lt;/CENTER&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</FONT></PRE>
<P><B><A HREF="09lax01.gif">Figure 9.1. The custom function (myfunction.htm) in the browser.</A></B>
<BR>
<P>In this example, execution of the script commences when you click the button. This fires an OnClick event, which is handled by the myButton_OnClick event handler, shown here:
<BR>
<PRE>
<FONT COLOR="#000080">Sub myButton_OnClick
 myVar = Document.Form1.Input.Value
 Document.Form1.Output.Value = myFunction(myVar)
End Sub</FONT></PRE>
<P>The value in the Input text box is copied into the myVar variable. The next line basically says to the program, &quot;Go and do myFunction, take myVar with you and bring back the result; then show that result in the Output text box.&quot; So off it goes to myFunction, taking myVar with it. Here's the myFunction function:
<BR>
<PRE>
<FONT COLOR="#000080">Function myFunction(ByVal AnyValue)
  myFunction = AnyValue &amp; &quot; added by my function&quot;
End Function</FONT></PRE>
<P>This function has been defined to receive one variable, which can be any variable. The ByVal keyword tells the scripting engine that it wants to receive just the value of the passed variable. If you try to call this function without any variables (or arguments), like
<BR>
<BR>
<PRE>
<FONT COLOR="#000080">x = myFunction()</FONT></PRE>
<P>or if you call it with more than one argument, like
<BR>
<BR>
<PRE>
<FONT COLOR="#000080">x = myFunction(y, a, I, strMyString)</FONT></PRE>
<P>you generate a runtime error. The number of arguments (or variables) must be the same. The names you use for the argument are irrelevant, but the order in which they appear is the same. Here is an example:
<BR>
<PRE>
<FONT COLOR="#000080">a = 10
b = 20
c = 30
d = 40
x = anyFunction(a,b,c,d)
Function anyFunction(e,f,g,h)</FONT></PRE>
<P>Within the anyFunction function, the values are e = 10, f = 20, g = 30, and h = 40.
<BR>
<P>To return the result of the function to the code that called it, you use the function name as the left side of an assignment, like this:
<BR>
<BR>
<PRE>
<FONT COLOR="#000080">myFunction = AnyValue &amp; &quot; added by my function&quot;</FONT></PRE>
<P>When the execution reaches the End Function, the value that has been assigned to the function is passed back to the calling script as the result.
<BR>
<P>But why not just put the code in line with the rest of the program? Well, it really depends on what you are trying to achieve. Let's say you use a particular calculation in many different parts of the program. Each time you use the calculation, you have to enter the same lines of code. It would be much easier to enter the code once in a function, and then call the function each time you need to use the calculation. Another benefit of a function is that it makes the code easier to read. Separating the code that performs a calculation makes for a tidier, less cluttered appearance. Look at the following &quot;before and after&quot; example:
<BR>
<PRE>
<FONT COLOR="#000080">&lt;SCRIPT LANGUAGE=&quot;vbscript&quot;&gt;
Sub cmdButton1_OnClick
 x = CDbl(Document.Form1.Text1.Value)
 y = CDbl(Document.Form1.Text2.Value)
 z = x * 34 + y
 b = z / (35 * 9) + 1
 i = b ^ 789 - 93
 Document.Form1.Text3.Value = CStr(i)
End Sub
Sub cmdButton2_OnClick
 x = CDbl(Document.Form1.Text4.Value)
 y = CDbl(Document.Form1.Text5.Value)
 z = x * 80 + y
 b = z / (35 * 9) + 1
 i = b ^ 789 - 93
 Document.Form1.Text6.Value = CStr(i)
End Sub
Sub cmdButton3_OnClick
 x = CDbl(Document.Form1.Text7.Value)
 y = 989
 z = x * 20 + y
 b = z / (35 * 9) + 1
 i = b ^ 789 - 93
 Document.Form1.Text9.Value = CStr(i)
End Sub
&lt;/SCRIPT&gt;</FONT></PRE>
<P>In this totally imaginary script, each of three buttons has a similar event handler. But notice the subtle differences in each one. The following is how it could be rescripted using a single function:
<BR>
<PRE>
<FONT COLOR="#000080">&lt;SCRIPT LANGUAGE=&quot;vbscript&quot;&gt;
Function myFunction(ByVal x, ByVal y, ByVal v)
 x = CDbl(x)
 y = CDbl(y)
 z = x * v + y
 b = z / (35 * 9) + 1
 i = b ^ 789 - 93
 myFunction = CStr(i)
End Function
Sub cmdButton1_OnClick
 Document.Form1.Text3.Value = myFunction(Document.Form1.Text1.Value, Document.Form1.Text2.Value, 34)
End Sub
Sub cmdButton2_OnClick
 Document.Form1.Text6.Value = myFunction(Document.Form1.Text4.Value, Document.Form1.Text5.Value, 80)
End Sub
Sub cmdButton3_OnClick
 Document.Form1.Text9.Value = myFunction(Document.Form1.Text7.Value, 989, 20)
End Sub
&lt;/SCRIPT&gt;</FONT></PRE>
<P>Not only does it look tidier, but it is also easier to maintain. Any modification to the formula needs to be made in only one place rather than three, which reduces the chance of error.
<BR>
<BR>
<A NAME="E68E54"></A>
<H3 ALIGN=CENTER>
<CENTER>
<FONT SIZE=5 COLOR="#FF0000"><B><IMG SRC="task.gif">Declaring Custom Procedures</B></FONT></CENTER></H3>
<BR>
<P>A custom procedure is a subroutine that doesn't return a value. Like functions, procedures can accept variables from other parts of the program. To declare a custom procedure, you use the Sub keyword, followed by the name of the procedure.
<BR>
<PRE>
<FONT COLOR="#000080">Sub myProcedure()
....
End Sub</FONT></PRE>
<P>You can use two types of syntax to call a custom procedure. The first method is to use the keyword Call, like this:
<BR>
<BR>
<PRE>
<FONT COLOR="#000080">Call myProcedure()</FONT></PRE>
<P>If you use the keyword Call, you must use parentheses around the argument list or use empty parentheses. The other method is to simply use the procedure name without the word Call, like this:
<BR>
<BR>
<PRE>
<FONT COLOR="#000080">myProcedure</FONT></PRE>
<P>If you omit the keyword Call, you cannot use parentheses around your argument list.
<BR>
<P>The following example uses both methods. The result is shown in Figure 9.2.
<BR>
<PRE>
<FONT COLOR="#000080">&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;My Custom Procedure&lt;/TITLE&gt;
&lt;SCRIPT LANGUAGE=&quot;vbscript&quot;&gt;
Sub Button1_OnClick
 Call DoComplexMessage(&quot;First Message&quot;)
End Sub
Sub Button2_OnClick
 DoComplexMessage &quot;Second Message&quot;
End Sub
Sub DoComplexMessage(ByVal Message)
 Dim CRLF
 Dim strTitle
 Dim strMainMessage
 CRLF = Chr(10) &amp; Chr(13)
 strTitle = &quot;My Custom Procedure&quot;
 strMainMessage = &quot;Hello this is the &quot; &amp; Message &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;This is my procedure to show &quot; &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;a message box which is similar &quot; &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;from both buttons&quot;
 x = MsgBox(strMainMessage,0,strTitle)
End Sub
&lt;/SCRIPT&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR=&quot;white&quot;&gt;
&lt;CENTER&gt;
&lt;INPUT TYPE=&quot;button&quot; NAME=&quot;Button1&quot; VALUE=&quot;Button 1&quot;&gt;
&lt;INPUT TYPE=&quot;button&quot; NAME=&quot;Button2&quot; VALUE=&quot;Button 2&quot;&gt;
&lt;/CENTER&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</FONT></PRE>
<P><B><A HREF="09lax02.gif">Figure 9.2. The custom procedure, proc.htm, in the browser.</A></B>
<BR>
<P>Both event handlers for the buttons call the DoComplexMessage procedure. One uses Call and parentheses, and the other simply uses the procedure name. As you can clearly see, the use of a custom procedure in this example removes the need for you to write the same code more than once.
<BR>
<BLOCKQUOTE>
<BLOCKQUOTE>
<HR ALIGN=CENTER>
<BR>
<NOTE>You can improve the readability of your code by using verbs in your custom procedure names&#151;for example, ShowTheTime() or OpenNewWindow().</NOTE>
<BR>
<HR ALIGN=CENTER>
</BLOCKQUOTE></BLOCKQUOTE>
<BR>
<A NAME="E68E55"></A>
<H3 ALIGN=CENTER>
<CENTER>
<FONT SIZE=5 COLOR="#FF0000"><B><IMG SRC="task.gif">Using the ActiveX Control Pad to Create Subroutines</B></FONT></CENTER></H3>
<BR>
<P>The ActiveX Control Pad enables you to quickly create custom procedures and functions, and it also makes it easy to add the calls to your custom procedures and functions.
<BR>
<P>To see how this works, let's re-create the example used in the last section using the ActiveX Control Pad.
<BR>
<OL>
<LI>Open the ActiveX Control Pad and, using the HTML template provided, create the HTML part of the page, which should now look like what you see in Figure 9.3.
<BR>
<BR><B><A HREF="09lax03.gif">Figure 9.3. The custom procedure example's HTML.</A></B>
<BR>
<BR>
<LI>Now open the Script Wizard by clicking the script button on the toolbar or selecting Script Wizard from the Tools menu.
<BR>
<BR>
<LI>To create a custom procedure, right-click anywhere in the right actions pane, and select New Procedure from the pop-up menu. The Script Wizard then opens a new custom procedure in the script pane and gives it a default name of Procedure1(). (See Figure 9.4.) 
<BR>
<BR><B><A HREF="09lax04.gif">Figure 9.4. The new custom procedure.</A></B>
<BR>
<BR>
<LI>Rename the procedure by changing Procedure1 to DoComplexMessage, and add ByVal Message between the parentheses.
<BR>
<BR>
<LI>Enter the following code into the script pane:
<BR>
<BR>
<UL>
<UL>
<PRE>
<FONT COLOR="#000080">Dim CRLF
 Dim strTitle
 Dim strMainMessage
 CRLF = Chr(10) &amp; Chr(13)
 strTitle = &quot;My Custom Procedure&quot;
 strMainMessage = &quot;Hello this is the &quot; &amp; Message &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;This is my procedure to show &quot; &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;a message box which is similar &quot; &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;from both buttons&quot;
 x = MsgBox(strMainMessage,0,strTitle)</FONT></PRE></UL></UL>
<BLOCKQUOTE>
<BLOCKQUOTE>
<HR ALIGN=CENTER>
<BR>
<NOTE>The Script Wizard automatically adds the End Sub statement.</NOTE>
<BR>
<HR ALIGN=CENTER>
</BLOCKQUOTE></BLOCKQUOTE>
<LI>Click the plus sign that appears next to the word Procedures in the right actions pane, and you can see that your new custom procedure is available to be used by any of the events. Your Script Wizard should now resemble the one in Figure 9.5.
<BR>
<BR><B><A HREF="09lax05.gif">Figure 9.5. The completed custom procedure.</A></B>
<BR>
<BR>
<LI>To call the custom procedure from the buttons events, click the plus sign to the left of Button1 in the left events frame, and select the OnClick event.
<BR>
<BR>
<LI>Double-click the DoComplexMessage procedure in the right actions pane. Automatically, the Script Wizard adds the words Call DoComplexMessage() to the script pane.
<BR>
<BR>
<LI>Edit the statement by adding &quot;First Message&quot; between the parentheses. Your Script Wizard now looks like the one in Figure 9.6.
<BR>
<BR><B><A HREF="09lax06.gif">Figure 9.6. Calling the procedure from the OnClick event.</A></B>
<BR>
<BR>
<LI>Repeat this for Button2, using &quot;Second Message&quot; between the parentheses.
<BR>
<BR>
<LI>To finish, click OK and the Script Wizard automatically generates the code, which looks like this:
<BR>
<BR>
</OL>
<UL>
<UL>
<PRE>
<FONT COLOR="#000080">&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;
&lt;!--
Sub DoComplexMessage(ByVal Message)
 Dim CRLF
 Dim strTitle
 Dim strMainMessage
 CRLF = Chr(10) &amp; Chr(13)
 strTitle = &quot;My Custom Procedure&quot;
 strMainMessage = &quot;Hello this is the &quot; &amp; Message &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;This is my procedure to show &quot; &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;a message box which is similar &quot; &amp; CRLF
 strMainMessage = strMainMessage &amp; &quot;from both buttons&quot;
 x = MsgBox(strMainMessage,0,strTitle)
end sub
--&gt;
    &lt;/SCRIPT&gt;
&lt;TITLE&gt;My Custom Procedure&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR=&quot;white&quot;&gt;
&lt;CENTER&gt;
    &lt;INPUT LANGUAGE=&quot;VBScript&quot; TYPE=button VALUE=&quot;Button 1&quot; ONCLICK=&quot;call DoComplexMessage(&amp;quot;First Message&amp;quot;)&quot;
     NAME=&quot;Button1&quot;&gt;
    &lt;INPUT LANGUAGE=&quot;VBScript&quot; TYPE=button VALUE=&quot;Button 2&quot;ONCLICK=&quot;call DoComplexMessage(&amp;quot;Second Message&amp;quot;)&quot;
     NAME=&quot;Button2&quot;&gt;
&lt;/CENTER&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</FONT></PRE></UL></UL>
<P>Note that the custom procedure code is identical to the one you created manually earlier. However, the Script Wizard places event handlers for HTML Intrinsic controls within the HTML definition of the control. Save the file and test it in the browser.
<BR>
<BLOCKQUOTE>
<BLOCKQUOTE>
<HR ALIGN=CENTER>
<BR>
<NOTE>You can also create custom functions using the ActiveX Script Wizard. Follow the previous instructions, and simply replace the word Sub with Function. When the Script Wizard generates the code, it will automatically place End Function rather than End Sub at the end of the script.</NOTE>
<BR>
<HR ALIGN=CENTER>
</BLOCKQUOTE></BLOCKQUOTE>
<BR>
<A NAME="E68E56"></A>
<H3 ALIGN=CENTER>
<CENTER>
<FONT SIZE=5 COLOR="#FF0000"><B><IMG SRC="task.gif">Making Decisions with If and Select</B></FONT></CENTER></H3>
<BR>
<P>Adding some pseudo-intelligence to your script is only possible if you can enable your script to make decisions. You can add decision-making capabilities in two ways.
<BR>
<BR>
<A NAME="E69E72"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>If...Then Else and ElseIf</B></FONT></CENTER></H4>
<BR>
<P>The If...Then conditional statement is the most widely used construct in any programming language. It is easy and quick to use and allows you to branch the program based on the result of the condition, like this:
<BR>
<PRE>
<FONT COLOR="#000080">If myVariable = yourVaraible Then
     Alert &quot;got a match&quot;
End</FONT></PRE>
<P>If...Then statements can also be nested, which means you can have a condition that is only tested if the condition of the first statement is true. Here is an example:
<BR>
<PRE>
<FONT COLOR="#000080">If myVariable = yourVariable Then
    If aVariable = bVariable Then
        Alert &quot;Both sets match&quot;
    End If
End If</FONT></PRE>
<P>For the code within the conditional statement to execute, the condition must evaluate True.
<BR>
<PRE>
<FONT COLOR="#000080">if x = 10 then
    Alert &quot;yes, x does equal 10&quot;
end if</FONT></PRE>
<P>But what happens if it evaluates to False? Well, normally execution continues with the code directly after the End If statement. However, you can add an Else statement within the condition, which makes the code execute only if the condition is False. Here is an example:
<BR>
<PRE>
<FONT COLOR="#000080">If x = 10 then
    Alert &quot;Yes, x does equal 10&quot;
Else
    Alert &quot;No, x does not equal 10&quot;
End If</FONT></PRE>
<P>You can even add a further condition within the Else section. Just use the ElseIf keyword, like this:
<BR>
<PRE>
<FONT COLOR="#000080">If x = 10 then
    Alert &quot;Yes, x does equal 10&quot;
ElseIf x = 20 Then
    Alert &quot;x does not equal 10 but it equals 20&quot;
Else
    Alert &quot;x does not equal 10 or 20&quot;
End If</FONT></PRE>
<P>You can turn the condition on its head and have the code execute only if the condition evaluates to False. This is done by including the negation operator Not.
<BR>
<PRE>
<FONT COLOR="#000080">If Not x = 10 Then
 Alert &quot;Sorry but x does not equal 10&quot;
End If</FONT></PRE>
<P>Note that, in truth, the overall statement still evaluates to True. Essentially, the statement says, &quot;Does x not equal 10? Yes, it doesn't.&quot;
<BR>
<BR>
<A NAME="E69E73"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>Select Case</B></FONT></CENTER></H4>
<BR>
<P>The other type of conditional statement you have at your disposal is the Select Case block. With Select Case, you start with a known value and then use the Case statement to compare whether the case variable matches the selection variable. If the comparison evaluates to true, the line following Case is executed. After execution, the program continues with the line following End Select.
<BR>
<PRE>
<FONT COLOR="#000080">Select Case x
Case 5
    Alert &quot;x equals 5&quot;
Case 10
    Alert &quot;x equals 10&quot;
Case 15
    Alert &quot;x equals 15&quot;
End Select</FONT></PRE>
<P>Again, let's ook at how you can have at least one line of the block execute no matter what the result. You use Case Else, like this:
<BR>
<PRE>
<FONT COLOR="#000080">Select Case x
Case 5
    Alert &quot;x equals 5&quot;
Case 10
    Alert &quot;x equals 10&quot;
Case 15
    Alert &quot;x equals 15&quot;
Case Else
    Alert &quot;I dont care what value x is but its not 5, 10 or 15&quot;
End Select</FONT></PRE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<HR ALIGN=CENTER>
<BR>
<NOTE>Unlike the Select Case in Visual Basic, the VBScript version does not allow statements like Case Is &lt; 8 or Case Is 10 To 100. All values for the Case statements must be explicit, which restricts its usage drastically.</NOTE>
<BR>
<HR ALIGN=CENTER>
</BLOCKQUOTE></BLOCKQUOTE>
<BR>
<A NAME="E68E57"></A>
<H3 ALIGN=CENTER>
<CENTER>
<FONT SIZE=5 COLOR="#FF0000"><B><IMG SRC="task.gif">Looping with For and Do</B></FONT></CENTER></H3>
<BR>
<P>What do you do if you need to execute the same section of code many times over, possibly with a slight change to the code? You could write the code over and over again, like this:
<BR>
<PRE>
<FONT COLOR="#000080">x = 0
Document.Write x
Document.Write x + 1
Document.Write x + 2
Document.Write x + 3
Document.Write x + 4
Document.Write x + 5</FONT></PRE>
<P>This could continue on, and copying and pasting it wouldn't take too long to reach 100! But there's a much easier method to achieve the same result. It's known as a <I>loop</I>.
<BR>
<P>VBScript gives you two ways in which you can repeat the same code as many times as you want:
<BR>
<UL>
<LI>For...Next
<BR>
<BR>
<LI>Do...Loop
<BR>
<BR>
</UL>
<BR>
<A NAME="E69E74"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>For...Next Loops</B></FONT></CENTER></H4>
<BR>
<P>A For...Next loop enables you to repeat execution of the code held within the loop a given number of times. You specify the upper and lower parameters of the loop counter, and the scripting engine increments the loop counter automatically as the loop is executed.
<BR>
<PRE>
<FONT COLOR="#000080">For x = 1 to 100
  do some code 100 times
Next</FONT></PRE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<HR ALIGN=CENTER>
<BR>
<NOTE>VB programmers should keep in mind that in VBScript, you can use only Next. You do not have the option to use the old Next x as you do in VB4.</NOTE>
<BR>
<HR ALIGN=CENTER>
</BLOCKQUOTE></BLOCKQUOTE>
<P>By default, the loop counter is incremented by one every time the program reaches the Next statement, until the upper limit is reached, at which point the program continues execution with the line following Next.
<BR>
<P>Let's have a look at a few variations on the For...Next theme. First, what if you want the counter to increment in reverse, or maybe increment by more than 1 each time? There's a special keyword called Step. Step is used to change the behavior of the increment. If Step is negative, the loop goes backward, like so:
<BR>
<PRE>
<FONT COLOR="#000080">For x = 100 to 0 Step -1
    Do something 100 times
Next</FONT></PRE>
<P>In this example, x starts at 100 and is reduced by 1 with every loop until it reaches 0, at which point the loop is terminated. Step can be any number, and that number then becomes the increment.
<BR>
<PRE>
<FONT COLOR="#000080">For x = 0 to 100 Step 2
    Do something 50 times
Next</FONT></PRE>
<P>Second, what if you want to initially loop a certain number of times, but jump out of the loop if a particular condition is met? For this, you use Exit For. Exit For takes the execution out of the loop and resumes the program at the line immediately following the Next statement.
<BR>
<PRE>
<FONT COLOR="#000080">For x = 0 to 50
 y = y + 1
  If y = z then
   Exit For
  End If
Next</FONT></PRE>
<BR>
<A NAME="E69E75"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>Do...Loop</B></FONT></CENTER></H4>
<BR>
<P>Another way you can repeat the same code over and over is to use a Do...Loop statement, like this:
<BR>
<PRE>
<FONT COLOR="#000080">Do
code to execute for ever
Loop</FONT></PRE>
<P>But, actually, it's not like this at all. If you wrote that into your script, your script would never finish. You need to give the loop a condition so that it knows when to stop repeating. The two conditions are While and Until.
<BR>
<P>A Do While loop repeats while a condition is True, as in the following example:
<BR>
<PRE>
<FONT COLOR="#000080">x = 2
Do While x &lt; 10
 x = x + 1
Loop</FONT></PRE>
<P>A Do Until loop repeats until a condition is True, as in the following example:
<BR>
<PRE>
<FONT COLOR="#000080">Do Until x = 10
 x = x + 1
Loop</FONT></PRE>
<P>As with the For...Next loop, you have several options that you can use with the Do...Loop statement. The first is Exit Do. Again, this is to allow an exit route for your program in case the need arises.
<BR>
<PRE>
<FONT COLOR="#000080">Do While x &lt; 100
 x = x + 1
 z = z - 1
  If z = 50
   Exit Do
  End if
Loop</FONT></PRE>
<P>The next option is to place the While or Until on the same line as Loop, rather than on the same line as Do, like this:
<BR>
<PRE>
<FONT COLOR="#000080">Do
 x = x + 1
Loop Until x = 100</FONT></PRE>
<P>The difference is that placing While or Until next to Loop forces the statement block to be executed at least once. If the condition is placed next to Do, and the condition is True as the program arrives at the statement block, then the loop is not executed. Here is an example:
<BR>
<PRE>
<FONT COLOR="#000080">x = 200
Do While x &lt; 100
 This code never executes
Loop</FONT></PRE>
<P>However, if the code was rewritten like the following, the code executes once:
<BR>
<PRE>
<FONT COLOR="#000080">x = 200
Do
 This Code executes only once
Loop While x &lt; 100</FONT></PRE>
<BR>
<A NAME="E69E76"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>Workshop Wrap-Up</B></FONT></CENTER></H4>
<BR>
<P>In this chapter, you've been through the main language components that enable you to control the flow within your script. From defining subroutines and functions, to decision making statements, and finally how to execute code over and over. Here's a brief summary:
<BR>
<UL>
<LI>Functions are subroutines that return a value.
<BR>
<BR>
<LI>Procedures are subroutines that do not return a value.
<BR>
<BR>
<LI>Event handlers are subroutines that are called in response to an action acting upon an object or control.
<BR>
<BR>
<LI>Use If...Then or If...Else...Then to execute code based on the result of a condition.
<BR>
<BR>
<LI>Use Select Case to specify which code should execute.
<BR>
<BR>
<LI>Loop a given number of times with For...Next. Use Step to change the default increment.
<BR>
<BR>
<LI>Do While Loop repeats while a condition is True.
<BR>
<BR>
<LI>Do Until Loop repeats until a condition is True.
<BR>
<BR>
<LI>Do Loop While and Do Loop Until repeat at least once.
<BR>
<BR>
</UL>
<BR>
<A NAME="E69E77"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>Next Steps</B></FONT></CENTER></H4>
<BR>
<P>Now you know how to create scripts that can make decisions, branch to other parts of the script, repeat sections of code, and generally perform like they know what they're doing. You can add even more functionality to your scripts by looking at the following chapters:
<BR>
<UL>
<LI>To complete your knowledge of the VBScript language elements, see Chapter 10, &quot;Using the Power of Arrays.&quot;
<BR>
<BR>
<LI>For a further example of using If...Then and loops, see Chapter 5, &quot;Interfacing VBScript with HTML Intrinsic Controls.&quot;
<BR>
<BR>
<LI>For an example of using Select..Case, see Chapter 8, &quot;Adding Date and Time Functions.&quot;
<BR>
<BR>
</UL>
<BR>
<A NAME="E69E78"></A>
<H4 ALIGN=CENTER>
<CENTER>
<FONT SIZE=4 COLOR="#FF0000"><B>Q&amp;A</B></FONT></CENTER></H4>
<BR>
<P><B>Q: How do you decide when to subdivide a program into smaller sections?</B>
<BR>
<P><B>A:</B> Many of the reasons for creating separate subroutines and functions will give you an idea about when it is right to create a separate subroutine. Subroutines save coding. If you find yourself coding the same lines over and over, you probably need a subroutine. If you have a routine that returns a value, and that value might (now or in future) be needed by several parts of the program, or if the routine to produce the value is more than a few lines of code, I would suggest that it be placed in its own function.
<BR>
<P ALIGN=CENTER>
<A HREF="lax08.htm" TARGET="_self"><IMG SRC="blanprev.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="Previous Page"></A>
<A HREF="#I0" TARGET="_self"><IMG SRC="blantop.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="Page Top"></A>
<A HREF="httoc.htm" TARGET="_self"><IMG SRC="blantoc.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="TOC"></A>
<A HREF="lax10.htm" TARGET="_self"><IMG SRC="blannext.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="Next Page"></A>
<A HREF="http://www.mcp.com/sams/" TARGET="_self"><IMG SRC="blanhome.gif" WIDTH = 37 HEIGHT = 37 BORDER = 0 ALT="See Page"></A>
</BODY></HTML>
