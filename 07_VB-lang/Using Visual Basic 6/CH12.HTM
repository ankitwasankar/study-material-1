<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<SCRIPT LANGUAGE="JavaScript">

<!--

function popUp(pPage) {
 var fullURL = document.location;
 var textURL = fullURL.toString();
 var URLlen = textURL.length;
 var lenMinusPage = textURL.lastIndexOf("/");
 lenMinusPage += 1;
 var fullPath = textURL.substring(0,lenMinusPage);
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '</head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + fullPath + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 window.popUpWin.document.write(zhtm);
 window.popUpWin.document.close();
 // Johnny Jackson 4/28/98
 }

//-->
                                                                
</SCRIPT>
<link rel="stylesheet" href="ebooks.css" tppabs="http://pbs.mcp.com/includes/stylesheets/ebooks.css">

	<META NAME="GENERATOR" Content="Symantec Visual Page Mac 1.1.1">
	<TITLE>Using Visual Basic 6 -- Ch 12 -- Working with Strings and Typecasting</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<H1 ALIGN="CENTER"><IMG SRC="que.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/que.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM"
BORDER="0"><BR>
Using Visual Basic 6</H1>
<CENTER>
<P><A HREF="ch11.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/ch11/ch11.htm"><IMG SRC="previous.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch13.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/ch13/ch13.htm"><IMG
SRC="next.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index-38.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/index.htm"><IMG SRC="contents.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> 
<HR>

</CENTER>
<H1 ALIGN="CENTER">- 12 -<BR>
Working with Strings and Typecasting</H1>
<H1></H1>

<UL>
	<LI><A HREF="#Heading1">Manipulating Strings</A>
	<UL>
		<LI><A HREF="#Heading2">Reversing the Order of Characters in Strings</A>
		<LI><A HREF="#Heading3">Replacing Characters Within Strings</A>
		<LI><A HREF="#Heading4">Concatenating Strings</A>
		<LI><A HREF="#Heading5">Determining a String's Length with Len()</A>
		<LI><A HREF="#Heading6">Truncating Strings with Left() and Right()</A>
		<LI><A HREF="#Heading7">Using Mid() to Return Characters from Inside a String</A>
		<LI><A HREF="#Heading8">Using InStr() to Search for Characters Within a String</A>
	</UL>
	<LI><A HREF="#Heading9">Using Strings and Arrays of Strings</A>
	<UL>
		<LI><A HREF="#Heading10">Splitting a String into an Array of Strings with Split()</A>
		<LI><A HREF="#Heading11">Creating a Sublist from an Array of Strings with Filter()</A>
		<LI><A HREF="#Heading12">Combining an Array of Strings with Join()</A>
	</UL>
	<LI><A HREF="#Heading13">Changing a String's Case with UCase() and LCase()</A>
	<LI><A HREF="#Heading14">Using String-Parsing Functions</A>
	<LI><A HREF="#Heading15">Controlling Data Types with Typecasting</A>
	<UL>
		<LI><A HREF="#Heading16">Changing Data Types with the Conversion Functions</A>
	</UL>
	<LI><A HREF="#Heading17">Validating Data with IsNumeric()</A>
</UL>

<P>
<HR SIZE="4">

<H2><A NAME="Heading1"></A>Manipulating Strings</H2>
<P>The first task when working with strings is to be able to locate parts of a string
and then rearrange them as required.</P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>Visual Basic 6's string functions</STRONG></P>
	<P>Visual Basic 6 comes with a lot of new string functions, many of them vast functional
	enhancements to the native language. Seasoned VB programmers can now replace entire
	custom functions in their programs with a single line of code. Because of VB6's numerous
	new string functions, expect to refer to this chapter several times before you uncover
	all that can be accomplished with these new functions. 
<HR>


</BLOCKQUOTE>

<H3><A NAME="Heading2"></A>Reversing the Order of Characters in Strings</H3>
<P>Visual Basic's new StrReverse() function enables you to completely reverse the
order of a string. Its syntax is as follows:</P>
<P>
<PRE><I>strResult</I> = StrReverse(<I>strMyString</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>strResult</I> is the string returned from the function.
	<P>
	<LI>StrReverse is the function name.
	<P>
	<LI><I>strMyString</I> is the string to be reversed.
</UL>

<P>The TextBoxes shown in Figure 12.1 were initialized during the form's load event.
Notice that line 3 of the following code is an empty string of length zero. It's
important to distinguish this from a null string. Most databases, such as Microsoft
Access and SQL Server, allow fields to be null or undefined until they're initialized.
These null values will cause problems for the string functions.</P>
<P>
<PRE><B>01</B> Private Sub Form_Load()
<B>02</B> txtMyString.Text = &quot;It's raining cats and dogs.&quot;
<B>03</B> txtResult.Text = &quot;&quot;
<B>04</B> End Sub
</PRE>
<P>Visual Basic defaults all internal variables to valid values--numeric variables
default to zero, and strings default to empty. The problem happens when you take
a null data field from a database and assign it to an internal variable or when you
perform a string function on the null data field.</P>
<P>The sample program in Figure 12.1 uses two ways of reversing a string. Listing
12.1 shows the code required for Visual Basic 5. In this version, a loop was required
to step through each character in the string and then build the new string in reverse
order. The code in Listing 12.2 delivers the same result with the new StrReverse()
function, with no loops and only one simple command.</P>
<P><A HREF="javascript:popUp('12fig01.gif')"><B>FIGURE 12.1</B></A> <I>The string
is reversed by either the old or the new string-reversing subroutines.</I></P>
<P>
<H4>LISTING 12.1&nbsp;&nbsp;12LIST01.TXT--A VB5 For...Loop That Reverses a String
by Using<BR>
the Len() Function</H4>
<PRE><B>01 </B>Private Sub OldVersion_Click()</PRE>
<PRE><B>02 </B>Dim intLength As Integer `Length of the string</PRE>
<PRE><B>03 </B>Dim intCntr As Integer `Loop counter</PRE>
<PRE><B>04</B></PRE>
<PRE><B>05 </B>`Initialize the txtResult.Text string and then</PRE>
<PRE><B>06 </B>` determine the length of txtMyString.Text</PRE>
<PRE><B>07 </B>intLength = Len(txtMyString.Text)</PRE>
<PRE><B>08 </B>txtResult.Text = &quot;&quot;</PRE>
<PRE><B>09</B></PRE>
<PRE><B>10 </B>`Loop through the first string one character at a time.</PRE>
<PRE><B>11 </B>`Concatenate each character to the beginning.</PRE>
<PRE><B>12 </B>For intCntr = 1 To intLength</PRE>
<PRE><B>13 </B>txtResult.Text = Mid(txtMyString.Text, intCntr, 1) _</PRE>
<PRE>&amp; txtResult.Text</PRE>
<PRE><B>14 </B>Next intCntr</PRE>
<PRE><B>15</B> Refresh</PRE>
<PRE><B>16</B></PRE>
<PRE><B>17 </B>End Sub</PRE>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>Download this chapter's code</STRONG></P>
	<P>You can find all the code for the examples in this chapter on the Web at <A target="_new" HREF="javascript:if(confirm('http://www.mcp. com/info  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.mcp. com/info'" tppabs="http://www.mcp. com/info">http://www.mcp.
	com/info</A>. At the prompt, enter 078971633x (for the book's ISBN) and then click
	Search to go to the Book Info page for Using Visual Basic 6. 
<HR>


</BLOCKQUOTE>

<H4>LISTING 12.2&nbsp;&nbsp;12LIST02.TXT--Using the New StrReverse() Function</H4>
<PRE><B>01 </B>Private Sub NewVersion_Click()</PRE>
<PRE><B>02 </B>`This new function works on strings.</PRE>
<PRE><B>03</B></PRE>
<PRE><B>04 </B>txtResult.Text = StrReverse(txtMyString.Text)</PRE>
<PRE><B>05 </B>Refresh</PRE>
<PRE>06</PRE>
<PRE><B>07 </B>End Sub</PRE>
<P>Listing 12.2's seven code lines are more for contrast than function. Only lines
4 and 5 perform any actions. Notice, however, that because a simple assignment statement
could be used, the value of txtResult.Text didn't have to be initialized, further
reducing the lines of code required.</P>
<P>
<H3><A NAME="Heading3"></A>Replacing Characters Within Strings</H3>
<P>The next new function to introduce is Replace(), which can find and then replace
or remove the found string within the target string. Find operations also can either
consider or ignore capitalization. If you've ever used the replace feature in a word
processing program, you have a good understanding of how this function works.</P>
<P>The syntax for the Replace() function is as follows:</P>
<P>
<PRE><I>strResult</I> = Replace(<I>strMyString</I>, <I>strFind</I>, <I>strRplWith</I>, _
                    <I>intStart</I>, <I>intCnt</I>, <I>intCompare</I>)
</PRE>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>Replace() can return a partial string</STRONG></P>
	<P>A feature of the Replace() function is that it returns only the portion of the
	string to which the function was directed to work on. When you specify the optional
	parameter intStart with a value greater than 1, the return string won't contain the
	characters before the intStart position. 
<HR>


</BLOCKQUOTE>

<P>In this syntax,</P>

<UL>
	<LI><I>strResult</I> is the string returned from the function.
	<P>
	<LI>Replace is the function name.
	<P>
	<LI><I>strMyString</I> is the string to be changed.
	<P>
	<LI><I>strFind</I> is the string to find in <I>strMyString</I>.
	<P>
	<LI><I>strRplWith</I> is the string to be used to replace <I>strFind</I>.
	<P>
	<LI><I>intStart</I> is an optional position parameter within <I>strMyString</I> at
	which to begin looking for <I>strFind</I>.
	<P>
	<LI><I>intCnt</I> is an optional parameter for the maximum number of times to replace
	<I>strFind</I> in <I>strMyString</I>.
	<P>
	<LI><I>intCompare</I> is an optional integer parameter that indicates case sensitivity
	for the function.
</UL>

<P>The <I>intCompare</I> argument has several settings (see Table 12.1). The first
option enables the function to be driven by the global compare option, which can
be set in the general declaration section of the program. This makes changing the
case sensitivity for all Replace() functions in a program as simple as changing one
line of code.</P>
<P>
<H4>TABLE 12.1&nbsp;&nbsp;Options for the intCompare Argument</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>Constant</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Value</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Description</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbUseCompareOption</TD>
		<TD ALIGN="LEFT">-1</TD>
		<TD ALIGN="LEFT">Performs a comparison as set in the Option Compare statement</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbBinaryCompare</TD>
		<TD ALIGN="LEFT">0</TD>
		<TD ALIGN="LEFT">Performs a case-sensitive comparison</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbTextCompare</TD>
		<TD ALIGN="LEFT">1</TD>
		<TD ALIGN="LEFT">Performs a comparison that is not case sensitive</TD>
	</TR>
</TABLE>
</P>
<P>The program in Figure 12.2 uses the string contained in the first TextBox as the
target of a search-and-replace operation.</P>
<P><A HREF="javascript:popUp('12fig02.gif')"><B>FIGURE 12.2</B></A> <I>The word cats
is replaced with the word horses in both locations in the string.</I></P>
<P>As with the example for reversing a string, the sample program in Figure 12.2
initializes the TextBox Text properties when the form is loaded. In the following
code, lines 3 and 4 show the values of the <I>strFind</I> and <I>strRplWith</I> arguments,
respectively.</P>
<P>
<PRE><B>01</B> Private Sub Form_Load()
<B>02</B> txtMyString.Text = &quot;It's raining cats and dogs&quot; _
               &amp; &quot;and dogs and cats&quot;
<B>03</B> txtFind.Text = &quot;cats&quot;
<B>04</B> txtRplWith.Text = &quot;horses&quot;
<B>05</B> End Sub
</PRE>
<P>When the click event is fired, the assignment statement takes the return value
from the Replace() function and assigns it to the Text property of TextBox1. Line
3 in the following code uses the continuation symbol (_) to allow the statement to
extend to the next line.</P>
<P>
<PRE><B>01</B> Private Sub cmdReplace_Click()
<B>02</B> `The Replace function works on strings.
<B>03</B> txtMyString.Text = Replace(txtMyString.Text, _
        txtFind.Text, txtRplWith.Text)
<B>04</B> Refresh
<B>05</B> End Sub
</PRE>
<P>When the TextBoxes are updated (see Figure 12.3) with horses as the <I>strFind</I>
value and &quot;&quot; (the zero-length string) as the <I>strRplWith</I> value, the
function will replace the found string with nothing. This is how you can use the
function to remove only the found values, but notice again that both locations in
the string were changed.</P>
<P><A HREF="javascript:popUp('12fig03.gif')"><B>FIGURE 12.3</B></A> <I>The Replace()
function can also remove characters.</I></P>

<P>The power of Replace also offers the opportunity to create errors. Table 12.2
lists six conditions that, when you're writing programs, you need to understand and
check for. Each condition identifies a return value when the function is given a
certain input to work with.</P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>Replace() won't always work</STRONG></P>
	<P>It's important to be able to process the return values of the Replace() function
	when an error has occurred. This function can err in several ways that are important
	to capture in your program. 
<HR>


</BLOCKQUOTE>

<H4>TABLE 12.2&nbsp;&nbsp;Return Values from Errors in the Replace() Function</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>When...</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Replace() Returns...</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>strMyString </I>is zero length</TD>
		<TD ALIGN="LEFT">A zero-length string of &quot;&quot;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>strMyString</I> is null</TD>
		<TD ALIGN="LEFT">An error</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>strFind</I> is zero length</TD>
		<TD ALIGN="LEFT">A copy of <I>strMyString</I></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>strRplWith</I> is zero length</TD>
		<TD ALIGN="LEFT">A copy of <I>strMyString</I> with all occurrences of <I>strFind</I> removed</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>intStart</I> &gt; Len(<I>strMyString</I>)</TD>
		<TD ALIGN="LEFT">A zero-length string of &quot;&quot;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>intCnt</I> is 0</TD>
		<TD ALIGN="LEFT">A copy of <I>strMyString</I></TD>
	</TR>
</TABLE>
</P>
<P>When the value of <I>strFind</I> or <I>strRplWith</I> is a zero-length string,
an unwanted result might occur that you can trap with a simple If...Then statement
around the function. The following code and Figure 12.4 show how the function on
line 3 of the preceding example could be changed to check for this condition. This
would be important if you wanted to prevent any replacement of characters when the
<I>strFind</I> or <I>strRplWith</I> string is empty.</P>
<P>
<PRE><B>01</B> Private Sub cmdReplace_Click()
<B>02</B> `Test for Empty String; then Replace the strings.
<B>03</B> If txtFind.Text = &quot;&quot; Or txtRplWith = &quot;&quot; Then
<B>04</B>      MsgBox &quot;You Found the Error&quot;, vbExclamation, _
         &quot; Empty String data error&quot;
<B>05</B> Else
<B>06</B>      txtMyString.Text = Replace(txtMyString.Text, _
         txtFind.Text, txtRplWith.Text)
<B>07</B> End If
<B>08</B> Refresh
<B>09</B> End Sub
</PRE>
<P>There are many other techniques for finding and processing errors. Chapter 21,
&quot;Debugging Your Applications,&quot; covers these more extensively.</P>
<P><A HREF="javascript:popUp('12fig03a.gif')"><B>FIGURE 12.4</B></A> <I>The Replace()
function parameters should be checked for unwanted values.</I></P>
<P>
<H3><A NAME="Heading4"></A>Concatenating Strings</H3>
<P><I>Concatenating</I> one string to another means combining both strings. In Visual
Basic, you concatenate two strings by using the &amp; operator. In Listing 12.3,
the value of strResult will be blueberry.</P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>More efficient code</STRONG></P>
	<P>This example helps you understand the role of variables and literals. The same
	result could be achieved in one line: cmdBerry.Caption = &quot;blue&quot; &amp; &quot;berry&quot;.
	
<HR>


</BLOCKQUOTE>

<H4>LISTING 12.3&nbsp;&nbsp;12LIST03.TXT--Simple Concatenation of Two Strings</H4>
<PRE><B>01 </B>Private Sub cmdBerry_Click()</PRE>
<PRE><B>02 </B>Dim strMine As String</PRE>
<PRE><B>03 </B>Dim strYours As String</PRE>
<PRE>04 Dim strResult As String</PRE>
<PRE><B>05</B></PRE>
<PRE><B>06 </B>strMine = &quot;blue&quot;</PRE>
<PRE><B>07 </B>strYours = &quot;berry&quot;</PRE>
<PRE><B>08 </B>strResult = strMine &amp; strYours</PRE>
<PRE><B>09</B></PRE>
<PRE><B>10 </B>cmdBerry.Caption = strResult</PRE>
<PRE><B>11 </B>End Sub</PRE>
<P>You can also concatenate more than two strings together with the &amp; operator.
For example, you might want to add a space character between a first name and last
name, as shown in Listing 12.4. Figure 12.5 shows Listing 12.4's code in action.</P>
<P>
<H4>LISTING 12.4&nbsp;&nbsp;12LIST04.TXT--Concatenating More Than Two Strings</H4>
<PRE><B>01 </B>Private Sub cmdFullName_Click()</PRE>
<PRE><B>02 </B>Dim strFirst As String</PRE>
<PRE><B>03 </B>Dim strLast As String</PRE>
<PRE><B>04 </B>Dim strFull As String</PRE>
<PRE><B>05</B></PRE>
<PRE><B>06 </B>`Get the first name for the textbox</PRE>
<PRE><B>07 </B>strFirst = txtFirst.Text</PRE>
<PRE><B>08</B></PRE>
<PRE><B>09 </B>`Get the last name from another textbox</PRE>
<PRE><B>10 </B>strLast = txtSecond.Text</PRE>
<PRE><B>11</B></PRE>
<PRE><B>12 </B>`Concatenate the first and last name, putting</PRE>
<PRE><B>13 </B>`a space character between them.</PRE>
<PRE><B>14 </B>strFull = strFirst &amp; &quot; &quot; &amp; strLast</PRE>
<PRE><B>15</B></PRE>
<PRE><B>16 </B>`Display the Full Name</PRE>
<PRE><B>17 </B>lblResult.Caption = strFull</PRE>
<PRE><B>18</B></PRE>
<PRE><B>19 </B>End Sub</PRE>
<P><A HREF="javascript:popUp('12fig04.gif')"><B>FIGURE 12.5</B></A> <I>Using the
+ character to concatenate strings is a holdover from earlier versions of Visual
Basic and can produce unwanted results if your string variables have numbers in them.
See the sample program later in the section &quot;Controlling Data Types with Typecasting.&quot;</I></P>
<P>
<H3><A NAME="Heading5"></A>Determining a String's Length with Len()</H3>
<P>You use the Visual Basic Len() function to determine how many characters are in
a given string. You'll use this function often, particularly with the other string-manipulation
functions.</P>
<P>The syntax of the Len() function is as follows:</P>
<P>
<PRE><I>intResult</I> = Len(<I>strMyString</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>intResult</I> is an integer that contains the number of characters returned
	by the function.
	<P>
	<LI>Len is the name of the function.
	<P>
	<LI><I>strMyString</I> is the string, the length of which you want to determine.
</UL>

<P>Listing 12.5 shows how to use the Len() function. Figure 12.6 shows the result
of Listing 12.5 in action.</P>
<P>
<H4>LISTING 12.5&nbsp;&nbsp;12LIST05.TXT--Using the Len() Function</H4>
<PRE><B>01 </B>Private Sub cmdFindLen_Click()</PRE>
<PRE><B>02 </B>Dim strFind As String</PRE>
<PRE><B>03 </B>Dim intLen As Integer</PRE>
<PRE><B>04</B></PRE>
<PRE><B>05 </B>`Assign a string to find to the local variable</PRE>
<PRE><B>06 </B>strFind = txtFirst.Text</PRE>
<PRE><B>07</B></PRE>
<PRE><B>08 </B>`Find the length of the string</PRE>
<PRE><B>09 </B>intLen = Len(strFind)</PRE>
<PRE><B>10</B></PRE>
<PRE><B>11 </B>`Report the results</PRE>
<PRE><B>12 </B>lblResult.Caption = CStr(intLen)</PRE>
<PRE><B>13 </B>End Sub</PRE>
<P><A HREF="javascript:popUp('12fig05.gif')"><B>FIGURE 12.6</B></A><I> You can also
use Len() to find the size (in bytes) of a nonstring variable.</I></P>
<P>
<H3><A NAME="Heading6"></A>Truncating Strings with Left() and Right()</H3>
<P>You use the Left() and Right() functions to truncate strings. Informally, to <I>truncate</I>
a string means to cut off part of it to make the string smaller. The Left() function
returns a certain number of characters from the left side of a given string to a
buffer string. (A <I>buffer string</I> is a holding string.)</P>
<P>The Right() function is similar to the Left() function, but rather than return
characters from the left side of a string, Right() returns a given number of characters
from the right side of a string.</P>
<P>The following is the syntax for the Left() and Right() functions:</P>
<P>
<PRE><I>strResult</I> = Left(<I>MyString</I>, <I>lNumToReturn</I>)
<I>strResult</I> = Right(<I>MyString</I>, <I>lNumToReturn</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>strResult</I> is the string returned from the function.
	<P>
	<LI>Left and Right are the function names.
	<P>
	<LI><I>MyString</I> is the string on which you want to perform the function.
	<P>
	<LI><I>lNumToReturn</I> is a Long that indicates the number of characters that you
	want to return. The least amount of characters you can return is 1. Using 0 (zero)
	will produce an error.
</UL>

<P>Listing 12.6 shows how to use the Left() and Right() functions to truncate a given
amount of characters from a string. Figure 12.7 shows the result of this code.</P>
<P>
<H4>LISTING 12.6&nbsp;&nbsp;12LIST06.TXT--Using the Left() and Right() Functions</H4>
<PRE><B>01 </B>Private Sub cmdLeft_Click()</PRE>
<PRE><B>02 </B>Dim intChrCnt As Integer `Number of characters</PRE>
<PRE><B>03 </B>Dim strBuffer As String `String buffer</PRE>
<PRE><B>04 </B>Dim strMyString As String `String to truncate</PRE>
<PRE><B>05</B></PRE>
<PRE><B>06 </B>`Convert the numeral for the number of</PRE>
<PRE><B>07 </B>`characters to truncate to a number</PRE>
<PRE><B>08 </B>intChrCnt = CInt(txtSecond.Text)</PRE>
<PRE><B>09</B></PRE>
<PRE><B>10 </B>`Get the string to truncate</PRE>
<PRE><B>11 </B>strMyString = txtFirst.Text</PRE>
<PRE><B>12</B></PRE>
<PRE><B>13 </B>`Truncate the string by using the Left() function</PRE>
<PRE><B>14 </B>strBuffer = Left(strMyString, intChrCnt)</PRE>
<PRE><B>15</B></PRE>
<PRE><B>16 </B>`Display the results</PRE>
<PRE><B>17 </B>lblResult.Caption = strBuffer</PRE>
<PRE><B>18 </B>End Sub</PRE>
<PRE><B>19</B></PRE>
<PRE><B>20 </B>Private Sub cmdRight_Click()</PRE>
<PRE><B>21 </B>Dim intChrCnt `Number of characters to return</PRE>
<PRE><B>22 </B>Dim strBuffer `string buffer</PRE>
<PRE><B>23 </B>Dim strMyString As String `string to truncate</PRE>
<PRE><B>24</B></PRE>
<PRE><B>25 </B>`Convert the numeral for the number of</PRE>
<PRE><B>26 </B>`characters to truncate to a number</PRE>
<PRE><B>27 </B>intChrCnt = CInt(txtSecond.Text)</PRE>
<PRE><B>28</B></PRE>
<PRE><B>29 </B>`Get the string to truncate</PRE>
<PRE><B>30 </B>strMyString = txtFirst.Text</PRE>
<PRE><B>31</B></PRE>
<PRE><B>32 </B>`Truncate the string by using the Right() function</PRE>
<PRE><B>33 </B>strBuffer = Right(strMyString, intChrCnt)</PRE>
<PRE><B>34</B></PRE>
<PRE><B>35 </B>`Display the results</PRE>
<PRE><B>36 </B>lblResult.Caption = strBuffer</PRE>
<PRE><B>37 </B>End Sub</PRE>
<P><A HREF="javascript:popUp('12fig06a.gif')"><B>FIGURE 12.7</B></A> <I>Left() returns
a given number of characters from the left side of a string; Right() returns a given
number of characters from the right side.</I></P>

<P><A HREF="javascript:popUp('12fig06b.gif')"><B>FIGURE 12.7b</B></A><I></I></P>
<P>
<H3><A NAME="Heading7"></A>Using Mid() to Return Characters from Inside a String</H3>
<P>The Mid() function returns a string of a given number of characters from a specified
location in another string. For example, if you want to return the string &quot;Allen&quot;
from the string &quot;Edgar Allen Poe&quot;, you use the Mid() function.</P>
<P>The syntax for the Mid() function is as follows:</P>
<P>
<PRE><I>strResult</I> = Mid(<I>MyString</I>, <I>lngStart</I>[, <I>lngSize</I>])
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>strResult</I> is the string returned from the function.
	<P>
	<LI>Mid is the function name.
	<P>
	<LI><I>MyString</I> is the string from which to extract the return string.
	<P>
	<LI><I>lngStart</I> is a value of type Long that reflects the position on which the
	characters to extract begin. If this number is larger than the size of <I>strMyString</I>,
	the return will be an empty string (&quot;&quot;). This number can't be less than
	1.
	<P>
	<LI><I>lngSize</I> is an optional value of type Long that reflects the number of
	characters to return from <I>strMyString</I>. If you don't specify a length, Mid()
	returns all the characters starting from the position determined by <I>lngStart</I>
	to the end of the string <I>strMyString</I>. For example, in the following code,
	the value of strResult is r All:
</UL>

<PRE>MyString = &quot;Edgar Allen Poe&quot;,
</PRE>
<PRE>strResult = Mid(MyString, 5, 5)
</PRE>

<UL>
	<LI>In the following example, the value of strResult is r Allen Poe:
</UL>

<PRE>MyString = &quot;Edgar Allen Poe&quot;,
strResult = Mid(MyString, 5)
</PRE>
<P>Listing 12.7 shows you how to use the Mid() function to extract a substring from
a string.</P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>The space character occupies a character position</STRONG></P>
	<P>Notice in this example that the space clearly occupies position 6 and Allen doesn't
	start until position 7. 
<HR>


</BLOCKQUOTE>

<H4>LISTING 12.7&nbsp;&nbsp;12LIST07.TXT--Using the Mid() Function</H4>
<PRE><B>01 </B>Private Sub cmdSimpleMid_Click()</PRE>
<PRE><B>02 </B>Dim strBuffer As String `String Buffer</PRE>
<PRE><B>03 </B>Dim strMyString As String `The string on which</PRE>
<PRE><B>04 </B>`to perform the Mid() function</PRE>
<PRE><B>05</B></PRE>
<PRE><B>06 </B>Dim lngStart As Long `The starting position</PRE>
<PRE><B>07 </B>`of the Mid()function</PRE>
<PRE><B>08</B></PRE>
<PRE><B>09 </B>Dim lngSize As Long `Size of the string to return</PRE>
<PRE><B>10</B></PRE>
<PRE><B>11 </B>`Assign the text in the first textbox to the</PRE>
<PRE><B>12 </B>`MyString variable</PRE>
<PRE><B>13 </B>strMyString = txtFirst.Text</PRE>
<PRE><B>14</B></PRE>
<PRE><B>15 </B>`Convert the numeral in the second textbox to a</PRE>
<PRE><B>16 </B>`LONG and assign it to the starting position</PRE>
<PRE><B>17 </B>`variable.</PRE>
<PRE><B>18 </B>lngStart = CLng(txtSecond.Text)</PRE>
<PRE><B>19</B></PRE>
<PRE><B>20 </B>`Convert the numeral in the third textbox to a</PRE>
<PRE><B>21 </B>`LONG and assign it to the return size variable.</PRE>
<PRE><B>22 </B>lngSize = CLng(txtThird.Text)</PRE>
<PRE><B>23</B></PRE>
<PRE><B>24 </B>`Run the Mid() function and assign the result to</PRE>
<PRE><B>25 </B>`the buffer variable.</PRE>
<PRE><B>26 </B>strBuffer = Mid(strMyString, lngStart, lngSize)</PRE>
<PRE><B>27</B></PRE>
<PRE><B>28 </B>`Display the result in a textbox.</PRE>
<PRE><B>29 </B>txtHold.Text = strBuffer</PRE>
<PRE><B>30 </B>End Sub</PRE>
<P>The Mid() function is powerful. It takes some practice to get accustomed to using
it. Remember the following helpful hints:</P>

<UL>
	<LI>The value of the start position variable must be at least 1.
	<P>
	<LI>Characters in strings start at 1, unlike array indices, which start at 0.
	<P>
	<LI>If you don't specify a return size variable for the return string, the Mid()
	function returns all characters from the value of the start position variable to
	the end of the string.
</UL>

<H3><A NAME="Heading8"></A>Using InStr() to Search for Characters Within a String</H3>
<P>You use the InStr() function to determine whether a character or string exists
within another string. If it does, the function returns a Long that reflects the
position of the located string. For example, if you want to know whether a decimal
character is in a string, 123.345, you use the Instr() function. The syntax for the
InStr() function is</P>
<P>
<PRE><I>lngResult</I> = InStr([<I>intStart</I>, ]<I>strMyString</I>, <I>strFind</I>[, <I>intCompare</I>])
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>lngResult</I> is the returned Long value that indicates the position of the
	first found instance of the <I>strLookedFor</I> string in the string <I>strMyString</I>.
	<P>
	<LI>InStr is the function name.
	<P>
	<LI><I>lngStart</I> is an optional number that indicates where to start looking.
	If you omit it, the function starts searching at the beginning of the string <I>strMyString</I>.
	<P>
	<LI><I>strMyString</I> is the string in which the function searches for the substring
	<I>strFind</I>.
	<P>
	<LI><I>strFind</I> is the string or character for which you're searching.
	<P>
	<LI><I>intCompare</I> is the number that indicates how to look for the string <I>strFind</I>.
	If you omit this argument or set it to zero, InStr() does a case-sensitive search.
	If you include <I>intCompare</I> with the value 1, the search won't be case sensitive.
</UL>

<P>Listing 12.8 shows you how to use the InStr() function; Figure 12.8 shows the
code in action.</P>
<P>
<H4>LISTING 12.8&nbsp;&nbsp;12LIST08.TXT--Using the InStr() Function</H4>
<PRE><B>01 </B>Private Sub cmdInStr_Click()</PRE>
<PRE><B>02 </B>Dim lngResult As Long</PRE>
<PRE><B>03 </B>Dim strMyString As String</PRE>
<PRE><B>04 </B>Dim strFind As String</PRE>
<PRE><B>05 </B>Dim lngStart As Long</PRE>
<PRE><B>06</B></PRE>
<PRE><B>07 </B>`Assign the value for the string in which you are</PRE>
<PRE><B>08 </B>`going to look for your character or string.</PRE>
<PRE><B>09 </B>strMyString = txtFirst.Text</PRE>
<PRE><B>10</B></PRE>
<PRE><B>11 </B>`Get the string you want to look for from the</PRE>
<PRE><B>12 </B>`TextBox</PRE>
<PRE><B>13 </B>strFind = txtSecond.Text</PRE>
<PRE><B>14</B></PRE>
<PRE><B>15 </B>`If the TextBox is not empty, get the starting</PRE>
<PRE><B>16 </B>`position for the search</PRE>
<PRE><B>17 </B>If txtThird.Text &lt;&gt; &quot;&quot; Then</PRE>
<PRE><B>18 </B>lngStart = CLng(txtThird.Text)</PRE>
<PRE><B>19 </B>Else</PRE>
<PRE><B>20 </B>`If it is empty, set the starting position to</PRE>
<PRE><B>21 </B>`the first character</PRE>
<PRE><B>22 </B>lngStart = 1</PRE>
<PRE><B>23 </B>End If</PRE>
<PRE><B>24 </B>lngResult = InStr(lngStart, strMyString, strFind)</PRE>
<PRE><B>25</B></PRE>
<PRE><B>26 </B>`Display the answer</PRE>
<PRE><B>27 </B>txtHold.Text = CStr(lngResult)</PRE>
<PRE><B>28 </B>End Sub</PRE>
<P><A HREF="javascript:popUp('12fig07.gif')"><B>FIGURE 12.8</B></A> <I>The InStr()
function reports the position of the first occurrence of a given character or string.
To search for other occurrences, you must set the function's lngStart argument.</I></P>
<P>
<H2><A NAME="Heading9"></A>Using Strings and Arrays of Strings</H2>
<P>One of the more time-consuming parts of working with strings and arrays of strings
is the extensive programming required to manipulate and prepare lists. Many extensive
programs have been written to handle the tasks. The following three new functions
provide easy control over any long string of words and provide for the creation of
arrays from those lists.</P>
<P>The sample program used in this section reads a long string of modem filenames
from a text file and then demonstrates the use of each new function. Listing 12.9
details the declarations and the first command button that loads the list of filenames
into a public string variable; Figure 12.9 shows the initial screen.</P>
<P>
<H4>LISTING 12.9&nbsp;&nbsp;12LIST09.TXT--Declarations and Load Statements for the
<BR>
Filter.vbp Program</H4>
<PRE><B>01 </B>Public strModems As String</PRE>
<PRE><B>02 </B>Public varFull As Variant</PRE>
<PRE><B>03 </B>Public varFilter As Variant</PRE>
<PRE><B>04</B></PRE>
<PRE><B>05 </B>Public Sub Form_Load()</PRE>
<PRE><B>06 </B>`When the form is loaded, display the current path</PRE>
<PRE><B>07 </B>` and the filename. Clear the two ListBoxes</PRE>
<PRE><B>08 </B>txtDir.Text = CurDir &amp; &quot;\MODEM.TXT&quot;</PRE>
<PRE><B>09 </B>lstFull.Clear</PRE>
<PRE><B>10 </B>lstFilter.Clear</PRE>
<PRE><B>11 </B>End Sub</PRE>
<PRE><B>12</B></PRE>
<PRE><B>13 </B>Private Sub cmdLoad_Click()</PRE>
<PRE><B>14 </B>Dim intFile As Integer</PRE>
<PRE><B>15 </B>` Find the next free File handle</PRE>
<PRE><B>16 </B>intFile = FreeFile</PRE>
<PRE><B>17 </B>` Open the modem file for input and then read</PRE>
<PRE><B>18 </B>` the first and only row into Public strModem</PRE>
<PRE><B>19 </B>Open CurDir &amp; &quot;\MODEM.TXT&quot; For Input As #intFile</PRE>
<PRE><B>20 </B>Input #intFile, strModems</PRE>
<PRE><B>21 </B>Close #intFile</PRE>
<PRE><B>22 </B>`Display the String in the TextBox</PRE>
<PRE><B>23 </B>txtList.Text = strModems</PRE>
<PRE><B>24 </B>End Sub</PRE>
<P><A HREF="javascript:popUp('12fig08.gif')"><B>FIGURE 12.9</B></A> <I>The Filter.vbp
program starts with the Load File command, which reads a text file for a list of
modem filenames.</I></P>
<P>Line 23 in Listing 12.9 displays the contents of strModems in the second TextBox
on the form. This is the data used throughout the sample program and is a public
string variable. The program also uses two variant-type variables to hold the array
of strings for the Split() and Filter() examples.</P>
<P>
<H3><A NAME="Heading10"></A>Splitting a String into an Array of Strings with Split()</H3>
<P>Visual Basic's new Split() function takes a list of words or numeric values stored
in a string and breaks them into individual elements of an array of strings. In past
versions of Visual Basic, this function would require several complex programming
steps to walk through the string and build the array. The key to using this function
is knowing how the string to be separated is constructed. In the case of a sentence,
a space acts as the delimiter. A row from a data file can contain numbers and words
separated by a comma. Either option will work with this function.</P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>Delimiters can be more than one character</STRONG></P>
	<P>Delimiters aren't limited to a single character, such as a space or a comma. Any
	valid string of characters can be used. The important feature to remember is that
	the delimiter isn't returned with the substring. If the only distinguishing separator
	is an important part of the word or data field, you can add the delimiter back after
	creating the array. 
<HR>


</BLOCKQUOTE>

<P>The syntax for Split() is as follows:</P>
<P>
<PRE><I>varResult</I> = Split(<I>strList</I>, <I>strDelimiter</I>, <I>intElemCnt</I>, <I>intCompare</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>varResult</I> is the variant that contains a one-dimensional array of strings
	returned from the function.
	<P>
	<LI>Split is the function name.
	<P>
	<LI><I>strList</I> is the string list that's to be separated by the function.
	<P>
	<LI><I>strDelimiter</I> is the character or string of characters used to identify
	the separate elements of the string. Delimiters are used to find the end point of
	the current element and the starting point for the next element in the array. The
	delimiters are dropped and not returned with the substrings. The default value is
	the space character, which is the ASCII character code 32. If a zero-length string
	is used for the delimiter, the entire string is loaded into the first element of
	the array.
	<P>
	<LI><I>intElemCnt</I> is the number of string array elements to create from the <I>strList</I>.
	<P>
	<LI><I>intCompare</I> is the integer that indicates case sensitivity for the function
	when identifying the delimiters in the <I>strList</I>. The default value is zero,
	which indicates a case-sensitive search. <I>intCompare</I> uses the following values:
</UL>

<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>Constant</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Value</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Description</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbUseCompareOption</TD>
		<TD ALIGN="LEFT">-1</TD>
		<TD ALIGN="LEFT">Performs a comparison by using the setting of the Option Compare statement</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbBinaryCompare</TD>
		<TD ALIGN="LEFT">0</TD>
		<TD ALIGN="LEFT">Performs a binary comparison</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbTextCompare</TD>
		<TD ALIGN="LEFT">1</TD>
		<TD ALIGN="LEFT">Performs a textual comparison</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">vbDatabaseCompare</TD>
		<TD ALIGN="LEFT">2</TD>
		<TD ALIGN="LEFT">Performs a comparison based on information in your database (for Microsoft Access
			only)</TD>
	</TR>
</TABLE>
</P>
<P>Listing 12.10 shows the Split() function being used to turn a long string into
a array of strings. Lines 21-23 detail the For...Loop that's used to add the elements
of the array of strings to the ListBox. The lstFull ListBox contains all the values
in the strModems string unless the delimited CheckBox is selected. Lines 7-14 check
this condition, and if checked, the list is built with only six values from the original.</P>
<P>
<H4>LISTING 12.10&nbsp;&nbsp;12LIST10.TXT--String Splitting with an Optional Delimiter</H4>
<PRE><B>01 </B>Private Sub cmdList_Click()</PRE>
<PRE><B>02 </B>Dim intRecCnt As Integer</PRE>
<PRE><B>03 </B>Dim intCntr As Integer</PRE>
<PRE><B>04</B></PRE>
<PRE><B>05 </B>`Check if the String is to be split with the default</PRE>
<PRE><B>06 </B>`delimiter.</PRE>
<PRE><B>07 </B>If chkDelimit.Value Then</PRE>
<PRE><B>08 </B>`If checked, use the value in the txtFilter</PRE>
<PRE><B>09 </B>`TextBox and limit the number of elements to 6</PRE>
<PRE><B>10 </B>varFull = Split(strModems, txtFilter.Text, 6)</PRE>
<PRE><B>11 </B>Else</PRE>
<PRE><B>12 </B>`If not checked, use the default values for Split()</PRE>
<PRE><B>13 </B>varFull = Split(strModems)</PRE>
<PRE><B>14 </B>End If</PRE>
<PRE><B>15</B></PRE>
<PRE><B>16 </B>`Determine the number of elements in the array</PRE>
<PRE><B>17 </B>intRecCnt = UBound(varFull)</PRE>
<PRE><B>18</B></PRE>
<PRE><B>19 </B>lstFull.Clear</PRE>
<PRE><B>20 </B>`Add Elements to ListBox for each element in array</PRE>
<PRE><B>21 </B>For intCntr = 0 To intRecCnt _</PRE>
<PRE><B>22 </B>lstFull.AddItem varFull(intCntr)</PRE>
<PRE><B>23 </B>Next intCntr</PRE>
<PRE><B>24</B></PRE>
<PRE><B>25 </B>Refresh</PRE>
<PRE><B>26 </B>End Sub</PRE>
<P>
<H3><A NAME="Heading11"></A>Creating a Sublist from an Array of Strings with Filter()</H3>
<P>The Filter() function builds on the power of the Split() function. When you have
your list in an array of strings, the Filter() function lets you create a new list
that's a filtered version of your first list. This function, like the Split() function,
returns an array of strings.</P>
<P>The syntax for Filter() follows:</P>
<P>
<PRE><I>varResult</I> = Filter(<I>varlist</I>, <I>strFind</I>, <I>bolInclude</I>, <I>intCompare</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>varResult</I> is the variant that contains a one-dimensional string array
	returned from the function.
	<P>
	<LI>Filter is the function name.
	<P>
	<LI><I>varList</I> is the variant that contains the string array that the function
	is to filter.<BR>
	<BR>
	
	<LI>n <I>strFind</I> is the string of characters used to identify which elements
	to include in the new string array.<BR>
	<BR>
	
	<LI><I>bolInclude</I> is the Boolean flag used to indicate whether elements containing
	the <I>strFind</I> value are included or excluded. By default, the elements are included.
	<P>
	<LI><I>intCompare</I> is the integer that indicates case sensitivity for the function
	when matching a <I>strFind</I> with the <I>varList</I> element. The default value
	is zero and performs a case-sensitive search.
</UL>

<P>If no matches of <I>strFind</I> are found within the string array <I>varList</I>,
the function returns an empty array. If <I>varList</I> is null or isn't a one-dimensional
array, an error is returned. Listing 12.11 shows the code used to select from an
array with the Filter() function.</P>
<P>
<H4>LISTING 12.11&nbsp;&nbsp;12LIST11.TXT--Using Filter() to Select from an Array</H4>
<PRE><B>01 </B>Private Sub CmdFilter_Click()</PRE>
<PRE><B>02 </B>Dim intRecCnt As Integer</PRE>
<PRE><B>03 </B>Dim intCntr As Integer</PRE>
<PRE><B>04</B></PRE>
<PRE><B>05 </B>`Create the Filtered array from the Full array</PRE>
<PRE><B>06 </B>varFilter = Filter(varFull, txtFilter.Text)</PRE>
<PRE><B>07</B></PRE>
<PRE><B>08 </B>`Determine the number of elements in the array</PRE>
<PRE><B>09 </B>intRecCnt = UBound(varFilter)</PRE>
<PRE><B>10</B></PRE>
<PRE><B>11 </B>lstFilter.Clear</PRE>
<PRE><B>12 </B>`Add Elements to ListBox for each element in the array</PRE>
<PRE><B>13 </B>For intCntr = 0 To intRecCnt _</PRE>
<PRE><B>14 </B>lstFilter.AddItem varFilter(intCntr)</PRE>
<PRE><B>15 </B>Next intCntr</PRE>
<PRE><B>16</B></PRE>
<PRE><B>17 </B>Refresh</PRE>
<PRE><B>18 </B>End Sub</PRE>
<P>
<H3><A NAME="Heading12"></A>Combining an Array of Strings with Join()</H3>
<P>The new Join() function is the counterpart to the Split() function. This function
combines all the elements in an array of strings into one single string. The optional
delimiter enables the delineation of the separate elements on the string, which allows
for enhanced processing in the future.</P>
<P>The syntax for Join() is as follows:</P>
<P>
<PRE><I>strResult</I> = Join(<I>varList</I>, <I>strDelimiter</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>strResult</I> is the string that contains the concatenation of the array and
	the delimiters returned by the function.
	<P>
	<LI>Join is the function name.
	<P>
	<LI><I>varList</I> is a variant that contains a one-dimensional string array that
	the function will combine.
	<P>
	<LI><I>strDelimiter</I> is the character, or string of characters, that's placed
	between the separate elements of the array when combined into the <I>strResult</I>.
	The delimiter is used to mark the end point of each element and the starting point
	for the next element in the string. The default delimiter is the space character.
	If a zero-length string is used for the delimiter, the string is built without delimiters.
</UL>

<P>Line 9, or line 12, performs the join in Listing 12.12. If the delimited CheckBox
has been marked, the join will use the value in the txtFilter.Text property (line
9) for the delimiter. The sample program lets you try various combinations of characters
for delimiters. The resulting new string is placed in the txtListBox, which is the
highlighted ListBox in Figure 12.10. Notice that in this example, two characters
(**) are used as a delimiter.</P>
<P>
<H4>LISTING 12.12&nbsp;&nbsp;12LIST12.TXT--Putting Together an Array of Strings</H4>
<PRE><B>01 </B>Private Sub CmdJoin_Click()</PRE>
<PRE><B>02 </B>Dim intRecCnt As Integer</PRE>
<PRE><B>03 </B>Dim intCntr As Integer</PRE>
<PRE><B>04</B></PRE>
<PRE><B>05 </B>`Check if the Join will use the default delimiter</PRE>
<PRE><B>06 </B>If chkDelimit.Value Then</PRE>
<PRE><B>07 </B>`If checked, use the value in the txtFilter</PRE>
<PRE><B>08 </B>`TextBox to separate the Sub-strings</PRE>
<PRE><B>09 </B>txtList.Text = Join(varFilter, txtFilter.Text)</PRE>
<PRE><B>10 </B>Else</PRE>
<PRE><B>11 </B>`If not checked, use the default values for Join()</PRE>
<PRE><B>12 </B>txtList.Text = Join(varFilter)</PRE>
<PRE><B>13 </B>End If</PRE>
<PRE><B>14 </B>Refresh</PRE>
<PRE><B>15 </B>End Sub</PRE>
<P><A HREF="javascript:popUp('12fig09.gif')"><B>FIGURE 12.10</B></A> <I>You can join
an array of strings by using any character as the delimiter.</I></P>
<P>
<H2><A NAME="Heading13"></A>Changing a String's Case with UCase() and LCase()</H2>
<P>The UCase() and LCase() functions affect the case of a given string or character.
The UCase() function returns a string in which all the characters are set to uppercase,
whereas the LCase() function returns a string in which all the characters are set
to lowercase. The following is the syntax for the UCase() and LCase() functions:</P>
<P>
<PRE><I>strResult</I> = UCase(<I>strMyString</I>)
<I>strResult</I> = LCase(<I>strMyString</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>strResult</I> is the string returned from the function.
	<P>
	<LI>UCase|LCase are the function names.
	<P>
	<LI><I>strMyString</I> is the string to set to uppercase (or lowercase).
</UL>

<P>Listing 12.13 shows you how to use UCase() and LCase() to set a given string to
uppercase and lowercase; Figure 12.11 shows the code example in action.</P>
<P>
<H4>LISTING 12.13&nbsp;&nbsp;12LIST13.TXT--Using the UCase() and LCase() Functions</H4>
<PRE><B>01 </B>Private Sub cmdUpper_Click()</PRE>
<PRE><B>02 </B>Dim strBuffer As String `string buffer</PRE>
<PRE><B>03 </B>`Assign the characters in the first textbox</PRE>
<PRE><B>04 </B>`to the buffer variable</PRE>
<PRE><B>05 </B>strBuffer = txtFirst.Text</PRE>
<PRE><B>06</B></PRE>
<PRE><B>07 </B>`Set all the characters in the buffer to</PRE>
<PRE><B>08 </B>`uppercase and display the result</PRE>
<PRE><B>09 </B>lblResult.Caption = UCase(strBuffer)</PRE>
<PRE><B>10 </B>End Sub</PRE>
<PRE><B>11</B></PRE>
<PRE><B>12 </B>Private Sub cmdLower_Click()</PRE>
<PRE><B>13 </B>Dim strBuffer As String `String buffer</PRE>
<PRE><B>14 </B>`Assign the characters in the first textbox</PRE>
<PRE><B>15 </B>`to the buffer variable</PRE>
<PRE><B>16 </B>strBuffer = txtFirst.Text</PRE>
<PRE><B>17</B></PRE>
<PRE><B>18 </B>`Set all the characters in the buffer to</PRE>
<PRE><B>19 </B>`lowercase and display the result</PRE>
<PRE><B>20 </B>lblResult.Caption = LCase(strBuffer)</PRE>
<PRE><B>21 </B>End Sub</PRE>
<P><B>FIGURE 12.11</B> <I>UCase() and LCase() are closely related functions.</I></P>
<P>
<H2><A NAME="Heading14"></A>Using String-Parsing Functions</H2>
<P>Now that you've seen how to do basic string manipulation with the Len(), Left(),
Right(), Mid(), and InStr() functions, you're going to put what you've learned to
more detailed use.</P>
<P><I>String parsing</I>--the activity of stripping and manipulating strings--is
a common activity among programmers. One of the most common parsing requirements
that programmers encounter is retrieving the first-name string and the last-name
string from a full-name string. You'll now study a set of user-defined functions
that do this: GetFirstName(), which returns the first name from the full name, and
GetLastName(), which returns the last name from the full name. Both functions take
one argument: a string indicating the full name. These functions are designed around
a central conceptual principle (and assumption) that within a full-name string, the
first name is separated from the last name by a space character and that if you know
the location of the space character in the full-name string, you can strip out the
first-name characters and the last-name characters.</P>
<P>Figure 12.12 illustrates the logic of determining the first-name and last-name
strings from a full-name string. In Listing 12.14, you can see the code for the functions
GetFirstName() and GetLastName().</P>
<P><A HREF="javascript:popUp('12fig11.gif')"><B>FIGURE 12.12</B></A> <I>The most
important thing that you need to know in order to parse names from a string is the
position of the space characters.</I></P>
<P>
<H4>LISTING 12.14&nbsp;&nbsp;12LIST14.TXT--Using GetFirstName() and GetLastName()
to Parse<BR>
Strings</H4>
<PRE><B>01 </B>Public Function GetFirstName(strFullName As String) _</PRE>
<PRE>As String</PRE>
<PRE>...</PRE>
<PRE><B>20 </B>Dim lSpacePos As Long `Position of space char</PRE>
<PRE><B>21 </B>`in a string</PRE>
<PRE><B>22 </B>Dim strSpaceChar As String `Space character</PRE>
<PRE><B>23 </B>Dim strFirstName As String `Buffer for First Name</PRE>
<PRE><B>24 </B>Dim lngResult As Long `Result variable</PRE>
<PRE><B>25 </B>Dim lngLeftLen As Long `Number of characters</PRE>
<PRE><B>26 </B>`Name</PRE>
<PRE><B>27</B></PRE>
<PRE><B>28 </B>`Use the IsValid function to make sure that the</PRE>
<PRE><B>29 </B>`Full Name string has only one space character in it</PRE>
<PRE><B>30 </B>If IsValid(strFullName) = False Then</PRE>
<PRE><B>31 </B>`If it doesn't, return the error string</PRE>
<PRE><B>32 </B>GetFirstName = &quot;Error&quot;</PRE>
<PRE><B>33 </B>`And exit the function</PRE>
<PRE><B>34 </B>Exit Function</PRE>
<PRE><B>35 </B>End If</PRE>
<PRE><B>36</B></PRE>
<PRE><B>37 </B>`Define space character</PRE>
<PRE><B>38 </B>strSpaceChar = &quot; &quot;</PRE>
<PRE><B>39</B></PRE>
<PRE><B>40 </B>`Find the position of the space character within the</PRE>
<PRE><B>41 </B>`full-name string.</PRE>
<PRE><B>42 </B>lngResult = InStr(1, strFullName, strSpaceChar)</PRE>
<PRE><B>43</B></PRE>
<PRE><B>44 </B>`The position of the space character is also</PRE>
<PRE><B>45 </B>`the length to extract for the left side (First Name)</PRE>
<PRE><B>46 </B>lngLeftLen = lngResult</PRE>
<PRE><B>47</B></PRE>
<PRE>48 `Extract the First Name and assign it to the</PRE>
<PRE><B>49 </B>`First Name variable</PRE>
<PRE><B>50 </B>strFirstName = Left(strFullName, lngLeftLen)</PRE>
<PRE><B>51</B></PRE>
<PRE><B>52 </B>`Return the value of the first name</PRE>
<PRE><B>53 </B>GetFirstName = strFirstName</PRE>
<PRE><B>54 </B>End Function</PRE>
<PRE><B>55</B></PRE>
<PRE><B>56 </B>Public Function GetLastName(strFullName As String) _</PRE>
<PRE>As String</PRE>
<PRE>...</PRE>
<PRE><B>75 </B>Dim lSpacePos As Long `Position of space</PRE>
<PRE><B>76 </B>`character in a string</PRE>
<PRE><B>77 </B>Dim strSpaceChar As String `Space character</PRE>
<PRE><B>78 </B>Dim strLastName As String `Buffer string</PRE>
<PRE><B>79 </B>Dim lngResult As Long `Result variable</PRE>
<PRE><B>80 </B>Dim lRightLen As Long `Num of chars in Last Name</PRE>
<PRE><B>81</B></PRE>
<PRE><B>82 </B>`Use the IsValid function to make sure that the</PRE>
<PRE><B>83 </B>`Full Name string has only one space character.</PRE>
<PRE><B>84 </B>If IsValid(strFullName) = False Then</PRE>
<PRE><B>85 </B>`If it doesn't, return the error string</PRE>
<PRE><B>86 </B>GetLastName = &quot;Error&quot;</PRE>
<PRE><B>87 </B>`And exit the function</PRE>
<PRE><B>88 </B>Exit Function</PRE>
<PRE><B>89 </B>End If</PRE>
<PRE><B>90</B></PRE>
<PRE><B>91 </B>`Define space character</PRE>
<PRE><B>92 </B>strSpaceChar = &quot; &quot;</PRE>
<PRE><B>93</B></PRE>
<PRE><B>94 </B>`Find the position of the space character</PRE>
<PRE><B>95 </B>lngResult = InStr(1, strFullName, strSpaceChar)</PRE>
<PRE><B>96</B></PRE>
<PRE><B>97 </B>`Define the number of characters to extract from</PRE>
<PRE><B>98 </B>`the right of the space character, (Last Name).</PRE>
<PRE><B>99 </B>`If you subtract the position of the space character</PRE>
<PRE><B>100 </B>`for the total number of characters in the Full Name</PRE>
<PRE><B>101 </B>`string, this will yield the number of characters to</PRE>
<PRE><B>102 </B>`extract from the right side of the Full Name string.</PRE>
<PRE><B>103 </B>`This technique avoids including the space character</PRE>
<PRE><B>104 </B>`itself by accident.</PRE>
<PRE><B>105 </B>lRightLen = Len(strFullName) - lngResult</PRE>
<PRE><B>106</B></PRE>
<PRE><B>107 </B>`Extract the right side of the Full Name string and</PRE>
<PRE><B>108 </B>`assign it to the Last Name Buffer</PRE>
<PRE><B>109 </B>strLastName = Right(strFullName, lRightLen)</PRE>
<PRE><B>110</B></PRE>
<PRE><B>111 </B>`Return the value of the Last Name string out of the</PRE>
<PRE><B>112 </B>`function.</PRE>
<PRE><B>113 </B>GetLastName = strLastName</PRE>
<PRE><B>114 </B>End Function</PRE>
<P>You might have a full name that contains a middle name or middle initial or have
a last name made up of two strings, such as Von Beethoven. In this case, the function
wouldn't be valid. You build a <I>validation</I> function, IsValid(), to determine
whether the string can be parsed into a first name and last name. Figure 12.13 illustrates
the logic for the user-defined function IsValid(), and Listing 12.15 shows the code
for the function.</P>
<P><A HREF="javascript:popUp('12fig12.gif')"><B>FIGURE 12.13</B></A> <I>Loops are
an excellent way to traverse a string, provided you know the string's length.</I></P>
<P>
<H4>LISTING 12.15&nbsp;&nbsp;12LIST15.TXT--Testing to Verify Only One Space Character
Per <BR>
String</H4>
<PRE><B>01 </B>Public Function IsValid(strFullName) As Boolean</PRE>
<PRE><B>02 </B>`****************************************</PRE>
<PRE><B>03 </B>`Sub/Function: IsValid</PRE>
<PRE><B>04 </B>`</PRE>
<PRE><B>05 </B>`Arguments: strFullName A string representing a full</PRE>
<PRE><B>06 </B>` name to validate</PRE>
<PRE><B>07 </B>`</PRE>
<PRE><B>08 </B>`Return: True, if the string has only 1</PRE>
<PRE><B>09 </B>` character</PRE>
<PRE><B>10 </B>`</PRE>
<PRE><B>11 </B>`Remarks: This function is used to</PRE>
<PRE><B>12 </B>` determine if more than one</PRE>
<PRE><B>13 </B>` space character exists in a string.</PRE>
<PRE><B>14 </B>`</PRE>
<PRE><B>15 </B>`Programmer: Bob Reselman</PRE>
<PRE><B>16 </B>`</PRE>
<PRE><B>17 </B>`Copyright 1998, Macmillan Publishing</PRE>
<PRE><B>18 </B>`****************************************</PRE>
<PRE><B>19</B></PRE>
<PRE><B>20 </B>Dim intSpaces As Integer `Hold the count of the</PRE>
<PRE><B>21 </B>`number ofspaces in a string</PRE>
<PRE><B>22 </B>Dim intChars As Integer `Number of characters</PRE>
<PRE><B>23 </B>Dim intCntr As Integer `Counter variable</PRE>
<PRE><B>24 </B>Dim strSpace As String `The space character</PRE>
<PRE><B>25 </B>Dim strPresent As String `A buffer to hold one</PRE>
<PRE><B>26 </B>`character to examine</PRE>
<PRE>27 `Define the space character</PRE>
<PRE><B>28 </B>strSpace = &quot; &quot;</PRE>
<PRE><B>29</B></PRE>
<PRE><B>30 </B>`Find out how many characters are in the full name</PRE>
<PRE><B>31 </B>intChars = Len(strFullName)</PRE>
<PRE><B>32</B></PRE>
<PRE><B>33 </B>`Loop through the entire string, strFullName</PRE>
<PRE><B>34 </B>For intCntr = 1 To intChars</PRE>
<PRE><B>35 </B>`Look at each character one at a time</PRE>
<PRE><B>36 </B>strPresent = Mid$(strFullName, intCntr, 1)</PRE>
<PRE><B>37 </B>`If the character that you are inspecting is a</PRE>
<PRE><B>38 </B>`space....</PRE>
<PRE><B>39 </B>If strPresent = strSpace Then</PRE>
<PRE><B>40 </B>`...Increment the space counter variable by 1</PRE>
<PRE><B>41 </B>intSpaces = intSpaces + 1</PRE>
<PRE><B>42 </B>End If</PRE>
<PRE><B>43 </B>Next intCntr</PRE>
<PRE><B>44</B></PRE>
<PRE><B>45 </B>`If there is only one space in the Full Name string...</PRE>
<PRE><B>46 </B>If intSpaces = 1 Then</PRE>
<PRE><B>47 </B>`...return True</PRE>
<PRE><B>48 </B>IsValid = True</PRE>
<PRE><B>49 </B>Else</PRE>
<PRE><B>50 </B>`If not, return False</PRE>
<PRE><B>51 </B>IsValid = False</PRE>
<PRE><B>52 </B>End If</PRE>
<PRE><B>53 </B>End Function</PRE>
<P>If you want to see this code in action, go to the project AdvncStr.VBP, which
you can download from <A target="_new" HREF="javascript:if(confirm('http:// www.mcp.com/info  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http:// www.mcp.com/info'" tppabs="http:// www.mcp.com/info">http:// www.mcp.com/info</A>.
When you run the code, you'll see buttons for the GetFirstName() and GetLastName()
functions, as well as one to test the IsValid() function. Enter a full name in the
txtHold TextBox and then click the buttons to see the results.</P>
<P>
<H2><A NAME="Heading15"></A>Controlling Data Types with Typecasting</H2>
<P>When you <I>typecast</I> a variable, you transform its value from one type to
another. As you read earlier, Visual Basic is so highly automated that it hides many
mundane chores of typecasting from you. Consider the following code:</P>
<P>
<PRE>Private Sub cmdAutoType_Click()
    txtFirst.Text = 5
End Sub
</PRE>
<P>The data type that the Text property expects is a String, but it's being assigned
an Integer. However, it works! Visual Basic automatically takes the Integer 5 and
converts it to a String type. You would have to do a lot to get this code to work
in a more <I>type-safe</I> language such as C++.</P>
<P>Now consider the following code (Figure 12.14 shows this code in action):</P>
<P>
<PRE>Private Sub cmdError_Click()
    lblResult.Caption = txtFirst.Text + txtSecond.Text
End Sub
</PRE>
<P><A HREF="javascript:popUp('12fig13.gif')"><B>FIGURE 12.14</B></A> <I>Concatenating
string variables yields a different result than adding integers.</I></P>
<P>Notice that Visual Basic's automated nature has now broken down. If you type 5
and 2 in the TextBoxes, the result is the string 52, not the integer 7. VB will convert
5 to an integer only if you try to add it to a value or variable of type Integer;
the + operator works just like &amp; for strings.</P>
<P>Therefore, to ensure that integer addition does indeed happen as you plan it to,
you must convert at least one TextBox Text value to an integer by using the CInt()
function. For example, in the following code snippet, if txtFirst.Text and txtSecond.Text
hold numeric strings, the value of lblResult's Caption property will be the result
of integer addition:</P>
<P>
<PRE>lblResult.Caption = CInt(txtFirst.Text) + txtSecond.Text
</PRE>
<P>Letting Visual Basic do most of the work with regard to data types might serve
you well, but as you can see from the preceding example, gaining control of data
types and typecasting is a skill that you need to develop over the long term.</P>
<P>
<H3><A NAME="Heading16"></A>Changing Data Types with the Conversion Functions</H3>
<P>Throughout this book you've seen the functions CStr() and CInt() used liberally
with no real explanation. These functions are conversion functions. A <I>conversion
function </I>transforms a value from one data type to another. In Visual Basic, you
use the conversion functions to typecast.</P>
<P>Because experienced Visual Basic programmers try to impose as much type safety
on their code as they can, among seasoned programmers it's not unusual to find the
value of an object's property typecast before it's applied to a variable. Of course,
before you try to convert a value from one type to another, make sure that the value
is appropriate to the type. For example, the following would be erroneous:</P>
<P>
<PRE>strMyString = &quot;Batman&quot;
intCounter - CInt(&quot;Batman&quot;)
intCounter = strMyString$
</PRE>
<P>Table 12.3 shows the type conversion functions and provides a discussion and example
of each function.</P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>Testing for proper data in your programs</STRONG></P>
	<P>Ensuring that data type conversion is possible is where validation functions such
	as IsNumeric(), IsValue(), and IsDate() come in handy. For a detailed discussion
	of these functions, read Visual Basic's online help. 
<HR>


</BLOCKQUOTE>

<H4>TABLE 12.3&nbsp;&nbsp;Type Conversion Functions</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>Function</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Comments</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Example</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CBool()</TD>
		<TD ALIGN="LEFT">Converts a value to a Boolean</TD>
		<TD ALIGN="LEFT">CBool(-1)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CByte()</TD>
		<TD ALIGN="LEFT">Converts values between 0 and 255 to a Byte</TD>
		<TD ALIGN="LEFT">Cbyte(254)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CCur()</TD>
		<TD ALIGN="LEFT">Converts a value to Currency</TD>
		<TD ALIGN="LEFT">CCur(&quot;$23.98&quot;)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CDate()</TD>
		<TD ALIGN="LEFT">Converts a date expression to a Date data type</TD>
		<TD ALIGN="LEFT">CDate(&quot;July 4, 1776&quot;)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CDbl()</TD>
		<TD ALIGN="LEFT">Converts a value to a Double</TD>
		<TD ALIGN="LEFT">CDbl(MyInt%)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CDec()</TD>
		<TD ALIGN="LEFT">Used only with variants</TD>
		<TD ALIGN="LEFT">N/A</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CInt()</TD>
		<TD ALIGN="LEFT">Converts a value to an Integer</TD>
		<TD ALIGN="LEFT">CInt(&quot;4&quot;)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CLng()</TD>
		<TD ALIGN="LEFT">Converts a value to a Long</TD>
		<TD ALIGN="LEFT">CLng(Form1.hWnd)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CSng()</TD>
		<TD ALIGN="LEFT">Converts a value to a Single</TD>
		<TD ALIGN="LEFT">CSng(&quot;23.1&quot;)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CVar()</TD>
		<TD ALIGN="LEFT">Converts a value to a Variant</TD>
		<TD ALIGN="LEFT">CVar(Text1.Text)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">CStr()</TD>
		<TD ALIGN="LEFT">Converts a value to a String</TD>
		<TD ALIGN="LEFT">CStr(MyInt%)</TD>
	</TR>
</TABLE>

<H2><A NAME="Heading17"></A>Validating Data with IsNumeric()</H2>
<P>As your programs rely more on valid user input, you must address the issue of
users inputting text strings when you need them to enter numeric strings. Visual
Basic has a built-in function that will help: IsNumeric(). IsNumeric() checks a string
to see whether it &quot;looks&quot; like a number. If a string looks like a number,
IsNumeric() returns True; otherwise, it returns False. The syntax for IsNumeric()
is as follows:</P>
<P>
<PRE><I>bResult</I> = IsNumeric(<I>MyString</I>)
</PRE>
<P>In this syntax,</P>

<UL>
	<LI><I>bResult</I> is a return value of type Boolean.
	<P>
	<LI>IsNumeric is the function name.
	<P>
	<LI><I>MyString</I> is the string that you want to check.
</UL>

<P>Listing 12.16 shows code that uses IsNumeric() to check whether user input can
be assigned to variables of type Integer.</P>
<P>
<H4>LISTING 12.16&nbsp;&nbsp;12LIST16.TXT--Using IsNumeric() to Validate User Input</H4>
<PRE><B>01 </B>Private Sub cmdIsNumeric_Click()</PRE>
<PRE><B>02 </B>Dim intAnswer As Integer</PRE>
<PRE><B>03 </B>Dim intX As Integer</PRE>
<PRE><B>04 </B>Dim intY As Integer</PRE>
<PRE><B>05</B></PRE>
<PRE><B>06 </B>If IsNumeric(txtFirst.Text) = True Then</PRE>
<PRE><B>07 </B>intX = CInt(txtFirst.Text)</PRE>
<PRE><B>08 </B>Else</PRE>
<PRE><B>09 </B>MsgBox &quot;Type Error&quot;, vbCritical</PRE>
<PRE><B>10 </B>Exit Sub</PRE>
<PRE><B>11 </B>End If</PRE>
<PRE><B>12</B></PRE>
<PRE><B>13 </B>If IsNumeric(txtSecond.Text) = True Then</PRE>
<PRE><B>14 </B>intY = CInt(txtSecond.Text)</PRE>
<PRE><B>15 </B>Else</PRE>
<PRE><B>16 </B>MsgBox &quot;Type Error&quot;, vbCritical</PRE>
<PRE><B>17 </B>Exit Sub</PRE>
<PRE><B>18 </B>End If</PRE>
<PRE><B>19</B></PRE>
<PRE><B>20 </B>intAnswer = intX + intY</PRE>
<PRE><B>21</B></PRE>
<PRE><B>22 </B>lblResult.Caption = CStr(intAnswer)</PRE>
<PRE><B>23 </B>End Sub</PRE>
<P>Table 12.4 lists all the Visual Basic validation functions.</P>
<P>
<H4>TABLE 12.4&nbsp;&nbsp;Visual Basic's Validation Functions</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><B><I>Function</I></B></TD>
		<TD ALIGN="LEFT"><B><I>Test Condition</I></B></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsArray()</TD>
		<TD ALIGN="LEFT">Returns True if the variable is an array</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsDate()</TD>
		<TD ALIGN="LEFT">Returns True if the expression is a valid date</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsEmpty()</TD>
		<TD ALIGN="LEFT">Returns True if the variable hasn't been initialized or has been set to empty</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsError()</TD>
		<TD ALIGN="LEFT">Returns True if a numeric expression represents an error</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsMissing()</TD>
		<TD ALIGN="LEFT">Returns True if no value has been passed to a function</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsNull()</TD>
		<TD ALIGN="LEFT">Returns True if the expression is null or has been set to null</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsNumeric()</TD>
		<TD ALIGN="LEFT">Returns True if the entire expression is a number</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IsObject()</TD>
		<TD ALIGN="LEFT">Returns True if the expression is an object</TD>
	</TR>
</TABLE>
</P>
<H1></H1>
<CENTER>
<P>
<HR>
<A HREF="ch11.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/ch11/ch11.htm"><IMG SRC="previous.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch13.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/ch13/ch13.htm"><IMG
SRC="next.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index-38.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/index.htm"><IMG SRC="contents.gif" tppabs="http://pbs.mcp.com/ebooks/078971633X/button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> <BR>
</P>

<P>&copy; <A HREF="copy.htm" tppabs="http://pbs.mcp.com/ebooks/078971633X/copy.htm">Copyright</A>, Macmillan Computer Publishing. All
rights reserved.
</CENTER>

</BODY>

</HTML>
