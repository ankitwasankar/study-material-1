<HTML>
<BODY BGCOLOR="white" TEXT="black" LINK="blue" ALINK="red" VLINK="green">
<BASEFONT SIZE="5">
<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>


   <META>
<H1><FONT COLOR=#FF0000>Chapter 15</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Developing Database Applications
and Applets with the JDBC</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#WhytheJavaDatabaseConnectivityJDBC" >Why the Java Database Connectivity (JDBC) Specification?</A>
<LI><A HREF="#StoringDatafortheWeb" >Storing Data for the Web</A>
<LI><A HREF="#ProvidingAccesstoData" >Providing Access to Data</A>
<LI><A HREF="#TheJDBCAPI" >The JDBC API</A>
<UL>
<LI><A HREF="#DatabaseRequirements" >Database Requirements</A>
<LI><A HREF="#TheJDBCInterfaces" >The JDBC Interfaces</A>
</UL>
<LI><A HREF="#SimpleDatabaseAccessUsingtheJDBCIn" >Simple Database Access Using the JDBC Interfaces</A>
<UL>
<LI><A HREF="#TheCounterAppletExample" >The Counter Applet Example</A>
</UL>
<LI><A HREF="#ResultSetsandtheMetadataInterfaces" >Result Sets and the Meta-data Interfaces</A>
<LI><A HREF="#OtherJDBCFunctionality" >Other JDBC Functionality</A>
<UL>
<LI><A HREF="#TransactionManagement" >Transaction Management</A>
<LI><A HREF="#CursorSupport" >Cursor Support</A>
<LI><A HREF="#StoredProcedures" >Stored Procedures</A>
<LI><A HREF="#MultipleResultSets" >Multiple Result Sets</A>
</UL>
<LI><A HREF="#BuildingaJDBCImplementation" >Building a JDBC Implementation</A>
<UL>
<LI><A HREF="#ImplementingtheInterfaces" >Implementing the Interfaces</A>
</UL>
<LI><A HREF="#ExtendingJDBC" >Extending JDBC</A>
<LI><A HREF="#DesigningaDatabaseApplication" >Designing a Database Application</A>
<UL>
<LI><A HREF="#SecurityIssues" >Security Issues</A>
<LI><A HREF="#ConstructingaThreetierApplication" >Constructing a Three-tier Application</A>
<LI><A HREF="#AThreetierBugTrackingSystem" >A Three-tier Bug Tracking System</A>
<LI><A HREF="#ImplementingaThreetierApplicationwi" >Implementing a Three-tier Application with Java</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Perhaps the most exciting and powerful use of computers involve
heavy duty storage of data and organized access to that data.
For example, business users have long benefited from the ability
to centrally store data for many different users to access. By
connecting the millions of once-isolated home computers on a common
network, the Internet has empowered developers to bring the advantages
of client/server computing into the home. Until Java, such Web
applications have primarily used CGI for connecting to databases.
<P>
For a few years now, the business solution to client/server development
has been rapid application development tools such as Borland Delphi,
Sybase PowerBuilder, and Microsoft Visual Basic. These applications
provide both rapid GUI development through the use of drag-and-drop
screen painting as well as a library of tools for accessing data
housed in relational databases. Unfortunately, these applications
are not well suited to Internet development, where platform independence,
security, and distribution are all imperative.
<P>
A major strength of rapid application development products is
their database connectivity. Ideally, you would have wanted the
Order Entry System to access a real database and function off
of that data. For example, the applet could report to a customer
whether a certain item was available when the order was sent in.
Or, even better, the applet could check and feature only those
items that were in stock. But, as you saw, the Order Entry System
by the time you finished with it was already becoming unwieldy.
This chapter will provide you with the basis to include these
database access and manipulation features into your own applets.
I will also create a number of coded examples that will demonstrate
these features and techniques that you can apply to your own Web
programming.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note:</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=572>
<BLOCKQUOTE>
This chapter focuses on the mechanics of how Java can interact with databases, not on explaining many concepts key to database use. For that reason, some concepts of databases I refer to in this chapter may seem like gibberish if you are not familiar with databases. If you want to implement a database, a number of good resources such as books and documents on the Web will help you. The information in this chapter will then show you how to create Java programs that will interact with your database. The Java Database Connectivity (JDBC) standard is very similar to Microsoft's Open Database Connectivity (ODBC) standard, which can be a starting point for your introduction to databases.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="WhytheJavaDatabaseConnectivityJDBC"><B><FONT SIZE=5 COLOR=#FF0000>Why
the Java Database Connectivity (JDBC) Specification?</FONT></B></A>
</H2>
<P>
The Java specification, as well as the original release of the
Java Developer's Kit (JDK), made no provisions for Java database
access. To create access to a database, a programmer had to create
an intermediary program between the database manager and the Java
program that would access the data. To force a multitude of programmers
all to write code that does essentially the same thing is truly
a waste. Of course, each different programmer would do it his/her
own way and suddenly you'd have a large mess on your hands. It
is entirely inefficient not to have a standardized access format
between Java code and database management systems.
<P>
Another reason that a standardized database interface proves necessary
stems from security issues. By making a standard JDBC specification,
database manufacturers can produce interfaces for their database,
regardless of the internal storage format, so that the standardized
interface could work with any Java program. This is a large bonus:
Any Java program that implements database features can manipulate
and access any database that has a JDBC-compliant interface. Also,
the standardized classes and interfaces of the database interface
classes can join the ranks of &quot;trusted&quot; classes that
Web browsers can then safely use. Of course, home-brewed database
interfaces would not be trusted or put into wide use and applets
would not be able to use databases at all.
<P>
For these reasons, some kind of standardized database capability
is necessary. In March 1996, Sun Microsystems, Inc. addressed
this need with the draft release of the Java Database Connectivity
specification, JDBC. As of this writing, the JDBC specification
is still in a request-for-comments phase and is scheduled to be
available soon in a full release. This chapter addresses the problem
of database access in Java and demonstrates how to write code
that conforms to and enhances the JDBC interface.
<P>
A hidden plus of the JDBC standard is that implementing database
features in a Java program should make it easy to use that same
implementation on another database. Of course, standardizing all
of these functions comes at a price. It is less efficient to include
the JDBC interface as another layer between your program and the
database itself, but you should be accustomed to the tradeoff
between standardization and simplicity and efficiency.
<P>
Currently, a number of database system developers have committed
to developing JDBC-specification-compliant interfaces for their
database systems. As of July 1996, database system producers ranging
from Borland to tiny companies have stated their intent to develop
JDBC interfaces immediately. As always, the latest information
on Java database developments can be found at Java's home page:
<BLOCKQUOTE>
<TT><A TARGET="resource window" HREF="http://java.sun.com/">http://java.sun.com/</A></TT>
</BLOCKQUOTE>
<H2><A NAME="StoringDatafortheWeb"><B><FONT SIZE=5 COLOR=#FF0000>Storing
Data for the Web</FONT></B></A></H2>
<P>
Simple applets rarely need to perform database access. They are
generally executed as on-off programs without the need to save
any state information across executions. As Java developers move
their work out of the realm of the simple applet, they will find
the need to access some sort of data store. A popular yet simple
example is the ubiquitous page counter. Of course, a page counter
is simply an applet or CGI script that keeps track of how many
times a particular page has been hit and displays that number
on the page (see Figure 15.1).
<P>
<A HREF="f15-1.gif" ><B>Figure 15.1 : </B><I>A Web page running a counter applet.</I></A>
<P>
At the other extreme in complexity are the search engines with
which you can perform keyword searches to find the most trivially
related pages of information existing on the Internet. No matter
how complex the application, the basic data management needs are
the same. Many users need to gain access to the same piece of
information and require an application built in such a way that
it can access and/or modify centrally stored data. The developer
must then take the following steps to provide users with access
to data:
<UL>
<LI>Select and install a database management system (DBMS)
<LI>Build data processing logic
<LI>Build a user interface
</UL>
<H2><A NAME="ProvidingAccesstoData"><B><FONT SIZE=5 COLOR=#FF0000>Providing
Access to Data</FONT></B></A></H2>
<P>
Whether Java or some other language is used to build these pieces,
the DBMS used will have a direct impact on the implementation.
A detailed discussion of database management systems is well beyond
the scope of this book. When you choose among the various technologies,
however, keep your needs (and your wallet) in mind and resist
the dazzle of technology. Three basic data storage technologies
that serve various needs follow:
<UL>
<LI>Object-oriented database (OODBMS)
<LI>Relational database (RDBMS)
<LI>Object-relational database (OORDBMS)
</UL>
<P>
With the advent of the high multimedia content data storage needs
of the Internet, developers have been more open to the idea of
using object databases. In addition to being better suited to
the unusual demands of storing multimedia data, object databases
also help provide a true object paradigm from data store to client
application.
<P>
What does this mean to you? You'll be concerned with a couple
of issues, the first of which are the time and storage space requirements
necessary for each different type of database manager. If you're
trying to store a large amount of customer orders, for example,
you should choose the appropriate database management system,
such as a simple relational database. Or, if you're going heavy
into multimedia, you'll want to use an object-based database manager.
<P>
The second issue is how the choice will affect how easily you
can access the database. As you probably know, accessing a pure
object database with any front-end tool is a challenge. Because
the JDBC specification revolves around ANSI SQL-2 compliance and
few object databases have SQL support, accessing an object database
through Java will prove to be doubly challenging.
<P>
For developers not faced with the need to store complex data,
any traditional relational databases should do exactly what you
need. The grand trick to programming in Java with a relational
database, or doing any object programming against a relational
database, is mapping between the dynamic realm of objects and
the static realm of pure data.
<P>
Paving the road between these two seemingly disparate technologies
are the object-relational databases. For developers with complex
data modeling needs, an object-relational database can provide
the object modeling power of an object database while maintaining
the ease of data access afforded by traditional relational systems.
<H2><A NAME="TheJDBCAPI"><B><FONT SIZE=5 COLOR=#FF0000>The JDBC
API</FONT></B></A></H2>
<P>
To provide a common base API for accessing data, Sun Microsystems,
Inc., with support from a number of independent software vendors,
developed JDBC. JDBC defines a number of Java interfaces to enable
developers to access data independent of the actual database product
being used to store the data. In theory, an application written
against the basic JDBC API using only SQL-2 can function against
any database technology that supports SQL-2. Of course, the key
words are &quot;in theory.&quot; The idea is that the interaction
between your Java program and any database is standardized through
the JDBC specification standard.
<H3><A NAME="DatabaseRequirements"><B>Database Requirements</B></A>
</H3>
<P>
You may store data in a wide variety of formats using various
technologies. In addition to the three major modern database management
systems, you will want to consider other systems, such as hierarchical
databases and file systems. Any low-level API trying to find some
common ground between all of these systems would be unsuccessful.
JDBC mandates no specific requirements on the underlying DBMS,
however. In other words, the JDBC doesn't care what's going on
underneath the interface as long as it meets the ANSI SQL-2 standards.
Rather than dictating what sort of DBMS an application must have
to support JDBC, the specification places all of its requirements
on the JDBC implementation.
<P>
Each platform and database-specific implementation of the JDBC
by a software developer will provide a standardized environment
in which your Java programs can operate. The JDBC specification
primarily mandates that a JDBC implementation supports at least
ANSI SQL-2 Entry Level. Because most common relational database
systems and object-relational database systems support SQL-2,
this requirement provides a reasonable baseline from which software
developers can build Java database access. In addition, because
SQL-2 is required only at the JDBC implementation level, that
implementation can provide its own SQL-2 wrapper around non-SQL
data stores.
<P>
The most important thing for you to remember when developing in
Java is that your applications and applets are limited to accessing
databases that support the ANSI SQL-2 standard. These databases
naturally follow this standard or have had a specialized JDBC-compliant
interface written for them.
<H3><A NAME="TheJDBCInterfaces"><B>The JDBC Interfaces</B></A>
</H3>
<P>
The JDBC defines eight interfaces that must be implemented to
be JDBC-compliant:
<UL>
<LI><TT>java.sql.Driver</TT>
<LI><TT>java.sql.Connection</TT>
<LI><TT>java.sql.Statement</TT>
<LI><TT>java.sql.PreparedStatement</TT>
<LI><TT>java.sql.CallableStatement</TT>
<LI><TT>java.sql.ResultSet</TT>
<LI><TT>java.sql.ResultSetMetaData</TT>
<LI><TT>java.sql.DatabaseMetaData</TT>
</UL>
<P>
Figure 15.2 shows these interfaces and how they interact in the
full JDBC object model.
<P>
The central object around which the whole concept revolves is
the <TT>java.sql.DriverManager</TT>
object. This object is responsible for keeping track of the various
JDBC implementations that may exist for an application. If, for
example, a system were aware of Sybase and Oracle JDBC implementations,
the <TT>DriverManager</TT> would be
responsible for tracking those implementations. Any time an application
desires to connect to a database, it asks the <TT>DriverManager</TT>
to give it a database connection using a database URL through
the <TT>DriverManager.getConnection()</TT>
method. Based on this URL, the <TT>DriverManager</TT>
searches for a <TT>Driver</TT> implementation
that accepts the URL. It then gets a <TT>Connection</TT>
implementation from that <TT>Driver</TT>
and returns it to the application.
<P>
<A HREF="f15-2.gif" ><B>Figure 15.2 : </B><I>The JDBC object model.</I></A>
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note:</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=566>
<BLOCKQUOTE>
What is a database URL? To enable an application to specify the database to which it wants to connect, JDBC uses the Internet standard Universal Resource Locator (URL) system. A JDBC URL consists of the following pieces: <TT>jdbc:<I>&lt;subprotocol&gt;:&lt;subname&gt;</I></TT>. As with URLs you have seen all over the Internet, the first element is the resource protocol-in this case, a JDBC data source. The subprotocol is specific to the JDBC implementation. In many cases, it likely will be the DBMS name and version; for example, syb10 might indicate Sybase System 10. The subname element is any information specific to the DBMS that tells it where it needs to connect. For mSQL, the JDBC URL is in the format of <TT>jdbc:msql://<I>hostname</I>:<I>port</I>/<I>database</I></TT>. JDBC itself does not much care what a database URL looks like. The important thing is simply that a desired JDBC implementation can recognize the URL and get the information it needs to connect to a database from that URL.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT>DriverManager</TT> is the
only instantiated class provided by JDBC other than exception
objects and a few specialized subclasses of <TT>java.util.Date</TT>.
Additional calls made by an application are written against the
JDBC interfaces that are implemented for specific DBMSs.
<H4><TT><B>java.sql.Driver</B></TT>
</H4>
<P>
A <TT>Driver</TT> is essentially a
<TT>Connection</TT> factory. The <TT>DriverManager</TT>
uses the <TT>Driver</TT> to determine
whether it, the <TT>DriverManager</TT>,
can handle a given URL. If it can handle the URL, it should create
a connection object and return it to the <TT>DriverManager</TT>.
Because an application only indirectly references a <TT>Driver</TT>
through the <TT>DriverManager</TT>,
applications are rarely concerned with this class.
<H4><TT><B>java.sql.Connection</B></TT>
</H4>
<P>
A <TT>Connection</TT> is a single
database session. As such, it stores state information about the
database session it manages and provides the application with
<TT>Statement</TT>, <TT>PreparedStatement</TT>,
or <TT>CallableStatement</TT> objects
to make calls during the session.
<H4><TT><B>java.sql.Statement</B></TT>
</H4>
<P>
A <TT>Statement</TT> is an unbound
SQL call to the database. It is generally a simple <TT>UPDATE</TT>,
<TT>DELETE</TT>, <TT>INSERT</TT>,
or <TT>SELECT</TT> for which no columns
need to bind to Java data. It provides methods for making such
calls and returns to the application the results of any <TT>SELECT</TT>
statements, or the number of rows affected by an <TT>UPDATE</TT>,
<TT>DELETE</TT>, or <TT>INSERT</TT>.
<P>
<TT>Statement</TT> has the subclass
<TT>PreparedStatement</TT>, which
is in turn subclassed by <TT>CallableStatement</TT>.
A <TT>PreparedStatement</TT> is a
precompiled database call that requires binding parameters. An
example of a <TT>PreparedStatement</TT>
might be a stored procedure call that has no <TT>OUT</TT>
or <TT>INOUT</TT> parameters. For
stored procedures with <TT>OUT</TT>
or <TT>INOUT</TT> parameters, an application
should use the <TT>CallableStatement</TT>
interface.
<H4><TT><B>java.sql.ResultSet</B></TT>
</H4>
<P>
A <TT>SELECT</TT> query returns data
to an application by implementing this interface. Specifically,
the <TT>ResultSet</TT> object enables
an application to retrieve sequential rows of data returned from
a previous <TT>SELECT</TT> call. It
provides a multitude of methods that enable you to retrieve a
given row as any data type to which it makes sense to convert
it. For example, if you have a date stored in the database as
a datetime, you can retrieve it through the <TT>getString()</TT>
method to use it as a string.
<H4><B>The Meta-data Interfaces</B></H4>
<P>
Meta-data is data about data. Specifically, it is a set of data
that gives you information about the database and data retrieved
from the database. Java provides two meta-data interfaces: <TT>java.sql.ResultSetMetaData</TT>
and <TT>java.sql.DatabaseMetaData</TT>.
The <TT>ResultSetMetaData</TT> provides
a means for getting information about a particular <TT>ResultSet</TT>.
For example, among other things, it provides information on the
number of columns in the result set, the name of a column, and
its type. The <TT>DatabaseMetaData</TT>
interface, on the other hand, gives the application information
on the database in general, such as what levels of support it
has, its name, version, and other features.
<H2><A NAME="SimpleDatabaseAccessUsingtheJDBCIn"><B><FONT SIZE=5 COLOR=#FF0000>Simple
Database Access Using the JDBC Interfaces</FONT></B></A></H2>
<P>
An application for which database independence is paramount, in
other words, one in which you want to write a program that can
use different databases using a JDBC interface, should be written
to the JDBC specification without using database-specific calls
and without making use of SQL that is not part of the ANSI SQL-2
standard. In such code, no reference should be made to a specific
implementation of JDBC. Writing a simple database application
using only JDBC calls involves the following steps:
<OL>
<LI>Ask the <TT>DriverManager</TT>
for a <TT>Connection</TT> implementation.
<LI>Ask the <TT>Connection</TT> for
a <TT>Statement</TT> or subclass of
<TT>Statement</TT> to execute your
SQL.
<LI>For subclasses of <TT>Statement</TT>,
bind any parameters to be passed to the prepared statement.
<LI>Execute the <TT>Statement</TT>.
<LI>For queries, process the <TT>ResultSet</TT>
returned from the query. Do this for each result set (if you have
multiple result sets) until none are left.
<LI>For other statements, check the return value for the number
of rows affected.
<LI>Close the <TT>Statement</TT>.
<LI>Process any number of such statements and then close the connection.
</OL>
<H3><A NAME="TheCounterAppletExample"><B>The Counter Applet Example</B></A>
</H3>
<P>
The counter applet discussed earlier in this chapter provides
a simple example of JDBC programming. Using the JDBC interfaces,
this applet connects to a database, determines how many times
the page on which it appears has been hit, updates the page to
reflect the new hit, and displays the number of hits. To use this
example, you need a database engine to run your database and a
JDBC driver to access that database engine. If you do not have
a database engine, download mSQL and JDBC, which are both free
for noncommercial use. Links to mSQL and the JDBC class may be
found through
<BLOCKQUOTE>
<TT>http://www.imaginary.com/Java/.</TT>
</BLOCKQUOTE>
<P>
In addition, you need to create a table called <TT>t_counter</TT>
with the fields <TT>counter_file</TT>
(<TT>CHAR(100)</TT>, <TT>PRIMARY
KEY</TT>) and <TT>counter_num</TT>
(<TT>INT</TT>, <TT>NOT
NULL</TT>). The following mSQL script creates the table:
<BLOCKQUOTE>
<TT>DROP TABLE t_counter\p\g<BR>
<BR>
<BR>
CREATE TABLE t_counter(<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter_file&nbsp;&nbsp;&nbsp;&nbsp;CHAR(100)&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY
KEY,<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOT
NULL<BR>
)\p\g</TT>
</BLOCKQUOTE>
<P>
The applet consists of two classes, <TT>Counter</TT>
and <TT>Database</TT>. The <TT>Counter</TT>
class is the subclass of applet that provides the user interface
to the applet. It contains two instance variables: <TT>count</TT>,
which is the number this applet is supposed to display, the number
of page hits, and <TT>database</TT>,
which is an instance of the <TT>Database</TT>
class that provides wrappers for the JDBC access needed by the
applet.
<P>
<TT>Counter</TT> does not define any
new methods; rather, it simply overrides the <TT>java.applet.Applet.init()</TT>
and <TT>java.applet.Applet.paint()</TT>
methods. The <TT>init()</TT> method
is used to create a <TT>Database</TT>
instance and find out from it what the page hit count is for display.
The <TT>paint()</TT> method displays
the page hit count.
<P>
This interesting JDBC-related work is all encapsulated inside
the <TT>Database</TT> class. This
class has a single instance variable, <TT>connection</TT>,
which is an instance of a JDBC Connection implementation. The
<TT>connection</TT> variable is initialized
in the <TT>Database</TT> class constructor:
<BLOCKQUOTE>
<TT>public Database(String url, String user,
String pass)<BR>
&nbsp;throws java.sql.SQLException&nbsp;&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection = DriverManager.getConnection(url,
user, pass);<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<P>
By getting an instantiated <TT>Connection</TT>
object, the applet is ready to access whatever database it needs.
<P>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Tip:</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=577>
<BLOCKQUOTE>
As of the printing of this book, the <TT>java.sql</TT> package has not been incorporated into Java browsers such as Netscape. Due to a security feature of such browsers, which prevents the loading of classes in the <TT>java.*</TT> <TT>namespace</TT>, the applet examples in this chapter will not work properly. So how do I know they work at all? To get an applet using the <TT>java.sql</TT> classes to work, simply rename your <TT>java.sql</TT> packages to something else and recompile them. That moves them from the <TT>java.*</TT> <TT>namespace</TT> so that such browsers can load them. This problem does not affect stand-alone applications and it will not apply once the JDBC specification is finalized and <TT>java.sql</TT> classes are incorporated into the browser releases.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The applet uses the <TT>getCount()</TT>
method to calculate how many page hits this particular access
to the Web page represents. That seemingly benign query actually
represents several steps:
<OL>
<LI>Create a <TT>Statement</TT> object.
<LI>Formulate and execute the <TT>SELECT</TT>
query.
<LI>Process the result.
<LI>Increment the hit count.
<LI>Format and execute an <TT>UPDATE</TT>
or <TT>INSERT</TT> statement.
<LI>Close the <TT>Statement</TT> and
<TT>Connection</TT> objects.
</OL>
<P>
The <TT>Statement</TT> is created
through the JDBC call:
<BLOCKQUOTE>
<TT>java.sql.Statement statement = connection.createStatement();</TT>
</BLOCKQUOTE>
<P>
You want the number of hits for this page from the <TT>t_counter</TT>
table:
<BLOCKQUOTE>
<TT>sql = &quot;SELECT counter_num FROM t_counter
&quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE counter_file = '&quot;
+ page + &quot;'&quot;;<BR>
<BR>
result_set = statement.executeQuery(sql);</TT>
</BLOCKQUOTE>
<P>
The <TT>result_set</TT> variable now
holds the results of the query. For queries that return multiple
rows, an application loops through the <TT>next()</TT>
method in the result set until no more rows exist. This query
should only return one row with one column, unless the page has
never been hit. If the page has never been hit, the query will
not find any rows and the count variable should be set to 0:
<BLOCKQUOTE>
<TT>if( !result_set.next() ) count = 0;</TT>
</BLOCKQUOTE>
<P>
Otherwise, you need to retrieve that row into the count variable
as an integer:
<BLOCKQUOTE>
<TT>else count = result_set.getInt(1);</TT>
</BLOCKQUOTE>
<P>
After incrementing the count to reflect this new hit, close out
the <TT>Statement</TT> object and
get a new one to prepare for the <TT>UPDATE</TT>:
<BLOCKQUOTE>
<TT>count++;<BR>
<BR>
statement.close();<BR>
<BR>
statement = connection.create Statement();</TT>
</BLOCKQUOTE>
<P>
If this is the first time the page is being hit, the applet needs
to <TT>INSERT</TT> a new row into
the database. Otherwise, it should <TT>UPDATE</TT>
the existing row:
<BLOCKQUOTE>
<TT>if( count == 1 ) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sql = &quot;INSERT INTO t_counter &quot;
+<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(counter_file,
counter_num) &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES
('&quot; + file + &quot;', &quot; + count + &quot;)&quot;;<BR>
}<BR>
<BR>
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sql = &quot;UPDATE t_counter &quot; +
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;SET
counter_num = &quot; + count + &quot; &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
counter_file = '&quot; + file + &quot;'&quot;;<BR>
}<BR>
<BR>
statement.executeUpdate(sql);</TT>
</BLOCKQUOTE>
<P>
The method then cleans up and returns the hit count.
<P>
Listing 15.1 puts the whole applet together.
<HR>
<BLOCKQUOTE>
<B>Listing 15.1. The Counter applet.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.sql.Connection;<BR>
import java.sql.DriverManager;<BR>
import java.sql.ResultSet;<BR>
import java.sql.Statement;<BR>
import java.awt.Graphics;<BR>
<BR>
public class Counter extends java.applet.Applet {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Database db;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;String count;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void init() {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String driver
= getParameter(&quot;driver&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String url = getParameter(&quot;url&quot;);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String user =
getParameter(&quot;user&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String pass =
getParameter(&quot;password&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String page =
getParameter(&quot;page&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class.forName(driver).newInstance();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db
= new Database(url, user, pass);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= db.getCount(page);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;catch( java.sql.SQLException e ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= &quot;Database exception&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;catch( Exception e ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count
= &quot;Unable to load driver&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void paint(Graphics g) {<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(new
java.awt.Font(getParameter(&quot;font&quot;),<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.awt.Font.BOLD,
14));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(count,
5, 15);<BR>
<BR>
}<BR>
<BR>
}<BR>
<BR>
<BR>
<BR>
class Database {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Connection connection;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public Database(String url, String user,
String pass)<BR>
&nbsp;throws java.sql.SQLException {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;connection = DriverManager.getConnection(url,
user, pass);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
<BR>
public String getCount(String page) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count = 0;
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.sql.Statement
statement =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.createStatement();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.sql.ResultSet
result_set;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
sql;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql
= &quot;SELECT counter_num FROM t_counter &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
counter_file = '&quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page
+ &quot;'&quot;;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result_set
= statement.executeQuery(sql);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
!result_set.next() ) count = 0;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
count = result_set.getInt(1);<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.close();
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement
= connection.createStatement();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(
count == 1 ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql
= &quot;INSERT INTO t_counter &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(counter_file,
counter_num) &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES
('&quot; + page + &quot;', &quot; +count+ &quot;)&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;else
{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sql
= &quot;UPDATE t_counter &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;SET
counter_num = &quot; + count + &quot; &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
counter_file = '&quot; + page + &quot;'&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.executeUpdate(sql);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement.close();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.close();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;catch( java.sql.SQLException e ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return (&quot;&quot; + count);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><B>Note:</B></TD></TR>
<TR VALIGN=TOP><TD WIDTH=586>
<BLOCKQUOTE>
How are drivers registered with the <TT>DriverManager</TT>? In the previous example, it was done by specifically loading the driver passed into the program through the driver parameter. A JDBC-compliant driver must notify the <TT>DriverManager</TT> of its existence when it is instantiated. The preferred method of listing multiple JDBC drivers for the <TT>DriverManager</TT> is through the <TT>jdbc.drivers</TT> property.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="ResultSetsandtheMetadataInterfaces"><B><FONT SIZE=5 COLOR=#FF0000>Result
Sets and the Meta-data Interfaces</FONT></B></A></H2>
<P>
In simple applications such as the counter applet, there is no
need to perform any tricks with the results from a query-the data
is simply retrieved sequentially and processed. More commonly,
however, an application will need to process the data in a more
complex fashion. For example, a set of classes might want to deal
with data on a more abstract level than the <TT>Database</TT>
class from the counter example. Instead, such classes might not
know exactly what data is being retrieved. They can query the
meta-data interfaces to process intelligently such data that they
would otherwise not know. Listing 15.2 shows a generic database
view class that is populated with database objects based on a
result set.<BR>
<HR>
<BLOCKQUOTE>
<B>Listing 15.2. A generic database view class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.sql.ResultSet;<BR>
import java.sql.ResultSetMetaData;<BR>
import java.util.Hashtable;<BR>
import java.util.Vector;<BR>
<BR>
<BR>
public class View {<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;private Vector objects;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public void populate(ResultSet result_set,
String cl) {<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSetMetaData
meta_data;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i, maxi;<BR>
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects
= new Vector();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;meta_data
= result_set.getMetaData();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxi
= meta_data.getColumnCount();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(
result_set.next() ) {<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable
row = new Hashtable();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataObject
obj;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=1;
i&lt;=maxi; i++) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
key;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object
value;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
t;<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
key = meta_data.getColumnLabel(i);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t
= meta_data.getColumnType(i);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value
= result_set.getObject(i, t);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row.put(key,
value);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj
= (DataObject)Class.forName(cl);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.restore(row);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects.addElement(obj);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;catch ( java.sql.SQLException e ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects
= new Vector();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
In the <TT>View</TT> class, reference
is made to a <TT>DataObject</TT> class
that implements a restore(<TT>java.util.Hashtable</TT>)
method not listed.
<P>
Because many applications will use this generic class, the class
knows nothing about the queries it is executing. Instead, it takes
any random result set and assumes that each row corresponds to
an instance of the class named by the second parameter to <TT>populate()</TT>.
<P>
To get the information it needs for performing the data retrievals,
the <TT>populate()</TT> method first
obtains the meta-data object for this result set. This method
is specifically interested in knowing how many columns, as well
as the names of the columns, are in the result set.
<P>
To store the columns in a <TT>Hashtable</TT>
object that the <TT>DataObject</TT>
object can use for restoring itself, all data must be in the form
of objects. Thus, for each column in the result set, the <TT>DataObject</TT>
finds its data type from the meta-data and retrieves the column
as an object. The final step is to store it in the <TT>Hashtable</TT>.
<H2><A NAME="OtherJDBCFunctionality"><B><FONT SIZE=5 COLOR=#FF0000>Other
JDBC Functionality</FONT></B></A></H2>
<P>
The JDBC provides functionality beyond the commonly used methods
already discussed in terms of the following features:
<UL>
<LI>Transaction management
<LI>Cursor support
<LI>Stored procedure support
<LI>Multiple result set processing
</UL>
<H3><A NAME="TransactionManagement"><B>Transaction Management</B></A>
</H3>
<P>
JDBC implementations should default automatically to committing
transactions unless the application otherwise requests that transactions
require an explicit commitment. An application may toggle the
automatic commit of the JDBC implementation it is using through
the <TT>Connection.setAutoCommit()</TT>
method. An example follows:
<BLOCKQUOTE>
<TT>connection.setAutoCommit(false);</TT>
</BLOCKQUOTE>
<P>
Of course, by not setting the <TT>AutoCommit</TT>
attribute or by setting it to true, the JDBC implementation will
make certain that the DBMS commits after each statement you send
to the database. When set to false, however, the JDBC implementation
requires specific commits from the application before a transaction
is committed to the database. A series of statements executed
as a single transaction would look like this:
<BLOCKQUOTE>
<TT>public void add_comment(String comment)
{<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Statement s;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSet r;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int comment_id;
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.setAutoCommit(false);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = connection.createStatement();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r = s.executeQuery(&quot;SELECT
next_id &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;FROM
t_id &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
id_name = 'comment_id'&quot;);<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( !r.next()
) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
new SQLException(&quot;No comment id exists &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;in
t_id table.&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comment_id = r.getInt(1)
+ 1;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.close();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s
= connection.createStatement();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.executeUpdate(&quot;UPDATE
t_id &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;SET
comment_id = &quot;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;comment_id
+ &quot; &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE
next_id = 'comment_id'&quot;);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.close();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = connection.createStatement();
<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.executeUpdate(&quot;INSERT
INTO t_comment &quot; +<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(comment_id,
comment_text) &quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES(&quot;
+ comment_id + &quot;, '&quot; +<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comment
+ &quot;')&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.commit();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;catch( SQLException e ) {<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connection.rollback();
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch( SQLException e2 )&nbsp;&nbsp;System.exit(-1);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
}</TT>
</BLOCKQUOTE>
<P>
This method adds a comment to a comment table for some applications.
To insert the new comment, the method needs to generate a new
<TT>comment_id</TT> and then update
the table for generating IDs so that the next one will be one
greater than this one. Once the program has an ID for this comment,
it then inserts the comment into the database and commits the
entire transaction. If an error occurs at any time, the entire
transaction is rolled back.
<P>
JDBC currently has no support for a two-phase commit. Applications
written against distributed databases require extra support to
allow for a two-phase commit.
<H3><A NAME="CursorSupport"><B>Cursor Support</B></A></H3>
<P>
JDBC provides limited cursor support. It enables an application
to associate a cursor with a result set through the <TT>ResultSet.getCursorName()</TT>
method. The application can then use the cursor name to perform
positioned <TT>UPDATE</TT> or <TT>DELETE</TT>
statements.
<H3><A NAME="StoredProcedures"><B>Stored Procedures</B></A></H3>
<P>
Stored procedures are precompiled SQL statements stored in the
database that enable faster execution of SQL. JDBC supports stored
procedures through the <TT>CallableStatement</TT>
class. In the counter applet, you could have used a stored procedure
to update the page hit count in the following way:
<BLOCKQUOTE>
<TT>CallableStatement s = connection.prepareCall(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;{call
sp_upd_hit_count[?, ?]}&quot;);<BR>
<BR>
s.setStringParameter(1, &quot;file&quot;);<BR>
<BR>
s.setIntParameter(2, count);<BR>
<BR>
s.executeUpdate();</TT>
</BLOCKQUOTE>
<H3><A NAME="MultipleResultSets"><B>Multiple Result Sets</B></A>
</H3>
<P>
In some cases, especially with stored procedures, an application
can find a statement by returning multiple result sets. JDBC handles
this through the method <TT>Statement.getMoreResults()</TT>.
Although result sets are left to be processed, this method returns
true. The application can then obtain the next <TT>ResultSet</TT>
object by calling <TT>Statement.getResultSet()</TT>.
Processing multiple result sets simply involves looping through
as long as <TT>Statement.getMoreResults()</TT>
returns a value of <TT>true</TT>.
<H2><A NAME="BuildingaJDBCImplementation"><B><FONT SIZE=5 COLOR=#FF0000>Building
a JDBC Implementation</FONT></B></A></H2>
<P>
Building a JDBC implementation requires a lot more in-depth knowledge
of both your DBMS and the JDBC specification than does simply
coding to it. Most people will never encounter the need to roll
their own implementation because database vendors logically want
to make them available for their product. Understanding the inner
workings of JDBC can help advance your application programming,
however.
<P>
JDBC is a low-level interface that provides direct SQL-level access
to the database. Most business applications and class libraries
abstract from that SQL-level access to provide such features as
object persistence and business-aware database access. A narrow
example of such an abstraction is the <TT>Database</TT>
class from the counter example.
<P>
The ideal object method of accomplishing these goals is to reuse
existing JDBC implementations for the DBMS in question and to
add custom interfaces on top of those implementations. If the
DBMS is an oddball DBMS, or perhaps if you are concerned about
the available implementations that exist, writing one from scratch
makes sense.
<H3><A NAME="ImplementingtheInterfaces"><B>Implementing the Interfaces</B></A>
</H3>
<P>
The first concern of any JDBC implementation is how it will talk
to the database. Figure 15.3 illustrates the architecture of three
possible JDBC implementations. Depending on the design goals in
question, one of these methods will suit any JDBC implementation:
<P>
<A HREF="f15-3.gif" ><B>Figure 15.3 : </B><I>Possible JDBC implementation architectures.</I></A>
<UL>
<LI>A native C library
<LI>A socket interface
<LI>Extending a vendor JDBC implementation
</UL>
<P>
Of course, extending a vendor JDBC implementation is not really
the same as building a JDBC implementation. Because a key to any
object-oriented project is reusing code instead of building from
scratch it is listed here.
<P>
With all three architectures, the application is apparently isolated
from the actual communication mechanism. In truth, however, the
native C library method places severe restrictions on any application
using a JDBC implementation built on top of it. Because it uses
native calls, it is naturally not portable across operating systems.
In addition, due to virtual machine restrictions on most browsers,
native calls are either severely limited or fully restricted.
<P>
To use one of these mechanisms for database communication, you
need to construct the four basic interfaces: <TT>java.sql.Driver</TT>,
<TT>java.sql.Connection</TT>, <TT>java.sql.Statement</TT>,
and <TT>java.sql.ResultSet</TT>. These
interfaces will provide minimum functionality so that you can
test against simple queries and updates. Once these interfaces
are functional, the implementation needs the meta-data interfaces
as well as the <TT>Statement</TT>
subclasses to be complete and JDBC-compliant.
<H2><A NAME="ExtendingJDBC"><B><FONT SIZE=5 COLOR=#FF0000>Extending
JDBC</FONT></B></A></H2>
<P>
Nothing requires an application to use the JDBC interface to access
a database. In fact, before JDBC, developers programmed to Java
classes written specifically to go against several major database
engines. JDBC isolates the database access behind a single interface.
This isolation provided developers with the ability to write database
access in Java without having to know which database engine their
application is actually hitting. With a single prevalent database
API, finding people with experience programming against it proves
much simpler than finding people to program against a proprietary
API. JDBC is, however, a low-level specification that requires
developers to write both SQL code as well as Java code.
<P>
Both examples in this chapter demonstrate two different ways in
which you can extend JDBC. In the counter applet, a database class
was created as a wrapper around the JDBC implementation. The applet
itself was divided into a representational portion, the <TT>Counter</TT>
class, and a functional portion, the <TT>Database</TT>
class. If you make changes to the visual representation, such
as making the hit count appear through an odometer graphic, you
won't have to make changes to the functional logic because it
is isolated in a separate class. In fact, if the applet were more
complex, requiring multiple developers, all the SQL would still
be isolated in a class specifically interested in the functional
behavior of the application. This reduces the number of people
who need to write SQL code.
<P>
The <TT>View</TT> class example was
a more abstract way of extending JDBC. The <TT>View</TT>
class assumes that rows in result sets translate into business
objects. In an application using this class, <TT>View</TT>
objects are created to make JDBC calls and populate the applications
with meaningful objects.
<P>
Another manner in which you can extend JDBC is to take advantage
of database-specific features. Although it is prudent to question
the need to make use of any proprietary features of a given DBMS,
it is equally important that you do not ignore the extra power
a specific DBMS gives you. It is, after all, very rare that an
application actually needs to switch database engines.
<H2><A NAME="DesigningaDatabaseApplication"><B><FONT SIZE=5 COLOR=#FF0000>Designing
a Database Application</FONT></B></A></H2>
<P>
Knowing the JDBC API and coding cute applets is naturally just
the start to database programming in Java. To harness the advantages
of Java, application designers need to be able to address the
design issues Java raises. The entire Java paradigm empowers developers
to write database applications and applets using architectures
that before were either very complex or simply not supported by
other tools. Two such buzzwords that have been flying around the
client/server world for a while are distributed objects and three-tier
client/server.
<H3><A NAME="SecurityIssues"><B>Security Issues</B></A></H3>
<P>
Before going off the edge and into the deep end, Java does put
some restrictions on applets for security reasons that can appear
to be particularly limiting to the database developer. The following
two particular applet restrictions affect database programmers:
<UL>
<LI>Limited access to native libraries
<LI>Limited network access
</UL>
<P>
The native call limitation affects programmers who need to use
some sort of C- or operating system-level library to design an
applet. This is especially troublesome to applet writers who take
advantage of a database-specific feature not supported outside
of native calls.
<P>
To veteran client/server developers, however, the most troubling
idea is likely that your Web server must be on the same machine
to which your applet connects for database access. Specifically,
most Java virtual machines restrict applets from connecting to
any machine except the host that served the applet. The applet
cannot connect directly to any local or third-machine databases.
As limiting as this particular restriction seems, a three-tier
architecture provides a liberating solution.
<H3><A NAME="ConstructingaThreetierApplication"><B>Constructing
a Three-tier Application</B></A></H3>
<P>
Two-tier applications tend to push a lot of processing onto the
client machines. This architecture poses several problems:
<UL>
<LI>Client-side resource requirements balloon with the extra processing
needs. It is not uncommon to find business applications requiring
Pentiums with 32M of RAM.
<LI>User interface and business processing tend to get rolled
together, especially with the rapid application development tools
on the market. With the user interface so closely tied to business
processing, changes to one end up having a direct impact on the
other, making maintenance a headache.
<LI>With all this redundant processing occurring on many client
machines rather than in a central location, new applications are
forced to reinvent the wheel when dealing with the same business
processing.
</UL>
<P>
With the guaranteed execution environment of the Java virtual
machine and an easy-to-use Internet socket interface, Java is
actually well suited to implementing three-tier systems. A three-tier
application is one in which a third application layer exists between
the client and server layers of traditional two-tier client/server
development. This middle layer has a wide variety of uses depending
on the application.
<P>
In the three-tier architecture, the middle layer separates business
processing from the visual representation of data. This layer,
called the application server, is responsible for knowing how
to find and manipulate business data. The client evolves into
a much leaner application, responsible only for retrieving information
from the application server and displaying it on the screen.
<P>
In addition to removing a huge processing burden from client machines,
this application server can be used to consolidate enterprise-wide
business rules.
<P>
Where business rules had to be rewritten for each two-tier application
thrust on the desktop, application servers process business rules
in a single place for multiple applications to use. When the business
rules change, a change to the application server takes care of
that change for all the applications being run by the business.
<P>
Of specific interest to Java developers is the ability to hide
any knowledge of the database server from the client. Because
Internet clients view the applet or application as interfacing
with a single application server, you can use that application
server to determine such issues as where the data really exists.
Additionally, this back-end independence enables applications
to scale much easier across CPUs. Figure 15.4 shows a three-tier
architecture.
<P>
<A HREF="f15-4.gif" ><B>Figure 15.4 : </B><I>A three-tier Java applet or application.</I></A>
<H3><A NAME="AThreetierBugTrackingSystem"><B>A Three-tier Bug
Tracking System</B></A></H3>
<P>
The application server forms the core of a three-tier architecture.
In it, the business rules are defined and processed. Implementing
the counter using a three-tier architecture would naturally be
overkill. Instead, the ideal application for a three-tier design
is one in which some manipulation of data occurs or where the
data can be viewed in multiple fashions (or even better, by multiple
applications). The first step in building an application server
would thus be to identify the data processing needs of the application.
<H3><A NAME="ImplementingaThreetierApplicationwi"><B>Implementing
a Three-tier Application with Java</B></A></H3>
<P>
Figure 15.5 shows a bug tracking application implemented as a
three-tier Java application.
<P>
<A HREF="f15-5.gif" ><B>Figure 15.5 :</B> <I>A bug tracking system using a three-tier architecture.</I></A>
<P>
The only processing done on the client is the painting of GUI
widgets and user data entry. On the other end, the database server
runs on a machine otherwise inaccessible to the client applet.
The application server bridges this gap by finding desired data,
mapping it from its relational state into objects, and performing
operations on those objects.
<P>
With any three-tier architecture, the greatest programming challenge
is getting the three layers to communicate with one another. JDBC
or some similar set of database access classes should handle the
application server-to-database server communication in a manner
transparent to the application developer. The client-to-application
server solution is still left wanting.
<P>
The two best methods for providing such communication in Java
are Java sockets or distributed objects.
<P>
Compared to sockets from other languages, Java sockets are quite
simple to use. Sockets, however, force the developer to make esoteric
decisions about exactly what is being communicated between client
and application server because method calls and object passing
are better handled by the distributed objects solution. A socket
solution generally best fits an application when the scope of
communication is limited and well-defined. The bug tracking system
would be best implemented in this manner.
<P>
Distributed objects provide the more elegant solution. From the
developer's point of view, the application server objects appear
to be part of the same application as the client, just residing
on a central server and available to other applications simultaneously.
The developer handles communication simply through method calls.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
Although the original Java release did not address the issue of
database access, the JDBC specification attempts to address this
issue by defining a set of interfaces that can give applications
access to data independent of the DBMS being used to store that
data. Though this back-end independence can be very liberating,
it is important to balance it with the advantages of the DBMS
being used.
<P>
Many books cover only the subjects of database application design
and programming. This chapter does not attempt to delve into those
matters; instead, it focuses on the application of Java to database
programming.
<P>
Programmers interested in using Java to write database applications
should become familiar with the general subject matter.
<P>
In spite of the vastness of the subject matter, this chapter should
whet your appetite for database programming and prepare you at
least enough to write simple applets and applications. Much of
the Java experience you already have translates into many of the
issues specific to Java database programming. For example, applets
written to use a database must work around the strict security
limitations of Java virtual machines. Using the basics of a three-tier
architecture can help an applet get around this limitation while
giving it greater functionality. It is, however, important not
to overdesign a simple applet just for the sake of doing a three-tier
design.

<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>





</td>

<!-- end main content column -->

</tr>

<!-- end main content column -->


</tr>
</table>

</BODY>
</HTML>
