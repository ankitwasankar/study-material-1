<HTML>
<BODY BGCOLOR="white" TEXT="black" LINK="blue" ALINK="red" VLINK="green">
<BASEFONT SIZE="5">
<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META>
<H1><FONT COLOR=#FF0000>Chapter 4</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Creating Your Own Objects</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#CreatingObjectsfromJavaClasses" >Creating Objects from Java Classes</A>
<UL>
<LI><A HREF="#DeclaringtheReferenceVariable" >Declaring the Reference Variable</A>
<LI><A HREF="#CreatingtheObject" >Creating the Object</A>
<LI><A HREF="#InitializingtheObject" >Initializing the Object</A>
<LI><A HREF="#UsingtheObject" >Using the Object</A>
</UL>
<LI><A HREF="#CreatingYourOwnClasses" >Creating Your Own Classes</A>
<UL>
<LI><A HREF="#WritingtheClass" >Writing the Class</A>
<LI><A HREF="#DeclaringtheMemberVariables" >Declaring the Member Variables</A>
<LI><A HREF="#CreatingtheMethods" >Creating the Methods</A>
<LI><A HREF="#UsingInstanceMembersversusClassMemb" >Using Instance Members versus Class Members</A>
<LI><A HREF="#CreatingtheConstructorsandtheFinali" >Creating the Constructors and the Finalize() Methods</A>
</UL>
<LI><A HREF="#CreatingInterfaces" >Creating Interfaces</A>
<LI><A HREF="#UsingtheGarbageCollector" >Using the Garbage Collector</A>
<UL>
<LI><A HREF="#UnderstandingGarbageCollection" >Understanding Garbage Collection</A>
<LI><A HREF="#LookingAttheGarbageCollectorsEffec" >Looking At the Garbage Collector's Effect on Performance</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter builds on the fundamentals of object-oriented programming
covered in <A HREF="ch1.htm" >Chapter 1</A>, &quot;An Overview
of Java.&quot; It explains how to create actual objects, classes,
and interfaces. First, you will learn to create objects from the
classes in Java's packages, which are covered in <A HREF="ch3.htm" >Chapter 3</A>,
&quot;An Introduction to Java Classes.&quot; Second, you will
learn to write your own classes and methods; and third, you'll
learn how to create and use interfaces. After you master these
concepts, you will be ready to move onto all the fun chapters
that show you how to create Java applets and applications.
<P>
As you know, an <I>object</I> is an instance of a class that has
variables that describe it and methods that modify it. The Java
applications you will write will continuously create objects from
classes. Objects you create interact with other objects created
in your application by invoking methods to perform actions on
the other objects. So, essentially, all you'll need to know in
order to write a Java application is how to create objects from
classes and how to create methods to manipulate them. Using methods
to combine the functionality of individual objects, you can create
applications that can do practically anything. You can animate
graphics, create interactive games, or create an on-line order-entry
system that records and processes information a user enters into
on-line forms. Later in the book, you will learn how to write
each of these types of applications from beginning to end. This
chapter provides shorter examples to introduce you to creating
and using objects, classes, and interfaces.
<H2><A NAME="CreatingObjectsfromJavaClasses"><FONT SIZE=5 COLOR=#FF0000>Creating
Objects from Java Classes</FONT></A></H2>
<P>
The next section teaches you how to create your own class. This
section uses the classes from Java's built-in packages to concentrate
on creating objects. As you learned in <A HREF="ch3.htm" >Chapter 3</A>,
Java provides several basic libraries of classes that have been
tested and are thread-safe. You will want to use many of these
utilities provided by Java's packages in your code in order to
save time.
<P>
The operator you will use in your code to create new objects is
called, appropriately, <TT>new</TT>.
When you call the <TT>new</TT> operator
in your code, you follow it by the name of the class from which
you want to instantiate the object. Java automatically allocates
a portion of memory to store instances of the variables declared
in the class. This portion of memory is the <I>object</I>. After
allocating an object, you will use methods in the object's class
to send messages to it. You also can send messages to the object
from methods in other classes.
<P>
You can use several pieces of code to create an object in Java
in addition to the <TT>new</TT> operator.
When <TT>new</TT> creates the object
from the specified class, it automatically calls a <I>constructor</I>
to build it. The constructors you create enable parameters to
be passed to the object. You can create your own constructors
for objects, but it is not a requirement. Java calls a default
constructor if <TT>new</TT> is called
without parameters. You can create one or many constructors for
the object, each with different parameters, or you can let Java
assign a default constructor. When <TT>new</TT>
is called with parameters, Java selects the constructor you created
that has the matching parameters.
<P>
When you create an object, you typically declare a reference variable
that will hold the object's <I>reference</I>. Java creates a reference
automatically whenever <TT>new</TT>
instantiates an object in order to locate the object in memory
when necessary. You will need a <I>reference variable</I> that
stores the reference in order to refer to the object in your code.
The reference variable is a name you assign to the object.
<P>
The very rudimentary form of an object creation follows:
<BLOCKQUOTE>
<TT>classname reference-variable = new classname
(parameter list);</TT>
</BLOCKQUOTE>
<P>
Here, <TT>classname</TT> represents
the class you use to create the object. <TT>reference-variable</TT>
is the name you use to refer to the reference Java creates so
that Java's runtime system can locate it. The <TT>new</TT>
operator followed by <TT>classname</TT>
actually instantiates the object from the class. The <TT>parameter
list</TT> is the part of the object creation that specifies
which of the constructors stored in the class are used to create
the object.
<P>
The following example creates a new <TT>Rectangle</TT>
object from the <TT>Rectangle</TT>
class in the <TT>java.awt</TT> package:
<BLOCKQUOTE>
<TT>Rectangle ThisRect = new Rectangle();</TT>
</BLOCKQUOTE>
<P>
This example of the creation of a new <TT>Rectangle</TT>
object accomplishes four tasks in one line of code: it declares
the reference variable <TT>ThisRect</TT>,
creates a new <TT>Rectangle</TT> object,
assigns the <TT>Rectangle</TT> object
to the reference variable <TT>ThisRect</TT>,
and initializes the object.
<P>
These tasks can be separated into two lines in the following form:
<BLOCKQUOTE>
<TT>classname reference-variable;&nbsp;&nbsp;//variable
declaration<BR>
reference-variable = new classname (parameter list); //creation,
assignment,<BR>
</TT><FONT FACE="ZapfDingbats">&Acirc;</FONT><TT>initialization</TT>
</BLOCKQUOTE>
<P>
In the Rectangle example, you could create the <TT>Rectangle</TT>
object in two lines, as this code shows:
<BLOCKQUOTE>
<TT>Rectangle ThisRect;<BR>
ThisRect = new Rectangle();</TT>
</BLOCKQUOTE>
<H3><A NAME="DeclaringtheReferenceVariable">Declaring the Reference
Variable</A></H3>
<P>
<TT>Rectangle</TT> <TT>ThisRect</TT>
is a simple variable declaration, much like the object-variable
declarations covered in <A HREF="ch1.htm" >Chapter 1</A>. This
declaration tells the compiler that the reference variable <TT>ThisRect</TT>
refers to an object for which the class is <TT>Rectangle</TT>.
When you think about it, the class in the declaration of an object-reference
variable is very similar to the data type in the declaration of
a variable in a class. Recall that the data type explained in
<A HREF="ch1.htm" >Chapter 1</A> was declared as the following:
<BLOCKQUOTE>
<TT><I>data-type variable-name;</I></TT>
</BLOCKQUOTE>
<P>
The data types used to declare object variables basically are
predefined Java classes with states and behaviors just like any
other class, except that data types are classes that cannot be
subclassed. Therefore, you can think of the declaration of a reference
variable to hold an object just as you would the declaration of
a variable to hold a value of a data type.
<H3><A NAME="CreatingtheObject">Creating the Object</A></H3>
<P>
Declarations do not instantiate objects. <TT>Rectangle</TT>
<TT>ThisRect</TT> does not create
a new <TT>Rectangle</TT> object; it
just creates a variable named <TT>ThisRect</TT>
to hold a <TT>Rectangle</TT> object.
To instantiate the <TT>Rectangle</TT>
object, you assign the reference variable to the object-creation
sequence, which consists of the <TT>new</TT>
operator followed by the class name and its constructor parameters.
<P>
The <TT>new</TT> operator returns
a reference to the newly created <TT>Rectangle</TT>
object, which is stored in the <TT>ThisRect</TT>
reference variable.
<H3><A NAME="InitializingtheObject">Initializing the Object</A>
</H3>
<P>
<I>Constructors</I> are special methods provided by each Java
class to initialize new objects from a class. The <TT>new</TT>
operator creates the object, and the constructor initializes it.
<P>
Here's an example of using the <TT>new</TT>
operator with parameters for a constructor to build a <TT>Rectangle</TT>
object with a width of 4 and a height of 2:
<BLOCKQUOTE>
<TT>new Rectangle(4, 2);</TT>
</BLOCKQUOTE>
<P>
<TT>Java.awt.Rectangle</TT> provides
several constructors. In the example, <TT>Rectangle(4,
2)</TT> calls the constructor that exists in <TT>Java.awt.Rectangle</TT>
that has arguments that match the number and types of parameters
specified in the initialization statement. The <TT>4</TT>
and <TT>2</TT> parameters match the
number and type of the width and height arguments of the following
<TT>Java.awt.Rectangle</TT> constructor:
<BLOCKQUOTE>
<TT>public Rectangle(int width, int height);</TT>
</BLOCKQUOTE>
<P>
A class may provide multiple constructors to perform different
kinds of initializations on new objects. When looking at the implementation
for a class, you can recognize the constructors because they have
the same name as the class and have no return type. In a class
with multiple constructors, they all have the same name but different
arguments. Each constructor initializes the new object in a different
way. In addition to the default constructor used to initialize
a new <TT>Rectangle</TT> object and
the <TT>Rectangle</TT> constructor
used earlier for <TT>ThisRect</TT>,
<TT>Rectangle</TT> can use a different
constructor, as shown in this code:
<BLOCKQUOTE>
<TT>Rectangle ThisRect = new Rectangle(3,
3, 4, 2);</TT>
</BLOCKQUOTE>
<P>
This creates a <TT>Rectangle</TT>
object at point 3,3 of width 4 and height 2, using the following
constructor from <TT>Java.awt.Rectangle</TT>:
<BLOCKQUOTE>
<TT>public Rectangle(int x, int y, int width,
int height);</TT>
</BLOCKQUOTE>
<H3><A NAME="UsingtheObject">Using the Object</A></H3>
<P>
After your object is instantiated, you can change its behavior
by using methods to change the values of its variables or by directly
assigning new values to the variables. Using methods to change
variables is a more consistent way to manipulate objects. This
section examines both these procedures.
<P>
You can access an object's variables directly from another object
by adding a period (.) to the end of the reference-variable name
and appending the name of the object variable, as shown in this
example:
<BLOCKQUOTE>
<TT><I>reference-variable.variable;</I></TT>
</BLOCKQUOTE>
<P>
To access the <TT>width</TT> variable
in one of the <TT>Rectangle</TT> objects
created in the preceding section, you can use the following reference:
<BLOCKQUOTE>
<TT>ThisRect.width;</TT>
</BLOCKQUOTE>
<P>
To change the value of the <TT>width</TT>
and <TT>height</TT> variables in the
<TT>ThisRect</TT> object, you simply
set them equal to new values in the following statements:
<BLOCKQUOTE>
<TT>ThisRect.width = 5;<BR>
ThisRect.height = 3;</TT>
</BLOCKQUOTE>
<P>
To get the <TT>width</TT> variable
from the <TT>ThisRect</TT> object,
you can refer to it as the following:
<BLOCKQUOTE>
<TT>Width = ThisRect.width;</TT>
</BLOCKQUOTE>
<P>
You can call an object's methods by adding a period (.) to the
end of the reference-variable name and appending the name of the
object method, followed by parameters to the method enclosed in
parentheses:
<BLOCKQUOTE>
<TT><I>Reference-variable.methodName(parameters);</I></TT>
</BLOCKQUOTE>
<P>
To invoke the <TT>Java.awt.Rectangle.reshape</TT>
method on the <TT>ThisRect</TT> object,
you use this statement:
<BLOCKQUOTE>
<TT>ThisRect.reshape(5, 3);</TT>
</BLOCKQUOTE>
<P>
This statement reshapes the object by modifying its <TT>height</TT>
and <TT>width</TT> variables. It has
the same effect as the direct variable assignments used earlier
in this section:
<BLOCKQUOTE>
<TT>ThisRect.width = 5;<BR>
ThisRect.height = 3;</TT>
</BLOCKQUOTE>
<P>
The <TT>reshape()</TT> method in the
<TT>Java.awt.Rectangle</TT> package
is declared void, so it doesn't return a value. All methods that
are not declared as void do evaluate to some value. You can use
the value returned by a method in expressions or as variable values.
<H2><A NAME="CreatingYourOwnClasses"><FONT SIZE=5 COLOR=#FF0000>Creating
Your Own Classes</FONT></A></H2>
<P>
Although you can create functional applications by creating and
using objects with Java's built-in classes, you undoubtedly will
want to know how to create your own classes, constructors, methods,
and variables to add additional functionality to your applications.
This section explains how you can accomplish these tasks.
<H3><A NAME="WritingtheClass">Writing the Class</A></H3>
<P>
When you create your own class, you usually will want it to be
a subclass of a built-in Java class. Most basic functionality
is provided by the classes in Java's packages. By restricting
your class creations to subclasses of Java classes, you ensure
the portability of your application. You know for sure that every
user of your application will have Java's built-in classes available
in his runtime system.
<P>
Remember that the primary advantage of subclassing is that it
enables you to reuse code. You create subclasses as extensions
of existing classes to create new objects with properties that
are enhancements of existing objects. These subclasses use the
existing methods and variables of the superclass and add methods
and variables that make each subclass unique.
<P>
You learned the basic form of a class structure in <A HREF="ch1.htm" >Chapter 1</A>.
An example of how you can create a subclass called <TT>Square</TT>
from the <TT>Rectangle</TT> class
follows:
<BLOCKQUOTE>
<TT>public class Square extends Rectangle
{<BR>
//new variable and method declarations<BR>
}</TT>
</BLOCKQUOTE>
<P>
<TT>Square</TT> is the name of your
subclass. The name of your class must be a legal Java identifier
and should begin with a capital letter. The <TT>extends
Rectangle</TT> part is where the <TT>Rectangle</TT>
class is identified as the superclass. This allows the <TT>Square</TT>
class to use any variables or methods defined in <TT>Rectangle</TT>.
If a superclass is not specified, Java assumes that the <TT>Java.lang.Object</TT>
class is the superclass. The <TT>Square</TT>
class' unique variables and methods are declared next.
<P>
The <TT>class Square</TT> statement
uses the <TT>public</TT> access modifier
to allow all other classes and subclasses to access it. You can
precede a class name or method name with the word <TT>final</TT>
if you do not want the compiler to allow it to be subclassed or
overridden, or by the word <TT>abstract</TT>
if you want to require that it be subclassed.
<P>
Your subclass inherits variables and methods from its superclass
that are declared <TT>public</TT>
or <TT>protected</TT> by the superclass.
If variables and methods are declared <TT>private</TT>,
they are not inherited. If no access modifier is specified, only
classes within the same package can inherit methods and variables.
<P>
Within your subclass, you can hide the superclass' variables by
using the superclass' variable names for subclass variables, and
you can override methods inherited from the superclass. Although
the subclass does not inherit the superclass' hidden variables
and may override the superclass' methods, the subclass always
can access these variables and methods as they appear in the superclass
by using the keyword <TT>super</TT>,
as this example shows:
<BLOCKQUOTE>
<TT>ThisHeight = super.height;</TT>
</BLOCKQUOTE>
<P>
This statement refers to the value of height as it is stored in
the superclass.
<P>
You create all the methods and variables of the class, enclosing
them in curly braces ({}). The collection of methods and variable
declarations within the braces are called the <I>body</I> of the
class. The variables typically are declared first.
<H3><A NAME="DeclaringtheMemberVariables">Declaring the Member
Variables</A></H3>
<P>
The class member variable declaration is much like the reference
variable declaration in an object creation:
<BLOCKQUOTE>
<TT><I>type variable-name;</I></TT>
</BLOCKQUOTE>
<P>
The difference is that member variables exist in the body of the
class, but are declared outside of methods, object creations,
and constructors. In the following example of the <TT>Square</TT>
class, the area variable is declared:
<BLOCKQUOTE>
<TT>class Square extends Rectangle {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int area;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;// methods<BR>
}</TT>
</BLOCKQUOTE>
<P>
Typically, a member variable is not capitalized. It must be a
legal Java identifier. No two member variables within a class
can have the same name.
<P>
The member variable declaration offers several optional modifiers,
as shown in this code:
<BLOCKQUOTE>
<TT>[<I>access-modifier</I>] [static] [final]
[transient] [volatile] <I>type variable-name</I>;</TT>
</BLOCKQUOTE>
<P>
The <TT>access modifier</TT> <TT>public</TT>,
<TT>private</TT>, or <TT>protected</TT>
restricts access in the same way it does for methods and classes.
<TT>static</TT> defines the variable
as a class variable rather than an instance variable. This means
that when the variable value is changed, it is changed in all
instances. An instance variable is specific to the instance only.
<TT>final</TT> indicates that the
variable is a constant. Constant variables typically are written
in all uppercase letters. They cannot be changed. <TT>transient</TT>
indicates that the variable is not part of the persistent state
of the object and will not be saved when the object is archived.
<TT>volatile</TT> indicates that the
variable is modified asynchronously by concurrently running threads.
<H3><A NAME="CreatingtheMethods">Creating the Methods</A></H3>
<P>
As you learned in <A HREF="ch1.htm" >Chapter 1</A>, a <I>method</I>
returns a value unless it is declared as void. The method name
is preceded by a return type to inform Java of how to interpret
the value returned. It is followed by an optional list of arguments
enclosed in parentheses. Like classes and member variables, the
method declaration can be preceded by an access modifier. The
following code shows how the method declaration is structured:
<BLOCKQUOTE>
<TT>[<I>access-modifier</I>] <I>returnType
methodName</I>([<I>arguments</I>]) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//<I>statements<BR>
</I>}</TT>
</BLOCKQUOTE>
<P>
If you include arguments when you write a method, you can call
it with matching parameters. Parameters pass information to the
method.
<P>
Using the fundamentals you learned in the previous chapters of
Part I  about statements, expressions, operators, and variables,
you can create methods to manipulate your objects.
<P>
The following sections explain several types of methods available
in Java: <TT>Class</TT> and <TT>Instance</TT>
methods, constructors, and <TT>finalize()</TT>
methods.
<H3><A NAME="UsingInstanceMembersversusClassMemb">Using Instance
Members versus Class Members</A></H3>
<P>
<I>Members</I>-a word for the variables and methods in a class-can
be specific to the class or to the instance of the class, depending
on how you write them and where you place them in your code. This
is an important concept to learn, because variable values may
differ when you define them as class variables rather than instance
variables, and vice versa. Different rules apply to instance and
class members as well, so you will be prone to compile errors
if you are not mindful of these concepts.
<P>
Member variables can be class variables or instance variables.
<I>Class variables</I> are declared using the <TT>static</TT>
modifier. When Java's runtime system loads the class, the class
variables are allocated in memory only once. When instances of
the class are created, the class variables are not copied but
instead are shared by all the instances. No additional memory
is allocated for these variables because only one copy exists.
Class variables can be accessed from any instance or from the
class. Because class variables are shared by instances, the values
assigned to them are the same for all instances of the class.
When class variables are changed, they are changed universally
for all instances that refer to them.
<P>
If no modifier is specified, variables are instance variables
by default. Unlike class variables, all <I>instance variables</I>
are copied and allocated memory by the Java runtime system each
time an instance is created. An object's instance variables can
be accessed only from an object-not from the class. If you want
to access the instance variables of object A from your class,
for example, you cannot refer to it directly. You must create
a new object B that refers to it. The value of an instance variable
is specific to the object. Other objects created from the same
class can have different values assigned to their instance variables.
<P>
Member methods can be class methods or instance methods. <I>Class
methods</I> also are declared using the <TT>static</TT>
modifier. They have no access to the instance variables of the
objects. They are invoked on the class and do not require any
instance to be created in order to be called.
<P>
<I>Instance methods</I>, on the other hand, have access to the
instance variables of the object, other objects, and the class
variables of their class. They can be run only when an object
is created.
<P>
You will want to use class variables in your code when you need
only one copy of an item that must be accessible by all objects
created from the class. Using class variables saves memory. You
will want to use class methods for security reasons-to restrict
access to the objects' instance variables.
<H3><A NAME="CreatingtheConstructorsandtheFinali">Creating the
Constructors and the <TT><FONT SIZE=4>Finalize()</FONT></TT><FONT SIZE=4>
Methods</FONT></A></H3>
<P>
Constructors and <TT>finalize()</TT>
methods are special methods you can use in your class. As you
have learned, constructors are used to build objects when they
are instantiated. You can use the <TT>finalize()</TT>
method to destroy objects.
<P>
As you know, classes can store multiple constructors (all with
the same name) with different arguments that are called when the
<TT>new</TT> operator instantiates
an object with parameters. If no parameters are passed, Java assigns
a default constructor. The default constructor for the <TT>Rectangle</TT>
class, for example, is <TT>Rectangle()</TT>.
Constructors use the same access modifiers as methods and classes.
<P>
Many of Java's built-in classes provide multiple constructors.
The <TT>Java.awt.Rectangle</TT> class
that you have been using in this chapter, for example, provides
the following constructors:
<BLOCKQUOTE>
<TT>public Rectangle();<BR>
public Rectangle(int x, int y, int width, int height);<BR>
public Rectangle(int width, int height);<BR>
public Rectangle(Point p, Dimension d);<BR>
public Rectangle(Point p);<BR>
public Rectangle(Dimension d);</TT>
</BLOCKQUOTE>
<P>
In your class, you may want to create multiple constructors if
you will be passing different parameters when creating new objects.
The Java compiler decides which constructor to use based on the
number and type of parameters passed. If you create a new rectangle
with the following statement, for example, Java selects the second
constructor:
<BLOCKQUOTE>
<TT>new Rectangle(3, 3, 4, 2);</TT>
</BLOCKQUOTE>
<P>
When you write your constructors, keep in mind that each name
must be the same as the name of its class, and each constructor
must have arguments that are different in number or in type. Unlike
regular method declarations, you do not define return types.
<P>
Constructors are not limited to single-line declarations. They
can declare variables and methods like a regular method does.
Although they can look much like regular methods, you will be
able to spot constructors when you read through Java code, because
they do not specify a return type and have the same name as the
class.
<P>
If you need to access the constructors in your <TT>Square</TT>
class' superclass, for example, you can do so by using the keyword
<TT>super</TT> before the declaration:
<BLOCKQUOTE>
<TT>super.Rectangle()</TT>
</BLOCKQUOTE>
<P>
This line invokes a constructor provided by <TT>Rectangle</TT>,
which is the superclass of <TT>Square</TT>.
Typically, the superclass constructor is invoked first in the
subclass' constructor.
<P>
When objects no longer are needed in an application, they must
be cleaned out of memory. Java provides an automatic Garbage Collector
to find unused objects and reclaim their memory. The Garbage Collector
runs a <TT>finalize()</TT> method
just before clearing an object from memory. You can override Java's
<TT>finalize()</TT> method in your
code. This <TT>finalize()</TT> method,
provided by the <TT>Java.lang.Object</TT>
class, releases system resources, such as open files or open sockets,
before the object is collected. The last section of this chapter
describes in detail how garbage collection works. For now, it
is enough to know that the Garbage Collector is responsible for
automatically clearing unused objects from memory.
<P>
You have the option of using the <TT>Object</TT>
class' <TT>finalize()</TT> method
or overriding it by creating your own <TT>finalize()</TT>
method for your class. The structure of a <TT>finalize()</TT>
method declaration follows:
<BLOCKQUOTE>
<TT>protected void finalize() throws throwable{
<BR>
//statements<BR>
}</TT>
</BLOCKQUOTE>
<P>
In the body of this special method, you will close files and sockets
after determining that they are no longer in use.
<P>
To call a <TT>finalize()</TT> method
specified in your superclass, precede the name <TT>finalize()</TT>
with the keyword <TT>super</TT> and
a period (.). It is a good idea to call the superclass' <TT>finalize()</TT>
method after your class' <TT>finalize()</TT>
method, in case the object has obtained resources through methods
that it inherited. Such a <TT>finalize()</TT>
method looks like this:
<BLOCKQUOTE>
<TT>protected void finalize() throws Throwable
{<BR>
// clean up statements<BR>
super.finalize();<BR>
}</TT>
</BLOCKQUOTE>
<H2><A NAME="CreatingInterfaces"><FONT SIZE=5 COLOR=#FF0000>Creating
Interfaces</FONT></A></H2>
<P>
At this point, you know how to create classes, to define their
member variables and methods, and to instantiate objects from
them. You will be able to create some small applications with
this knowledge. Java's strict class hierarchy rules limit a subclass
you create, however, to inherit only from the classes in its hierarchy.
To create more complex applications, you undoubtedly will need
to inherit from classes outside your class' hierarchy. In Java,
you access methods and variables from classes outside your class'
hierarchy by implementing multiple interfaces in your class. These
interfaces must be defined in the foreign classes that you are
accessing. You also can make portions of your class available
to other classes that cannot inherit from it by defining interfaces
in your class.
<P>
Interfaces always are abstract. Their variables can be used only
as constants; they always are static and final. Their methods
are <TT>abstract</TT> and <TT>public</TT>.
An interface declares a set of methods and constants without specifying
the implementation for any of the methods. When a class implements
an interface, it provides implementations for all the methods
declared in the interface.
<P>
As you learned in <A HREF="ch1.htm" >Chapter 1</A>, interfaces
are implemented by a class in the class declaration:
<BLOCKQUOTE>
<TT>class classname implements [interface-list]
{<BR>
}</TT>
</BLOCKQUOTE>
<P>
The form of an interface declaration for a class follows:
<BLOCKQUOTE>
<TT>[public access-modifier] interface Interface-name
extends [interface-list]{<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //methods and constants<BR>
}</TT>
</BLOCKQUOTE>
<P>
The <TT>public access</TT> modifier
is the only modifier supported in the latest release of Java for
interfaces. It can be used before an interface declaration to
allow all other classes and packages to use it. If <TT>public</TT>
is not declared, only the classes within its package can use the
interface. The keyword <TT>interface</TT>
is followed by the name of the interface, which typically is capitalized.
The <TT>extends interface-list</TT>
part is similar to a class extending a superclass, but it can
list multiple interfaces that it extends. This list is comma-delimited.
<P>
Like inheritance in a subclass, an interface inherits all constants
and methods from the interfaces it extends unless the interface
hides an inherited constant by declaring a variable of the same
name or overrides a method with a new method declaration.
<P>
There is no need to use any of the following modifiers in an interface,
because they are invalid:
<P>
<TT>private<BR>
protected<BR>
synchronized<BR>
transient<BR>
volatile</TT>
<P>
Here is an example of an interface declaration:
<BLOCKQUOTE>
<TT>interface Movable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; void moveLeft(int x, int y);<BR>
&nbsp;&nbsp;&nbsp;&nbsp; void moveRight(int x, int y);<BR>
}</TT>
</BLOCKQUOTE>
<P>
This is an example of the implementation of the <TT>Movable()</TT>
interface in a class:
<BLOCKQUOTE>
<TT>class Rectangle implements Movable {
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; public void moveLeft(3, 1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; //code for moving object<BR>
&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
}</TT>
</BLOCKQUOTE>
<H2><A NAME="UsingtheGarbageCollector"><FONT SIZE=5 COLOR=#FF0000>Using
the Garbage Collector</FONT></A></H2>
<P>
Now that you have learned to subclass objects, you might wonder
how the memory they are allocated is managed. If you're a C++
developer, you might think that I missed some memory-management
steps in my subclassing explanation. In Java, memory management
is performed automatically with a utility called a Garbage Collector.
When an object that has been instantiated by your application
finishes performing its task, it is destroyed and Java's automatic
Garbage Collector reclaims its memory.
<P>
The Java team made its most important improvement over C++ in
automatic memory management and thread controls. Through the use
of an automatic, threaded garbage-collection utility, Java removes
the burden of memory management from the shoulders of the programmer
yet retains high performance standards. Additionally, it eliminates
the many bugs commonly caused by the use of pointers in C++ applications
without sacrificing performance. This section describes what garbage
collection is and how it uses multithreading to maintain the performance
of your application.
<H3><A NAME="UnderstandingGarbageCollection">Understanding Garbage
Collection</A></H3>
<P>
Garbage collection is Java's answer to automatic memory management.
This section on garbage collection begins by explaining why the
management of memory in a multithreaded application should be
automated, and how Java automates explicit memory management tasks
of C-type languages, and how garbage collection works.
<P>
In C and C++, creating multithreaded applications is possible
through explicit memory management. Programmers manage memory
by using memory-management libraries to allocate memory, free
memory, and keep track of which memory is available to be freed
and when. Explicit memory management has proved to be a common
source of bugs, crashes, memory leaks, and performance degradation
in C++ applications. The need to free programmers from the encumbrance
of memory management is evidenced by the fact that most bugs in
C++-type code are caused by misuse of pointers and freeing of
objects that are allocated in memory. If memory management is
automated, programmers can spend most of their time worrying about
the functionality of their applications instead of wasting it
by debugging memory problems.
<P>
Pointers, pointer arithmetic, <TT>malloc</TT>,
and <TT>free</TT>, which are used
for memory management in C++, automatically are incorporated into
Java's environment. Pointers are replaced by references. As you
discovered earlier in this chapter, Java has a <TT>new</TT>
operator, which is used to allocate memory for objects. There
is no <TT>free</TT> function, however,
that a programmer can invoke in code to clean up the memory space
when the object no longer is needed. There is, in fact, no need
to deallocate or free memory explicitly in Java.
<P>
Java generally automates memory management by tracking the use
of objects that are created as your application runs. The interpreter
automatically marks objects to be freed from memory when they
no longer are in use. Such automatic memory management is performed
by Java's Garbage Collector.
<P>
The purpose of Java's Garbage Collector is to ensure that memory
is available when it is needed. When the Garbage Collector executes,
it searches, discovers, marks, clears, and compacts unused memory,
increasing the likelihood that adequate memory resources are available
when required by the user.
<P>
More specifically, when an object is instantiated from a class,
it is given a unique reference, which is used by the Garbage Collector.
The Garbage Collector sets the reference counter to 1 when the
object is allocated. It keeps track of all the references to objects
instantiated in an application by incrementing the counter each
time an object is referenced and decrementing it when the reference
is gone. The Garbage Collector searches for reference counters
that are equal to 0, meaning that there are no more references
to the object. After discovering that a counter is set to 0, the
Garbage Collector marks the unused object for removal, making
it a candidate for garbage collection.
<P>
Java ensures that certain objects integral to the system will
never be freed, such as the <TT>Object</TT>
class.
<P>
After an object is cleared from memory, it leaves a hole the size
of the object that can be reused. The Java Garbage Collector searches
memory for fragments and reorganizes it by compacting it. When
the Garbage Collector <I>compacts</I> memory, it consolidates
the objects that have references into a contiguous group, making
one large area of unallocated memory available for use by new
objects as necessary.
<P>
Java provides for situations in which a long chain of object references
comes full circle, back to the originating reference, leaving
the counts for unused objects at 1 and the memory uncleared. Java
avoids this problem by marking root objects, searching all references
to objects, marking them, searching those objects' references,
and so on until no other references exist. The Garbage Collector
then removes all unmarked objects and compacts memory.
<P>
The effect of compacting objects is that they are moved to different
areas of memory. In Java, references to objects that have moved
are not lost, because these references are not pointers to specific
areas of memory but instead are handles that are maintained in
an <I>object index</I>, which maps them to actual objects. When
an object is moved, only its references in the object index must
be repaired.
<P>
You might wonder how such activities possibly can run throughout
the execution of an application without degrading performance.
The following section explores that question.
<H3><A NAME="LookingAttheGarbageCollectorsEffec">Looking At the
Garbage Collector's Effect on Performance</A></H3>
<P>
The Garbage Collector's processes, described in the last section,
would normally be very CPU-intensive-incrementing and decrementing
counters for vast quantities of references to objects, searching
them for 0 values, compacting memory, and remapping references
in the object index. Java's Garbage Collector is not CPU-intensive,
partly because it provides some additional tricks, such as designating
objects that do not need to be referenced and saving work for
the Garbage Collector, but mostly due to the fact that it runs
as a separate, low-priority thread.
<P>
The Java Garbage Collector takes advantage of the user's behavior
when interacting with Java applications. When a user pauses while
using an application, when the system pauses, or when the system
requires the use of memory taken up by defunct classes, the Java
runtime system runs the Garbage Collector in a low-priority background
thread and frees unused objects from memory. Because the Garbage
Collector utility is effective only because it runs in a multithreaded
environment, this section briefly explains what multithreading
means.
<P>
Multithreading is an innovation that makes applications more interactive
and faster. <I>Single-threaded</I> applications only have the
capability to execute one process at a time. While a process is
executing, all other processes are stalled. Because every application
is a separate process, you have the option of switching between
applications in such an environment, pushing one application's
processing to the foreground; this pauses all other applications,
however. When a process polls the operating system for events
and requests an event, the operating system checks to see whether
any other processes are performing any event processing and gives
them time to complete. The operating system then passes the event
to the process and allocates time for it to execute. With several
application processes given time to execute, the user perceives
that they are running simultaneously. They are not executing their
tasks simultaneously, however. If one of these processes is lengthy,
it monopolizes the system's resources and other processes do not
run.
<P>
Such an application would be fine for small tasks but would not
be practical for Internet applications, which may need to run
several applets at once or perform tasks while the user is doing
something else.
<P>
<I>Multithreaded</I> applications have the capability to maintain
multiple concurrent paths of execution. While the user is performing
some action in an application, other applications can perform
other tasks. These paths of execution are called <I>threads</I>.
<P>
Java is a multithreaded application. It balances thread synchronization
between the class level (performed at runtime) and the language
level (performed when code is written). The runtime Java interpreter
runs the Garbage Collector as a low-priority background thread
while executing an application's code without disturbing the performance
of the application. You will see how to create multithreaded applications
with the Java language in <A HREF="ch16.htm" >Chapter 16</A>,
&quot;Multithreading with Java.&quot;
<P>
Java's automatic garbage collection makes programming in Java
easier, eliminating many potential bugs that would arise if you
managed memory explicitly. It generally provides better performance
than you will find in most applications created with explicit
memory management.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
In this chapter, you learned to create objects, classes, and interfaces;
and to declare their variables and methods. If you understand
the concepts outlined in this chapter, you will have no problem
moving onto the chapters in the rest of the book. In the rest
of the chapters, you will have the opportunity to practice putting
these concepts to work while creating actual applications.

<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>





</td>

<!-- end main content column -->

</tr>

<!-- end main content column -->


</tr>
</table>

</BODY>
</HTML>
