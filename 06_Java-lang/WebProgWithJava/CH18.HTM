<HTML>
<BODY BGCOLOR="white" TEXT="black" LINK="blue" ALINK="red" VLINK="green">
<BASEFONT SIZE="5">
<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META>
<H1><FONT COLOR=#FF0000>Chapter 18</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Serious Play: Game Applets</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#ComputerGames" >Computer Games</A>
<LI><A HREF="#NetGames" >Net Games</A>
<LI><A HREF="#InterfaceDesign" >Interface Design</A>
<LI><A HREF="#TheGameofCopyCat" >The Game of CopyCat</A>
<UL>
<LI><A HREF="#LookingAtObjectsandDataFlow" >Looking At Objects and Data Flow</A>
<LI><A HREF="#CoordinatingCopyCatandPlayArea" >Coordinating CopyCat and PlayArea</A>
<LI><A HREF="#DealingwithEvents" >Dealing with Events</A>
</UL>
<LI><A HREF="#InterfaceandCommunication" >Interface and Communication</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
&quot;What's your game?&quot; Maybe that should be, &quot;What's
your definition of a game?&quot; Games play an important role
in our society. But what are games?
<P>
There are common components to all games: a goal, rules, and a
world (or a framework) in which the game is played. The goal of
a game drives the players to perform or to achieve. In chess,
the goal is to capture the opponent's King. The rules, in a way,
are impediments to achieving goals instantly. Often, the rules
make the game fair so that anyone playing the game has the same
chance at winning. In tic-tac-toe, for example, one rule is that
players must alternate turns; otherwise, one player easily would
dominate the game and win. The world in which games are played
provides a place where both the goal and the rules make sense;
it is the ground on which the struggle for the goal can be enacted.
As the rules always require, to succeed at the game, players must
remain in that world. The world of Monopoly, for example, is a
microcosm of the business world, and the players' goal is to achieve
financial domination. Players must travel around this world searching
for business prospects, acquiring properties, and becoming wealthy.
They are given the neighborhoods, currency, and power to achieve
that goal. Sometimes these components (goal, rules, world) are
difficult to identify, but in varying forms, they always exist.
For every game, when players know the rules, understand the world,
and want the goal, they can build strategies they can use to play
each game.
<P>
The ability to build strategies is important for every aspect
of life, so this chapter takes the viewpoint that games are a
testing ground for life skills. Consider the game of chess as
a testing ground for strategy, concentration, and sequencing;
the game of poker focuses on the skills of computing probability,
managing stress, and judging other players' reactions and behaviors.
This viewpoint gives you a common starting point.
<P>
What makes a good game? Good games have innumerable qualities
to them, as diverse as people's varying talents, and just as impossible
to list with any accuracy or completeness. Qualities that make
a game good engage players on the following levels:
<BLOCKQUOTE>
Achievement-challenge/improvement
</BLOCKQUOTE>
<BLOCKQUOTE>
Adrenaline-risk/chance/excitement
</BLOCKQUOTE>
<BLOCKQUOTE>
Relations-social/wit/interplay
</BLOCKQUOTE>
<BLOCKQUOTE>
Senses-sensual/auditory/tactile
</BLOCKQUOTE>
<BLOCKQUOTE>
Creativity-imagination/allusion/aesthetic
</BLOCKQUOTE>
<P>
A game that is rich with these attributes can be a good game only
if this richness is balanced with approachability. Players then
can experience the game's richness because it is accessible. This
chapter examines some examples of games and their various attributes.
<H2><A NAME="ComputerGames"><B><FONT SIZE=5 COLOR=#FF0000>Computer
Games</FONT></B></A></H2>
<P>
How do these ideas about the concept of games relate to computers?
The first step is to examine the medium. Computers are good at
manipulating and massaging information, but they have very little
tactile input and diminished human interaction. A good computer
game must take all this into account. In Solitaire, for example,
there is no human interaction, and shuffling and redealing are
time consuming. Solitaire therefore is a good example of an ideal
game to be computerized. Although the tactile handling of the
cards is lost, most people prefer the efficiency of computer shuffling
and redealing.
<P>
Instead of computerizing an existing game, many games have been
designed especially for computers. Descent, a fully 3-D battle
game, makes wonderful use of the computer medium. Specifically,
the game uses the computer's capability to manipulate 3-D information.
Any other medium would have great difficulty creating the world
of Descent. A problem with Descent, however, is that it has a
complex interface. This detracts from its popularity.
<P>
The game Lemmings, on the other hand, makes innovative use of
the computer medium with an approachable interface. The concepts
in Lemmings break new ground with interface and game design. Players
guide a group of lemmings through a maze-like world by assigning
a series of jobs to individual lemmings who aide the others in
completing the maze. Most other contemporary computer game designs
focus on manipulating only one object for success, whereas Lemmings'
focus is on a group's success, possibly at the expense of a few
individuals. The innovation in the interface is the player's ability
to control multiple individuals within one group.
<H2><A NAME="NetGames"><B><FONT SIZE=5 COLOR=#FF0000>Net Games</FONT></B></A>
</H2>
<P>
Now that home computers have the capacity to use the Internet,
there are many innovative possibilities for games. An existing
board game that would greatly benefit from a networked computer
is Diplomacy, which reenacts the First World War. The players
role-play the leaders of important European countries. Because
there is no element of chance to the game, players must conspire
with other leaders to achieve their individual goals of European
domination. Unfortunately, while playing the board game, the players
often are aware of who is talking to whom. This greatly affects
the trust factor in agreements. Imagine the game now with the
assistance of the net's anonymity. Conspiracy and backroom politics
are handled with secrecy. Much like the Solitaire example, this
game shows how a game can be enhanced by a new medium.
<P>
A good example of existing net games is multiuser dungeons (MUDs).
These let multiple people interact in one game world. Because
these games are mainly text based, they appeal to individuals'
imaginations, much like radio programs did before the advent of
television. Unfortunately, even though the text in the game can
be very appealing for imaginative purposes, the text-as an interface
to move around and interact with the world-also detracts from
the game because it is complex and cumbersome for beginners to
use.
<H2><A NAME="InterfaceDesign"><B><FONT SIZE=5 COLOR=#FF0000>Interface
Design</FONT></B></A></H2>
<P>
Looking at games now as a designer/programmer, the key concept
is the way in which players interact with the world: the interface.
A difficult interface makes a game less approachable and also
can diminish the fun of play, especially if a lot of the difficulty
of the game lies in the interface and not in the content of the
game.
<P>
A good interface is intuitive and responsive. A good way to test
whether an interface is intuitive is to have some noncomputer
people play the game with minimal prior instruction, and then
see whether they can figure it out. One thing that helps people
figure things out is to ensure that the game is responsive to
input.
<P>
Just as you saw games as a training ground for life skills, a
good way to look at computer-game design is as a training ground
for interface-design skills. Computers are information tools;
the easier it is to use the tool to process the information into
a more desirable form, the better the tool is. In the creation
of a game, the programmer is free to design innovative interfaces
without having the burden of conventional or real-world problems.
Considering the richness of games, a revolution in interface design
probably will spring from a game interface.
<H2><A NAME="TheGameofCopyCat"><B><FONT SIZE=5 COLOR=#FF0000>The
Game of </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 >CopyCat</FONT></B></TT></A>
</H2>
<P>
The CD-ROM included with this book contains an example of a game
I developed that has a good interface. The game is called <TT>CopyCat</TT>,
and it, too, has a goal, rules, and a world. The goal of the game
is to copy a picture created by several patterned faces of a cube
or some other shape. The one rule is that players can slide or
roll the shape around only in specific ways. Here, the interface
plays a central role, because the complexity of the game springs
from the way players must manipulate the shape. The world consists
of the picture to be copied, a blank frame where the copy of the
picture will be, a shape with the patterned faces with which to
make the copy, some regions where the shape can be rolled, and
a duplicate shape used for reference.
<H3><A NAME="LookingAtObjectsandDataFlow"><B>Looking At Objects
and Data Flow</B></A></H3>
<P>
To start off, you will look at the overall workings of the program.
The crucial step in programming a game is to be able to identify
the objects that are needed; it is about pattern recognition and
being able to break down the program into objects by searching
for commonalties. Finding the essence of the program often takes
a bit of work and usually requires abstract thinking. The pieces
I broke the <TT>CopyCat</TT> game
into follow:
<BLOCKQUOTE>
<TT>CopyCat<BR>
PlayArea<BR>
Board<BR>
BoardBox<BR>
GroupGraph<BR>
TFSolid</TT>
</BLOCKQUOTE>
<P>
Pieces also include your old friends from the preceding chapter:
<BLOCKQUOTE>
<TT>Rotator<BR>
Solid<BR>
Omatrix</TT>
</BLOCKQUOTE>
<P>
<TT>CopyCat</TT> is the applet, and
it is the foreman of the program; it gets all the other objects
going and then checks on them when needed. <TT>PlayArea</TT>
is a <TT>Canvas</TT> where the important
actions are performed. Most of your interest will be focused on
this class. <TT>Board</TT> is a class
that holds all the important information about the <TT>Board</TT>-the
picture to be replicated. <TT>BoardBox</TT>
is the <TT>Canvas</TT> that displays
the desired picture. The <TT>GroupGraph</TT>
holds the geometrical information about the shape/solid. <TT>TFSolid</TT>
stands for <TT>Top-Face-Solid</TT>,
which is a subclass of <TT>Solid</TT>
with special importance to the top face of the solid or shape.
<P>
Figure 18.1 shows an overview of how those pieces fit together
(after everything is instantiated by <TT>CopyCat</TT>).
I suggest that you play the game before reading the rest of this
chapter.
<P>
<A HREF="f18-1.gif" ><B>Figure 18.1 :</B> <I>The flow of CopyCat.</I></A>
<P>
Three runnable objects are in this program: <TT>CopyCat</TT>,
<TT>PlayArea</TT>, and <TT>Rotator</TT>.
You already saw what <TT>Rotator</TT>
does, so now take a look at the other two objects. This system
actually is event driven, with the threads sleeping most of the
time. You can think of <TT>CopyCat</TT>
as a lazy foreman who snoozes at his desk and only wakes up when
<TT>PlayArea</TT> tells him that there
has been some event that may be interesting-something has changed.
He deals with the event and promptly goes back to sleep. Similarly,
<TT>PlayArea</TT> works on this event-driven
idea, except he is more like a fast food cashier because he gets
a lot of events: <TT>mouse down</TT>,
<TT>mouse up</TT>, and <TT>mouse
drag</TT>. He receives all his events through the event
handler. The separate thread in <TT>PlayArea</TT>
runs animations during the play; these are used to place the top
face of the shape on the game <TT>Board</TT>.
I will go into detail about how this all works, but for now, get
a feel for the data flow.
<P>
Notice that <TT>Rotator</TT> and <TT>BoardBox</TT>
are separate from the rest of the program. <TT>Rotator</TT>
is used to display a duplicate of the shape for reference. <TT>BoardBox</TT>
is responsible for displaying the goal-the picture to be copied.
Both <TT>BoardBox</TT> and <TT>Rotator</TT>
are there only to provide static information about the game; the
shape doesn't change midway through the game and neither does
the goal. So after they are instantiated, they have no contact
with the rest of the program. Figure 18.2 shows the visible components
of <TT>CopyCat</TT>: <TT>PlayArea</TT>,
<TT>Rotator</TT>, and <TT>BoardBox</TT>.
<P>
<A HREF="f18-2.gif" ><B>Figure 18.2 :</B> <I>The visible components of CopyCat:PlayArea, Rotator and BoardBox.</I></A>
<H3><A NAME="CoordinatingCopyCatandPlayArea"><B>Coordinating </B><TT><B><FONT SIZE=4 >CopyCat</FONT></B></TT><B><FONT SIZE=4>
and </FONT></B><TT><B><FONT SIZE=4>PlayArea</FONT></B></TT></A>
</H3>
<P>
Now look at how <TT>CopyCat</TT> and
<TT>PlayArea</TT> communicate. It
is a simple interaction. <TT>CopyCat</TT>
wants to sleep until <TT>PlayArea</TT>
has <TT>changedThings</TT>. Both <TT>CopyCat</TT>
and <TT>PlayArea</TT> use <TT>Board</TT>.
<TT>Board</TT> stores the current
state of the <TT>Board</TT>; <TT>PlayArea</TT>
changes the current state of the <TT>Board</TT>
every time a top face of the shape is placed. Then <TT>CopyCat</TT>
simply checks to see whether the <TT>Board</TT>
is finished by seeing whether <TT>Board.finished</TT>
is <TT>true</TT>. In <TT>CopyCat</TT>'s
<TT>run</TT> method, shown in Listing
18.1, the line <TT>PlayArea.thingsChange();</TT>
is really a question: &quot;Have things changed?&quot; The answer
to the question is always yes, but that is because <TT>PlayArea</TT>
waits for the answer to be yes before it responds to the request.
After <TT>CopyCat</TT> waits for things
to change, it checks to see whether something important has changed.
If the number of rotations has changed from what it was before,
it updates <TT>rotations</TT> and
displays it to the screen by <TT>RecordScore</TT>.
If the player has completed the pattern, it displays the appropriate
<TT>Finished</TT> message and plays
a little tune.
<HR>
<BLOCKQUOTE>
<B>Listing 18.1. The </B><TT><B>run</B></TT><B>
method from </B><TT><B>CopyCat</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public void run(){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;rotations=0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while(true){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;.. wait for things
to change .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlayArea.thingsChange();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rotations != PlayArea.rotations){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotations = PlayArea.rotations;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecordScore(rotations);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Board.finished &amp;&amp;
!finished){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finished = true;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle.setBackground(new
Color(255,150,150));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (level1)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle.title=(String)
&quot;Finished (&quot;+rotations+&quot;/&quot;+Board.minRot+&quot;)&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle.title=(String)
&quot;Finished (&quot;+rotations+&quot;/?)&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;purrr.play();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtitle.centre();
<BR>
subtitle.repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
<TT>thingsChange</TT> works like a
door at a high-school dance, where the organizers want the same
number of girls and boys to enter. The organizers ensure this
by only accepting a girl, then a boy, then a girl, and so on.
So if the last person let in was a boy, the next boy to come in
must wait for a girl to enter. Keeping this analogy in mind, take
a look at the code. Suppose that when the variable <TT>nochange</TT>
equals <TT>false</TT>, it indicates
&quot;a girl was the last person let in.&quot; When <TT>nochange</TT>
is <TT>true</TT>, it indicates &quot;a
boy was the last person let in.&quot; The question <TT>thingsChange</TT>
is like the boy, and <TT>changedThings</TT>
is like the girl. When <TT>CopyCat</TT>
calls <TT>PlayArea.thingsChange();</TT>,
it checks whether the last person admitted was a boy (<TT>nochange</TT>
is <TT>true</TT>); if so, then it
waits/sleeps. If, while <TT>CopyCat</TT>
is sleeping, someone wakes the boy, he checks to see whether a
girl has gone through. Eventually, a girl will go through and
the boy will be let in. After going in, the <TT>nochange</TT>
variable must be set to <TT>false</TT>,
which shows that the last person through was a boy. Just in case
a girl was waiting to come in, this variable wakes up everyone.
As it turns out, the counterpart <TT>changedThings</TT>
is exactly the same (see Listing 18.2).
<HR>
<BLOCKQUOTE>
<B>Listing 18.2. The </B><TT><B>run</B></TT><B>
method from </B><TT><B>PlayArea.java</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public synchronized void thingsChange() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (nochange == true)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{ wait(); } catch (InterruptedException
e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;nochange = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;notifyAll();<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-
*/<BR>
&nbsp;&nbsp;public synchronized void changedThings() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while (nochange == false)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{ wait(); } catch (InterruptedException
e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;nochange = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;notifyAll();<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="DealingwithEvents"><B>Dealing with Events</B></A>
</H3>
<P>
How does <TT>PlayArea</TT> deal with
its events? Now that you've finished with the interaction between
<TT>PlayArea</TT> and <TT>CopyCat</TT>,
you start to see that <TT>PlayArea</TT>
is the component that does the real work.
<P>
First, you must identify all the events <TT>PlayArea</TT>
knows how to deal with. As in <TT>Rotator</TT>,
mentioned in the preceding chapter, the events dealt with are
mouse down, mouse drag, and mouse up. <TT>Rotator</TT>'s
methods are much simpler than these, so I encourage you to revisit
that chapter if this next section gets a bit too convoluted; a
reasonable understanding of <TT>Rotator</TT>'s
event handling will be very helpful. It is important to understand
the overall goal for the interface so that you can use it as a
torch to light your way through some complicated code.
<P>
The goal is to have a responsive control to move the shape. The
mouse down event is interpreted as an attempt to grab the object.
The <TT>mouseDown</TT> will<TT>
</TT>be successful if the pointer is relatively close to
the shape; otherwise, nothing happens. If the shape is under the
control of the mouse, the <TT>mouseDrag</TT>
makes sense. This <TT>mouseDrag</TT>
method is fairly intuitive. Dragging the shape simply slides the
shape to where the mouse points. The tricky part occurs when the
mouse drags the shape over an <I>oriented rough surface</I>. These
rough surfaces make the shape roll in a particular direction.
The rolling behaves like a ratchet. During a roll, the shape locks
into the desired set positions and doesn't allow the user to go
back to the previous locked position. The desired position usually
has one of the faces pointing upright; this is referred to as
the <I>top face</I>. The mouse up event is interpreted as letting
go of the shape. The only tricky part to <TT>mouseUp</TT>
is that if the shape is let go in a place on the <TT>Board</TT>
where the top face will fit, the <TT>mouseUp</TT>
method calls up a small animation that shows how the top face
is placed on the <TT>Board</TT>. If
this interface outline is a little fuzzy, I suggest that you play
the game and pay close attention to the interface.
<P>
Now you can break down each of the three methods that handle the
interface. The next section starts with the easiest: <TT>mouseDown</TT>.
<H4><TT><B>mouseDown</B></TT></H4>
<P>
In the <TT>mouseDown</TT> method,
the fast-food cashier handles the event as long as an animation
isn't running and if the pointer is close enough to the shape.
As you will see later, all events are ignored if an animation
is running. If the mouse down event is handled, to indicate to
the player that the shape now is being held, the shape is raised;
the <TT>height</TT> of the shape becomes
slightly bigger. Also, the <TT>onSolid</TT>
flag is set to <TT>true</TT>. This
tells <TT>mouseDrag</TT> that the
shape is within the control of the mouse (see Listing 18.3).
<HR>
<BLOCKQUOTE>
<B>Listing 18.3. The method </B><TT><B>mouseDown</B></TT><B>
from </B><TT><B>PlayArea</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public boolean mouseDown(java.awt.Event evt, int x,
int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* .. pick up the solid .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (!animation_running){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Math.abs(x-solid.cenx)&lt;solid.W
&amp;&amp; Math.abs(y-solid.ceny)&lt;solid.H){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onSolid = true;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height =
0.2;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H4><TT><B>mouseDrag</B></TT></H4>
<P>
Unfortunately, all the handling of events isn't so simple. The
next event handler for <TT>PlayArea</TT>
is <TT>mouseDrag</TT>, shown in Listing
18.4. If not for the rolling part, the interface would be easy.
On the other hand, the rolling is the most important part of the
interface and the program.
<P>
The drag has several behaviors or modes: <TT>TRANSLATE</TT>,
<TT>IN_A</TT>, and <TT>IN_B</TT>.
The mode used depends on whether the mouse is over one of the
rough surfaces. The <TT>TRANSLATE</TT>
mode is the default mode. Being in this mode means that the object
will only slide, because it is not on a rough surface. The orientation
of the shape will stay fixed. Being in the <TT>IN_A</TT>
and <TT>IN_B</TT> modes means that
the mouse is over one of the rough surfaces. Dragging the shape
over either of the rough surfaces might make the shape roll over.
There are two different modes because, depending on which of the
two regions the mouse is over, the shape rolls in different directions.
<P>
Because this method is very long, I'll explain it in small pieces
at a time. Listing 18.4 shows the method, along with commentary
inserted between sections of code. I'll leave the mathematical
explanations to you, because a discussion of this would bog down
an already convoluted method.
<HR>
<BLOCKQUOTE>
<B>Listing 18.4. The method </B><TT><B>mouseDrag</B></TT><B>
from </B><TT><B>PlayArea</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public boolean mouseDrag(java.awt.Event evt, int x,
int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* .. move the around the solid -- maybe
roll it .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (onSolid &amp;&amp; !animation_running){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.cenx = x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.ceny = y;</TT>
</BLOCKQUOTE>
<HR>
<P>
First, to perform the drag, the player must be holding the shape:
<TT>onSolid</TT> must be <TT>true</TT>.
The other condition is that the animations aren't running, so
the variable <TT>animation_running</TT>
is <TT>false</TT>. The next two lines
center the shape to where the mouse now is pointing.
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..&nbsp;find
the newMode--TRANSLATE, IN_A, or IN_B<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this
is used to find out whether the mode has changed .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newMode = TRANSLATE;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i=0;i&lt;2;i++){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chX = (int)((solid.cenx-region[i][0])*vec[i][0]+
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(solid.ceny-region[i][1])*vec[i][1]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int chY = (int)((solid.cenx-region[i][0])*vec[i][1]-
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(solid.ceny-region[i][1])*vec[i][0]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (chX&gt;=0
&amp;&amp; chX&lt;region[i][2] &amp;&amp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chY&gt;=0
&amp;&amp; chY&lt;region[i][3]) newMode = i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
This segment of code figures out which region of <TT>PlayArea
</TT>the mouse is on. <TT>TRANSLATE</TT>,
<TT>IN_A</TT>, and <TT>IN_B</TT>
are <TT>public static final</TT> variables
or constants; they are used to make values of the mode easy to
identify. The only purpose is to compute the <TT>newMode</TT>.
<BLOCKQUOTE>
<TT>...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode == TRANSLATE) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode != newMode)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode
= newMode;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_roll
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
The <TT>TRANSLATE</TT> mode is the
easiest mode, because the shape already follows the mouse's pointer.
The only thing it must do is prepare the shape for a roll if the
<TT>newMode</TT> is different from
<TT>TRANSLATE</TT>. The Boolean variable,
<TT>start_roll</TT>, is used as a
flag to run some code later. Actually, a better way to handle
starting a roll is to construct a method called <TT>startRoll</TT>.
The code that computes the <TT>newMode</TT>
probably should be its own method, too.
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* .. mode = IN_A
or IN_B .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mode != newMode)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
.. not in roll region anymore .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode
= TRANSLATE;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ang &lt; sign(angle)*angle/2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.pos
= oldPos;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ang&gt;SMALL_ANG) sounds[THUD].play();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sounds[THUD].play();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotations++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changedThings();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.orient
= group.element[group.pos];</TT>
</BLOCKQUOTE>
<P>
This section deals with being on a rough surface. If the <TT>newMode</TT>
is different from the old mode (this means that the mouse is off
the rough surface it was on), you must ensure that the shape is
in one of the standard positions and not partially rotated. This
is one of the underlying properties of the modes; a given mode
assumes that the shape has a certain orientation. If the shape
is not in one of the fixed positions, you take it to the closest
fixed position. This is determined by how close <TT>ang</TT>
is to <TT>angle,</TT> where <TT>ang</TT>
is the current angle of rotation of the shape relative to the
last fixed position, and <TT>angle</TT>
is the amount of rotation needed to get from the last fixed position
to the new fixed position. So the question really is, <I>Is </I><TT><I>ang</I></TT><I>
closer to zero or to </I><TT><I>angle</I></TT>?
If it falls back to the old position, it will only make a <TT>THUD</TT>
noise if the fall was big enough-that is, <TT>ang</TT>
exceeded <TT>SMALL_ANG</TT>. Otherwise,
the shape falls to the new position, the number of <TT>rotations</TT>
is incremented, and <TT>CopyCat</TT>
is informed of the change.
<BLOCKQUOTE>
<TT>}&nbsp;else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
.. in roll region .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ang
= (vec[mode][0]*(x-lastPt[0]) + vec[mode][1]*(y-lastPt[1]))*<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROLL_VALUE/solid.W;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ang&lt;0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ang
= 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPt[0]
= x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPt[1]
= y;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ang&gt;Math.abs(angle)) { /* .. finished one rotation .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotations++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changedThings();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sounds[THUD].play();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.orient
= group.element[group.pos];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_roll
= true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp.Rotation(1,2,sign(angle)*ang);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.orient
= mid.Times(tmp.Times&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><FONT FACE="Wingdings">&Acirc;</FONT><TT>(mid.Transpose().Times(group.element[oldPos])));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
Here, the mode has not changed; the shape is still on a rough
surface. The variable <TT>ang</TT>
represents the angle at which the shape will be rotated toward
the new position. It depends on how far away the mouse position
is from the start of the roll, <TT>lastPt</TT>,
in a certain direction. The interface works like a ratchet; when
putting in a bolt, the ratchet is free to turn counterclockwise
and the bolt is not turned, but the ratchet locks into the last
position it passed when it is turned clockwise, and then the bolt
can be turned. Taking this analogy back to the interface, the
shape rolls freely when you move the mouse in one direction, analogous
to the counterclockwise ratchet. Moving the mouse in the other
direction locks the rolling mechanism of the shape, like the locked
clockwise-turning ratchet. Here, if <TT>ang</TT>
turns out to be negative, the shape does not rotate; with a positive
<TT>ang</TT>, however, the shape does
rotate. After <TT>ang</TT> reaches
<TT>angle</TT> (the angle of the next
position), you must increment the number of <TT>rotations</TT>,
inform <TT>CopyCat</TT> of the change,
make the <TT>THUD</TT> noise, and
start a new roll. Otherwise, you must calculate the orientation
of the shape in the intermediate position between the old fixed
position and the new fixed position.
<BLOCKQUOTE>
<TT>if (start_roll){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldPos = group.pos;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.pos = group.arrows[group.pos][mode];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle = mid.FindTran(solid.orient,group.element[group.pos]);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPt[0] = x;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastPt[1] = y;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start_roll = false;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
Here, you finally have the code for how to start a new roll. The
old fixed position, <TT>oldPos</TT>,
is saved and the new position, <TT>group.pos</TT>,
is figured out. The <TT>angle</TT>
to the new position is calculated, and the matrix <TT>mid</TT>
is computed to help figure out the intermediate positions. Finally,
the <TT>lastPt</TT> is recorded so
that it can be used for the calculation of <TT>ang</TT>.
<BLOCKQUOTE>
<TT>repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
All the changes then are thrown to the screen with <TT>repaint</TT>.
<TT>return true;</TT> tells the event
handler that the <TT>mouseDrag</TT>
has been handled. It turns out that the only real things you affected
in this whole method are the orientation and position of the shape.
It is a good idea to keep the event handlers as simple as possible,
because these method are called very often. Even though the code
looks long, because there are really only three methods in this
method, it is fairly fast. Figures 18.3 and 18.4 demonstrate two
drags.
<P>
<A HREF="f18-3.gif" ><B>Figure 18.3 :</B> <I>A drag in the TRANSLATE mode.</I></A>
<BR>
<P>
<A HREF="f18-4.gif" ><B>Figure 18.4 :</B> <I>A drag in the IN_B mode.</I></A>
<H4><TT><B>mouseUp</B></TT></H4>
<P>
The <TT>mouseUp</TT> method associates
releasing the mouse button with letting the shape go. If the shape
is let go close enough to a place where it fits on the <TT>Board</TT>,
the top face of the shape is placed on the <TT>Board</TT>.
Otherwise, the shape is placed by changing the <TT>height</TT>
variable. One other case also must be handled; if the player drops
the shape outside of <TT>PlayArea</TT>,
it brings the shape back to the initial position. Of course, not
taking care of that case would mean that the player would never
be able to retrieve the shape, which would really slow down the
game.
<BLOCKQUOTE>
<TT>/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public boolean mouseUp(java.awt.Event evt, int x,
int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* .. place the pattern down .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (onSolid &amp;&amp; !animation_running){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* .. See if it's close enough
to a location that is the same type .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onSolid = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height = -0.05;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Board.ClosestFace(x,y,CLOSE_ENOUGH))
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (group.blank[Board.face[Board.closestface]]==group.blank[group.pos]){
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.cenx
= Board.vertex[Board.closestface][0];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.ceny
= Board.vertex[Board.closestface][1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Board.faceTry[Board.closestface]
= group.smallestFace[group.pos];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Board.finished
= (Board.nvert == Board.NumCorrect());<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changedThings();
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(level1) solid.ExplodePrep(group.tilt);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
solid.StampPrep(group.tilt);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
Thread(this).start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x&lt;0 || x&gt;W || y&lt;0
|| y&gt;H) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goToStart(false);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return false;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
If the shape is placed on the <TT>Board</TT>,
there is some bookkeeping to take care of: centering the shape
over the <TT>Board</TT> where the
top face will be placed, updating the <TT>Board</TT>
and notifying <TT>CopyCat</TT> of
the change, and starting the animation of placing the top face
on the player's copy of the picture. The animations are either
an explosion (level 1), where the top face lands on the <TT>Board</TT>
(this takes about 10 frames); or a 20-frame animation (level 2),
where the shape flips and stamps the <TT>Board</TT>,
leaving a mirror<I> </I>image imprint of the top face. See Figures
18.5 and 18.6.<BR>
<P>
<A HREF="f18-5.gif" ><B>Figure 18.5 :</B> <I>Dropping the shape in a location not desired.</I></A>
<BR>
<A HREF="f18-6.gif" ><B>Figure 18.6 :</B> <I>Dropping the shape in a place it fits on the board--the top face drops to the board and the other faces blow away.</I></A>
<H2><A NAME="InterfaceandCommunication"><B><FONT SIZE=5 COLOR=#FF0000>Interface
and Communication</FONT></B></A></H2>
<P>
Computer games take on many different forms, so it is difficult
to come up with useful programming tips and examples that would
apply to all games. I have two principles that I follow in game
design. One is to delegate the responsibilities of managing the
game world to simpler objects that communicate with one other.
Another is to search for a responsive, intuitive interface-some
natural way that players can communicate their will to the game's
world. With these ideas for designing an effective interface and
an efficient internal representation of the game world, a good
game concept can be turned into a good game. Without these designing
ideas, however, this same concept easily could turn into one of
the many &quot;cr-applets&quot; on the net.
<P>
I have illustrated these ideas with the game <TT>CopyCat</TT>.
I broke down <TT>CopyCat</TT> into
its functional parts, which communicate with each other to present
and manage the game's world. In general, decomposing a game into
usable objects can be very tricky. Deciding where to draw the
lines between objects depends on not only the specific original
intended uses of the objects, but also on possible future uses.
Developing an eye for pattern recognition, along with learning
good data structures, will help you develop this skill of decomposition.
For beginning game programmers to learn this skill, it is good
practice to constantly revise and redesign the internal workings
of games to try to push the flexibility of their games. The flexibility
of a game is a good measure of how well the internal workings
of the game were thought out.
<P>
Also, <TT>CopyCat</TT> has a responsive
intuitive interface. The essence of <TT>CopyCat</TT>'s
interface is that for every action the player makes in the game,
there is a response so that the player knows the computer understood
the attempted action. Every time the player &quot;picks up the
shape,&quot; for example, it raises slightly; the shape lowers
when the player lets go of it. The control of the rolling allows
for many intermediate positions. Generically, this is like a conversation
between the player and the game. The player says, &quot;blah blah
blah,&quot; and the game has some response. The game may merely
nod so that the player can continue talking, knowing that the
last statement was understood; or, the game may do something more
noticeable, depending on what the player has said. In designing
the interface, the programmer is designing a limited language
that the player uses to interact or converse with the game. The
simpler or more familiar the language, the easier it is for the
player to play the game. In <TT>CopyCat</TT>,
the interface is relatively easy because it draws on people's
experiences with the physical world: rolling and sliding shapes,
ratchets, ink stamps, puzzles, and probably a lot more. This physicality,
along with the drag-and-drop idea, makes the interface/language
familiar to a lot of people.
<P>
With these principles, a sprinkle of the ideas from <A HREF="ch12.htm" >Chapter 12</A>,
&quot;Network Programming with Java,&quot; some laser pistols
or swords, and a lot of sleepless nights, you could be the creator
of the greatest net game to ever be caught in the Web.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
The Web has changed not only the way we view information, but
also the way we interact with it. Web games can help us acquire
the new life-skills of this information age.
<P>
The Java language provides simple but powerful tools for designing
professional interfaces. The <TT>CopyCat</TT>
applet shows the ease of dealing with the mouse events to communicate
complex messages to the world of the game. Now it is up to you
to tame the event handlers and catch some sockets and do some
serious playing around. 

<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>





</td>

<!-- end main content column -->

</tr>

<!-- end main content column -->


</tr>
</table>

</BODY>
</HTML>
