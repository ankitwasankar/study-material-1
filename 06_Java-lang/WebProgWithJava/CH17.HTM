<HTML>
<BODY BGCOLOR="white" TEXT="black" LINK="blue" ALINK="red" VLINK="green">
<BASEFONT SIZE="5">
<font face="Arial,Helvetica" size="-1" color="#006666"><A HREF="/reference/r_library.html"><B>All Categories</A> :</B>
<b><A HREF="/reference/r_java.html">Java</A></b></font><p>

   <META>
<H1><FONT COLOR=#FF0000>Chapter 17</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Advanced Graphics: Multimedia</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#IntroductionTheInformationAge" >Introduction: The Information Age</A>
<UL>
<LI><A HREF="#TheInternetMedium" >The Internet Medium</A>
<LI><A HREF="#InformationFormat" >Information Format</A>
</UL>
<LI><A HREF="#Rotator" >Rotator</A>
<UL>
<LI><A HREF="#TheSubtletiesofUpdateandPaint" >The Subtleties of Update and Paint</A>
<LI><A HREF="#RotatorontheRun" >Rotator on the Run</A>
</UL>
<LI><A HREF="#OmatrixandSolidClasses" >Omatrix and Solid Classes</A>
<UL>
<LI><A HREF="#Omatrix" >Omatrix</A>
<LI><A HREF="#Solid" >Solid</A>
</UL>
<LI><A HREF="#SummaryTheBottomLineIsBandwidth" >Summary: The Bottom Line Is Bandwidth</A>
</UL>
<HR>
<H2><A NAME="IntroductionTheInformationAge"><B><FONT SIZE=5 COLOR=#FF0000>Introduction:
The Information Age</FONT></B></A></H2>
<P>
There is no doubt that we are in the information age. Right now,
people are reading books, newspapers, magazines, journals, listening
to radios, and watching TV. Information is flowing like a million
rivers spreading their spider web tributaries across the world.
Information is a profitable commodity with large corollary industries.
There are many different distribution paths for information. An
example is a book, which is directly bought (and read). A more
complex distribution path is the use of advertisers to support
TV and radio stations' programs (the information). Stations attempt
to draw in the most viewers possible so that advertisers have
a large pool of viewers' time to buy.
<P>
One of the newest distribution paths for information is the Internet.
Information is put on the Internet to be read. Since there is
such an abundance of information on the net, the information needs
to be very impressive for people to want to read it. Advertisers
may wish to embed their advertisements in Internet information
with a high readership, just as they target radio and TV stations
that have high viewerships. But regardless of whether information
providers seek to sell time to advertisers with their information,
they are still likely to make their information as impressive
as possible to the readers.
<P>
The best way to create impressive presentations is to understand
the medium. For instance, an example of misuse of a medium is
a TV show that scrolls by the text of a Shakespearean play. This
is unsuccessful because it is not using the benefits of the TV
medium-moving picture and sound. For the text of a Shakespearean
play, this interface is much worse than a book as a medium because
the TV scroll does not account for the reader's speed, a reader
cannot refer back to earlier passages to check forgotten characters
or internal references, and such. Thus most viewers prefer to
watch a mindless sitcom on TV-which more effectively uses the
TV medium's potential benefits-than read a Shakespearean play
on TV, even though the play has considerably more quality content
than the sitcom.
<H3><A NAME="TheInternetMedium"><B>The Internet Medium</B></A>
</H3>
<P>
What is the Internet as a medium about? As with TV, information
on the Internet can be displayed by pictures and sound. However,
on the Internet, viewers have more freedom in what they view,
they can interact with the information they view, and they can
interact with other viewers. The Internet can use most forms of
media (visual, auditory, textual, and so forth).
<P>
However, the Internet does have two serious drawbacks: bandwidth
limitations and accessibility. Radio shows and songs can be heard
over the Internet (with RealAudio <TT><A TARGET="resource window" HREF="http://www.realaudio.com">http://www.realaudio.com</A></TT>),
but the bandwidth problems reduce the sound quality. Similarly,
TV has bandwidth problems that reduce picture quality. Books on
the other hand can be comfortably downloaded but the interface
is not as physically convenient as a hand-held novel. Even for
interactive computer games and educational tools, CDs are better
because all of the information is local. It is therefore much
quicker than the Internet-again, a bandwidth problem. On the other
hand, CDs are static, so there is no real interaction with the
information. Accessibility is another problem as there are still
many individuals and companies who lack Internet access. Once
accessed, the information is not always portable.
<P>
The best use of the Internet as a medium is one that maximizes
its potential benefits and minimizes the problems like bandwidth
limitations and accessibility. The Internet is therefore the best
medium for numerous uses, including the following:
<UL>
<LI><FONT COLOR=#000000>Information that changes frequently</FONT>
<LI><FONT COLOR=#000000>Information with a high degree of specificity</FONT>
<LI><FONT COLOR=#000000>Inexpensive worldwide distribution of
information</FONT>
<LI><FONT COLOR=#000000>User interaction with the information</FONT>
</UL>
<H3><A NAME="InformationFormat"><B>Information Format</B></A>
</H3>
<P>
How can the information be displayed effectively? This question
brings up the focus of this chapter. Computers are very good at
manipulating and massaging data. It is important to give the computer
the information in a format such that the computer can play with
it and output the data in many ways. For instance, text of many
Web pages can be configured by viewers. They can change the font,
font size, and page size and search for key words. If, instead
of using primitive text, the text is scanned in from a page in
a book (maybe in the format of a bitmap), then viewers can do
very little with the information. The format of the information
is thus of vital importance, and choosing a format that is appropriate
needs to be stressed.
<P>
When designing a format for graphics, you can learn from the flexibility
shown in the text format, as in the previous example. Finally,
you arrive at a strategy for making impressive graphics. Right
now, there are many pages that use <TT>ImageloopItem</TT>
written by James Gosling at Sun Systems or its descendants like
the Animator. <TT>ImageloopItem</TT>
takes a series of GIFs and flips through them, making a short
animation. The Java mascot Duke is a classic example. Duke waves
every once in a while-it is very impressively done. The animation
consists of ten images that are 55x68 pixels. In total, it consists
of approximately 20K of data and 3K of class files. I contrast
this example with my program <TT>Rotator</TT>,
which uses a very different technology. <TT>Rotator</TT>
uses more primitive data and constructs the images from the data.
The example I use has 1K of data and 16K of class files.
<H2><A NAME="Rotator"><TT><B><FONT SIZE=5 COLOR=#FF0000>Rotator</FONT></B></TT></A>
</H2>
<P>
All the previous discussion leads to <TT>Rotator</TT>.
<TT>Rotator</TT> is a utility that
displays rotating 3-D shapes. The shapes are composed of colored
polygons that fit together snugly. The output (the picture) is
shown on a <TT>Canvas</TT> whose size
is determined at runtime. The main method of achieving a 3D effect
with the shape is to keep the picture rotating continuously, but
perspective, shading, and hidden face removal also help achieve
this effect. There is a simple interface that allows the user
to move the shape around. The original intent of the utility was
to make geometrical objects accessible, but this utility can also
be used to make 3-D logos spin, bounce, and move in fascinating
patterns. Much of the appeal of these 3-D logos compared with
many of the standard 3-D logos is that they are interactive, and
they have infinite variety, as opposed to a fixed collection of
frames.
<P>
<TT>Rotator</TT> is an extension of
<TT>Canvas</TT>, which is a &quot;component.&quot;
This means <TT>Rotator</TT> inherits
a large number of methods that relate to input from the keyboard
and mouse, and graphics (these methods can be found in the API
User's Guide). <TT>Rotator</TT> is
thus in the same family as <TT>Label</TT>,
<TT>Button</TT>, <TT>List</TT>,
<TT>TextComponent</TT> and such, which
means that it is simple to place <TT>Rotator</TT>
within a complex applet like a data entry form or the game in
<A HREF="ch18.htm" >Chapter 18</A>, &quot;Serious Play: Game Applets.&quot;
<P>
For instance, Listing 17.1 is a section of code that adds <TT>Rotator</TT>
to a panel.
<HR>
<BLOCKQUOTE>
<B>Listing 17.1. Excerpt from </B><TT><B>SimpleApplet</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Rotator rotator= new Rotator(this,solid,W,H);
<BR>
new Thread(rotator).start();<BR>
rotator.background = new Color(255,200,200);<BR>
add(rotator);<BR>
show();</TT>
</BLOCKQUOTE>
<HR>
<P>
This code comes from <TT>SimpleApplet.java</TT>.
Rotator has its own thread, making the continuous rotating independent
and easy.
<P>
The classes that <TT>Rotator</TT>
uses are <TT>Solid</TT> (which later
gets extended to <TT>NCSolid</TT>-non-convex
solid) and <TT>Omatrix</TT>. The <TT>Solid</TT>
class holds all the information about the shape: faces, colors,
position, and how to draw the shape. The <TT>Omatrix</TT>
class holds all the information about orientations of shapes:
how the shape sits in space. With these general class descriptions
in mind, take a look at the code for <TT>Rotator</TT>
in Listing 17.2.
<HR>
<BLOCKQUOTE>
<B>Listing 17.2. </B><TT><B>Rotator</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.applet.*;<BR>
import java.awt.*;<BR>
import java.net.*;<BR>
import java.lang.*;<BR>
import Solid;<BR>
import Omatrix;<BR>
<BR>
/*----------------------------------------------------------------------*/
<BR>
public class Rotator extends Canvas implements Runnable {<BR>
&nbsp;&nbsp;public Color background;<BR>
<BR>
&nbsp;&nbsp;private int W,H,delay,oldx,oldy;<BR>
&nbsp;&nbsp;private double angle,angle0=0,bounce=0;<BR>
&nbsp;&nbsp;private boolean keep_going;<BR>
<BR>
&nbsp;&nbsp;private Solid solid;<BR>
&nbsp;&nbsp;private Omatrix tmp,tmp2,tmp3,M0;<BR>
&nbsp;&nbsp;private Image im;<BR>
&nbsp;&nbsp;private Graphics offscreen;</TT>
</BLOCKQUOTE>
<HR>
<P>
The only public variable is <TT>background</TT>;
all the other variables can only be accessed by <TT>Rotator</TT>'s
methods. The purpose of the variables will become clear later,
as they are used.
<P>
Listing 17.3 shows the constructor (there is only one for now).
<HR>
<BLOCKQUOTE>
<B>Listing 17.3. Constructor for </B><TT><B>Rotator</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;Rotator(Applet applet,Solid solid_,int width,int height)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;solid = solid_;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;W = width;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;H = height;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M0 = new Omatrix();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tmp = new Omatrix();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tmp2 = new Omatrix();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tmp3 = new Omatrix();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;angle0 = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;delay = 100;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;resize(W,H);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;im = applet.createImage(W,H);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;background = Color.lightGray;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setBackground(background);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offscreen = im.getGraphics();<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Now, look at two major aspects of the above code. First, the reference
<TT>solid</TT> is set to match the
reference passed in <TT>solid</TT>_
since <TT>solid</TT>_'s scope is only
the constructor; these references are now equivalent. The reference
refers to the object that knows everything about the shape to
be drawn. Similarly, <TT>W</TT> and
<TT>H</TT> are set to the values passed
in. Then four orientation matrices (<TT>Omatrix</TT>)
are instantiated. <TT>M0</TT> stands
for the initial orientation, and all <TT>tmp</TT>s
signify temporary matrices that are used to do calculations.
<P>
Second, regarding the display, the <TT>Canvas</TT>
is resized to the desired width and height, creating an image,
<TT>im</TT>, that is used for double
buffering. This means that instead of drawing directly to the
screen, you can create an image that you can take your time drawing
and then when you are finished drawing, you can throw the whole
image to the screen. This stops the distracting flicker that some
programs have. The image is basically a block of memory for which
the object, <TT>offscreen</TT>, can
manipulate with the graphics methods like <TT>fillRect</TT>,
<TT>setColor</TT>, <TT>drawPoly</TT>
and so forth.
<H3><A NAME="TheSubtletiesofUpdateandPaint"><B>The Subtleties
of </B><TT><B><FONT SIZE=4>Update</FONT></B></TT><B><FONT SIZE=4>
and </FONT></B><TT><B><FONT SIZE=4>Paint</FONT></B></TT></A>
</H3>
<P>
Since this is the graphics chapter, I had better start drawing
things! The three essential methods in a <TT>Canvas</TT>
are <TT>paint</TT>, <TT>update</TT>,
and <TT>repaint</TT>. The first information
to know about these methods is how they fit in the hierarchy.
<TT>Paint</TT> and <TT>update</TT>
are methods called by the parent. The parent calls the <TT>Canvas</TT>'
<TT>paint</TT> method when the <TT>Canvas</TT>
is initialized. Also, if part or all of the <TT>Canvas</TT>
gets covered by another window, the parent can call the paint
command to fix its appearance. If the <TT>Canvas</TT>
is static, this is the only method required. If the <TT>Canvas</TT>
changes, as in the case of animation, then the <TT>Canvas</TT>
calls the 'repaint,' which notifies the parent that it should
update the <TT>Canvas</TT>; the parent
then calls the <TT>Canvas</TT>' <TT>update</TT>
method.
<P>
Often it is easier to redraw the whole picture than to change
only what needs to be changed. The following strategy achieves
this:
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;public void update(Graphics
g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;paint(g);<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<P>
Unfortunately, this solution introduces a flicker problem. The
paint method starts by clearing the <TT>Canvas</TT>,
and then numerous commands draw the picture. There can be a noticeable
time lag between the execution of the first and last commands
in the drawing sequence, which is distracting.
<P>
The way to solve this problem is by reversing the roles of <TT>update</TT>
and <TT>paint</TT>: have <TT>paint</TT>
call <TT>update</TT>. As well, you
may add a double buffer. The <TT>update</TT>
is likely called more frequently than the <TT>paint</TT>,
so it makes sense for it to be the dominant method of the two.
<P>
Listing 17.4 shows <TT>Rotator</TT>'s
<TT>paint</TT> and <TT>update</TT>
methods.
<HR>
<BLOCKQUOTE>
<B>Listing 17.4. </B><TT><B>Rotator</B></TT><B>'s
</B><TT><B>paint</B></TT><B> and </B><TT><B>update</B></TT><B>
methods.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public void paint(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;update(g);<BR>
&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offscreen.setColor(background);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offscreen.fillRect(0, 0, W, H);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;solid.Draw(offscreen,(int)(W/2),(int)(H/2),bounce);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(im, 0, 0, null);<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
This simple <TT>update</TT> draws
a filled rectangle to <TT>offscreen</TT>
(which effectively clears anything that is on the off screen)
and then draws the <TT>solid</TT>.
The <TT>offscreen</TT> image, <TT>im</TT>,
is then drawn to <TT>g</TT>. This
<TT>g</TT> is a graphics context like
<TT>offscreen</TT>, but it is beyond
the scope of this class; it must be supplied by the parent.
<P>
In the <TT>update</TT> method of <TT>Rotator</TT>,
there is little that can change except the variable <TT>bounce</TT>.
Another value that may change-although it is not readily apparent-is
the orientation matrix of the shape that is encapsulated in the
object, <TT>solid</TT>. In the run
method of <TT>Rotator</TT>, repaint
is called. The <TT>update</TT> then
draws the picture using the current bounce and shape orientation
values. If they have changed since the last update, the current
picture may be drastically different from the previous picture.
<H3><A NAME="RotatorontheRun"><TT><B><FONT SIZE=4>Rotator</FONT></B></TT><B><FONT SIZE=4>
on the Run</FONT></B></A></H3>
<P>
The run method of <TT>Rotator</TT>
is conceptually simple, as shown in Listing 17.5. It updates the
height and the orientation of the shape and then redraws the shape.
It then loops until it is told to stop.
<HR>
<BLOCKQUOTE>
<B>Listing 17.5. </B><TT><B>Run</B></TT><B>
method for </B><TT><B>Rotator</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public void run(){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;keep_going = true;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;angle=0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while(keep_going){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..&nbsp;modify bounce
and solid.orient .. */<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle += 0.1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp3.Rotation(1,2,angle);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp2.Rotation(1,0,angle*Math.sqrt(2)/2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp.Rotation(0,2,angle*Math.PI/4);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solid.orient = tmp3.Times(tmp2.Times(tmp.Times(M0)));
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bounce = Math.abs(Math.cos(0.5*(angle+angle0)))*2-1;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(delay);}
catch (InterruptedException e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
Referring to the loop in the above code, <TT>solid.orient</TT>
(the shape's orientation) is a function of <TT>angle</TT>,
with <TT>M0</TT> as the initial value.
<TT>Bounce (the shape's height)</TT>,
however, is a function of <TT>angle</TT>,
with <TT>angle0</TT> as its initial
value. The values of <TT>solid.orient</TT>
exhibit interesting behavior: theoretically, the orientation never
repeats. The <TT>Rotation</TT> and
<TT>Times</TT> methods are discussed
later in the chapter.
<P>
After the request to update via the <TT>repaint</TT>
command, the run thread sleeps for a while to give up the CPU
for other threads. This process continues as long as <TT>keep_going</TT>
is true.
<P>
A simple and logical interface is essential to any interactive
application. Now look at a simple interface for <TT>Rotator</TT>
that gives the user control of the shape's orientation, rather
than leaving the shape to tumble in accordance with the convoluted
function. The interface design is this: the tumbling stops when
users press a mouse button. They may then drag the mouse to rotate
the shape in chosen directions at will. Letting go of the mouse
button returns the shape to its tumbling.
<P>
The first step in designing this interface is to stop the run
thread when a mouse button is pressed, as shown in Listing 17.6.
<HR>
<BLOCKQUOTE>
<B>Listing 17.6. </B><TT><B>Rotator</B></TT><B>:
</B><TT><B>mouseDown</B></TT><B> routine.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public boolean mouseDown(java.awt.Event evt, int x,
int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;keep_going = false;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;try {Thread.sleep(delay*2);} catch (InterruptedException
e){}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M0 = solid.orient;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;angle0 += angle;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;angle = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;oldx = x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;oldy = y;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The first line ensures that the run process eventually finishes.
The sleep command waits to make sure this is so. The current value
of the shape's orientation is saved, as it becomes the new initial
value. When the tumbling resumes, it thus resumes from the current
orientation. The variables <TT>oldx</TT>
and <TT>oldy</TT> record the position
where the mouse has been pressed; this is used to determine how
much the mouse moves during a <TT>mouseDrag</TT>.
The &quot;<TT>return true</TT>&quot;
tells the <TT>Rotator</TT>'s parent
that the <TT>mouseDown</TT> event
has been handled, so there is no need for another thread or process
to handle the <TT>mouseDown</TT> event.
<P>
The responsibility of returning the shape to the tumbling shape
falls on the <TT>mouseUp</TT> method,
as shown in Listing 17.7. But all it has to do is start a <TT>new</TT>
run thread.
<HR>
<BLOCKQUOTE>
<B>Listing 17.7. </B><TT><B>Rotator: mouseUp</B></TT><B>
routine.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public boolean mouseUp(java.awt.Event evt, int x,
int y)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;new Thread(this).start();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT>mouseUp</TT> event starts
the shape tumbling again by starting the  <TT>this</TT>
thread, that is, starting the <TT>run</TT>
method of this object (<TT>Rotator</TT>).
<P>
Finally, you arrive at the sensitive part of this interface. The
<TT>mouseDrag</TT> method allows the
user to manipulate the shape. You use the difference between the
old and new mouse position to calculate how you want the shape
moved.
<HR>
<BLOCKQUOTE>
<B>Listing 17.8. </B><TT><B>Rotator: mouseDrag</B></TT><B>
routine.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;*/
<BR>
&nbsp;&nbsp;public boolean mouseDrag(java.awt.Event evt, int x,
int y) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tmp2.Rotation(0,2,(x - oldx) * Math.PI/
solid.W);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tmp.Rotation(1,2,(oldy - y) * Math.PI/
solid.H);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M0 = tmp.Times(tmp2.Times(M0));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;solid.orient = M0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;oldx = x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;oldy = y;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;repaint();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return true;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
The first line of this method causes the shape to rotate in the
XZ-plane by an angle that relates to the drag motion in the x
direction, the angle being equal to (x-oldx)*constant. Similarly,
the second line rotates in the YZ-plane. This case differs from
the previous one by a minus sign; this is because the origin is
in the upper left corner, and traveling down the screen corresponds
to an increase in the y value. Since <TT>M0</TT>
always refers to the current orientation during <TT>mouseDrag</TT>,
when the <TT>mouseUp</TT> is called
the shape begins tumbling again starting with the current orientation.
<P>
Although this finishes the brief discussion of this interface,
the next chapter looks more deeply into good interfaces.
<H2><A NAME="OmatrixandSolidClasses"><TT><B><FONT SIZE=5 COLOR=#FF0000>Omatrix</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000>Solid</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Classes</FONT></B></A></H2>
<P>
In the following section, there are some difficult mathematical
concepts, so rather than going through every detail, a general
picture of what is happening is presented. For those who like
more details, you may check the CD and go over the code that is
there. Part of the appeal of object-oriented code is that the
programmer doesn't need to understand all of the code to effectively
use it. For this reason, big projects benefit from using object-oriented
programming languages.
<H3><A NAME="Omatrix"><TT><B><FONT SIZE=4>Omatrix</FONT></B></TT></A>
</H3>
<P>
The basis of the <TT>Omatrix</TT>
method used by <TT>Rotator</TT> is
that shapes are defined in terms of points, in the form (x, y,
z). For a simple visualization of this form, imagine x as a horizontal
axis across the width of the screen, y as a vertical axis along
the length or height of the screen, and z as an axis along a direction
perpendicular to the screen, with one end pointing in toward the
screen and the other end pointing out toward the user. Call this
the standard orientation.
<P>
The class <TT>Omatrix</TT> describes
an orientation. The way it does this is it replaces the standard
x-y-z axes with new axes. These new axes are 3 vectors; call them
x'-y'-z'. You store x'-y'-z' as the columns of a matrix. For x'-y'-z'
to make sense as an orientation, these vectors must each have
a unit length, and must also be perpendicular to each other-like
the standard orientation (1,0,0)-(0,1,0)-(0,0,1).
<P>
In Listing 17.9, you have the initial code for the <TT>Omatrix
class</TT>. It mainly concerns itself with the 3-by-3 matrix.
When an <TT>Omatrix</TT> is constructed,
it is set to the standard axis.
<HR>
<BLOCKQUOTE>
<B>Listing 17.9. First section of the </B><TT><B>Omatrix</B></TT><B>
class.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>public class Omatrix{<BR>
&nbsp;&nbsp;public double[][] M;<BR>
&nbsp;&nbsp;private int row,col,k,l;<BR>
<BR>
&nbsp;&nbsp;Omatrix(){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M = new double[3][3];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Assign(1,0,0,0,1,0,0,0,1);<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;/*&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;*/
<BR>
&nbsp;&nbsp;public void Assign(double a, double b, double c,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double
d, double e, double f,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double
g, double h, double i ){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[0][0] = a;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[1][0] = b;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[2][0] = c;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[0][1] = d;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[1][1] = e;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[2][1] = f;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[0][2] = g;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[1][2] = h;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[2][2] = i;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
This matrix, <TT>M</TT>, is the data
part of the class. The other variables declared are <TT>row</TT>,
<TT>col</TT>, <TT>k</TT>,
and  <TT>l</TT>. These dummy variables
are used often. In general, it is safer to have dummy variables
declared in the methods that require them, but this setup works
here because no two methods are called at the same time.
<P>
In the <TT>Omatrix</TT> constructor,
the space for <TT>M</TT> is allocated,
and the method <TT>Assign</TT> sets
the initial value of <TT>M</TT> equal
to the standard orientation. The following two methods are the
major tools used by <TT>Rotator</TT>
to change the orientation: <TT>Rotation</TT>
and <TT>Times</TT>.
<H4><TT><B>Rotation</B></TT></H4>
<P>
The method <TT>Rotation</TT> replaces
the matrix, M. It is replaced with a matrix that represents an
orientation different from the standard orientation by a rotation
in one of the coordinate planes by &quot;<TT>angle</TT>&quot;
(in radians). Here, <TT>i</TT> and
<TT>j</TT> are the numbers of the
axes that get changed. For instance, 0 and 1 represent that the
change occurs in the first and second columns-the x and y axis.
<TT>Rotation(0,1,0.5)</TT> sets the
orientation, M, to the following:
<P>
<FONT FACE="AGaramond Bold">Orientation Matrix</FONT>
<BLOCKQUOTE>
<TT>&nbsp;cos(0.5)&nbsp;&nbsp;sin(0.5)&nbsp;&nbsp;0
<BR>
-sin(0.5)&nbsp;&nbsp;cos(0.5)&nbsp;&nbsp;0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</TT>
</BLOCKQUOTE>
<P>
Figures 17.1 and 17.2 show the result.
<P>
<A HREF="f17-1.gif" ><B>Figure 17.1 :</B> <I>The same shapes viewed with the standard basis.</I></A>
<BR>
<P>
<A HREF="f17-2.gif" ><B>Figure 17.2 :</B> <I>The same shapes after a rotation of half a radian.</I></A>
<P>
Listing 17.10 shows how &quot;rotation&quot; works.
<HR>
<BLOCKQUOTE>
<B>Listing 17.10. </B><TT><B>Rotation</B></TT><B>
method in </B><TT><B>Omatrix</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&nbsp;/*&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;*/
<BR>
&nbsp;&nbsp;public void Rotation (int i, int j, double angle)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Assign(1,0,0,0,1,0,0,0,1);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[i][i] = Math.cos(angle);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[j][j] = M[i][i];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[i][j] = Math.sin(angle);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;M[j][i] = -M[i][j];<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<H4><TT><B>Times</B></TT></H4>
<P>
The next method, shown in Listing 17.11, allows you to make changes
in the orientation relative to any given orientation. In matrix
notation, this operation is multiplication or <TT>Times</TT>.
Unlike the method <TT>Rotation</TT>,
<TT>Times</TT> returns a new orientation
object rather than changing <TT>M</TT>.
This turns out to be convenient, as seen in <TT>Rotator</TT>.
Notice that every instance <TT>Times</TT>
is called, a new <TT>Omatrix</TT>
object is created. Happily, however, garbage collection is automatic,
so the old <TT>Omatrix</TT> objects
are cleared away.
<HR>
<BLOCKQUOTE>
<B>Listing 17.11. </B><TT><B>Times</B></TT><B>
method of Omatrix.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;*/
<BR>
&nbsp;&nbsp;public Omatrix Times(Omatrix N){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Omatrix temp = new Omatrix();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (row=0; row &lt; 3; row++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (col=0; col &lt;3; col++)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp.M[row][col]
= 0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (k=0; k &lt;
3; k++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp.M[row][col]
+= M[row][k] * N.M[k][col];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return temp;<BR>
&nbsp;&nbsp;}</TT>
</BLOCKQUOTE>
<HR>
<P>
In Figure 17.3, you can see the result of two rotations composed
by using Times. Combining the methods <TT>Rotation</TT>
and <TT>Times</TT> together allows
you to make any orientation. This completes the explanation of
the <TT>Omatrix</TT> methods used
by <TT>Rotator</TT>. However, there
are several more methods to <TT>Omatrix</TT>,
some of which are quite interesting. They are used in the next
chapter.
<P>
<A HREF="f17-3.gif" ><B>Figure 17.3 :</B> <I>An orientation constructed by combining two simple notations.</I></A>
<H3><A NAME="Solid"><TT><B><FONT SIZE=4>Solid</FONT></B></TT></A>
</H3>
<P>
Next is an explanation about the <TT>Solid</TT>
class. This class holds all of the shape's information. In general,
the shapes are made up of faces; these faces are all flat. The
faces are polygons that have only one side, or plane, that is
visible. All the faces put together form the outside of a convex
shape. In other words, the polygons are all joined along their
sides to form one shape, for which there is a perspective that
only sees the planes that face upwards. The upward-facing planes
vary with the shape's orientation. This description of a shape
is very narrow; it will be extended when <TT>NCSolid</TT>
is described, but for now, these restrictions help draw the shape
without a sorting routine, and without redrawing the same areas
of the picture.
<P>
The method <TT>CalcScrPts</TT> (calculate
screen coordinates) is a routine that takes the orientation of
the shape in space and computes all the screen coordinates. First,
it computes the points relative to the new basis, then it projects
each of the points to the screen. This means that you can draw
a wire frame diagram of the shape by connecting all the appropriate
screen coordinates. This is a bad idea, however, since the back
and front of the object often become hard to identify.
<P>
Instead, the <TT>Draw</TT> method
uses <TT>faceUp</TT> to decide which
faces it draws. The <TT>faceUp</TT>
method returns a true if the face is pointing upwards; this is
where the one-sidedness of the face is important. The faces have
a top that you want drawn, and a bottom that you don't want  drawn
(as you never see the bottoms). Since the shape is convex, all
the hidden faces return a false value for <TT>faceUp</TT>,
and therefore don't need to be drawn. Thus all of the hidden face
removal is taken care of. The <TT>getColour</TT>
method then computes the shading, and the polygons are drawn with
<TT>DrawPoly</TT>.
<P>
Since this <TT>Draw</TT> method is
fairly specific, there is another <TT>Draw</TT>
method that is more general but slower. This <TT>Draw</TT>
method is part of the class <TT>NCSolid</TT>
in Listing 17.12, which extends <TT>Solid</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 17.12. The class </B><TT><B>NCSolid</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>import java.io.*;<BR>
import java.awt.*;<BR>
import Solid;<BR>
<BR>
public class NCSolid extends Solid{<BR>
&nbsp;&nbsp;private int order[],min;<BR>
<BR>
&nbsp;&nbsp;NCSolid (InputStream is, int wid, int heig, int ncolour_)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throws IOException{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;super(is, wid, heig, ncolour_);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;order = new int[nface];<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;/*&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;*/
<BR>
&nbsp;&nbsp;public void Draw(Graphics offscreen,int x0,int y0,double
z){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;CalcScrPts((double)x0,(double)y0,z);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* .. put in a list all the faces that
are point up.. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i=0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (f=0;f&lt;nface;f++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (faceUp(f)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order[i] = f;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/* .. find the face farthest away and
draw it 'i' times .. */<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for (j=0;j&lt;i;j++){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = j;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (k=j+1;k&lt;i;k++)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rotPts[order[k]+nface][2]&lt;rotPts[order[min]+nface][2])
min =k;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (min !=j) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = order[min];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order[min] = order[j];
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else f = order[j];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (k=1;k&lt;faces[f][0]+1;k++)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DrawPoly(offscreen,faces[f][k],getColour(f,k));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The following line is a check to see which one of the faces is
closer to the screen:
<P>
<TT>if (rotPts[order[k]+nface][2]&lt;rotPts[order[min]+nface][2])
min =k;</TT>
<P>
This line is used to sort the faces into an order that delineates
farthest to closest.
<P>
Here are some examples of <TT>Rotator</TT>
being used. Figure 17.4 uses <TT>Solid</TT>.
Figure 17.5 uses <TT>NCSolid</TT>.
<P>
<A HREF="f17-4.gif" ><B>Figure 17.4 :</B> <I>A sample of SimpleApplet (cubeR.hmt)</I></A>
<BR>
<P>
<A HREF="f17-5.gif" ><B>Figure 17.5 :</B> <I>A sample of SimpleApplet2 (tetraR.htm).</I></A>
<H2><A NAME="SummaryTheBottomLineIsBandwidth"><B><FONT SIZE=5 COLOR=#FF0000>Summary:
The Bottom Line Is Bandwidth</FONT></B></A></H2>
<P>
How economical has the bandwidth been so far? Table 17.1 shows
the data for the cube.
<P>
<CENTER><B>Table 17.1. The breakdown of data needed to be transferred
with </B><TT><B>SimpleApplet</B></TT><B>.
<BR>
</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><I>Data</I></TD><TD WIDTH=156><I>Size</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=195><TT>SimpleApplet.class</TT>
</TD><TD WIDTH=156>1885 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=195><TT>Rotator.class</TT>
</TD><TD WIDTH=156>3010 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=195><TT>Solid.class</TT>
</TD><TD WIDTH=156>6274 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=195><TT>Omatrix.class</TT>
</TD><TD WIDTH=156>4385 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=195><TT>cube.dat</TT>
</TD><TD WIDTH=156>947 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=195>Total</TD><TD WIDTH=156>16501 bytes = 16.5K
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Table 17.2 shows the data for the tetrahedron with the center
missing (the second image).
<P>
<CENTER><B>Table 17.2. The breakdown of data needed to be transferred
with </B><TT><B>SimpleApplet2</B></TT><B>.
<P>
</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><I>Data</I></TD><TD WIDTH=156><I>Size</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>SimpleApplet2.class</TT>
</TD><TD WIDTH=156>1889 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Rotator.class</TT>
</TD><TD WIDTH=156>3010 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Solid.class</TT>
</TD><TD WIDTH=156>6274 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>NCSolid.class</TT>
</TD><TD WIDTH=156>1197 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Omatrix.class</TT>
</TD><TD WIDTH=156>4385 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>tetra.dat</TT>
</TD><TD WIDTH=156>1451 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205>Total</TD><TD WIDTH=156>18206 bytes = 18.2k
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Since the bandwidth has been used sparingly so far (under 20K),
go ahead and make <TT>Rotator</TT>
more interesting by adding a background image, and call it <TT>ImageRotator</TT>
(see Listing 17.13). Following the <TT>NCSolid</TT>
example of sub-classing, add more data into the constructor, and
replace the <TT>Draw</TT> routine.
Just as the <TT>Solid</TT> is supplied
to <TT>Rotator</TT> from <TT>Rotator</TT>'s
parent, the <TT>Image</TT> for <TT>Rotator</TT>'s
background is also supplied from the parent.
<HR>
<BLOCKQUOTE>
<B>Listing 17.13. The class </B><TT><B>ImageRotator</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>/*----------------------------------------------------------------------*/
<BR>
public class ImageRotator extends Rotator implements Runnable
{<BR>
&nbsp;&nbsp;Image gif;<BR>
&nbsp;&nbsp;int gifx,gify;<BR>
<BR>
&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-
*/<BR>
&nbsp;&nbsp;ImageRotator(Applet applet,Solid solid_,Image gif_,int
width,int height) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;super(applet,solid_,width,height);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gif = gif_;<BR>
&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;/*&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-
*/<BR>
&nbsp;&nbsp;public void update(Graphics g) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offscreen.setColor(background);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offscreen.fillRect(0, 0, W, H);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gifx = (int)((W - gif.getWidth(null))/2);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;gify = (int)(((H - gif.getHeight(null))/2)*(1-bounce));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;offscreen.drawImage(gif,gifx, gify, null);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;solid.Draw(offscreen,(int)(W/2),(int)(H/2),bounce);
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.drawImage(im, 0, 0, null);<BR>
&nbsp;&nbsp;}<BR>
}</TT>
</BLOCKQUOTE>
<HR>
<P>
The image that can be passed follows the general description of
an Image. In the example of <TT>SimpleApplet3</TT>
in Listing 17.14, you will pass in an <TT>Image</TT>
that is created from a GIF.
<HR>
<BLOCKQUOTE>
<B>Listing 17.14. </B><TT><B>SimpleApplet3</B></TT><B>'s
inclusion of </B><TT><B>Rotator</B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>URL here = this.getDocumentBase();<BR>
...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image gif = getImage(new URL(here,image));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(new Label(title,Label.CENTER));
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageRotator rotator= new
ImageRotator(this,solid,gif,W,H);<BR>
...</TT>
</BLOCKQUOTE>
<HR>
<P>
Figure 17.6 shows the program's output.
<P>
<A HREF="f17-6.gif" ><B>Figure 17.6 :</B> <I>A sample of SimpleApplet3 (tetraRB.htm).</I></A>
<P>
Table 17.3 shows how much information is sent over the Net.
<P>
<CENTER><B>Table 17.3. The breakdown of data needed to be transferred
with </B><TT><B>SimpleApplet3</B></TT><B>.
<BR>
</B></CENTER>
<CENTER><TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD><I>Data</I></TD><TD WIDTH=172><I> Size</I></TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>SimpleApplet3.class</TT>
</TD><TD WIDTH=172>2025 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Rotator.class</TT>
</TD><TD WIDTH=172>3010 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>ImageRotator.class</TT>
</TD><TD WIDTH=172>1265 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Solid.class</TT>
</TD><TD WIDTH=172>6274 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>NCSolid.class</TT>
</TD><TD WIDTH=172>1197 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>Omatrix.class</TT>
</TD><TD WIDTH=172>4385 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>tetra.dat</TT>
</TD><TD WIDTH=172>1451 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT>something.gif</TT>
</TD><TD WIDTH=172>92375 bytes</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205>Total</TD><TD WIDTH=172>111982 bytes = 112.0K
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Even in this small example that uses only one GIF, the GIF is
a large portion of what has been sent. Notice as well, the pictures
are no longer scaleable: when the size of the <TT>Canvas</TT>
is changed, the shape is scaled, but the GIF has a fixed resolution.
This takes away some of the flexibility. Instead of using the
GIF, the graphics primitives can be used to create the background
<TT>Image</TT>. This, no doubt, uses
less information than needs to be sent, but the information is
in a format that allows the computer to manipulate it. Thus the
image also comes alive and dances and the viewer doesn't have
to wait for everything to download.
<P>
So the real goal of graphics programming is to find the happy
medium for bandwidth, flexibility, and really cool graphics. This
must be solved by carefully choosing the format of the graphics
information and pushing the format to its limit. Reflect on the
92K GIF and think of all the wonderful Java code and data that
can be downloaded in the same time.
<HR WIDTH="100%"></P>

</P></CENTER>

<P>
<HR WIDTH="100%"></P>




</td>

<!-- end main content column -->

</tr>

<!-- end main content column -->


</tr>
</table>

</BODY>
</HTML>
