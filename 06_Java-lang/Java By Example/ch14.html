<HTML>

<HEAD>

<TITLE>Chapter 14 -- Classes</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#Ff0000>Chapter&nbsp;14</FONT></H1>

<H1><FONT SIZE=6 COLOR=#Ff0000>Classes</FONT></H1>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#ClassesandObjects">

Classes and Objects</A>

<UL>

<LI><A HREF="#DefiningaSimpleClass">

Defining a Simple Class</A>

<LI><A HREF="#DeclaringFieldsforaClass">

Declaring Fields for a Class</A>

<LI><A HREF="#DefiningaConstructor">

Defining a Constructor</A>

<LI><A HREF="#ExampleCreatinganObjectbyCallingaConstructor">

Example: Creating an Object by Calling a Constructor</A>

<LI><A HREF="#DefiningMethods">

Defining Methods</A>

</UL>

<LI><A HREF="#ExampleUsingClassesinApplets">

Example: Using Classes in Applets</A>

<LI><A HREF="#UnderstandingtheApplet">

Understanding the Applet</A>

<LI><A HREF="#UsingInheritance">

Using Inheritance</A>

<UL>

<LI><A HREF="#CreatingaSubclass">

Creating a Subclass</A>

<LI><A HREF="#AddingFieldsandMethodstotheSubclass">

Adding Fields and Methods to the Subclass</A>

<LI><A HREF="#ExampleAddingFieldsandMethods">

Example: Adding Fields and Methods</A>

</UL>

<LI><A HREF="#ExampleUsingaSubclassinaProgram">

Example: Using a Subclass in a Program</A>

<LI><A HREF="#OverridingMethodsoftheSuperclass">

Overriding Methods of the Superclass</A>

<LI><A HREF="#TheIthisIKeyword">

The <I>this</I> Keyword</A>

<LI><A HREF="#Summary">

Summary</A>

<LI><A HREF="#ReviewQuestions">

Review Questions</A>

<LI><A HREF="#ReviewExercises">

Review Exercises</A>

</UL>



<HR>

<P>

Way back in <A HREF="ch4.html" >Chapter 4</A> you got a general introduction to object-oriented

programming concepts. In that chapter, you took a first look at

classes and how they're used to organize source code into logically

defined modules. Since then, you've been using various classes

included as part of the Java language, but you haven't explored

the implications of using a class or of creating your own classes.

In this chapter, you plug up that hole in your understanding of

Java and how it uses classes to create applets.

<H2><A NAME="ClassesandObjects"><FONT SIZE=5 COLOR=#Ff0000>

Classes and Objects</FONT></A></H2>

<P>

In <A HREF="ch4.html" >Chapter 4</A> you learned that a class is the template for an

object and that a class is a way to encapsulate both data (called

fields in Java) and the functions (called methods) that operate

on that data. You also learned about inheritance, which enables

a class (called the subclass) to inherit the capabilities of a

base class (called a superclass in Java). Finally, you discovered

that polymorphism enables you to create virtual methods that can

be implemented differently in derived classes. In this section,

you'll apply what you know about object-oriented programming towards

creating Java classes.

<H3><A NAME="DefiningaSimpleClass">

Defining a Simple Class</A></H3>

<P>

As I said, a class is sort of a template for an object. In this

way, a class is equivalent to a data type such as <TT>int</TT>.

The main difference is that Java already knows what an integer

is. However, when you create a class, you must tell Java about

the class's characteristics. You define a class by using the <TT>class</TT>

keyword along with the class name, like this:

<BLOCKQUOTE>

<PRE>

class MyClass

{

}

</PRE>

</BLOCKQUOTE>

<P>

Believe it or not, the preceding lines are a complete Java class.

If you save the lines in a file called <TT>MyClass.java</TT>,

you could even compile the class into a .CLASS file, although

the file won't actually do anything if you tried to run it. As

you can see, the class definition begins with the keyword <TT>class</TT>

followed by the name of the class. The body of the class is marked

off by curly braces just like any other program block. In this

case, the class's body is empty.

<P>

Because its body is empty, this example class doesn't do anything.

You can, however, compile the class and even create an object

from it. To create an object from a class, you type the class's

name followed by the name of the object. For example, the line

below creates an object from the <TT>MyClass</TT> class:

<BLOCKQUOTE>

<PRE>

MyClass myObject = new MyClass();

</PRE>

</BLOCKQUOTE>

<H3><A NAME="DeclaringFieldsforaClass">

Declaring Fields for a Class</A></H3>

<P>

As I said, the <TT>MyClass</TT> example class doesn't do much

yet. In order to be useful, it needs both data fields and methods.

You declare fields for your class in much the same way you declare

any variable in a program, by typing the data type of the field

followed by the name of the field, like this:

<BLOCKQUOTE>

<PRE>

int myField;

</PRE>

</BLOCKQUOTE>

<P>

The above line declares a data field of type integer. However,

looking at the above line doesn't tell you much about how data

fields are used with classes. In fact, you can't tell from the

above line whether <TT>myField</TT> is actually part of an object

or just a normal variable. To clear up this ambiguity, you can

plug the above line into the <TT>MyClass</TT> class definition,

as shown in Listing 14.1.

<HR>

<BLOCKQUOTE>

<B>Listing 14.1&nbsp;&nbsp;LST14_1.TXT: Adding a Data Field to

a Class.<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

class MyClass

{

    int myField;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Now you can see that <TT>myField</TT> is a data field of the <TT>MyClass</TT>

class. Moreover, this data field is by default accessible only

by methods in the same package. (For now, you can think of a package

as a file.) You can change the rules of this access by using the

<TT>public</TT>, <TT>protected</TT>, and <TT>private</TT> keywords.

A <TT>public</TT> data field can be accessed by any part of a

program, inside or outside of the class in which it's defined.

A <TT>protected</TT> data field can only be accessed from within

the class or from within a derived class (a subclass). A <TT>private</TT>

data field cannot even be accessed by a derived class.

<H3><A NAME="DefiningaConstructor">

Defining a Constructor</A></H3>

<P>

You have now added a data field to <TT>MyClass</TT>. However,

the class has no methods and so can do nothing with its data field.

The next step in defining the class, then, is to create methods.

One special type of method, called a constructor, enables an object

to initialize itself when it's created. A constructor is a <TT>public</TT>

method (a method that can be accessed anywhere in a program) with

the same name as the class. Listing 14.2 shows the <TT>MyClass</TT>

class with its constructor in place.

<HR>

<BLOCKQUOTE>

<B>Listing 14.2&nbsp;&nbsp;LST14_2.TXT: Adding a Constructor to

a Class.<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

class MyClass

{

    int myField;



    public MyClass(int value)

    {

        myField = value;

    }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

As you can see, the class's constructor starts with the <TT>public</TT>

keyword. This is important because you want to be able to create

an object from the class anywhere in your program, and when you

create an object, you're actually calling its constructor. After

the <TT>public</TT> keyword comes the name of the constructor

followed by the constructor's arguments in parentheses. When you

create an object of the class, you must also provide the required

arguments.

<H3><A NAME="ExampleCreatinganObjectbyCallingaConstructor">

Example: Creating an Object by Calling a Constructor</A></H3>

<P>

If you want to create an object from <TT>MyClass</TT>, you must

supply an integer value that the class uses to initialize the

<TT>myField</TT> data field. This integer is the <TT>MyClass</TT>

constructor's single argument. You'd create an object of the class

like this:

<BLOCKQUOTE>

<PRE>

MyClass myObject = new MyClass(1);

</PRE>

</BLOCKQUOTE>

<P>

This line not only creates an object of the <TT>MyClass</TT> class,

but also initializes the <TT>myField</TT> data field to 1. The

first word in the line tells Java that  <TT>myObject</TT> is going

to be an object of the <TT>MyClass</TT> class. The next word is

the object's name. After the equals sign comes the keyword <TT>new</TT>

and the call to the class's constructor.

<H3><A NAME="DefiningMethods">

Defining Methods</A></H3>

<P>

Other methods that you add to a class are just like the methods

you've been writing in previous chapters. You just need to be

sure to provide the proper type of access to your methods. That

is, methods that must be called from outside the class, should

be defined as <TT>public</TT>, methods that must be callable only

from the class and its derived classes should be defined as <TT>protected</TT>,

and methods that must be callable only from within the class should

be declared as <TT>private</TT>.

<P>

Suppose <TT>myField</TT> is defined as <TT>private</TT>, and you

now want to be able to set the value of <TT>myField</TT> from

outside the <TT>MyClass</TT> class. Because that data field is

defined as <TT>private</TT>, meaning it can be accessed only from

within the same class, you cannot access it directly by name.

To solve this problem, you can create a public method that can

set the value for you. You might also want to create a method

that returns the value of the field, as well, as shown in Listing

14.3.

<HR>

<BLOCKQUOTE>

<B>Listing 14.3&nbsp;&nbsp;LST14_3.TXT: Adding a Method to the

Class.<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

class MyClass

{

    private int myField;



    public MyClass(int value)

    {

        myField = value;

    }



    public void SetField(int value)

    {

        myField = value;

    }



    public int GetField()

    {

        return myField;

    }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

<IMG ALIGN=RIGHT SRC="pseudo.gif" HEIGHT=94 WIDTH=94 BORDER=1>

<BLOCKQUOTE>

Start defining the <TT>MyClass</TT> class.<BR>

    Declare the class's <TT>myField</TT> data field.<BR>

    Define the class's constructor.<BR>

        Initialize the data field.<BR>

    Start defining the <TT>SetField()</TT> method.<BR>

        Set the data field to the value passed to <TT>SetField().

<BR>

</TT>    Start Defining the <TT>GetField()</TT> method.<BR>

        Return the value of the <TT>myField</TT> data field.<BR>

</BLOCKQUOTE>

<P>

<CENTER>

<TABLE BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

According to the rules of strict object-oriented design, all class data fields should be declared as <TT>private</TT>. Some programmers would go so far as to say that you should not even provide access to data fields through public methods. However, 
you'll see these rules broken a lot, even by programmers hired by big companies like Microsoft, Borland, and Sun. As you become more familiar with object-oriented programming, you'll better understand why the rules were made and when it's appropriate to 
break them.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H2><A NAME="ExampleUsingClassesinApplets"><FONT SIZE=5 COLOR=#Ff0000>

Example: Using Classes in Applets</FONT></A></H2>

<P>

Up till now, you've been writing applets using the classes already

supplied as part of Java. Now, you'll see how to use your own

classes in applets. This will help you understand not only how

your own classes work, but also help you to understand why you

used Java's classes as you did. Follow the steps below to see

how all this class stuff works.

<OL>

<LI>Type Listing 14.3 and save it to your CLASSES folder under

the name <TT>MyClass.java</TT>. (If you don't want to type, you

can find the listing on this book's CD-ROM, in the CHAP14 folder.)

<LI>Start a DOS session by selecting Programs/MS-DOS Prompt from

the Start menu. The DOS window appears, as shown in Figure 14.1.

<BR>

<IMG SRC="f14-1.gif"><B> Figure 14.1 : </B><I>This is the DOS prompt window.



</I></A><P>

<LI>Type <TT>CD C:\CLASSES</TT> to switch to your CLASSES folder.

<LI>Type <TT>javac MyClass.java</TT> to compile the <TT>MyClass</TT>

class. You'll then find the <TT>MyClass.class</TT> file in your

CLASSES folder.

<LI>Type Listing 14.4 and save it as <TT>Applet19.java</TT> in

your CLASSES folder.



<HR>

<BLOCKQUOTE>

<B>Listing 14.4&nbsp;&nbsp;Applet19.java: An Applet That Uses

the </B><I>MyClass</I><B> Class</B>.<BR>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

import java.awt.*;

import java.applet.*;

import MyClass;



public class Applet19 extends Applet

{

    MyClass myObject;

    TextField textField1;



    public void init()

    {

        myObject = new MyClass(1);

        textField1 = new TextField(10);

        add(textField1);

        textField1.setText(&quot;1&quot;);

    }



    public void paint(Graphics g)

    {

        String s = textField1.getText();

        int value = Integer.parseInt(s);

        myObject.SetField(value);

        value = myObject.GetField();

        s = String.valueOf(value);

        g.drawString(&quot;The data field of the object&quot;, 30, 80);

        g.drawString(&quot;is now set to this value:&quot;, 40, 95);

        g.drawString(s, 90, 125);

    }



    public boolean action(Event event, Object arg)

    {

        repaint();

        return true;

    }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

<IMG ALIGN=RIGHT SRC="pseudo.gif" HEIGHT=94 WIDTH=94 BORDER=1>

<BLOCKQUOTE>

Tell Java that the program uses the <TT>awt </TT>package.<BR>

Tell Java that the program uses the <TT>applet</TT> package.<BR>

Tell Java that the program uses the <TT>MyClass</TT> class.<BR>

Derive the <TT>Applet19</TT> class from the <TT>Applet</TT> class.

<BR>

    Declare an object of the <TT>MyClass</TT> class.<BR>

    Declare a <TT>TextField</TT> object.<BR>

    Override the <TT>Applet</TT> class's <TT>init()</TT> method.

<BR>

        Create an object of the <TT>MyClass</TT> class.<BR>

        Create a <TT>TextField</TT> object.<BR>

        Add the <TT>TextField</TT> object to the applet.<BR>

        Set the <TT>TextField</TT> object's text.<BR>

    Override the <TT>Applet</TT> class's <TT>paint()</TT> method.

<BR>

        Get the text from the <TT>TextField</TT> object.<BR>

        Convert the text to an integer.<BR>

        Set <TT>myObject</TT>'s <TT>myField</TT> data field.<BR>

        Get the value of <TT>myField</TT> from <TT>myObject.<BR>

</TT>        Convert the value to a string.<BR>

        Draw the applet's display area.<BR>

    Override the <TT>Applet</TT> class's <TT>action()</TT> method.

<BR>

        Repaint the applet's display area.<BR>

        Tell Java the method executed okay.

</BLOCKQUOTE>



<LI>Type <TT>javac Applet19.java</TT> to compile the Applet19

applet. You'll then have the <TT>Applet19.class</TT> file in your

CLASSES folder.

<LI>Type Listing 14.5 and save the file as APPLET19.htmlL.

</OL>

<HR>

<BLOCKQUOTE>

<B>Listing 14.5&nbsp;&nbsp;APPLET19.htmlL: The HTML Document for

Applet19.<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

&lt;title&gt;Applet Test Page&lt;/title&gt;

&lt;h1&gt;Applet Test Page&lt;/h1&gt;

&lt;applet

    code=&quot;Applet19.class&quot;

    width=200

    height=200

    name=&quot;Applet19&quot;&gt;

&lt;/applet&gt;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

You're now ready to run the Applet19 applet, which uses the <TT>MyClass</TT>

class. To run the program, type <TT>APPLETVIEWER APPLET19.htmlL</TT>.

When you do, you see the window shown in Figure 14.2.

<P>

<IMG SRC="f14-2.gif"><B> Figure 14.2 : </B><I>This is Applet19 running under Appletviewer.



</I></A><P>

<P>

The applet's display area shows the current setting of <TT>MyClass</TT>'s

data field, <TT>myField</TT>. You can change this setting by typing

a new value into the text box and pressing Enter.

<H2><A NAME="UnderstandingtheApplet"><FONT SIZE=5 COLOR=#Ff0000>

Understanding the Applet</FONT></A></H2>

<P>

By now, you should have a good idea of how classes work, at least

generally. Still, you'll now examine parts of Applet19's source

code. First, near the top of the source code is this line:

<BLOCKQUOTE>

<PRE>

import MyClass;

</PRE>

</BLOCKQUOTE>

<P>

Because the <TT>MyClass</TT> class is located in a different file

than Applet19, you need to tell Java where to find it. The above

line tells Java that it can find everything it needs to know about

<TT>MyClass</TT> in the <TT>MyClass.class</TT> file, which you

created when you compiled <TT>MyClass.java</TT>.

<P>

The next line of interest is this one, which is located at the

top of Applet19's definition:

<BLOCKQUOTE>

<PRE>

MyClass myObject;

</PRE>

</BLOCKQUOTE>

<P>

This line tells Java that you'll be creating an object of the

<TT>MyClass</TT> class and that the object will be called <TT>myObject</TT>.

<P>

At this point, you don't have the object created yet. You have

to create the object, which Applet19 does in its <TT>init()</TT>

method, using the <TT>new</TT> operator, like this:

<BLOCKQUOTE>

<PRE>

myObject = new MyClass(1);

</PRE>

</BLOCKQUOTE>

<P>

After the above line executes, Java has created the object, which

means you can now call the object's public methods to manipulate

the object as appropriate. Objects of the <TT>MyClass</TT> class

have only two public methods (not counting the constructor). Applet19

calls these methods in its <TT>paint()</TT> method, like this:

<BLOCKQUOTE>

<PRE>

myObject.SetField(value);

value = myObject.GetField();

</PRE>

</BLOCKQUOTE>

<P>

In the first line, Applet19 calls the object's <TT>SetField()</TT>

method, whose single argument is the value to which to set the

<TT>myField</TT> data field. Due to its private access, this is

the only way to set the value of <TT>myField</TT> outside of the

class. If you tried to access <TT>myField</TT> with the line

<BLOCKQUOTE>

<PRE>

myObject.myField = value;

</PRE>

</BLOCKQUOTE>

<P>

you wouldn't even be able to compile the file. The compiler will

generate an error telling you that you cannot access <TT>myField</TT>

in this way (Figure 14.3).

<P>

<IMG SRC="f14-3.gif"><B> Figure 14.3 : </B><I>The compiler complains when you ignore rules of access.



</I></A><P>

<H2><A NAME="UsingInheritance"><FONT SIZE=5 COLOR=#Ff0000>

Using Inheritance</FONT></A></H2>

<P>

You may not know it, but throughout the second part of this book,

you've been using inheritance to create your applets. Specifically,

you've been deriving your applet classes (i.e, Applet10, Applet11,

and so on) from Java's <TT>Applet</TT> superclass. By using inheritance

in this way, you can take an existing class and create a new similar

class that does things a little differently. The new class will

have all the characteristics of its superclass, but will also

have any new characteristics that you choose to add.

<H3><A NAME="CreatingaSubclass">

Creating a Subclass</A></H3>

<P>

You derive a new class from a superclass by using the <TT>extends</TT>

keyword, an apt name for a keyword because by deriving a new class

you usually extend the abilities of the original class. For example,

when you create a new applet, you start the applet's class with

a line that looks something like this:

<BLOCKQUOTE>

<PRE>

public class MyApplet extends Applet

</PRE>

</BLOCKQUOTE>

<P>

First, Java insists that all applet classes be declared as <TT>public</TT>.

Next in the line, you can see the <TT>class</TT> keyword followed

by the name of the class. Finally comes the <TT>extends</TT> keyword

followed by the name of the superclass. In English, the above

line means that the public class <TT>MyApplet</TT> is derived

from (is a subclass of) the existing <TT>Applet</TT> class. As

you've probably already figured out, <TT>Applet</TT> is a class

that the Java makers created for you. This class contains all

the basic functionality you need to create an applet. You need

only extend (there's that word again) the specifics of the class

in order to create your own applet class. Again, you've been doing

that in every applet you've written so far.

<H3><A NAME="AddingFieldsandMethodstotheSubclass">

Adding Fields and Methods to the Subclass</A></H3>

<P>

One thing you can do when you create a subclass is to add your

own data fields and methods. For example, when you derive your

own applet class from Java's <TT>Applet</TT> class, although your

class inherits tons of data fields and methods from the superclass,

you'll undoubtedly need fields and methods not supplied in the

superclass. Maybe your new applet is designed to play Tic-Tac-Toe.

(Hmmmm. Where have I seen that before?) Obviously, when the fine

programmers at Sun created the <TT>Applet</TT> class, they didn't

think to add the methods needed to play Tic-Tac-Toe. You'll have

to add those methods yourself.

<H3><A NAME="ExampleAddingFieldsandMethods">

Example: Adding Fields and Methods</A></H3>

<P>

Take the <TT>MyClass</TT> class that you created earlier in this

chapter (shown in Listing 14.3). Suppose you want to create a

new class that has a new data field called <TT>myNewField</TT>,

as well as a constructor and methods for setting and retrieving

the value of this new data field. You might come up with something

like Listing 14.6.

<HR>

<BLOCKQUOTE>

<B>Listing 14.6&nbsp;&nbsp;MYSUBCLASS.JAVA: Creating a Subclass.

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

import MyClass;



class MySubClass extends MyClass

{

    private int myNewField;



    public MySubClass(int value)

    {

        super(value);

        myNewField = value;

    }



    public void SetNewField(int value)

    {

        myNewField = value;

    }



    public int GetNewField()

    {

        return myNewField;

    }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The file containing the <TT>MySubClass</TT> class first imports

the <TT>MyClass</TT> file, because Java will need the information

contained in that file. In the constructor, the class first calls

<BLOCKQUOTE>

<PRE>

super(value);

</PRE>

</BLOCKQUOTE>

<P>

which ensures that the superclass (<TT>MyClass</TT>) is properly

initialized by calling its constructor. The keyword <TT>super</TT>

refers to the class's superclass. After calling the superclass's

constructor, the <TT>MySubClass</TT> constructor initializes the

new data field, <TT>myNewField</TT>. The new class also supplies

new methods for setting and getting the value of <TT>myNewField</TT>.

In short, <TT>MySubClass</TT> now has two data fields-<TT>myField</TT>,

which it inherited from <TT>MyClass</TT>, and the new <TT>myNewField</TT>-and

four methods-<TT>SetField()</TT> and <TT>GetField</TT>, which

it inherited from <TT>MyClass</TT>, and the new <TT>SetNewField()</TT>

and <TT>GetNewField()</TT> methods.

<H2><A NAME="ExampleUsingaSubclassinaProgram"><FONT SIZE=5 COLOR=#Ff0000>

Example: Using a Subclass in a Program</FONT></A></H2>

<P>

Now that you have the <TT>MySubClass</TT> subclass, it might be

nice to see how it works in a real programming situation. Applet20,

which is shown in Listing 14.7, does the honors of putting <TT>MySubClass</TT>

to work. In most places, compared to Applet19, the applet merely

replaces occurrences of <TT>MyClass</TT> with <TT>MySubClass</TT>.

The <TT>paint()</TT> method has to work a bit harder, though,

calling all four of <TT>MySubClass</TT>'s methods to prove they

work.

<HR>

<BLOCKQUOTE>

Listing 14.7&nbsp;&nbsp;APPLET20.JAVA: Using a Subclass in a Program.

<BR>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

import java.awt.*;

import java.applet.*;

import MySubClass;



public class Applet20 extends Applet

{

    MySubClass mySubObject;

    TextField textField1;

    TextField textField2;



    public void init()

    {

        mySubObject = new MySubClass(1);

        textField1 = new TextField(10);

        add(textField1);

        textField1.setText(&quot;1&quot;);

        textField2 = new TextField(10);

        add(textField2);

        textField2.setText(&quot;2&quot;);

    }



    public void paint(Graphics g)

    {

        String s = textField1.getText();

        int value = Integer.parseInt(s);

        mySubObject.SetField(value);

        value = mySubObject.GetField();

        s = String.valueOf(value);

        g.drawString(&quot;The myField data field&quot;, 30, 80);

        g.drawString(&quot;is now set to this value:&quot;, 40, 95);

        g.drawString(s, 90, 125);



        s = textField2.getText();

        value = Integer.parseInt(s);

        mySubObject.SetNewField(value);

        value = mySubObject.GetNewField();

        s = String.valueOf(value);

        g.drawString(&quot;The myNewField data field&quot;, 30, 155);

        g.drawString(&quot;is now set to this value:&quot;, 40, 170);

        g.drawString(s, 90, 200);

    }



    public boolean action(Event event, Object arg)

    {

        repaint();

        return true;

    }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

When you run Applet20 under Appletviewer, you see the window shown

in Figure 14.4. Use the first text box to enter values for the

original <TT>myField</TT> data field. Use the second text box

to enter values for <TT>myNewField</TT>. Whenever you press Enter,

the applet reads the values from the boxes and calls <TT>MySubClass</TT>'s

methods to set the new values and to retrieve the set values from

the object.

<P>

<IMG SRC="f14-4.gif"><B> Figure 14.4 : </B><I>This is Appletviewer running the Applet20 applet.



</I></A><P>

<H2><A NAME="OverridingMethodsoftheSuperclass"><FONT SIZE=5 COLOR=#Ff0000>

Overriding Methods of the Superclass</FONT></A></H2>

<P>

If you've been reading the pseudocode sections that follow many

of the listings in this book, you've seen the term &quot;overriding&quot;

many times. When you override a method, you are creating a new

version of a method that's part of the superclass. For example,

in many of the applets you've created, you've overridden methods

like <TT>init()</TT>, <TT>paint()</TT>, and <TT>action()</TT>.

All of these methods are defined in some general way in the <TT>Applet</TT>

superclass. When you derive a new class from applet, you can override

these methods to perform the tasks you want them to perform, rather

than the general tasks assigned to them by the <TT>Applet</TT>

class.

<P>

<CENTER>

<TABLE BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

In general object-oriented programming discussions, the term &quot;derive&quot; means exactly the same thing as &quot;subclass&quot; (when the latter is used as a verb). Ditto for the terms &quot;base class&quot; and &quot;superclass,&quot; which are the 
same thing. In other words, when you derive a new class from a base class, you are subclassing a new class from a superclass.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

For example, you know that, when Java starts up an applet, it

calls the applet's <TT>init()</TT> method. Here's how the <TT>Applet</TT>

class defines <TT>init()</TT>:

<BLOCKQUOTE>

<PRE>

public void init()

{

}

</PRE>

</BLOCKQUOTE>

<P>

No, your eyes aren't fooling you. In the <TT>Applet</TT> class,

the <TT>init()</TT> method does nothing at all. It's only there

so you can override it in your own class. Here's how it all works:

When you derive your applet class from <TT>Applet</TT>, your applet

class inherits all of <TT>Applet</TT>'s data fields and methods.

If you don't override a method, Java calls the original version

as necessary. In other words, if you don't override <TT>init()</TT>

in your applet class, when Java starts your applet, it calls the

<TT>Applet</TT> class's version of <TT>init()</TT>, which does

nothing. However, if you override <TT>init()</TT> in your class,

Java is smart enough to call the new version rather than the original

do-nothing version. Cool, eh?

<H2><A NAME="TheIthisIKeyword"><FONT SIZE=5 COLOR=#Ff0000>

The <I>this</I> Keyword</FONT></A></H2>

<P>

There may be times when you need to explicitly refer to an object

from within the object's methods. For example, you might need

to pass a reference to the object as an argument in a method call.

When you need to refer to the object explicitly, use the <TT>this</TT>

keyword. In many cases, the <TT>this</TT> keyword is implicit

in the method call or variable reference. For example, inside

an object that has the data field <TT>dataField</TT>, the line

<BLOCKQUOTE>

<PRE>

dataField = 1;

</PRE>

</BLOCKQUOTE>

<P>

is the same as

<BLOCKQUOTE>

<PRE>

this.dataField = 1;

</PRE>

</BLOCKQUOTE>

<P>

In the first case, the <TT>this</TT> keyword is implicit, whereas

in the second case, you've included it explicitly. If you needed

to pass a reference to the object as an argument, you might write

something like this:

<BLOCKQUOTE>

<PRE>

SomeMethod(this);

</PRE>

</BLOCKQUOTE>

<P>

Of course, the <TT>SomeMethod()</TT> method would have been written

to accept an object of <TT>this</TT>'s type as its single argument.

<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#Ff0000>

Summary</FONT></A></H2>

<P>

If you've never done any object-oriented programming, it might

take you a while to get used to using classes. Classes are the

single biggest hurdle to jump when making the transition from

normal procedural programming to object-oriented programming (OOP).

Just think of classes as a way to provide another level of abstraction

to your programs. In your non-OOP programs, you had program elements

called programs, files, and procedures, listed in the order of

their level of abstraction. Now, you can add classes to the end

of the list, right between files and procedures.

<H2><A NAME="ReviewQuestions"><FONT SIZE=5 COLOR=#Ff0000>

Review Questions</FONT></A></H2>

<OL>

<LI>What is a class?

<LI>How do classes help you to organize your programs?

<LI>What are the three parts of a simple, empty class?

<LI>What two elements do you add to complete the class?

<LI>How do you create an object from a class?

<LI>How do you use a class that's defined in a different file

than the file that accesses the class?

<LI>What is inheritance and how does it help you create new classes

quickly?

<LI>What is a subclass and a superclass?

<LI>How do you create a subclass?

<LI>How do you override a method inherited from a superclass?

</OL>

<H2><A NAME="ReviewExercises"><FONT SIZE=5 COLOR=#Ff0000>

Review Exercises</FONT></A></H2>

<OL>

<LI>Write a basic, empty class called <TT>TestClass</TT>.

<LI>Add to <TT>TestClass</TT> a string data field called <TT>data1</TT>.

This data field should be private to the class.

<LI>Add to <TT>TestClass</TT> a constructor that accepts a starting

value for <TT>data1</TT> as its single argument, and public methods

for setting and retrieving the value of <TT>data1</TT>. Call these

methods <TT>SetData()</TT> and <TT>GetData()</TT>.

<LI>Compile the finished class.

<LI>Write a subclass called <TT>TestSubClass</TT> that is derived

from <TT>TestClass</TT> and that adds an integer data field called

<TT>data2</TT> (declared as <TT>private</TT>) and a public method

called <TT>CreateDataString()</TT> that creates a string object

from <TT>data1</TT> and <TT>data2</TT>. That is, if <TT>data1</TT>

is equal to <TT>Java is cool!</TT> and <TT>data2</TT> is equal

to 15, the <TT>CreateDataString()</TT> method should return <TT>Java

is cool! 15</TT> as a single string object. Also, create public

methods called <TT>SetData2()</TT> and <TT>GetData2()</TT> for

setting and retrieving the value of <TT>data2</TT>, as well as

a constructor that accepts arguments for the starting values of

<TT>data1</TT> and <TT>data2</TT>.

<LI>Modify Applet20 so that it creates an object of the <TT>TestSubClass</TT>

class. You should provide text boxes for enabling the user to

set <TT>data1</TT> and <TT>data2</TT>, as well as write <TT>paint()</TT>

so that it displays the string returned by <TT>CreateDataString()</TT>.

Figure 14.5 shows what the ClassApplet applet should look like.

(You can find the solutions for these exercises in the CHAP14

folder of this book's CD-ROM.) <BR>

<IMG SRC="f14-5.gif"><B> Figure 14.5 : </B><I>This is ClassApplet running under Appletviewer.



</I></A><P>

</OL>

<HR>



<CENTER><P><A HREF="ch13.html"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.html"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch15.html"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>