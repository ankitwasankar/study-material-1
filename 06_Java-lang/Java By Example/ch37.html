<HTML>

<HEAD>

<TITLE>Appendix A -- Answers to Review Questions</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#Ff0000>Appendix&nbsp;A</FONT></H1>

<H1><FONT SIZE=6 COLOR=#Ff0000>Answers to Review Questions</FONT>

</H1>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#Chapter1">

Chapter 1</A>

<LI><A HREF="#Chapter2">

Chapter 2</A>

<LI><A HREF="#Chapter3">

Chapter 3</A>

<LI><A HREF="#Chapter4">

Chapter 4</A>

<LI><A HREF="#Chapter5">

Chapter 5</A>

<LI><A HREF="#Chapter6">

Chapter 6</A>

<LI><A HREF="#Chapter7">

Chapter 7</A>

<LI><A HREF="#Chapter8">

Chapter 8</A>

<LI><A HREF="#Chapter9">

Chapter 9</A>

<LI><A HREF="#Chapter10">

Chapter 10</A>

<LI><A HREF="#Chapter11">

Chapter 11</A>

<LI><A HREF="#Chapter12">

Chapter 12</A>

<LI><A HREF="#Chapter13">

Chapter 13</A>

<LI><A HREF="#Chapter14">

Chapter 14</A>

<LI><A HREF="#Chapter15">

Chapter 15</A>

<LI><A HREF="#Chapter16">

Chapter 16</A>

<LI><A HREF="#Chapter17">

Chapter 17</A>

<LI><A HREF="#Chapter18">

Chapter 18</A>

<LI><A HREF="#Chapter19">

Chapter 19</A>

<LI><A HREF="#Chapter20">

Chapter 20</A>

<LI><A HREF="#Chapter21">

Chapter 21</A>

<LI><A HREF="#Chapter22">

Chapter 22</A>

<LI><A HREF="#Chapter23">

Chapter 23</A>

<LI><A HREF="#Chapter24">

Chapter 24</A>

<LI><A HREF="#Chapter25">

Chapter 25</A>

<LI><A HREF="#Chapter26">

Chapter 26</A>

<LI><A HREF="#Chapter27">

Chapter 27</A>

<LI><A HREF="#Chapter28">

Chapter 28</A>

<LI><A HREF="#Chapter29">

Chapter 29</A>

<LI><A HREF="#Chapter30">

Chapter 30</A>

<LI><A HREF="#Chapter31">

Chapter 31</A>

<LI><A HREF="#Chapter32">

Chapter 32</A>

<LI><A HREF="#Chapter33">

Chapter 33</A>

<LI><A HREF="#Chapter34">

Chapter 34</A>

<LI><A HREF="#Chapter35">

Chapter 35</A>

<LI><A HREF="#Chapter36">

Chapter 36</A>

</UL>



<HR>

<H2><A NAME="Chapter1"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 1</FONT></A></H2>

<OL>

<LI>Probably the three most important reasons that Java is so

suitable for Internet applications are the language's robustness,

simplicity, and, most importantly, its security features.

<LI>A Java applet is a small program that is embedded in an HTML

document and is run when the document is loaded. A Java standalone

application doesn't need to be embedded in an HTML document and

can be run just like any other application.

<LI>Java applets are compiled into byte-code files that can be

executed by any computer that has a Java interpreter.

<LI>Applets are handled in an HTML document similarly to elements

like images. The applet is referenced in the HTML document, which

causes the HTML document to load and run the applet.

<LI>Java is platform-independent so that it can run on any system.

Java is also multithreaded, which means it can handle multiple

tasks concurrently and run fast.

</OL>

<H2><A NAME="Chapter2"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 2</FONT></A></H2>

<OL>

<LI>Use the Appletviewer tool included with the JDK.

<LI>The required attributes are <TT>code</TT>, <TT>width</TT>,

and <TT>height</TT>.

<LI>The <TT>codebase</TT> attribute specifies the location of

an applet's code (the .CLASS file). The given folder is relative

to the folder of the HTML document that contains the reference

to the applet.

<LI>Other optional attributes include <TT>alt</TT>, <TT>align</TT>,

<TT>name</TT>, <TT>hspace</TT>, and <TT>vspace</TT>.

<LI>Applet parameters enable a user to configure an applet to

fit his specific needs.

<LI>You can provide alternate content for non-Java browsers. You

do this by placing standard HTML script commands for the alternate

content right before the ending <TT>&lt;/applet&gt;</TT> tag.

</OL>

<H2><A NAME="Chapter3"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 3</FONT></A></H2>

<OL>

<LI>A local applet is located on your computer system.

<LI>A remote applet is located on another computer system and

must be downloaded onto your computer before it can be run.

<LI>The client is the computer that requests information (in this

case, an applet) from another computer. The computer that supplies

the information is the server.

<LI>Once applets can flow both from and to a remote computer,

the client/server relationship will become less important. This

is because computers will keep switching from being a client and

a server.

<LI>The Java interpreter validates every applet before the applet

is run. This prevents applets that have been modified (maybe by

having a virus attached) from affecting the destination system.

The validation process also ensures that an applet cannot crash

the system.

</OL>

<H2><A NAME="Chapter4"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 4</FONT></A></H2>

<OL>

<LI>When you use top-down programming, you divide a program up

such that the detail goes from general to specific as you work

your way down the program.

<LI>Top-down programming enables you to separate the general tasks

that must be completed by a program from the details that implement

those tasks, making a program easier to understand and organize.

<LI>OOP offers another organizational level to the programmer.

Not only can the programmer divide tasks up into logical chunks

in top-down, structured fashion, but he can also separate logical

elements of the program into objects.

<LI>The two main elements of a class are data fields and the methods

that operate on the data fields.

<LI>A class is like a template or blueprint for an object. An

object is an instance of the class.

<LI>The three main OOP concepts are encapsulation, inheritance,

and polymorphism.

<LI>Encapsulation is the act of enclosing both the data and the

functions that act on the data within the object. Inheritance

is the ability of a new object (a derived object) to inherit data

and functions from a base object. Polymorphism is the ability

of a derived object to implement a function of the base class

in a different way.

</OL>

<H2><A NAME="Chapter5"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 5</FONT></A></H2>

<OL>

<LI>A constant is a value that can't be changed during a program's

execution. Constants have symbolic names like <TT>PI</TT> or <TT>NUMBEROFITEMS</TT>.

<LI>A variable is a value that can be changed as much as needed

during a program's execution. Like constants, variables have symbolic

names. Examples of variable names are <TT>count</TT> and <TT>area_of_circle</TT>.

<LI>Constants and variables replace hard-to-understand values

with English-like names. Moreover, variables enable you to name

a value that must change many times during program execution.

<LI>Java's eight data types are <TT>byte</TT>, <TT>short</TT>,

<TT>int</TT>, <TT>long</TT>, <TT>float</TT>, <TT>double</TT>,

<TT>char</TT>, and <TT>boolean</TT>.

<LI>Variable scope determines where in a program a variable can

be accessed. A variable goes into scope at the beginning of the

program block in which the variable is declared and goes out of

scope at the end of the block.

</OL>

<H2><A NAME="Chapter6"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 6</FONT></A></H2>

<OL>

<LI>Graphical text is text that must be drawn on the screen just

like other shapes such as circles and squares, rather than printed

using a built-in character set as is done under MS-DOS.

<LI>In a proportional font, each letter takes up only the amount

of space it needs, whereas every letter in a non-proportional

font takes up exactly the same amount of space.

<LI>Arguments are values that are sent to a method when the method

is called.

<LI>The three arguments for the <TT>drawString()</TT> method are

the text string to display, and the column and row at which to

display the text.

<LI>The <TT>paint()</TT> method draws whatever needs to be displayed

in the applet's display area. Java calls <TT>paint()</TT> whenever

the applet needs to be redrawn.

<LI>One way to get user input is to add a <TT>TextField</TT> control

to your applet.

<LI>Java calls the <TT>init()</TT> method almost immediately after

an applet starts up in order to enable you to initialize objects

needed by the applet.

<LI>Java calls the <TT>action()</TT> method whenever the user

does something with the applet's controls. For example, when the

user types text into a <TT>TextField</TT> control and presses

Enter, Java calls <TT>action()</TT> so that the applet can respond

to the user's input.

<LI>To convert a numerical value to a string, you call the <TT>String</TT>

class's <TT>valueOf()</TT> method.

</OL>

<H2><A NAME="Chapter7"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 7</FONT></A></H2>

<OL>

<LI>The addition, subtraction, multiplication, and division operators

are +, &ETH;, *, and /, respectively.

<LI><TT>5*3</TT> equals 15.

<LI><TT>3 &ETH; 2 + 5 + 6 &ETH;1</TT> equals 11.

<LI>The ++ operator increments the variable, so <TT>num</TT> ends

up equal to 13.

<LI><TT>12 % 5</TT> equals 2.

<LI>If <TT>num</TT> equals 25, the expression <TT>num += 5</TT>

makes <TT>num</TT> equal to 30.

<LI>You set the text is a <TT>TextField</TT> object by calling

<TT>TextField's</TT> <TT>setText()</TT> method.

<LI><TT>12 + 3 * 6 / 2</TT> equals 21.

<LI>You can change <TT>3 / 5</TT> from integer to floating-point

division by changing one or both of the numbers to a floating-point

value, like this: <TT>3f / 5f</TT>.

<LI>You cast the result of <TT>56 &ETH; 34.56f</TT> to integer

like this: <TT>(int)(56 &ETH; 34.56f)</TT>.

<LI>You convert digits in a string to an integer by calling the

<TT>Integer</TT> class's <TT>parseInt()</TT> method.

<LI> (12 &ETH; 8) * 10 / 2 * 2 equals 40.

</OL>

<H2><A NAME="Chapter8"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 8</FONT></A></H2>

<OL>

<LI>An expression is a line of program code that can be reduced

to a value or that assigns a value to a variable or constant.

<LI> The three types of expressions are numerical, assignment,

and logical.

<LI>The expression <TT>(3 &lt; 5)</TT> equals <TT>true</TT>.

<LI>The expression <TT>(3 &lt; 5) &amp;&amp; (5 == 4 + 1)</TT>

equals <TT>true</TT>.

<LI>Expressions are recursive because they can contain other smaller

expressions, which in turn may contain other expressions.

<LI>The six comparison operators are <TT>==</TT> (equals), <TT>!=</TT>

(not equal), <TT>&lt;</TT> (less than), <TT>&gt;</TT> (greater

than), <TT>&lt;=</TT> (less than or equals), and <TT>&gt;=</TT>

(greater than or equals).

<LI>The four logical operators are  <TT>!</TT> (NOT), <TT>&amp;&amp;</TT>

(AND), <TT>||</TT> (OR), and <TT>^</TT> (exclusive OR).

<LI>The result of the expression <TT>(3 &lt; 5) || (6 == 5) ||

(3 != 3)</TT> is <TT>true</TT>.

<LI>The result of the expression <TT>(5 != 10) &amp;&amp; ((3

== 2 + 1) || (4 &lt; 2 + 5))</TT> is <TT>true</TT>.

<LI>The result of the expression <TT>!(5 == 2 + 3) &amp;&amp;

!(5 + 2 != 7 - 5)</TT> is false.

</OL>

<H2><A NAME="Chapter9"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 9</FONT></A></H2>

<OL>

<LI>Program flow is the order in which program statements are

executed.

<LI>Conditional branching occurs when a program branches to a

new section based on the value of some data. Unconditional branching

is when a computer instruction causes the program to branch regardless

of any conditions.

<LI>Two ways to control program flow are <TT>if</TT> and <TT>switch</TT>

statements.

<LI>No. The second line will execute only when <TT>choice</TT>

equals 3.

<LI>You can write an <TT>if</TT> statement without opening and

closing braces when only one program line will execute if the

condition evaluates to <TT>true</TT>. 

<LI>There is no difference between a logical and a Boolean expression.

They are both expressions that evaluate to <TT>true</TT> or <TT>false</TT>.

<LI>The program skips over both the <TT>if</TT> and the <TT>else

if</TT>.

<LI>The <TT>if</TT> and <TT>switch</TT> statements are similar

in that they both enable the computer to choose a path of execution

based on the value of a control variable. They are different in

that a <TT>switch</TT> statement is more appropriate for situations

in which there are many possible outcomes.

<LI>The variable <TT>num</TT> ends up with the value 3. If your

answer was 2, you didn't notice that the second <TT>case</TT>

has no <TT>break</TT> statement, causing program execution to

drop through to the third <TT>case</TT>.

</OL>

<H2><A NAME="Chapter10"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 10</FONT></A></H2>

<OL>

<LI>You should use a loop when your program must perform some

sort of repetitive task.

<LI>The body of the loop comprises the program lines that are

executed each time the loop's conditional expression is true.

<LI>When the conditional expression evaluates to <TT>false</TT>,

the loop ends.

<LI>There is no guarantee on how many times a <TT>while</TT> loop

will execute. It could be any number of times from 0 on up. A

<TT>do-while</TT> loop, on the other hand, always executes at

least once.

<LI>You must properly initialize the loop control variable because

the loop's conditional expression relies on the value of the variable

to determine how many times to loop.

<LI>An infinite loop occurs when a loop's conditional expression

can never result in <TT>false</TT>, causing the loop to repeat

endlessly.

<LI>Both the <TT>while</TT> and <TT>do-while</TT> loops can be

used to perform repetitive tasks in a program. However, the <TT>while</TT>

loop may execute any number of times, including 0, whereas a <TT>do-while</TT>

loop always executes at least once. This is because a <TT>do-while</TT>

loop's conditional expression is at the end of the loop, whereas

a <TT>while</TT> loop's conditional expression is at the beginning

of the loop.

<LI>The loop will execute six times, and <TT>count</TT> will be

equal to 16 at the end of the loop.

</OL>

<H2><A NAME="Chapter11"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 11</FONT></A></H2>

<OL>

<LI>You should use a <TT>for</TT> loop when you have a repetitive

task that must be performed a specific number of times.

<LI>The three parts of a <TT>for</TT> loop are the initialization,

condition, and increment sections.

<LI>A <TT>for</TT> loop stops looping when the condition section

becomes false.

<LI>A <TT>for</TT> loop can count backward by decrementing the

control variable in the increment section, rather than incrementing

it.

<LI>A <TT>for</TT> loop can count by tens by adding 10 to the

control variable in the increment section.

<LI>It's possible to create an infinite loop with a <TT>for</TT>

loop, but it's unlikely because the loop control variable is handled

by the loop itself.

<LI>The loop will execute five times, and <TT>x</TT> will be equal

to 13 at the end of the loop.

</OL>

<H2><A NAME="Chapter12"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 12</FONT></A></H2>

<OL>

<LI>Top-down programming means organizing source code into levels

that go from general functions to more detailed functions the

further down the hierarchy you go.

<LI>Functions make top-down programming possible by enabling you

to organize source code into well-defined tasks.

<LI>All functions have a return type, but the return type of <TT>void</TT>

means that the function returns no actual value.

<LI>Arguments are values that you pass to a function when you

call it. The receiving function can then access the values almost

as if they were local to the function.

<LI>Defining a function is the act of writing the function's source

code.

<LI>You return a value from a function by using the keyword <TT>return</TT>

followed by the value to be returned. The returned value must

be the same type as the function's defined return type.

<LI>The arguments in the function call must be in the same order

and be of the same type as the arguments given in the function's

definition.

<LI>The best way to break source code up into functions is to

locate the groups of commands that perform a specific task and

then replace those lines with a function call. The lines that

are replaced become the body of the new function.

</OL>

<H2><A NAME="Chapter13"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 13</FONT></A></H2>

<OL>

<LI>An array is a data structure that enables you to store many

related values under one variable name.

<LI>You can access the values of an array using loops, which greatly

reduces the amount of source code needed to handle large numbers

of related values.

<LI>An array subscript identifies a specific element of an array.

The subscript is a number or variable enclosed in square brackets.

A subscript and an index are exactly the same thing.

<LI>A two-dimensional array can store values in a table, with

a specific number of columns and rows.

<LI>The largest subscript you can use with a fifty-element array

is 49.

<LI>If you try to access a nonexistent array element, Java generates

an exception.

<LI>A <TT>for</TT> loop is perfect for array access because you

can use the loop control variable as an array subscript.

<LI>To initialize a two-dimensional array with <TT>for</TT> loops,

you'd use nested loops. The outer loop counts through the columns

and the inner loop counts through the rows.

</OL>

<H2><A NAME="Chapter14"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 14</FONT></A></H2>

<OL>

<LI>A class is a template from which you create an object. A class

usually contains data fields and methods.

<LI>A class provides an additional level of program abstraction

that enables you to organize data fields, and the methods that

interact with those data fields, within a single structure.

<LI>The three parts of a simple, empty class are the keyword <TT>class</TT>,

followed by the name of the class and the braces that mark off

the body of the class.

<LI>The two program elements that you must add to the empty class

in order to create a complete class are data fields and methods.

<LI>To create an object of a class, you use the <TT>new</TT> operator

followed by a call to the class's constructor.

<LI>To use a class that's defined in a different file, you place

the <TT>import</TT> keyword, followed by the class's name, at

the top of the file that needs access to the class. You must also

be sure that the compiler can find the class, usually by placing

the class files all in the same directory.

<LI>Using inheritance, a new class (subclass) derived from a base

class (superclass) inherits the data fields and methods defined

in the base class. The programmer then only needs to add whatever

additional functionality is required by the new class.

<LI>A subclass is a class that's been derived from another class

using the <TT>extends</TT> keyword. A superclass is the class

from which a subclass is derived. That is, the terms subclass

and base class are equivalent.

<LI>You create a subclass by using the <TT>extends</TT> keyword

like this:<BR>

<TT>class SubClass extends SuperClass<BR>

<FONT FACE="Courier New">{<BR>

}</FONT></TT>

<LI>To override a method, you provide, in your subclass, a method

with exactly the same name, return type, and arguments as the

method of the superclass you want to override. Then, Java will

call your class's version of the method rather than the superclass's

version.

</OL>

<H2><A NAME="Chapter15"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 15</FONT></A></H2>

<OL>

<LI>All applets must be derived from Java's <TT>Applet</TT> class.

<LI>Applet classes must be public so that the system can run the

applet. If you fail to declare an applet as <TT>public</TT>, it

will compile fine, but it will not run.

<LI>The five life-cycle stages of an applet are initialization,

start, paint, stop, and destroy.

<LI>The paint cycle isn't an &quot;official&quot; stage in the

applet's life cycle. It isn't, in fact, even defined within the

<TT>Applet</TT> class. Instead, the <TT>paint()</TT> method is

inherited from Java's <TT>Component</TT> class.

<LI>The initialize cycle occurs only once in the applet's life

cycle (when the applet is loaded and prepared to run), whereas

start can occur numerous times (after initialization or whenever

the applet is restarted).

<LI>The <TT>init()</TT>, <TT>start()</TT>, <TT>stop()</TT>, and

<TT>destroy()</TT> methods as they are implemented in the <TT>Applet</TT>

class do absolutely nothing. They are only placeholders that you

can override in your applet class. The same is true of the <TT>paint()</TT>

method.

</OL>

<H2><A NAME="Chapter16"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 16</FONT></A></H2>

<OL>

<LI>The area of an applet in which you can draw is called the

canvas.

<LI>The origin of Java's graphical coordinate system is in the

upper left corner with values of X increasing to the right and

values of Y increasing downwards.

<LI>The <TT>drawRect()</TT> method draws a hollow rectangle, whereas

the <TT>fillRect()</TT> method draws a filled (solid) rectangle.

<LI>The four arguments for the <TT>drawRect()</TT> method are

the X,Y coordinates of the rectangle's upper left corner and the

width and height of the rectangle.

<LI>The first four arguments for both <TT>drawRect()</TT> and

<TT>drawRoundRect()</TT> are exactly the same, being the X,Y coordinates,

width, and height of the rectangle. The <TT>drawRoundRect()</TT>

method, however, has two additional arguments that are the width

and height of a rectangle that determines the size of the rounded

corners.

<LI>The <TT>drawPolygon()</TT> method uses arrays to store its

coordinates because a polygon can have any number of sides, which

means that the method call must have a way to pass differing numbers

of points. The arrays enable you to define as many sides as you

need while keeping the method's argument count consistent.

<LI>The six arguments required by the <TT>drawArc()</TT> method

are the X,Y coordinates, width, and height of the bounding rectangle,

as well as the starting drawing angle and the number of degrees

around to draw.

<LI>The <TT>Polygon</TT> class provides several methods that enable

you to manipulate a polygon in various ways.

</OL>

<H2><A NAME="Chapter17"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 17</FONT></A></H2>

<OL>

<LI>To get a reference to the currently active font object, you

call the <TT>Graphics</TT> class's <TT>getFont()</TT> method.

<LI>To get a font's name, you can call the <TT>Font</TT> class's

<TT>getName()</TT> method.

<LI>To get a font's height, you can call the <TT>Font</TT> class's

<TT>getHeight()</TT> method.

<LI>You need to know a font's height so you can properly space

lines of text.

<LI>You get a reference to a <TT>FontMetrics</TT> object by calling

the <TT>Graphics</TT> class's <TT>getFontMetrics()</TT> method.

The <TT>Font</TT> object for which you want the metrics is the

method's single argument.

<LI>Use a <TT>FontMetrics</TT> object when you want to know more

detailed information about a font. The <TT>Font</TT> class offers

only general information about a font.

<LI>You can determine the width of a text string by calling the

<TT>FontMetrics</TT> class's <TT>stringWidth()</TT>. The method's

single argument is the string to measure.

<LI>A point is a unit of measurement of a font's height. A point

equals 1/72 of an inch.

<LI>Leading is the amount of white space between lines of text.

Ascent is the height of a character, from the baseline to the

top of the character. Descent is the size of the area that accommodates

the descending portions of letters, such as the tail on a lowercase

&quot;g.&quot;

<LI>A font's height is the sum of the font's leading, ascent,

and descent.

<LI>Use the <TT>new</TT> operator to call the <TT>Font</TT> class's

constructor. The constructor's three arguments are the font name,

style, and size. Styles you can use are any combination of <TT>Font.PLAIN</TT>,

<TT>Font.BOLD</TT>, and <TT>Font.ITALIC</TT>.

<LI>If the font you request is not available, Java substitutes

a default font. This is one reason it's so important to get a

font's size after you create the font.

</OL>

<H2><A NAME="Chapter18"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 18</FONT></A></H2>

<OL>

<LI>The two arguments required by the <TT>Label</TT> class's constructor

are the text for the label and the label's alignment value.

<LI>When an applet containing labels is resized, the labels automatically

reposition themselves as appropriate.

<LI>After creating controls, you add the controls to the applet

with the <TT>add()</TT> method.

<LI>The single argument needed by the <TT>Button</TT> class's

constructor is the text label for the button.

<LI>The values for setting a label's alignment are represented

by the <TT>Label</TT> class's <TT>Label.LEFT</TT>, <TT>Label.CENTER</TT>,

and <TT>Label.RIGHT</TT> fields.

<LI>The <TT>Label</TT> class provides methods for setting the

label's text and alignment.

<LI>You can change a button's text label by calling the <TT>Button</TT>

class's <TT>setLabel()</TT> method.

<LI>For a button click, the <TT>action()</TT> method receives

a reference to the button object and the selected button's text

label.

<LI>You can determine which button was selected by examining the

text label passed as the <TT>action()</TT> method's second parameter.

<LI>Nothing happens when a user clicks a label object, because

label objects do not generate events.

</OL>

<H2><A NAME="Chapter19"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 19</FONT></A></H2>

<OL>

<LI>The three arguments required by the <TT>Checkbox</TT> class's

constructor are the text for the label, a reference to the <TT>CheckboxGroup</TT>

object (or <TT>null</TT>), and checkbox's state (<TT>true</TT>

or <TT>false</TT>).

<LI>Checkboxes that are set to exclusive mode are also called

radio buttons.

<LI>The two arguments needed by the <TT>TextField</TT> class's

constructor are the default text and the width (in characters)

of the control.

<LI>To change the state of a checkbox control call the <TT>Checkbox</TT>

class's <TT>setState()</TT> method.

<LI>When checkboxes are in nonexclusive mode, the user can select

as many checkboxes at a time as he likes. In exclusive mode, the

user can select only one checkbox at a time.

<LI>To create a group of checkbox controls (in exclusive mode),

you must first create an object of the <TT>CheckboxGroup</TT>

class.

<LI>You use echo characters whenever the information being entered

into a textfield control should not be readable on the screen,

such as when the user is entering a password.

<LI>You select an echo character for a textfield control by calling

the <TT>TextField</TT> class's <TT>setEchoCharacter()</TT> method.

<LI>To determine which checkbox generated an event, you cast the

first parameter sent to the <TT>action()</TT> method to an object

of the <TT>Checkbox</TT> class. You can then call the checkbox

object's <TT>getLabel()</TT> method to get the checkbox's label.

</OL>

<H2><A NAME="Chapter20"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 20</FONT></A></H2>

<OL>

<LI>The <TT>Choice</TT> class's constructor accepts no arguments.

<LI>You add items to a choice menu by calling the <TT>Choice</TT>

class's <TT>addItem()</TT> method.

<LI>The two arguments needed by the <TT>List</TT> class's constructor

are the number of visible rows in the box and a boolean value

indicating whether the control will accept multiple selections.

<LI>You add items to a list by calling the <TT>List</TT> class's

<TT>addItem()</TT> method.

<LI>You would use a <TT>TextArea</TT> control when you need to

display, and enable the user to edit, more than one line of text.

The <TT>TextField</TT> control can display only a single line.

<LI>To determine the selected item in a choice menu, examine the

second parameter of the <TT>event()</TT> method. The selected

item's text string gets passed to <TT>event()</TT> as that parameter.

<LI>You create a multiple-selection list exactly the same way

you create a single-selection list, except that the value of the

constructor's second argument should be <TT>true</TT> rather than

<TT>false</TT>.

<LI>You retrieve the selected item from a list by calling the

<TT>List</TT> class's <TT>getSelectedItem()</TT> method. If you

want the index of the selected item, call <TT>getSelectedIndex()</TT>.

<LI>To create a string containing multiple lines of text, add

each line of the text to the string using the concatenation operator

(+). Make sure each line of text ends with the newline character

(<TT>\n</TT>).

<LI>To retrieve multiple selections from a scrolling list, call

the <TT>List</TT> class's <TT>getSelectedItems()</TT> method.

This method returns a string array containing the selected items.

<LI>Yes. You can delete items from a list by calling the <TT>List</TT>

class's <TT>deleteItem()</TT> or <TT>deleteItems()</TT> methods.

</OL>

<H2><A NAME="Chapter21"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 21</FONT></A></H2>

<OL>

<LI>The <TT>Scrollbar</TT> constructor's five arguments are the

scrollbar's orientation, value, page size, minimum value, and

maximum value.

<LI>A canvas is a blank component on which you can draw graphics.

<LI>The <TT>Canvas</TT> class's constructor requires no arguments.

<LI>Use a page size of zero when you want the scroll box to be

centered on the selected value and when you want the user to be

able to select a value from anywhere within the entire range.

<LI>The easiest way to respond to a scrollbar change is to override

the <TT>handleEvent()</TT> method. In the method, watch for a

component target of <TT>Scrollbar</TT>. When you receive an event

message from the scrollbar, call the scrollbar's <TT>getValue()</TT>

method to determine its setting.

<LI>A scrollbar can generate <TT>SCROLL_ABSOLUTE</TT>, <TT>SCROLL_LINE_DOWN</TT>,

<TT>SCROLL_LINE_UP</TT>, <TT>SCROLL_PAGE_DOWN</TT>, and <TT>SCROLL_PAGE_UP</TT>

event messages.

<LI>To create a custom canvas component, derive a new class from

Java's <TT>Canvas</TT> class.

<LI>To draw a canvas's display, override the class's <TT>paint()</TT>

method.

</OL>

<H2><A NAME="Chapter22"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 22</FONT></A></H2>

<OL>

<LI>You can use multiple panels in order to organize sets of controls

in a display. Each panel can have its own layout manager.

<LI>Java's five layout managers are <TT>FlowLayout</TT>, <TT>GridLayout</TT>,

<TT>BorderLayout</TT>, <TT>CardLayout</TT>, and <TT>GridBagLayout</TT>.

<LI>The default layout manager is <TT>FlowLayout</TT>.

<LI>The <TT>FlowLayout</TT> manager positions components one after

the other in rows. When a component won't fit on the current row,

the layout manager starts the next row.

<LI>The <TT>GridLayout</TT> constructor's four arguments are the

number of columns and rows in the grid, and the horizontal and

vertical spacing of the cells in the grid.

<LI>The component positions you can use with the <TT>BorderLayout</TT>

manager are North, South, East, West, and Center.

<LI>To add a component to an applet using the <TT>BorderLayout</TT>

manager, you call a special version of the <TT>add()</TT> method

that has the position string (North, South, etc.) and a reference

to the component as arguments.

<LI>You can use <TT>CardLayout</TT> to simulate property sheets

because the layout manager enables you to create &quot;cards&quot;

that contains groups of controls. Each card can be displayed separately.

<LI>When using the <TT>CardLayout</TT> manager, you can switch

from one card to another by calling the manager's <TT>first()</TT>,

<TT>next()</TT>, <TT>last()</TT>, <TT>previous()</TT>, or <TT>show()</TT>

method.

<LI>The constraints determine where in the layout a component

will be placed.

<LI><TT>GridBagConstraints.fill</TT> determines whether components

will stretch vertically or horizontally to fill their cells.

<LI>To add a component when using the <TT>GridBagLayout</TT> manager,

you first initialize and set the constraints. You then call <TT>add()</TT>

as you normally would.

</OL>

<H2><A NAME="Chapter23"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 23</FONT></A></H2>

<OL>

<LI>To create a frame window, call the <TT>Frame</TT> class's

constructor with the title of the window as the constructor's

single argument.

<LI>To display a frame window, call the window's <TT>show()</TT>

method.

<LI>To determine whether a frame window is visible, call the <TT>isShowing()</TT>

method, which returns <TT>true</TT> if the window is currently

visible and <TT>false</TT> otherwise.

<LI>You use <TT>MenuItem</TT> objects for regular items in a menu,

whereas you use <TT>CheckboxMenuItem</TT> objects for items that

can be checkmarked. 

<LI>To create a custom frame-window class, you extend the <TT>Frame</TT>

class, which itself extends the <TT>Window</TT> class.

<LI>To initialize a custom frame window's superclass (<TT>Frame</TT>),

you call the <TT>super()</TT> method with the window's title string

as the method's single argument.

<LI>You can draw in a frame window in exactly the same way you

can draw in an applet's display area, by overriding the class's

<TT>paint()</TT> method.

<LI>The six steps for creating a menu bar are create the <TT>MenuBar</TT>

object, call <TT>setMenuBar()</TT>, create <TT>Menu</TT> objects,

add the <TT>Menu</TT> objects to the <TT>MenuBar</TT> object,

create <TT>MenuItem</TT> objects, and add the <TT>MenuItem</TT>

objects to the menus.

<LI>To add components to a frame window, first create and set

a layout manager for the window. Then create and add the components

to the window as appropriate for the type of layout manager you

chose.

<LI>You respond to selected menu items by watching for their strings

in the <TT>action()</TT> method, which you must override in the

window's class.

<LI>A menu separator is just a normal <TT>MenuItem</TT> object

that has a single hyphen as its string.

</OL>

<H2><A NAME="Chapter24"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 24</FONT></A></H2>

<OL>

<LI>The <TT>Dialog</TT> constructor's three arguments are a reference

to the dialog box's parent frame window, the dialog's title, and

a <TT>boolean</TT> value indicating whether the dialog is modal.

<LI>You can display or hide a dialog box by calling the class's

<TT>show()</TT> or <TT>hide()</TT> methods.

<LI>A dialog box must have a frame window as a parent window.

The first argument in <TT>Dialog</TT>'s constructor is, in fact,

a reference to this frame window.

<LI>Every dialog box should have at least an OK button that enables

the user to dismiss the dialog box.

<LI>Modal dialog boxes must be dismissed before the user can continue

with the program. Modeless dialog boxes do not need to be dismissed

in order to continue using the program.

<LI>In order to add components to a dialog box, you must first

create and set a layout manager for the dialog. Then, you create

the controls you need and call the dialog box's <TT>add()</TT>

method to add the controls to the layout.

</OL>

<H2><A NAME="Chapter25"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 25</FONT></A></H2>

<OL>

<LI>The most commonly used mouse event is <TT>MOUSE_DOWN</TT>,

which indicates that the user pressed his mouse button.

<LI>An applet receives more <TT>MOUSE_MOVE</TT> event messages

than any other type of mouse event. An applet receives hundreds

of these messages as the user moves his mouse over the applet.

<LI>The six mouse event messages are <TT>MOUSE_DOWN</TT>, <TT>MOUSE_UP</TT>,

<TT>MOUSE_MOVE</TT>, <TT>MOUSE_DRAG</TT>, <TT>MOUSE_ENTER</TT>,

and <TT>MOUSE_EXIT</TT>.

<LI>The two most important keyboard events are <TT>KEY_PRESS</TT>

and <TT>KEY_RELEASE</TT>.

<LI>To determine the type of object that generated a event, check

the <TT>Event</TT> object's <TT>target</TT> data field.

<LI>To determine the event type, check the <TT>event</TT> object's

<TT>id</TT> field.

<LI>The coordinates of the mouse event are passed as the second

and third arguments of the specific mouse method. If you're overriding

<TT>handleEvent()</TT>, you can get the mouse coordinates from

the <TT>Event</TT> object's <TT>x</TT> and <TT>y</TT> data fields.

<LI>If the user single-clicked the mouse, the <TT>Event</TT> object's

<TT>clickCount</TT> data field will be 1. With a double-click,

<TT>clickCount</TT> will be 2.

<LI>The two methods associated with the <TT>KEY_PRESS</TT> and

<TT>KEY_RELEASE</TT> event messages are <TT>keyDown()</TT> and

<TT>keyUp()</TT>, respectively.

<LI>The <TT>keyDown()</TT> method receives as arguments an <TT>Event</TT>

object and an integer holding the key's ASCII code.

<LI>The <TT>mouseDown()</TT> event receives as arguments an <TT>Event</TT>

object and the X and Y coordinates of the mouse click.

<LI>You use the <TT>SHIFT_MASK</TT> and <TT>CTRL_MASK</TT> constants

to determine whether the user had the Shift or Ctrl keys pressed.

<LI>To handle all events in a single method, you should override

the <TT>handleEvent()</TT> method.

</OL>

<H2><A NAME="Chapter26"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 26</FONT></A></H2>

<OL>

<LI>Parameterized applets are easier for users who want to add

the applets to their own Web pages. The parameters enable them

to customize the applet to more closely fit their needs.

<LI>The <TT>&lt;PARAM&gt;</TT> tag's two parts are <TT>NAME</TT>,

which specifies the parameter's name, and <TT>VALUE</TT>, which

associates a value with the parameter.

<LI>To retrieve the value of a parameter, you call the <TT>getParameter()</TT>

method, whose single argument is the name of the parameter you

want.

<LI>You specify parameter values in the HTML document, as part

of the applet's definition.

<LI>No. The whole point of parameters is that your applet can

change the way it looks and acts without recompiling.

<LI>You can have as many applet parameters as you need.

<LI>The <TT>getParameter()</TT> method always returns the given

parameter's value as a string. Therefore, you may need to convert

the returned parameter to an integer or some other data type.

<LI>If you fail to define default values for all parameters, your

applet may generate errors as it tries to use nonexistent or invalid

parameter values.

</OL>

<H2><A NAME="Chapter27"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 27</FONT></A></H2>

<OL>

<LI>Java can load only GIF or JPEG files.

<LI>The two parameters required by many of the image and sound

methods are the base URL and the relative location of the file

to load.

<LI>Java recognizes only AU audio files.

<LI>To display an image after it's loaded, you call the <TT>Graphics</TT>

object's <TT>drawImage()</TT> method.

<LI>No. You can store images and sounds in any directory relative

to the base URL.

<LI>To scale an image, simply supply the <TT>drawImage()</TT>

method with the width and height with which you want the image

displayed.

<LI>To determine the normal width and height of an image, call

the <TT>Image</TT> object's <TT>getWidth()</TT> and <TT>getHeight()</TT>

methods.

<LI>The document base URL is the location of the HTML document,

whereas the code base URL is the location of the applet's CLASS

file.

<LI>You have more control over sounds with an <TT>AudioClip</TT>

object because the <TT>AudioClip</TT> class provides the <TT>play()</TT>,

<TT>stop()</TT>, and <TT>loop()</TT> methods, whereas the applet

can only play an audio file from beginning to end.

</OL>

<H2><A NAME="Chapter28"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 28</FONT></A></H2>

<OL>

<LI>The single argument is a string containing the URL from which

the <TT>URL</TT> object should be constructed.

<LI>An <TT>AppletContext</TT> object represents the application

containing the applet. This application is usually a Web browser.

<LI>To obtain an <TT>AppletContext</TT> object, call the applet's

<TT>getAppletContext()</TT> method.

<LI>To ensure that you have a valid <TT>URL</TT> object, you handle

the exception that may be generated by the <TT>URL</TT> class.

<LI>To create an exception handler, you must create <TT>try</TT>

and <TT>catch</TT> program blocks.

<LI>To connect to an URL, call the <TT>AppletContext</TT> object's

<TT>showDocument()</TT> method.

<LI>The <TT>URL</TT> class throws a MalformedURLException exception

if the URL's string is syntactically incorrect.

</OL>

<H2><A NAME="Chapter29"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 29</FONT></A></H2>

<OL>

<LI>A package is a group of related classes and interfaces.

<LI>To tell Java that a class uses a particular package, you use

the <TT>import</TT> keyword followed by the full name of the package.

<LI>To add a class or interface to a package, place the <TT>package</TT>

keyword at the top of the class's or interface's source code followed

by the name of the package to which the class or interface will

be added.

<LI>To tell Java that a class implements a particular interface,

add the <TT>implements</TT> keyword to the class's declaration

line, followed by the name of the interface.

<LI>The biggest difference between an interface and a class is

that an interface declares, but never implements, its methods.

An interface's methods must be defined in any class that implements

the interface.

<LI>Interfaces and classes are similar in that they are declared

in almost exactly the same way.

<LI>The complete name of a package mirrors the folder hierarchy

on your hard disk into which the package files must be stored.

</OL>

<H2><A NAME="Chapter30"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 30</FONT></A></H2>

<OL>

<LI>You use a <TT>try</TT> block to hold the program statements

that may generate the exceptions you want to handle.

<LI>You use a <TT>catch</TT> block to hold the program statements

that should be executed when a particular exception is thrown.

<LI>You don't have to catch all types of exceptions in your applets,

because Java has default handlers for many of them.

<LI>If you call a method that's declared with a <TT>throw</TT>

phrase, you must handle the exception in your program.

<LI>You can have as many <TT>catch</TT> blocks as you need in

order to respond to all appropriate exceptions.

<LI>To pass an exception on to a calling method, you declare the

called method with the <TT>throws</TT> phrase. Java will then

pass the exception to the calling function, where it must be handled

or thrown again.

<LI>Java throws exceptions that must be handled in your program,

as well as throws system, runtime exceptions that you may or may

not decide to handle in your program.

</OL>

<H2><A NAME="Chapter31"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 31</FONT></A></H2>

<OL>

<LI>Threads are like small programs within the main program. Just

as a multitasking system can run two or more applications simultaneously,

so can an applet or application run more than one thread simultaneously.

<LI>All Java threads must implement the <TT>Runnable</TT> interface,

which contains the <TT>run()</TT> method needed to start a thread.

<LI>To start a thread, you call the thread object's <TT>start()</TT>

method.

<LI>When you start a thread, Java calls the thread object's <TT>run()</TT>

method.

<LI>You'll usually stop your applet's threads in either the <TT>stop()</TT>

or <TT>destroy()</TT> method.

<LI>When you suspend a thread, you put it to sleep so that it

remains ready to run when you next need it. When you stop a thread,

you kill the thread, meaning that you'll have to create a new

thread object when you want to run the thread again.

<LI>To ensure that all threads get a chance to run, you should

call, in any thread that takes a while to run, the <TT>sleep()</TT>

or <TT>yield()</TT> method.

<LI>When retaining a thread's state is not an issue, you can both

create and start the thread in the applet's <TT>start()</TT> method.

<LI>When you want to retain a thread's state while the user switches

to and from the Web page containing your applet, you should create

the threads in <TT>init()</TT>, start or resume the threads in

<TT>start()</TT>, suspend the threads in <TT>stop()</TT>, and

stop the threads in <TT>destroy()</TT>.

<LI>Use the <TT>synchronized</TT> keyword to mark a method or

a block of code as a potential area of conflict for threads trying

to access the same resources.

<LI>When a thread enters a synchronized area of code, Java gives

the thread the class's monitor object. Until the thread releases

the monitor object, no other thread can enter the synchronized

area. In this way, a monitor object is much like a key that unlocks

a synchronized method or block of code.

</OL>

<H2><A NAME="Chapter32"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 32</FONT></A></H2>

<OL>

<LI>The one method that you'll find in every application, but

not in an applet, is <TT>main()</TT>, which is where a Java application's

execution begins.

<LI>To run a Java application, you compile it using javac, and

then run the byte-code .CLASS file with the Java interpreter,

java.

<LI>The single parameter received by <TT>main()</TT> is the application's

command-line parameters.

<LI>The parameters come into the <TT>main()</TT> method as an

array of strings. Each parameter is in one element of the array,

so you can access the elements by indexing the array.

<LI>To convert an applet to an application, you must add the <TT>main()</TT>

method.

<LI>You must instantiate an object from a class before you can

call its methods because a class is just a template for an object,

much the same way a blueprint is a template for a manufactured

object.

<LI>To create and display an application's window, you call the

<TT>Frame</TT> class's constructor, and then call the <TT>Frame</TT>

object's <TT>resize()</TT> and <TT>show()</TT> methods.

</OL>

<H2><A NAME="Chapter33"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 33</FONT></A></H2>

<OL>

<LI>To run more than one applet at a time with Appletviewer, create

an HTML document that loads the applets you want to see. Appletviewer

will load and run each applet in its own window.

<LI>Although HotJava is a good example of the type of programs

you can create with Java, it hasn't been kept up to date with

the Java programming language. For this reason, HotJava cannot

run applets created with the latest version of Java. Netscape

Navigator 2.0, on the other hand, can load and run these newer

applets.

<LI>A doc-comment block, which is placed at the top of a class

or right before a method, provides the information javadoc needs

to create useful HTML documentation files.

<LI>To start a program that's been loaded into the Java debugger,

type run.

<LI>To document a method's return value and parameters in a doc-comment,

you use the <TT>@return</TT> and <TT>@param</TT> doc tags.

<LI>To start a debugging session with appletviewer, type <TT>appletviewer

-debug applet.htmll</TT>, where <TT>applet.htmll</TT> is the HTML

document that loads the applet.

<LI>To create hyperlinks in javadoc's HTML documents, add <TT>@see</TT>

doc tags where appropriate in your doc-comment blocks.

<LI>To start a debugging session with jdb, type <TT>jdb app.class</TT>,

where <TT>app.class</TT> is the .CLASS file of the application

you want to debug.

<LI>The javap tool is a disassembler that converts byte-code .CLASS

files into a description of the source code.

<LI>Native methods are methods written in a language other than

Java.

<LI>The javah tool helps you implement native methods by creating

the header files you need to gain access to data fields in Java

classes from your C source code.

<LI>To set a breakpoint with the debugger, type <TT>stop at class:line</TT>,

where <TT>class:line</TT> is the class's name and breakpoint line

number separated by a colon.

</OL>

<H2><A NAME="Chapter34"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 34</FONT></A></H2>

<OL>

<LI>You must use the compiler to convert your source-code files

into byte-code (.CLASS) files that Java's interpreter can read

and run.

<LI>If you fail to include the .java extension when specifying

a source-code file in the javac command line, the compiler will

not compile the file and will instead generate an illegal argument

error.

<LI>The options for the javac command line go between the <TT>javac</TT>

command and the name of the source-code file.

<LI>Yes, you can specify multiple options in one command line.

Just place them one after the other between the <TT>javac</TT>

command and the name of the source-code file.

<LI>To set a target directory for the compiler's output files,

use the <TT>-d</TT> option followed by the name of the directory.

<LI>The <TT>-g</TT> command-line option instructs the compiler

to add debugging information to the byte-code files it generates.

<LI>The <TT>-nowarn</TT> command-line option instructs the compiler

to suppress warning messages as it compiles a file. The compiler

will still generate error messages.

<LI>To instruct the compiler to generate status information as

it works, specify the <TT>-verbose</TT> command-line option.

<LI>Byte-code files are the same format on every computer system.

Each type of computer has a Java interpreter specially written

for it. The interpreter reads and executes the byte-code files.

</OL>

<H2><A NAME="Chapter35"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 35</FONT></A></H2>

<OL>

<LI>Everything will run fine if you leave off the file extension.

In fact, the interpreter won't accept the file extension and will

generate an error if you include it.

<LI>Byte-code files have the .CLASS file extension. These are

the types of files that the interpreter can load and execute.

<LI>You can specify verbose output from the interpreter with the

<TT>-verbose</TT> or <TT>-v</TT> command options. The second is

just a short version of the first.

<LI>When writing a Java application, you must compile the source

code before the interpreter can load and execute the program.

<LI>To get a list of options supported by the interpreter, type

the command <TT>javac -help</TT>.

<LI>The interpreter is the only tool that can run a Java application.

This is because the compiler produces Java byte-code files rather

than regular executable files like most other compilers.

<LI>The <TT>-checksource</TT> (or <TT>-cs</TT>) command-line option

instructs the interpreter to recompile any source-code files that

have been changed since the last compilation.

</OL>

<H2><A NAME="Chapter36"><FONT SIZE=5 COLOR=#Ff0000>

Chapter 36</FONT></A></H2>

<OL>

<LI>The six main Java packages are <TT>lang</TT>, <TT>awt</TT>,

<TT>applet</TT>, <TT>io</TT>, <TT>util</TT>, and <TT>net</TT>.

<LI>The classes needed to write applications and applets that

run in a windowed environment are found in the <TT>awt</TT> package.

<LI>You would use the <TT>Math</TT> class whenever you need to

perform sophisticated mathematical calculations that require functions

like sin, cosine, tangent, and so on.

<LI>By creating an object of the <TT>String</TT> class, you can

use the class's many methods to manipulate the string.

<LI>To join (or concatenate) two strings, call the <TT>String</TT>

class's <TT>concat()</TT> method.

<LI>No, you do not instantiate an object from the <TT>Math</TT>

class. Because the class's methods are all static, you can call

them like this: <TT>Math.Method()</TT>, where <TT>Method</TT>

is the name of the method you want to call.

<LI>The data-type wrapper classes provide methods for manipulating

Java's primitive data types, such as <TT>int</TT>, <TT>float</TT>,

and <TT>boolean</TT>. To use the classes, you can either call

static methods through the class's name (such as, <TT>Integer.parseInt()</TT>)

or create an object of the class and call the methods through

that object.

<LI>The <TT>System</TT> class provides two methods-<TT>getProperty()</TT>

and <TT>getProperties()</TT>- that enable you to obtain information

about the system.

<LI>The <TT>io</TT> package features many classes that you can

use to perform various types of I/O operations using input and

output streams. Usually, you create an object of the appropriate

class and then manipulate the stream through the object's methods.

</OL>

<HR>



<CENTER><P><A HREF="ch36.html"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.html"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch38.html"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>

